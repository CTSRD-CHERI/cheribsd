/*
 * Functions to fill syscall uap structs.
 *
 * DO NOT EDIT-- this file is automatically generated.
 * $FreeBSD$
 */

#ifndef _SYS_COMPAT_CHERIABI_FILL_UAP_H_
#define	_SYS_COMPAT_CHERIABI_FILL_UAP_H_

static inline int
CHERIABI_SYS_cheriabi_syscall_fill_uap(struct thread *td,
    struct cheriabi_syscall_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] int number */
	uap->number = (__typeof__(uap->number))td->td_frame->a0;

	return (0);
}

static inline int
CHERIABI_SYS_exit_fill_uap(struct thread *td,
    struct sys_exit_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] int rval */
	uap->rval = (__typeof__(uap->rval))td->td_frame->a0;

	return (0);
}

static inline int
CHERIABI_SYS_read_fill_uap(struct thread *td,
    struct read_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] int fd */
	uap->fd = (__typeof__(uap->fd))td->td_frame->a0;

	/* [2] size_t nbyte */
	uap->nbyte = (__typeof__(uap->nbyte))td->td_frame->a1;

	/* [1] _Out_writes_bytes_(nbyte) void * buf */
	{
		int error;
		register_t reqperms = (CHERI_PERM_STORE);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_read, 1);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->buf),
		    &tmpcap, 1 * uap->nbyte, reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_write_fill_uap(struct thread *td,
    struct write_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] int fd */
	uap->fd = (__typeof__(uap->fd))td->td_frame->a0;

	/* [2] size_t nbyte */
	uap->nbyte = (__typeof__(uap->nbyte))td->td_frame->a1;

	/* [1] _In_reads_bytes_(nbyte) const void * buf */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_write, 1);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->buf),
		    &tmpcap, 1 * uap->nbyte, reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_open_fill_uap(struct thread *td,
    struct open_args *uap)
{
	struct chericap tmpcap __unused;

	/* [1] int flags */
	uap->flags = (__typeof__(uap->flags))td->td_frame->a0;

	/* [2] mode_t mode */
	uap->mode = (__typeof__(uap->mode))td->td_frame->a1;

	/* [0] _In_z_ const char * path */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_open, 0);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->path),
		    &tmpcap, sizeof(*uap->path), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_close_fill_uap(struct thread *td,
    struct close_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] int fd */
	uap->fd = (__typeof__(uap->fd))td->td_frame->a0;

	return (0);
}

static inline int
CHERIABI_SYS_wait4_fill_uap(struct thread *td,
    struct wait4_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] int pid */
	uap->pid = (__typeof__(uap->pid))td->td_frame->a0;

	/* [2] int options */
	uap->options = (__typeof__(uap->options))td->td_frame->a1;

	/* [1] _Out_opt_ int * status */
	{
		int error;
		register_t reqperms = (CHERI_PERM_STORE);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_wait4, 1);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->status),
		    &tmpcap, sizeof(*uap->status), reqperms, 1);
		if (error != 0)
			return (error);
	}

	/* [3] _Out_opt_ struct rusage * rusage */
	{
		int error;
		register_t reqperms = (CHERI_PERM_STORE);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_wait4, 3);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->rusage),
		    &tmpcap, sizeof(*uap->rusage), reqperms, 1);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_link_fill_uap(struct thread *td,
    struct link_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] _In_z_ const char * path */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_link, 0);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->path),
		    &tmpcap, sizeof(*uap->path), reqperms, 0);
		if (error != 0)
			return (error);
	}

	/* [1] _In_z_ const char * to */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_link, 1);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->to),
		    &tmpcap, sizeof(*uap->to), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_unlink_fill_uap(struct thread *td,
    struct unlink_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] _In_z_ const char * path */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_unlink, 0);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->path),
		    &tmpcap, sizeof(*uap->path), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_chdir_fill_uap(struct thread *td,
    struct chdir_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] _In_z_ const char * path */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_chdir, 0);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->path),
		    &tmpcap, sizeof(*uap->path), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_fchdir_fill_uap(struct thread *td,
    struct fchdir_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] int fd */
	uap->fd = (__typeof__(uap->fd))td->td_frame->a0;

	return (0);
}

static inline int
CHERIABI_SYS_mknod_fill_uap(struct thread *td,
    struct mknod_args *uap)
{
	struct chericap tmpcap __unused;

	/* [1] mode_t mode */
	uap->mode = (__typeof__(uap->mode))td->td_frame->a0;

	/* [2] dev_t dev */
	uap->dev = (__typeof__(uap->dev))td->td_frame->a1;

	/* [0] _In_z_ const char * path */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_mknod, 0);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->path),
		    &tmpcap, sizeof(*uap->path), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_chmod_fill_uap(struct thread *td,
    struct chmod_args *uap)
{
	struct chericap tmpcap __unused;

	/* [1] mode_t mode */
	uap->mode = (__typeof__(uap->mode))td->td_frame->a0;

	/* [0] _In_z_ const char * path */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_chmod, 0);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->path),
		    &tmpcap, sizeof(*uap->path), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_chown_fill_uap(struct thread *td,
    struct chown_args *uap)
{
	struct chericap tmpcap __unused;

	/* [1] int uid */
	uap->uid = (__typeof__(uap->uid))td->td_frame->a0;

	/* [2] int gid */
	uap->gid = (__typeof__(uap->gid))td->td_frame->a1;

	/* [0] _In_z_ const char * path */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_chown, 0);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->path),
		    &tmpcap, sizeof(*uap->path), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_mount_fill_uap(struct thread *td,
    struct mount_args *uap)
{
	struct chericap tmpcap __unused;

	/* [2] int flags */
	uap->flags = (__typeof__(uap->flags))td->td_frame->a0;

	/* [0] _In_z_ const char * type */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_mount, 0);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->type),
		    &tmpcap, sizeof(*uap->type), reqperms, 0);
		if (error != 0)
			return (error);
	}

	/* [1] _In_z_ const char * path */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_mount, 1);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->path),
		    &tmpcap, sizeof(*uap->path), reqperms, 0);
		if (error != 0)
			return (error);
	}

	/* [3] _In_opt_ void * data */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_mount, 3);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->data),
		    &tmpcap, sizeof(*uap->data), reqperms, 1);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_unmount_fill_uap(struct thread *td,
    struct unmount_args *uap)
{
	struct chericap tmpcap __unused;

	/* [1] int flags */
	uap->flags = (__typeof__(uap->flags))td->td_frame->a0;

	/* [0] _In_z_ const char * path */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_unmount, 0);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->path),
		    &tmpcap, sizeof(*uap->path), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_setuid_fill_uap(struct thread *td,
    struct setuid_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] uid_t uid */
	uap->uid = (__typeof__(uap->uid))td->td_frame->a0;

	return (0);
}

static inline int
CHERIABI_SYS_ptrace_fill_uap(struct thread *td,
    struct ptrace_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] int req */
	uap->req = (__typeof__(uap->req))td->td_frame->a0;

	/* [1] pid_t pid */
	uap->pid = (__typeof__(uap->pid))td->td_frame->a1;

	/* [2] vaddr_t addr */
	uap->addr = (__typeof__(uap->addr))td->td_frame->a2;

	/* [3] int data */
	uap->data = (__typeof__(uap->data))td->td_frame->a3;

	return (0);
}

static inline int
CHERIABI_SYS_cheriabi_recvmsg_fill_uap(struct thread *td,
    struct cheriabi_recvmsg_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] int s */
	uap->s = (__typeof__(uap->s))td->td_frame->a0;

	/* [2] int flags */
	uap->flags = (__typeof__(uap->flags))td->td_frame->a1;

	/* [1] _In_ struct msghdr_c * msg */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD|CHERI_PERM_LOAD_CAP);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_recvmsg, 1);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->msg),
		    &tmpcap, sizeof(*uap->msg), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_cheriabi_sendmsg_fill_uap(struct thread *td,
    struct cheriabi_sendmsg_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] int s */
	uap->s = (__typeof__(uap->s))td->td_frame->a0;

	/* [2] int flags */
	uap->flags = (__typeof__(uap->flags))td->td_frame->a1;

	/* [1] _In_ const struct msghdr_c * msg */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD|CHERI_PERM_LOAD_CAP);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_sendmsg, 1);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->msg),
		    &tmpcap, sizeof(*uap->msg), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_recvfrom_fill_uap(struct thread *td,
    struct recvfrom_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] int s */
	uap->s = (__typeof__(uap->s))td->td_frame->a0;

	/* [2] size_t len */
	uap->len = (__typeof__(uap->len))td->td_frame->a1;

	/* [3] int flags */
	uap->flags = (__typeof__(uap->flags))td->td_frame->a2;

	/* [1] _Out_writes_bytes_(len) void * buf */
	{
		int error;
		register_t reqperms = (CHERI_PERM_STORE);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_recvfrom, 1);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->buf),
		    &tmpcap, 1 * uap->len, reqperms, 0);
		if (error != 0)
			return (error);
	}

	/* [5] _Inout_opt_ socklen_t *__restrict fromlenaddr */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD|CHERI_PERM_STORE);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_recvfrom, 5);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->fromlenaddr),
		    &tmpcap, sizeof(*uap->fromlenaddr), reqperms, 1);
		if (error != 0)
			return (error);
	}

	/* [4] _Out_writes_bytes_opt_(*fromlenaddr) struct sockaddr *__restrict from */
	{
		int error;
		register_t reqperms = (CHERI_PERM_STORE);

		if (uap->fromlenaddr == NULL) {
			uap->from = NULL;
		} else {
			size_t reqlen;
			if (sizeof(*uap->fromlenaddr) == 2)
				reqlen = fuword16(uap->fromlenaddr);
			else if (sizeof(*uap->fromlenaddr) == 4)
				reqlen = fuword32(uap->fromlenaddr);
			else if (sizeof(*uap->fromlenaddr) == 8)
				reqlen = fuword64(uap->fromlenaddr);
			else
				panic("unhandled dependant argument size %zu", sizeof(*uap->fromlenaddr));
			if (reqlen == -1)
				return (EINVAL);
			cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_recvfrom, 4);
			error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->from),
			    &tmpcap, reqlen, reqperms, 1);
			if (error != 0)
				return (error);
		}
	}

	return (0);
}

static inline int
CHERIABI_SYS_accept_fill_uap(struct thread *td,
    struct accept_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] int s */
	uap->s = (__typeof__(uap->s))td->td_frame->a0;

	/* [2] _Inout_opt_ socklen_t * anamelen */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD|CHERI_PERM_STORE);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_accept, 2);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->anamelen),
		    &tmpcap, sizeof(*uap->anamelen), reqperms, 1);
		if (error != 0)
			return (error);
	}

	/* [1] _Out_writes_bytes_opt_(*anamelen) struct sockaddr *__restrict name */
	{
		int error;
		register_t reqperms = (CHERI_PERM_STORE);

		if (uap->anamelen == NULL) {
			uap->name = NULL;
		} else {
			size_t reqlen;
			if (sizeof(*uap->anamelen) == 2)
				reqlen = fuword16(uap->anamelen);
			else if (sizeof(*uap->anamelen) == 4)
				reqlen = fuword32(uap->anamelen);
			else if (sizeof(*uap->anamelen) == 8)
				reqlen = fuword64(uap->anamelen);
			else
				panic("unhandled dependant argument size %zu", sizeof(*uap->anamelen));
			if (reqlen == -1)
				return (EINVAL);
			cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_accept, 1);
			error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->name),
			    &tmpcap, reqlen, reqperms, 1);
			if (error != 0)
				return (error);
		}
	}

	return (0);
}

static inline int
CHERIABI_SYS_getpeername_fill_uap(struct thread *td,
    struct getpeername_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] int fdes */
	uap->fdes = (__typeof__(uap->fdes))td->td_frame->a0;

	/* [2] _Inout_opt_ socklen_t * alen */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD|CHERI_PERM_STORE);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_getpeername, 2);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->alen),
		    &tmpcap, sizeof(*uap->alen), reqperms, 1);
		if (error != 0)
			return (error);
	}

	/* [1] _Out_writes_bytes_(*alen) struct sockaddr *__restrict asa */
	{
		int error;
		register_t reqperms = (CHERI_PERM_STORE);

		if (uap->alen == NULL) {
			uap->asa = NULL;
		} else {
			size_t reqlen;
			if (sizeof(*uap->alen) == 2)
				reqlen = fuword16(uap->alen);
			else if (sizeof(*uap->alen) == 4)
				reqlen = fuword32(uap->alen);
			else if (sizeof(*uap->alen) == 8)
				reqlen = fuword64(uap->alen);
			else
				panic("unhandled dependant argument size %zu", sizeof(*uap->alen));
			if (reqlen == -1)
				return (EINVAL);
			cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_getpeername, 1);
			error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->asa),
			    &tmpcap, reqlen, reqperms, 0);
			if (error != 0)
				return (error);
		}
	}

	return (0);
}

static inline int
CHERIABI_SYS_getsockname_fill_uap(struct thread *td,
    struct getsockname_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] int fdes */
	uap->fdes = (__typeof__(uap->fdes))td->td_frame->a0;

	/* [2] _Inout_ socklen_t * alen */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD|CHERI_PERM_STORE);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_getsockname, 2);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->alen),
		    &tmpcap, sizeof(*uap->alen), reqperms, 0);
		if (error != 0)
			return (error);
	}

	/* [1] _Out_writes_bytes_(*alen) struct sockaddr *__restrict asa */
	{
		int error;
		register_t reqperms = (CHERI_PERM_STORE);

		if (uap->alen == NULL) {
			uap->asa = NULL;
		} else {
			size_t reqlen;
			if (sizeof(*uap->alen) == 2)
				reqlen = fuword16(uap->alen);
			else if (sizeof(*uap->alen) == 4)
				reqlen = fuword32(uap->alen);
			else if (sizeof(*uap->alen) == 8)
				reqlen = fuword64(uap->alen);
			else
				panic("unhandled dependant argument size %zu", sizeof(*uap->alen));
			if (reqlen == -1)
				return (EINVAL);
			cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_getsockname, 1);
			error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->asa),
			    &tmpcap, reqlen, reqperms, 0);
			if (error != 0)
				return (error);
		}
	}

	return (0);
}

static inline int
CHERIABI_SYS_access_fill_uap(struct thread *td,
    struct access_args *uap)
{
	struct chericap tmpcap __unused;

	/* [1] int amode */
	uap->amode = (__typeof__(uap->amode))td->td_frame->a0;

	/* [0] _In_z_ const char * path */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_access, 0);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->path),
		    &tmpcap, sizeof(*uap->path), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_chflags_fill_uap(struct thread *td,
    struct chflags_args *uap)
{
	struct chericap tmpcap __unused;

	/* [1] u_long flags */
	uap->flags = (__typeof__(uap->flags))td->td_frame->a0;

	/* [0] _In_z_ const char * path */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_chflags, 0);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->path),
		    &tmpcap, sizeof(*uap->path), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_fchflags_fill_uap(struct thread *td,
    struct fchflags_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] int fd */
	uap->fd = (__typeof__(uap->fd))td->td_frame->a0;

	/* [1] u_long flags */
	uap->flags = (__typeof__(uap->flags))td->td_frame->a1;

	return (0);
}

static inline int
CHERIABI_SYS_kill_fill_uap(struct thread *td,
    struct kill_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] int pid */
	uap->pid = (__typeof__(uap->pid))td->td_frame->a0;

	/* [1] int signum */
	uap->signum = (__typeof__(uap->signum))td->td_frame->a1;

	return (0);
}

static inline int
CHERIABI_SYS_dup_fill_uap(struct thread *td,
    struct dup_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] u_int fd */
	uap->fd = (__typeof__(uap->fd))td->td_frame->a0;

	return (0);
}

static inline int
CHERIABI_SYS_profil_fill_uap(struct thread *td,
    struct profil_args *uap)
{
	struct chericap tmpcap __unused;

	/* [1] size_t size */
	uap->size = (__typeof__(uap->size))td->td_frame->a0;

	/* [2] size_t offset */
	uap->offset = (__typeof__(uap->offset))td->td_frame->a1;

	/* [3] u_int scale */
	uap->scale = (__typeof__(uap->scale))td->td_frame->a2;

	/* [0] _Out_writes_bytes_(size) void * samples */
	{
		int error;
		register_t reqperms = (CHERI_PERM_STORE);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_profil, 0);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->samples),
		    &tmpcap, 1 * uap->size, reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_ktrace_fill_uap(struct thread *td,
    struct ktrace_args *uap)
{
	struct chericap tmpcap __unused;

	/* [1] int ops */
	uap->ops = (__typeof__(uap->ops))td->td_frame->a0;

	/* [2] int facs */
	uap->facs = (__typeof__(uap->facs))td->td_frame->a1;

	/* [3] int pid */
	uap->pid = (__typeof__(uap->pid))td->td_frame->a2;

	/* [0] _In_z_ const char * fname */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_ktrace, 0);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->fname),
		    &tmpcap, sizeof(*uap->fname), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_getlogin_fill_uap(struct thread *td,
    struct getlogin_args *uap)
{
	struct chericap tmpcap __unused;

	/* [1] u_int namelen */
	uap->namelen = (__typeof__(uap->namelen))td->td_frame->a0;

	/* [0] _Out_writes_z_(namelen) char * namebuf */
	{
		int error;
		register_t reqperms = (CHERI_PERM_STORE);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_getlogin, 0);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->namebuf),
		    &tmpcap, (sizeof(*uap->namebuf) * uap->namelen), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_setlogin_fill_uap(struct thread *td,
    struct setlogin_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] _In_z_ const char * namebuf */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_setlogin, 0);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->namebuf),
		    &tmpcap, sizeof(*uap->namebuf), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_acct_fill_uap(struct thread *td,
    struct acct_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] _In_z_ const char * path */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_acct, 0);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->path),
		    &tmpcap, sizeof(*uap->path), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_cheriabi_sigaltstack_fill_uap(struct thread *td,
    struct cheriabi_sigaltstack_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] _In_opt_ const cheriabi_stack_t * ss */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_sigaltstack, 0);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->ss),
		    &tmpcap, sizeof(*uap->ss), reqperms, 1);
		if (error != 0)
			return (error);
	}

	/* [1] _Out_opt_ cheriabi_stack_t * oss */
	{
		int error;
		register_t reqperms = (CHERI_PERM_STORE);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_sigaltstack, 1);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->oss),
		    &tmpcap, sizeof(*uap->oss), reqperms, 1);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int	CHERIABI_SYS_cheriabi_ioctl_fill_uap(struct thread *td,
    struct cheriabi_ioctl_args *uap);

static inline int
CHERIABI_SYS_reboot_fill_uap(struct thread *td,
    struct reboot_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] int opt */
	uap->opt = (__typeof__(uap->opt))td->td_frame->a0;

	return (0);
}

static inline int
CHERIABI_SYS_revoke_fill_uap(struct thread *td,
    struct revoke_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] _In_z_ const char * path */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_revoke, 0);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->path),
		    &tmpcap, sizeof(*uap->path), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_symlink_fill_uap(struct thread *td,
    struct symlink_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] _In_z_ const char * path */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_symlink, 0);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->path),
		    &tmpcap, sizeof(*uap->path), reqperms, 0);
		if (error != 0)
			return (error);
	}

	/* [1] _In_z_ const char * link */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_symlink, 1);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->link),
		    &tmpcap, sizeof(*uap->link), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_readlink_fill_uap(struct thread *td,
    struct readlink_args *uap)
{
	struct chericap tmpcap __unused;

	/* [2] size_t count */
	uap->count = (__typeof__(uap->count))td->td_frame->a0;

	/* [0] _In_z_ const char * path */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_readlink, 0);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->path),
		    &tmpcap, sizeof(*uap->path), reqperms, 0);
		if (error != 0)
			return (error);
	}

	/* [1] _Out_writes_z_(count) char * buf */
	{
		int error;
		register_t reqperms = (CHERI_PERM_STORE);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_readlink, 1);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->buf),
		    &tmpcap, (sizeof(*uap->buf) * uap->count), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_cheriabi_execve_fill_uap(struct thread *td,
    struct cheriabi_execve_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] _In_z_ const char * fname */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_execve, 0);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->fname),
		    &tmpcap, sizeof(*uap->fname), reqperms, 0);
		if (error != 0)
			return (error);
	}

	/* [1] _In_ struct chericap * argv */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_execve, 1);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->argv),
		    &tmpcap, sizeof(*uap->argv), reqperms, 0);
		if (error != 0)
			return (error);
	}

	/* [2] _In_ struct chericap * envv */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_execve, 2);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->envv),
		    &tmpcap, sizeof(*uap->envv), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_umask_fill_uap(struct thread *td,
    struct umask_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] mode_t newmask */
	uap->newmask = (__typeof__(uap->newmask))td->td_frame->a0;

	return (0);
}

static inline int
CHERIABI_SYS_chroot_fill_uap(struct thread *td,
    struct chroot_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] _In_z_ const char * path */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_chroot, 0);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->path),
		    &tmpcap, sizeof(*uap->path), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_msync_fill_uap(struct thread *td,
    struct msync_args *uap)
{
	struct chericap tmpcap __unused;

	/* [1] size_t len */
	uap->len = (__typeof__(uap->len))td->td_frame->a0;

	/* [2] int flags */
	uap->flags = (__typeof__(uap->flags))td->td_frame->a1;

	/* [0] _Pagerange_(len) void * addr */
	{
		int error;

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_msync, 0);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->addr),
		    &tmpcap, uap->len, 0, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_munmap_fill_uap(struct thread *td,
    struct munmap_args *uap)
{
	struct chericap tmpcap __unused;

	/* [1] size_t len */
	uap->len = (__typeof__(uap->len))td->td_frame->a0;

	/* [0] _Pagerange_vmmap_(len) void * addr */
	{
		int error;
		register_t reqperms = (CHERI_PERM_CHERIABI_VMMAP);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_munmap, 0);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->addr),
		    &tmpcap, uap->len, reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_cheriabi_mprotect_fill_uap(struct thread *td,
    struct cheriabi_mprotect_args *uap)
{
	struct chericap tmpcap __unused;

	/* [1] size_t len */
	uap->len = (__typeof__(uap->len))td->td_frame->a0;

	/* [2] int prot */
	uap->prot = (__typeof__(uap->prot))td->td_frame->a1;

	/* [0] _Pagerange_(len) const void * addr */
	{
		int error;

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_mprotect, 0);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->addr),
		    &tmpcap, uap->len, 0, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_cheriabi_madvise_fill_uap(struct thread *td,
    struct cheriabi_madvise_args *uap)
{
	struct chericap tmpcap __unused;

	/* [1] size_t len */
	uap->len = (__typeof__(uap->len))td->td_frame->a0;

	/* [2] int behav */
	uap->behav = (__typeof__(uap->behav))td->td_frame->a1;

	/* [0] _Pagerange_(len) void * addr */
	{
		int error;

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_madvise, 0);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->addr),
		    &tmpcap, uap->len, 0, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int	CHERIABI_SYS_mincore_fill_uap(struct thread *td,
    struct mincore_args *uap);

static inline int
CHERIABI_SYS_getgroups_fill_uap(struct thread *td,
    struct getgroups_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] u_int gidsetsize */
	uap->gidsetsize = (__typeof__(uap->gidsetsize))td->td_frame->a0;

	/* [1] _Out_writes_opt_(gidsetsize) gid_t * gidset */
	{
		int error;
		register_t reqperms = (CHERI_PERM_STORE);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_getgroups, 1);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->gidset),
		    &tmpcap, (sizeof(*uap->gidset) * uap->gidsetsize), reqperms, 1);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_setgroups_fill_uap(struct thread *td,
    struct setgroups_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] u_int gidsetsize */
	uap->gidsetsize = (__typeof__(uap->gidsetsize))td->td_frame->a0;

	/* [1] _In_reads_(gidsetsize) gid_t * gidset */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_setgroups, 1);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->gidset),
		    &tmpcap, (sizeof(*uap->gidset) * uap->gidsetsize), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_setpgid_fill_uap(struct thread *td,
    struct setpgid_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] int pid */
	uap->pid = (__typeof__(uap->pid))td->td_frame->a0;

	/* [1] int pgid */
	uap->pgid = (__typeof__(uap->pgid))td->td_frame->a1;

	return (0);
}

static inline int
CHERIABI_SYS_setitimer_fill_uap(struct thread *td,
    struct setitimer_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] int which */
	uap->which = (__typeof__(uap->which))td->td_frame->a0;

	/* [1] _In_ const struct itimerval * itv */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_setitimer, 1);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->itv),
		    &tmpcap, sizeof(*uap->itv), reqperms, 0);
		if (error != 0)
			return (error);
	}

	/* [2] _Out_opt_ struct itimerval * oitv */
	{
		int error;
		register_t reqperms = (CHERI_PERM_STORE);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_setitimer, 2);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->oitv),
		    &tmpcap, sizeof(*uap->oitv), reqperms, 1);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_swapon_fill_uap(struct thread *td,
    struct swapon_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] _In_z_ const char * name */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_swapon, 0);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->name),
		    &tmpcap, sizeof(*uap->name), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_getitimer_fill_uap(struct thread *td,
    struct getitimer_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] int which */
	uap->which = (__typeof__(uap->which))td->td_frame->a0;

	/* [1] _Out_ struct itimerval * itv */
	{
		int error;
		register_t reqperms = (CHERI_PERM_STORE);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_getitimer, 1);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->itv),
		    &tmpcap, sizeof(*uap->itv), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_dup2_fill_uap(struct thread *td,
    struct dup2_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] u_int from */
	uap->from = (__typeof__(uap->from))td->td_frame->a0;

	/* [1] u_int to */
	uap->to = (__typeof__(uap->to))td->td_frame->a1;

	return (0);
}

static inline int	CHERIABI_SYS_fcntl_fill_uap(struct thread *td,
    struct fcntl_args *uap);

static inline int	CHERIABI_SYS_select_fill_uap(struct thread *td,
    struct select_args *uap);

static inline int
CHERIABI_SYS_fsync_fill_uap(struct thread *td,
    struct fsync_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] int fd */
	uap->fd = (__typeof__(uap->fd))td->td_frame->a0;

	return (0);
}

static inline int
CHERIABI_SYS_setpriority_fill_uap(struct thread *td,
    struct setpriority_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] int which */
	uap->which = (__typeof__(uap->which))td->td_frame->a0;

	/* [1] int who */
	uap->who = (__typeof__(uap->who))td->td_frame->a1;

	/* [2] int prio */
	uap->prio = (__typeof__(uap->prio))td->td_frame->a2;

	return (0);
}

static inline int
CHERIABI_SYS_socket_fill_uap(struct thread *td,
    struct socket_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] int domain */
	uap->domain = (__typeof__(uap->domain))td->td_frame->a0;

	/* [1] int type */
	uap->type = (__typeof__(uap->type))td->td_frame->a1;

	/* [2] int protocol */
	uap->protocol = (__typeof__(uap->protocol))td->td_frame->a2;

	return (0);
}

static inline int
CHERIABI_SYS_connect_fill_uap(struct thread *td,
    struct connect_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] int s */
	uap->s = (__typeof__(uap->s))td->td_frame->a0;

	/* [2] socklen_t namelen */
	uap->namelen = (__typeof__(uap->namelen))td->td_frame->a1;

	/* [1] _In_reads_bytes_(namelen) const struct sockaddr * name */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_connect, 1);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->name),
		    &tmpcap, 1 * uap->namelen, reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_getpriority_fill_uap(struct thread *td,
    struct getpriority_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] int which */
	uap->which = (__typeof__(uap->which))td->td_frame->a0;

	/* [1] int who */
	uap->who = (__typeof__(uap->who))td->td_frame->a1;

	return (0);
}

static inline int
CHERIABI_SYS_bind_fill_uap(struct thread *td,
    struct bind_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] int s */
	uap->s = (__typeof__(uap->s))td->td_frame->a0;

	/* [2] socklen_t namelen */
	uap->namelen = (__typeof__(uap->namelen))td->td_frame->a1;

	/* [1] _In_reads_bytes_(namelen) const struct sockaddr * name */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_bind, 1);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->name),
		    &tmpcap, 1 * uap->namelen, reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_setsockopt_fill_uap(struct thread *td,
    struct setsockopt_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] int s */
	uap->s = (__typeof__(uap->s))td->td_frame->a0;

	/* [1] int level */
	uap->level = (__typeof__(uap->level))td->td_frame->a1;

	/* [2] int name */
	uap->name = (__typeof__(uap->name))td->td_frame->a2;

	/* [4] socklen_t valsize */
	uap->valsize = (__typeof__(uap->valsize))td->td_frame->a3;

	/* [3] _In_reads_bytes_opt_(valsize) const void * val */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_setsockopt, 3);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->val),
		    &tmpcap, 1 * uap->valsize, reqperms, 1);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_listen_fill_uap(struct thread *td,
    struct listen_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] int s */
	uap->s = (__typeof__(uap->s))td->td_frame->a0;

	/* [1] int backlog */
	uap->backlog = (__typeof__(uap->backlog))td->td_frame->a1;

	return (0);
}

static inline int
CHERIABI_SYS_gettimeofday_fill_uap(struct thread *td,
    struct gettimeofday_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] _Out_ struct timeval * tp */
	{
		int error;
		register_t reqperms = (CHERI_PERM_STORE);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_gettimeofday, 0);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->tp),
		    &tmpcap, sizeof(*uap->tp), reqperms, 0);
		if (error != 0)
			return (error);
	}

	/* [1] _Out_opt_ struct timezone * tzp */
	{
		int error;
		register_t reqperms = (CHERI_PERM_STORE);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_gettimeofday, 1);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->tzp),
		    &tmpcap, sizeof(*uap->tzp), reqperms, 1);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_getrusage_fill_uap(struct thread *td,
    struct getrusage_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] int who */
	uap->who = (__typeof__(uap->who))td->td_frame->a0;

	/* [1] _Out_ struct rusage * rusage */
	{
		int error;
		register_t reqperms = (CHERI_PERM_STORE);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_getrusage, 1);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->rusage),
		    &tmpcap, sizeof(*uap->rusage), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_getsockopt_fill_uap(struct thread *td,
    struct getsockopt_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] int s */
	uap->s = (__typeof__(uap->s))td->td_frame->a0;

	/* [1] int level */
	uap->level = (__typeof__(uap->level))td->td_frame->a1;

	/* [2] int name */
	uap->name = (__typeof__(uap->name))td->td_frame->a2;

	/* [4] _Inout_ socklen_t * avalsize */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD|CHERI_PERM_STORE);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_getsockopt, 4);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->avalsize),
		    &tmpcap, sizeof(*uap->avalsize), reqperms, 0);
		if (error != 0)
			return (error);
	}

	/* [3] _Out_writes_bytes_opt_(*avalsize) void * val */
	{
		int error;
		register_t reqperms = (CHERI_PERM_STORE);

		if (uap->avalsize == NULL) {
			uap->val = NULL;
		} else {
			size_t reqlen;
			if (sizeof(*uap->avalsize) == 2)
				reqlen = fuword16(uap->avalsize);
			else if (sizeof(*uap->avalsize) == 4)
				reqlen = fuword32(uap->avalsize);
			else if (sizeof(*uap->avalsize) == 8)
				reqlen = fuword64(uap->avalsize);
			else
				panic("unhandled dependant argument size %zu", sizeof(*uap->avalsize));
			if (reqlen == -1)
				return (EINVAL);
			cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_getsockopt, 3);
			error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->val),
			    &tmpcap, reqlen, reqperms, 1);
			if (error != 0)
				return (error);
		}
	}

	return (0);
}

static inline int
CHERIABI_SYS_cheriabi_readv_fill_uap(struct thread *td,
    struct cheriabi_readv_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] int fd */
	uap->fd = (__typeof__(uap->fd))td->td_frame->a0;

	/* [2] u_int iovcnt */
	uap->iovcnt = (__typeof__(uap->iovcnt))td->td_frame->a1;

	/* [1] _Inout_updates_(iovcnt) struct iovec_c * iovp */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD|CHERI_PERM_LOAD_CAP|CHERI_PERM_STORE|CHERI_PERM_STORE_CAP);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_readv, 1);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->iovp),
		    &tmpcap, (sizeof(*uap->iovp) * uap->iovcnt), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_cheriabi_writev_fill_uap(struct thread *td,
    struct cheriabi_writev_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] int fd */
	uap->fd = (__typeof__(uap->fd))td->td_frame->a0;

	/* [2] u_int iovcnt */
	uap->iovcnt = (__typeof__(uap->iovcnt))td->td_frame->a1;

	/* [1] _In_reads_(iovcnt) struct iovec_c * iovp */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD|CHERI_PERM_LOAD_CAP);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_writev, 1);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->iovp),
		    &tmpcap, (sizeof(*uap->iovp) * uap->iovcnt), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_settimeofday_fill_uap(struct thread *td,
    struct settimeofday_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] _In_ const struct timeval * tv */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_settimeofday, 0);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->tv),
		    &tmpcap, sizeof(*uap->tv), reqperms, 0);
		if (error != 0)
			return (error);
	}

	/* [1] _In_opt_ const struct timezone * tzp */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_settimeofday, 1);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->tzp),
		    &tmpcap, sizeof(*uap->tzp), reqperms, 1);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_fchown_fill_uap(struct thread *td,
    struct fchown_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] int fd */
	uap->fd = (__typeof__(uap->fd))td->td_frame->a0;

	/* [1] int uid */
	uap->uid = (__typeof__(uap->uid))td->td_frame->a1;

	/* [2] int gid */
	uap->gid = (__typeof__(uap->gid))td->td_frame->a2;

	return (0);
}

static inline int
CHERIABI_SYS_fchmod_fill_uap(struct thread *td,
    struct fchmod_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] int fd */
	uap->fd = (__typeof__(uap->fd))td->td_frame->a0;

	/* [1] mode_t mode */
	uap->mode = (__typeof__(uap->mode))td->td_frame->a1;

	return (0);
}

static inline int
CHERIABI_SYS_setreuid_fill_uap(struct thread *td,
    struct setreuid_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] int ruid */
	uap->ruid = (__typeof__(uap->ruid))td->td_frame->a0;

	/* [1] int euid */
	uap->euid = (__typeof__(uap->euid))td->td_frame->a1;

	return (0);
}

static inline int
CHERIABI_SYS_setregid_fill_uap(struct thread *td,
    struct setregid_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] int rgid */
	uap->rgid = (__typeof__(uap->rgid))td->td_frame->a0;

	/* [1] int egid */
	uap->egid = (__typeof__(uap->egid))td->td_frame->a1;

	return (0);
}

static inline int
CHERIABI_SYS_rename_fill_uap(struct thread *td,
    struct rename_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] _In_z_ const char * from */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_rename, 0);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->from),
		    &tmpcap, sizeof(*uap->from), reqperms, 0);
		if (error != 0)
			return (error);
	}

	/* [1] _In_z_ const char * to */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_rename, 1);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->to),
		    &tmpcap, sizeof(*uap->to), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_flock_fill_uap(struct thread *td,
    struct flock_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] int fd */
	uap->fd = (__typeof__(uap->fd))td->td_frame->a0;

	/* [1] int how */
	uap->how = (__typeof__(uap->how))td->td_frame->a1;

	return (0);
}

static inline int
CHERIABI_SYS_mkfifo_fill_uap(struct thread *td,
    struct mkfifo_args *uap)
{
	struct chericap tmpcap __unused;

	/* [1] mode_t mode */
	uap->mode = (__typeof__(uap->mode))td->td_frame->a0;

	/* [0] _In_z_ const char * path */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_mkfifo, 0);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->path),
		    &tmpcap, sizeof(*uap->path), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_sendto_fill_uap(struct thread *td,
    struct sendto_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] int s */
	uap->s = (__typeof__(uap->s))td->td_frame->a0;

	/* [2] size_t len */
	uap->len = (__typeof__(uap->len))td->td_frame->a1;

	/* [3] int flags */
	uap->flags = (__typeof__(uap->flags))td->td_frame->a2;

	/* [5] socklen_t tolen */
	uap->tolen = (__typeof__(uap->tolen))td->td_frame->a3;

	/* [1] _In_reads_bytes_(len) const void * buf */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_sendto, 1);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->buf),
		    &tmpcap, 1 * uap->len, reqperms, 0);
		if (error != 0)
			return (error);
	}

	/* [4] _In_reads_bytes_opt_(tolen) const struct sockaddr * to */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_sendto, 4);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->to),
		    &tmpcap, 1 * uap->tolen, reqperms, 1);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_shutdown_fill_uap(struct thread *td,
    struct shutdown_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] int s */
	uap->s = (__typeof__(uap->s))td->td_frame->a0;

	/* [1] int how */
	uap->how = (__typeof__(uap->how))td->td_frame->a1;

	return (0);
}

static inline int
CHERIABI_SYS_socketpair_fill_uap(struct thread *td,
    struct socketpair_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] int domain */
	uap->domain = (__typeof__(uap->domain))td->td_frame->a0;

	/* [1] int type */
	uap->type = (__typeof__(uap->type))td->td_frame->a1;

	/* [2] int protocol */
	uap->protocol = (__typeof__(uap->protocol))td->td_frame->a2;

	/* [3] _Out_writes_(2) int * rsv */
	{
		int error;
		register_t reqperms = (CHERI_PERM_STORE);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_socketpair, 3);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->rsv),
		    &tmpcap, (sizeof(*uap->rsv) * 2), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_mkdir_fill_uap(struct thread *td,
    struct mkdir_args *uap)
{
	struct chericap tmpcap __unused;

	/* [1] mode_t mode */
	uap->mode = (__typeof__(uap->mode))td->td_frame->a0;

	/* [0] _In_z_ const char * path */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_mkdir, 0);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->path),
		    &tmpcap, sizeof(*uap->path), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_rmdir_fill_uap(struct thread *td,
    struct rmdir_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] _In_z_ const char * path */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_rmdir, 0);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->path),
		    &tmpcap, sizeof(*uap->path), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_utimes_fill_uap(struct thread *td,
    struct utimes_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] _In_z_ const char * path */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_utimes, 0);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->path),
		    &tmpcap, sizeof(*uap->path), reqperms, 0);
		if (error != 0)
			return (error);
	}

	/* [1] _In_ const struct timeval * tptr */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_utimes, 1);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->tptr),
		    &tmpcap, sizeof(*uap->tptr), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_adjtime_fill_uap(struct thread *td,
    struct adjtime_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] _In_ const struct timeval * delta */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_adjtime, 0);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->delta),
		    &tmpcap, sizeof(*uap->delta), reqperms, 0);
		if (error != 0)
			return (error);
	}

	/* [1] _Out_opt_ struct timeval * olddelta */
	{
		int error;
		register_t reqperms = (CHERI_PERM_STORE);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_adjtime, 1);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->olddelta),
		    &tmpcap, sizeof(*uap->olddelta), reqperms, 1);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_quotactl_fill_uap(struct thread *td,
    struct quotactl_args *uap)
{
	struct chericap tmpcap __unused;

	/* [1] int cmd */
	uap->cmd = (__typeof__(uap->cmd))td->td_frame->a0;

	/* [2] int uid */
	uap->uid = (__typeof__(uap->uid))td->td_frame->a1;

	/* [0] _In_z_ const char * path */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_quotactl, 0);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->path),
		    &tmpcap, sizeof(*uap->path), reqperms, 0);
		if (error != 0)
			return (error);
	}

	/* [3] _In_ void * arg */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_quotactl, 3);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->arg),
		    &tmpcap, sizeof(*uap->arg), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_cheriabi_nlm_syscall_fill_uap(struct thread *td,
    struct cheriabi_nlm_syscall_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] int debug_level */
	uap->debug_level = (__typeof__(uap->debug_level))td->td_frame->a0;

	/* [1] int grace_period */
	uap->grace_period = (__typeof__(uap->grace_period))td->td_frame->a1;

	/* [2] int addr_count */
	uap->addr_count = (__typeof__(uap->addr_count))td->td_frame->a2;

	/* [3] _In_reads_(addr_count) struct chericap * addrs */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_nlm_syscall, 3);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->addrs),
		    &tmpcap, (sizeof(*uap->addrs) * uap->addr_count), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int	CHERIABI_SYS_cheriabi_nfssvc_fill_uap(struct thread *td,
    struct cheriabi_nfssvc_args *uap);

static inline int
CHERIABI_SYS_lgetfh_fill_uap(struct thread *td,
    struct lgetfh_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] _In_z_ const char * fname */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_lgetfh, 0);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->fname),
		    &tmpcap, sizeof(*uap->fname), reqperms, 0);
		if (error != 0)
			return (error);
	}

	/* [1] _Out_ struct fhandle * fhp */
	{
		int error;
		register_t reqperms = (CHERI_PERM_STORE);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_lgetfh, 1);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->fhp),
		    &tmpcap, sizeof(*uap->fhp), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_getfh_fill_uap(struct thread *td,
    struct getfh_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] _In_z_ const char * fname */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_getfh, 0);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->fname),
		    &tmpcap, sizeof(*uap->fname), reqperms, 0);
		if (error != 0)
			return (error);
	}

	/* [1] _Out_ struct fhandle * fhp */
	{
		int error;
		register_t reqperms = (CHERI_PERM_STORE);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_getfh, 1);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->fhp),
		    &tmpcap, sizeof(*uap->fhp), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int	CHERIABI_SYS_cheriabi_sysarch_fill_uap(struct thread *td,
    struct cheriabi_sysarch_args *uap);

static inline int
CHERIABI_SYS_rtprio_fill_uap(struct thread *td,
    struct rtprio_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] int function */
	uap->function = (__typeof__(uap->function))td->td_frame->a0;

	/* [1] pid_t pid */
	uap->pid = (__typeof__(uap->pid))td->td_frame->a1;

	/* [2] _Inout_ struct rtprio * rtp */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD|CHERI_PERM_STORE);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_rtprio, 2);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->rtp),
		    &tmpcap, sizeof(*uap->rtp), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_setfib_fill_uap(struct thread *td,
    struct setfib_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] int fibnum */
	uap->fibnum = (__typeof__(uap->fibnum))td->td_frame->a0;

	return (0);
}

static inline int
CHERIABI_SYS_ntp_adjtime_fill_uap(struct thread *td,
    struct ntp_adjtime_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] _Inout_ struct timex * tp */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD|CHERI_PERM_STORE);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_ntp_adjtime, 0);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->tp),
		    &tmpcap, sizeof(*uap->tp), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_setgid_fill_uap(struct thread *td,
    struct setgid_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] gid_t gid */
	uap->gid = (__typeof__(uap->gid))td->td_frame->a0;

	return (0);
}

static inline int
CHERIABI_SYS_setegid_fill_uap(struct thread *td,
    struct setegid_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] gid_t egid */
	uap->egid = (__typeof__(uap->egid))td->td_frame->a0;

	return (0);
}

static inline int
CHERIABI_SYS_seteuid_fill_uap(struct thread *td,
    struct seteuid_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] uid_t euid */
	uap->euid = (__typeof__(uap->euid))td->td_frame->a0;

	return (0);
}

static inline int
CHERIABI_SYS_stat_fill_uap(struct thread *td,
    struct stat_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] _In_z_ const char * path */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_stat, 0);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->path),
		    &tmpcap, sizeof(*uap->path), reqperms, 0);
		if (error != 0)
			return (error);
	}

	/* [1] _Out_ struct stat * ub */
	{
		int error;
		register_t reqperms = (CHERI_PERM_STORE);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_stat, 1);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->ub),
		    &tmpcap, sizeof(*uap->ub), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_fstat_fill_uap(struct thread *td,
    struct fstat_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] int fd */
	uap->fd = (__typeof__(uap->fd))td->td_frame->a0;

	/* [1] _Out_ struct stat * sb */
	{
		int error;
		register_t reqperms = (CHERI_PERM_STORE);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_fstat, 1);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->sb),
		    &tmpcap, sizeof(*uap->sb), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_lstat_fill_uap(struct thread *td,
    struct lstat_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] _In_z_ const char * path */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_lstat, 0);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->path),
		    &tmpcap, sizeof(*uap->path), reqperms, 0);
		if (error != 0)
			return (error);
	}

	/* [1] _Out_ struct stat * ub */
	{
		int error;
		register_t reqperms = (CHERI_PERM_STORE);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_lstat, 1);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->ub),
		    &tmpcap, sizeof(*uap->ub), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_pathconf_fill_uap(struct thread *td,
    struct pathconf_args *uap)
{
	struct chericap tmpcap __unused;

	/* [1] int name */
	uap->name = (__typeof__(uap->name))td->td_frame->a0;

	/* [0] _In_z_ const char * path */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_pathconf, 0);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->path),
		    &tmpcap, sizeof(*uap->path), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_fpathconf_fill_uap(struct thread *td,
    struct fpathconf_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] int fd */
	uap->fd = (__typeof__(uap->fd))td->td_frame->a0;

	/* [1] int name */
	uap->name = (__typeof__(uap->name))td->td_frame->a1;

	return (0);
}

static inline int
CHERIABI_SYS_getrlimit_fill_uap(struct thread *td,
    struct __getrlimit_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] u_int which */
	uap->which = (__typeof__(uap->which))td->td_frame->a0;

	/* [1] _Out_ struct rlimit * rlp */
	{
		int error;
		register_t reqperms = (CHERI_PERM_STORE);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_getrlimit, 1);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->rlp),
		    &tmpcap, sizeof(*uap->rlp), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_setrlimit_fill_uap(struct thread *td,
    struct __setrlimit_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] u_int which */
	uap->which = (__typeof__(uap->which))td->td_frame->a0;

	/* [1] _In_ struct rlimit * rlp */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_setrlimit, 1);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->rlp),
		    &tmpcap, sizeof(*uap->rlp), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_getdirentries_fill_uap(struct thread *td,
    struct getdirentries_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] int fd */
	uap->fd = (__typeof__(uap->fd))td->td_frame->a0;

	/* [2] u_int count */
	uap->count = (__typeof__(uap->count))td->td_frame->a1;

	/* [1] _Out_writes_bytes_(count) char * buf */
	{
		int error;
		register_t reqperms = (CHERI_PERM_STORE);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_getdirentries, 1);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->buf),
		    &tmpcap, 1 * uap->count, reqperms, 0);
		if (error != 0)
			return (error);
	}

	/* [3] _Out_ long * basep */
	{
		int error;
		register_t reqperms = (CHERI_PERM_STORE);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_getdirentries, 3);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->basep),
		    &tmpcap, sizeof(*uap->basep), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS___sysctl_fill_uap(struct thread *td,
    struct sysctl_args *uap)
{
	struct chericap tmpcap __unused;

	/* [1] u_int namelen */
	uap->namelen = (__typeof__(uap->namelen))td->td_frame->a0;

	/* [5] size_t newlen */
	uap->newlen = (__typeof__(uap->newlen))td->td_frame->a1;

	/* [0] _In_reads_(namelen) int * name */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS___sysctl, 0);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->name),
		    &tmpcap, (sizeof(*uap->name) * uap->namelen), reqperms, 0);
		if (error != 0)
			return (error);
	}

	/* [3] _Inout_opt_ size_t * oldlenp */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD|CHERI_PERM_STORE);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS___sysctl, 3);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->oldlenp),
		    &tmpcap, sizeof(*uap->oldlenp), reqperms, 1);
		if (error != 0)
			return (error);
	}

	/* [4] _In_reads_bytes_opt_(newlen) void * new */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS___sysctl, 4);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->new),
		    &tmpcap, 1 * uap->newlen, reqperms, 1);
		if (error != 0)
			return (error);
	}

	/* [2] _Out_writes_bytes_opt_(*oldlenp) void * old */
	{
		int error;
		register_t reqperms = (CHERI_PERM_STORE);

		if (uap->oldlenp == NULL) {
			uap->old = NULL;
		} else {
			size_t reqlen;
			if (sizeof(*uap->oldlenp) == 2)
				reqlen = fuword16(uap->oldlenp);
			else if (sizeof(*uap->oldlenp) == 4)
				reqlen = fuword32(uap->oldlenp);
			else if (sizeof(*uap->oldlenp) == 8)
				reqlen = fuword64(uap->oldlenp);
			else
				panic("unhandled dependant argument size %zu", sizeof(*uap->oldlenp));
			if (reqlen == -1)
				return (EINVAL);
			cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS___sysctl, 2);
			error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->old),
			    &tmpcap, reqlen, reqperms, 1);
			if (error != 0)
				return (error);
		}
	}

	return (0);
}

static inline int
CHERIABI_SYS_mlock_fill_uap(struct thread *td,
    struct mlock_args *uap)
{
	struct chericap tmpcap __unused;

	/* [1] size_t len */
	uap->len = (__typeof__(uap->len))td->td_frame->a0;

	/* [0] _Pagerange_(len) const void * addr */
	{
		int error;

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_mlock, 0);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->addr),
		    &tmpcap, uap->len, 0, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_munlock_fill_uap(struct thread *td,
    struct munlock_args *uap)
{
	struct chericap tmpcap __unused;

	/* [1] size_t len */
	uap->len = (__typeof__(uap->len))td->td_frame->a0;

	/* [0] _Pagerange_(len) const void * addr */
	{
		int error;

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_munlock, 0);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->addr),
		    &tmpcap, uap->len, 0, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_undelete_fill_uap(struct thread *td,
    struct undelete_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] _In_z_ const char * path */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_undelete, 0);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->path),
		    &tmpcap, sizeof(*uap->path), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_futimes_fill_uap(struct thread *td,
    struct futimes_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] int fd */
	uap->fd = (__typeof__(uap->fd))td->td_frame->a0;

	/* [1] _In_reads_(2) const struct timeval * tptr */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_futimes, 1);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->tptr),
		    &tmpcap, (sizeof(*uap->tptr) * 2), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_getpgid_fill_uap(struct thread *td,
    struct getpgid_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] pid_t pid */
	uap->pid = (__typeof__(uap->pid))td->td_frame->a0;

	return (0);
}

static inline int
CHERIABI_SYS_poll_fill_uap(struct thread *td,
    struct poll_args *uap)
{
	struct chericap tmpcap __unused;

	/* [1] u_int nfds */
	uap->nfds = (__typeof__(uap->nfds))td->td_frame->a0;

	/* [2] int timeout */
	uap->timeout = (__typeof__(uap->timeout))td->td_frame->a1;

	/* [0] _Inout_updates_(nfds) struct pollfd * fds */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD|CHERI_PERM_STORE);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_poll, 0);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->fds),
		    &tmpcap, (sizeof(*uap->fds) * uap->nfds), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_semget_fill_uap(struct thread *td,
    struct semget_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] key_t key */
	uap->key = (__typeof__(uap->key))td->td_frame->a0;

	/* [1] int nsems */
	uap->nsems = (__typeof__(uap->nsems))td->td_frame->a1;

	/* [2] int semflg */
	uap->semflg = (__typeof__(uap->semflg))td->td_frame->a2;

	return (0);
}

static inline int
CHERIABI_SYS_semop_fill_uap(struct thread *td,
    struct semop_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] int semid */
	uap->semid = (__typeof__(uap->semid))td->td_frame->a0;

	/* [2] u_int nsops */
	uap->nsops = (__typeof__(uap->nsops))td->td_frame->a1;

	/* [1] _In_reads_(nsops) struct sembuf * sops */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_semop, 1);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->sops),
		    &tmpcap, (sizeof(*uap->sops) * uap->nsops), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_msgget_fill_uap(struct thread *td,
    struct msgget_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] key_t key */
	uap->key = (__typeof__(uap->key))td->td_frame->a0;

	/* [1] int msgflg */
	uap->msgflg = (__typeof__(uap->msgflg))td->td_frame->a1;

	return (0);
}

static inline int
CHERIABI_SYS_msgsnd_fill_uap(struct thread *td,
    struct msgsnd_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] int msqid */
	uap->msqid = (__typeof__(uap->msqid))td->td_frame->a0;

	/* [2] size_t msgsz */
	uap->msgsz = (__typeof__(uap->msgsz))td->td_frame->a1;

	/* [3] int msgflg */
	uap->msgflg = (__typeof__(uap->msgflg))td->td_frame->a2;

	/* [1] _In_reads_bytes_(msgsz) void * msgp */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_msgsnd, 1);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->msgp),
		    &tmpcap, 1 * uap->msgsz, reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_msgrcv_fill_uap(struct thread *td,
    struct msgrcv_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] int msqid */
	uap->msqid = (__typeof__(uap->msqid))td->td_frame->a0;

	/* [2] size_t msgsz */
	uap->msgsz = (__typeof__(uap->msgsz))td->td_frame->a1;

	/* [3] long msgtyp */
	uap->msgtyp = (__typeof__(uap->msgtyp))td->td_frame->a2;

	/* [4] int msgflg */
	uap->msgflg = (__typeof__(uap->msgflg))td->td_frame->a3;

	/* [1] _Out_writes_bytes_(msgsz) void * msgp */
	{
		int error;
		register_t reqperms = (CHERI_PERM_STORE);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_msgrcv, 1);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->msgp),
		    &tmpcap, 1 * uap->msgsz, reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_shmat_fill_uap(struct thread *td,
    struct shmat_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] int shmid */
	uap->shmid = (__typeof__(uap->shmid))td->td_frame->a0;

	/* [2] int shmflg */
	uap->shmflg = (__typeof__(uap->shmflg))td->td_frame->a1;

	/* [1] _Pagerange_vmmap_opt_(1) void * shmaddr */
	{
		int error;
		register_t reqperms = (CHERI_PERM_CHERIABI_VMMAP);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_shmat, 1);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->shmaddr),
		    &tmpcap, 1, reqperms, 1);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_shmdt_fill_uap(struct thread *td,
    struct shmdt_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] _Pagerange_vmmap_opt_(1) void * shmaddr */
	{
		int error;
		register_t reqperms = (CHERI_PERM_CHERIABI_VMMAP);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_shmdt, 0);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->shmaddr),
		    &tmpcap, 1, reqperms, 1);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_shmget_fill_uap(struct thread *td,
    struct shmget_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] key_t key */
	uap->key = (__typeof__(uap->key))td->td_frame->a0;

	/* [1] int size */
	uap->size = (__typeof__(uap->size))td->td_frame->a1;

	/* [2] int shmflg */
	uap->shmflg = (__typeof__(uap->shmflg))td->td_frame->a2;

	return (0);
}

static inline int
CHERIABI_SYS_clock_gettime_fill_uap(struct thread *td,
    struct clock_gettime_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] clockid_t clock_id */
	uap->clock_id = (__typeof__(uap->clock_id))td->td_frame->a0;

	/* [1] _Out_ struct timespec * tp */
	{
		int error;
		register_t reqperms = (CHERI_PERM_STORE);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_clock_gettime, 1);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->tp),
		    &tmpcap, sizeof(*uap->tp), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_clock_settime_fill_uap(struct thread *td,
    struct clock_settime_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] clockid_t clock_id */
	uap->clock_id = (__typeof__(uap->clock_id))td->td_frame->a0;

	/* [1] _In_ const struct timespec * tp */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_clock_settime, 1);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->tp),
		    &tmpcap, sizeof(*uap->tp), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_clock_getres_fill_uap(struct thread *td,
    struct clock_getres_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] clockid_t clock_id */
	uap->clock_id = (__typeof__(uap->clock_id))td->td_frame->a0;

	/* [1] _Out_ struct timespec * tp */
	{
		int error;
		register_t reqperms = (CHERI_PERM_STORE);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_clock_getres, 1);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->tp),
		    &tmpcap, sizeof(*uap->tp), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_cheriabi_ktimer_create_fill_uap(struct thread *td,
    struct cheriabi_ktimer_create_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] clockid_t clock_id */
	uap->clock_id = (__typeof__(uap->clock_id))td->td_frame->a0;

	/* [1] _In_ struct sigevent_c * evp */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD|CHERI_PERM_LOAD_CAP);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_ktimer_create, 1);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->evp),
		    &tmpcap, sizeof(*uap->evp), reqperms, 0);
		if (error != 0)
			return (error);
	}

	/* [2] _Out_ int * timerid */
	{
		int error;
		register_t reqperms = (CHERI_PERM_STORE);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_ktimer_create, 2);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->timerid),
		    &tmpcap, sizeof(*uap->timerid), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_ktimer_delete_fill_uap(struct thread *td,
    struct ktimer_delete_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] int timerid */
	uap->timerid = (__typeof__(uap->timerid))td->td_frame->a0;

	return (0);
}

static inline int
CHERIABI_SYS_ktimer_settime_fill_uap(struct thread *td,
    struct ktimer_settime_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] int timerid */
	uap->timerid = (__typeof__(uap->timerid))td->td_frame->a0;

	/* [1] int flags */
	uap->flags = (__typeof__(uap->flags))td->td_frame->a1;

	/* [2] _In_ const struct itimerspec * value */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_ktimer_settime, 2);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->value),
		    &tmpcap, sizeof(*uap->value), reqperms, 0);
		if (error != 0)
			return (error);
	}

	/* [3] _Out_opt_ struct itimerspec * ovalue */
	{
		int error;
		register_t reqperms = (CHERI_PERM_STORE);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_ktimer_settime, 3);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->ovalue),
		    &tmpcap, sizeof(*uap->ovalue), reqperms, 1);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_ktimer_gettime_fill_uap(struct thread *td,
    struct ktimer_gettime_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] int timerid */
	uap->timerid = (__typeof__(uap->timerid))td->td_frame->a0;

	/* [1] _Out_ struct itimerspec * value */
	{
		int error;
		register_t reqperms = (CHERI_PERM_STORE);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_ktimer_gettime, 1);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->value),
		    &tmpcap, sizeof(*uap->value), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_ktimer_getoverrun_fill_uap(struct thread *td,
    struct ktimer_getoverrun_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] int timerid */
	uap->timerid = (__typeof__(uap->timerid))td->td_frame->a0;

	return (0);
}

static inline int
CHERIABI_SYS_nanosleep_fill_uap(struct thread *td,
    struct nanosleep_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] _In_ const struct timespec * rqtp */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_nanosleep, 0);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->rqtp),
		    &tmpcap, sizeof(*uap->rqtp), reqperms, 0);
		if (error != 0)
			return (error);
	}

	/* [1] _Out_opt_ struct timespec * rmtp */
	{
		int error;
		register_t reqperms = (CHERI_PERM_STORE);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_nanosleep, 1);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->rmtp),
		    &tmpcap, sizeof(*uap->rmtp), reqperms, 1);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_ffclock_getcounter_fill_uap(struct thread *td,
    struct ffclock_getcounter_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] _Out_ ffcounter * ffcount */
	{
		int error;
		register_t reqperms = (CHERI_PERM_STORE);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_ffclock_getcounter, 0);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->ffcount),
		    &tmpcap, sizeof(*uap->ffcount), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_ffclock_setestimate_fill_uap(struct thread *td,
    struct ffclock_setestimate_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] _In_ struct ffclock_estimate * cest */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_ffclock_setestimate, 0);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->cest),
		    &tmpcap, sizeof(*uap->cest), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_ffclock_getestimate_fill_uap(struct thread *td,
    struct ffclock_getestimate_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] _Out_ struct ffclock_estimate * cest */
	{
		int error;
		register_t reqperms = (CHERI_PERM_STORE);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_ffclock_getestimate, 0);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->cest),
		    &tmpcap, sizeof(*uap->cest), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_clock_getcpuclockid2_fill_uap(struct thread *td,
    struct clock_getcpuclockid2_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] id_t id */
	uap->id = (__typeof__(uap->id))td->td_frame->a0;

	/* [1] int which */
	uap->which = (__typeof__(uap->which))td->td_frame->a1;

	/* [2] _Out_ clockid_t * clock_id */
	{
		int error;
		register_t reqperms = (CHERI_PERM_STORE);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_clock_getcpuclockid2, 2);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->clock_id),
		    &tmpcap, sizeof(*uap->clock_id), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_ntp_gettime_fill_uap(struct thread *td,
    struct ntp_gettime_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] _Out_ struct ntptimeval * ntvp */
	{
		int error;
		register_t reqperms = (CHERI_PERM_STORE);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_ntp_gettime, 0);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->ntvp),
		    &tmpcap, sizeof(*uap->ntvp), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_minherit_fill_uap(struct thread *td,
    struct minherit_args *uap)
{
	struct chericap tmpcap __unused;

	/* [1] size_t len */
	uap->len = (__typeof__(uap->len))td->td_frame->a0;

	/* [2] int inherit */
	uap->inherit = (__typeof__(uap->inherit))td->td_frame->a1;

	/* [0] _Pagerange_(len) void * addr */
	{
		int error;

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_minherit, 0);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->addr),
		    &tmpcap, uap->len, 0, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_rfork_fill_uap(struct thread *td,
    struct rfork_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] int flags */
	uap->flags = (__typeof__(uap->flags))td->td_frame->a0;

	return (0);
}

static inline int
CHERIABI_SYS_lchown_fill_uap(struct thread *td,
    struct lchown_args *uap)
{
	struct chericap tmpcap __unused;

	/* [1] int uid */
	uap->uid = (__typeof__(uap->uid))td->td_frame->a0;

	/* [2] int gid */
	uap->gid = (__typeof__(uap->gid))td->td_frame->a1;

	/* [0] _In_z_ const char * path */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_lchown, 0);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->path),
		    &tmpcap, sizeof(*uap->path), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_cheriabi_aio_read_fill_uap(struct thread *td,
    struct cheriabi_aio_read_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] _Inout_ struct aiocb_c * aiocbp */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD|CHERI_PERM_LOAD_CAP|CHERI_PERM_STORE|CHERI_PERM_STORE_CAP);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_aio_read, 0);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->aiocbp),
		    &tmpcap, sizeof(*uap->aiocbp), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_cheriabi_aio_write_fill_uap(struct thread *td,
    struct cheriabi_aio_write_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] _Inout_ struct aiocb_c * aiocbp */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD|CHERI_PERM_LOAD_CAP|CHERI_PERM_STORE|CHERI_PERM_STORE_CAP);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_aio_write, 0);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->aiocbp),
		    &tmpcap, sizeof(*uap->aiocbp), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_cheriabi_lio_listio_fill_uap(struct thread *td,
    struct cheriabi_lio_listio_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] int mode */
	uap->mode = (__typeof__(uap->mode))td->td_frame->a0;

	/* [2] int nent */
	uap->nent = (__typeof__(uap->nent))td->td_frame->a1;

	/* [1] _Inout_updates_(nent) struct aiocb_c *const * acb_list */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD|CHERI_PERM_LOAD_CAP|CHERI_PERM_STORE|CHERI_PERM_STORE_CAP);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_lio_listio, 1);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->acb_list),
		    &tmpcap, (sizeof(*uap->acb_list) * uap->nent), reqperms, 0);
		if (error != 0)
			return (error);
	}

	/* [3] _In_opt_ struct sigevent_c * sig */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD|CHERI_PERM_LOAD_CAP);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_lio_listio, 3);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->sig),
		    &tmpcap, sizeof(*uap->sig), reqperms, 1);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_getdents_fill_uap(struct thread *td,
    struct getdents_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] int fd */
	uap->fd = (__typeof__(uap->fd))td->td_frame->a0;

	/* [2] size_t count */
	uap->count = (__typeof__(uap->count))td->td_frame->a1;

	/* [1] _Out_writes_bytes_(count) char * buf */
	{
		int error;
		register_t reqperms = (CHERI_PERM_STORE);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_getdents, 1);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->buf),
		    &tmpcap, 1 * uap->count, reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_lchmod_fill_uap(struct thread *td,
    struct lchmod_args *uap)
{
	struct chericap tmpcap __unused;

	/* [1] mode_t mode */
	uap->mode = (__typeof__(uap->mode))td->td_frame->a0;

	/* [0] _In_z_ const char * path */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_lchmod, 0);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->path),
		    &tmpcap, sizeof(*uap->path), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_lutimes_fill_uap(struct thread *td,
    struct lutimes_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] _In_z_ const char * path */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_lutimes, 0);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->path),
		    &tmpcap, sizeof(*uap->path), reqperms, 0);
		if (error != 0)
			return (error);
	}

	/* [1] _In_ const struct timeval * tptr */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_lutimes, 1);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->tptr),
		    &tmpcap, sizeof(*uap->tptr), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_nstat_fill_uap(struct thread *td,
    struct nstat_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] _In_z_ const char * path */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_nstat, 0);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->path),
		    &tmpcap, sizeof(*uap->path), reqperms, 0);
		if (error != 0)
			return (error);
	}

	/* [1] _Out_ struct nstat * ub */
	{
		int error;
		register_t reqperms = (CHERI_PERM_STORE);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_nstat, 1);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->ub),
		    &tmpcap, sizeof(*uap->ub), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_nfstat_fill_uap(struct thread *td,
    struct nfstat_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] int fd */
	uap->fd = (__typeof__(uap->fd))td->td_frame->a0;

	/* [1] _Out_ struct nstat * sb */
	{
		int error;
		register_t reqperms = (CHERI_PERM_STORE);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_nfstat, 1);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->sb),
		    &tmpcap, sizeof(*uap->sb), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_nlstat_fill_uap(struct thread *td,
    struct nlstat_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] _In_z_ const char * path */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_nlstat, 0);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->path),
		    &tmpcap, sizeof(*uap->path), reqperms, 0);
		if (error != 0)
			return (error);
	}

	/* [1] _Out_ struct nstat * ub */
	{
		int error;
		register_t reqperms = (CHERI_PERM_STORE);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_nlstat, 1);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->ub),
		    &tmpcap, sizeof(*uap->ub), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_cheriabi_preadv_fill_uap(struct thread *td,
    struct cheriabi_preadv_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] int fd */
	uap->fd = (__typeof__(uap->fd))td->td_frame->a0;

	/* [2] u_int iovcnt */
	uap->iovcnt = (__typeof__(uap->iovcnt))td->td_frame->a1;

	/* [3] off_t offset */
	uap->offset = (__typeof__(uap->offset))td->td_frame->a2;

	/* [1] _In_reads_(iovcnt) struct iovec_c * iovp */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD|CHERI_PERM_LOAD_CAP);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_preadv, 1);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->iovp),
		    &tmpcap, (sizeof(*uap->iovp) * uap->iovcnt), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_cheriabi_pwritev_fill_uap(struct thread *td,
    struct cheriabi_pwritev_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] int fd */
	uap->fd = (__typeof__(uap->fd))td->td_frame->a0;

	/* [2] u_int iovcnt */
	uap->iovcnt = (__typeof__(uap->iovcnt))td->td_frame->a1;

	/* [3] off_t offset */
	uap->offset = (__typeof__(uap->offset))td->td_frame->a2;

	/* [1] _In_reads_(iovcnt) struct iovec_c * iovp */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD|CHERI_PERM_LOAD_CAP);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_pwritev, 1);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->iovp),
		    &tmpcap, (sizeof(*uap->iovp) * uap->iovcnt), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_fhopen_fill_uap(struct thread *td,
    struct fhopen_args *uap)
{
	struct chericap tmpcap __unused;

	/* [1] int flags */
	uap->flags = (__typeof__(uap->flags))td->td_frame->a0;

	/* [0] _In_ const struct fhandle * u_fhp */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_fhopen, 0);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->u_fhp),
		    &tmpcap, sizeof(*uap->u_fhp), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_fhstat_fill_uap(struct thread *td,
    struct fhstat_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] _In_ const struct fhandle * u_fhp */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_fhstat, 0);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->u_fhp),
		    &tmpcap, sizeof(*uap->u_fhp), reqperms, 0);
		if (error != 0)
			return (error);
	}

	/* [1] _Out_ struct stat * sb */
	{
		int error;
		register_t reqperms = (CHERI_PERM_STORE);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_fhstat, 1);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->sb),
		    &tmpcap, sizeof(*uap->sb), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_modnext_fill_uap(struct thread *td,
    struct modnext_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] int modid */
	uap->modid = (__typeof__(uap->modid))td->td_frame->a0;

	return (0);
}

static inline int
CHERIABI_SYS_modstat_fill_uap(struct thread *td,
    struct modstat_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] int modid */
	uap->modid = (__typeof__(uap->modid))td->td_frame->a0;

	/* [1] _Out_ struct module_stat * stat */
	{
		int error;
		register_t reqperms = (CHERI_PERM_STORE);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_modstat, 1);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->stat),
		    &tmpcap, sizeof(*uap->stat), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_modfnext_fill_uap(struct thread *td,
    struct modfnext_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] int modid */
	uap->modid = (__typeof__(uap->modid))td->td_frame->a0;

	return (0);
}

static inline int
CHERIABI_SYS_modfind_fill_uap(struct thread *td,
    struct modfind_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] _In_z_ const char * name */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_modfind, 0);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->name),
		    &tmpcap, sizeof(*uap->name), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_kldload_fill_uap(struct thread *td,
    struct kldload_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] _In_z_ const char * file */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_kldload, 0);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->file),
		    &tmpcap, sizeof(*uap->file), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_kldunload_fill_uap(struct thread *td,
    struct kldunload_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] int fileid */
	uap->fileid = (__typeof__(uap->fileid))td->td_frame->a0;

	return (0);
}

static inline int
CHERIABI_SYS_kldfind_fill_uap(struct thread *td,
    struct kldfind_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] _In_z_ const char * file */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_kldfind, 0);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->file),
		    &tmpcap, sizeof(*uap->file), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_kldnext_fill_uap(struct thread *td,
    struct kldnext_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] int fileid */
	uap->fileid = (__typeof__(uap->fileid))td->td_frame->a0;

	return (0);
}

static inline int
CHERIABI_SYS_kldstat_fill_uap(struct thread *td,
    struct kldstat_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] int fileid */
	uap->fileid = (__typeof__(uap->fileid))td->td_frame->a0;

	/* [1] _Out_ struct kld_file_stat * stat */
	{
		int error;
		register_t reqperms = (CHERI_PERM_STORE);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_kldstat, 1);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->stat),
		    &tmpcap, sizeof(*uap->stat), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_kldfirstmod_fill_uap(struct thread *td,
    struct kldfirstmod_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] int fileid */
	uap->fileid = (__typeof__(uap->fileid))td->td_frame->a0;

	return (0);
}

static inline int
CHERIABI_SYS_getsid_fill_uap(struct thread *td,
    struct getsid_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] pid_t pid */
	uap->pid = (__typeof__(uap->pid))td->td_frame->a0;

	return (0);
}

static inline int
CHERIABI_SYS_setresuid_fill_uap(struct thread *td,
    struct setresuid_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] uid_t ruid */
	uap->ruid = (__typeof__(uap->ruid))td->td_frame->a0;

	/* [1] uid_t euid */
	uap->euid = (__typeof__(uap->euid))td->td_frame->a1;

	/* [2] uid_t suid */
	uap->suid = (__typeof__(uap->suid))td->td_frame->a2;

	return (0);
}

static inline int
CHERIABI_SYS_setresgid_fill_uap(struct thread *td,
    struct setresgid_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] gid_t rgid */
	uap->rgid = (__typeof__(uap->rgid))td->td_frame->a0;

	/* [1] gid_t egid */
	uap->egid = (__typeof__(uap->egid))td->td_frame->a1;

	/* [2] gid_t sgid */
	uap->sgid = (__typeof__(uap->sgid))td->td_frame->a2;

	return (0);
}

static inline int
CHERIABI_SYS_cheriabi_aio_return_fill_uap(struct thread *td,
    struct cheriabi_aio_return_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] _Inout_ struct aiocb_c * aiocbp */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD|CHERI_PERM_LOAD_CAP|CHERI_PERM_STORE|CHERI_PERM_STORE_CAP);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_aio_return, 0);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->aiocbp),
		    &tmpcap, sizeof(*uap->aiocbp), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_cheriabi_aio_suspend_fill_uap(struct thread *td,
    struct cheriabi_aio_suspend_args *uap)
{
	struct chericap tmpcap __unused;

	/* [1] int nent */
	uap->nent = (__typeof__(uap->nent))td->td_frame->a0;

	/* [0] _Inout_updates_(nent) struct aiocb_c *const * aiocbp */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD|CHERI_PERM_LOAD_CAP|CHERI_PERM_STORE|CHERI_PERM_STORE_CAP);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_aio_suspend, 0);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->aiocbp),
		    &tmpcap, (sizeof(*uap->aiocbp) * uap->nent), reqperms, 0);
		if (error != 0)
			return (error);
	}

	/* [2] _In_opt_ const struct timespec * timeout */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_aio_suspend, 2);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->timeout),
		    &tmpcap, sizeof(*uap->timeout), reqperms, 1);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_cheriabi_aio_cancel_fill_uap(struct thread *td,
    struct cheriabi_aio_cancel_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] int fd */
	uap->fd = (__typeof__(uap->fd))td->td_frame->a0;

	/* [1] _In_opt_ struct aiocb_c * aiocbp */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD|CHERI_PERM_LOAD_CAP);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_aio_cancel, 1);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->aiocbp),
		    &tmpcap, sizeof(*uap->aiocbp), reqperms, 1);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_cheriabi_aio_error_fill_uap(struct thread *td,
    struct cheriabi_aio_error_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] _In_ struct aiocb_c * aiocbp */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD|CHERI_PERM_LOAD_CAP);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_aio_error, 0);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->aiocbp),
		    &tmpcap, sizeof(*uap->aiocbp), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_mlockall_fill_uap(struct thread *td,
    struct mlockall_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] int how */
	uap->how = (__typeof__(uap->how))td->td_frame->a0;

	return (0);
}

static inline int
CHERIABI_SYS___getcwd_fill_uap(struct thread *td,
    struct __getcwd_args *uap)
{
	struct chericap tmpcap __unused;

	/* [1] size_t buflen */
	uap->buflen = (__typeof__(uap->buflen))td->td_frame->a0;

	/* [0] _Out_writes_z_(buflen) char * buf */
	{
		int error;
		register_t reqperms = (CHERI_PERM_STORE);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS___getcwd, 0);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->buf),
		    &tmpcap, (sizeof(*uap->buf) * uap->buflen), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_sched_setparam_fill_uap(struct thread *td,
    struct sched_setparam_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] pid_t pid */
	uap->pid = (__typeof__(uap->pid))td->td_frame->a0;

	/* [1] _In_ const struct sched_param * param */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_sched_setparam, 1);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->param),
		    &tmpcap, sizeof(*uap->param), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_sched_getparam_fill_uap(struct thread *td,
    struct sched_getparam_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] pid_t pid */
	uap->pid = (__typeof__(uap->pid))td->td_frame->a0;

	/* [1] _Out_ struct sched_param * param */
	{
		int error;
		register_t reqperms = (CHERI_PERM_STORE);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_sched_getparam, 1);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->param),
		    &tmpcap, sizeof(*uap->param), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_sched_setscheduler_fill_uap(struct thread *td,
    struct sched_setscheduler_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] pid_t pid */
	uap->pid = (__typeof__(uap->pid))td->td_frame->a0;

	/* [1] int policy */
	uap->policy = (__typeof__(uap->policy))td->td_frame->a1;

	/* [2] _In_ const struct sched_param * param */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_sched_setscheduler, 2);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->param),
		    &tmpcap, sizeof(*uap->param), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_sched_getscheduler_fill_uap(struct thread *td,
    struct sched_getscheduler_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] pid_t pid */
	uap->pid = (__typeof__(uap->pid))td->td_frame->a0;

	return (0);
}

static inline int
CHERIABI_SYS_sched_get_priority_max_fill_uap(struct thread *td,
    struct sched_get_priority_max_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] int policy */
	uap->policy = (__typeof__(uap->policy))td->td_frame->a0;

	return (0);
}

static inline int
CHERIABI_SYS_sched_get_priority_min_fill_uap(struct thread *td,
    struct sched_get_priority_min_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] int policy */
	uap->policy = (__typeof__(uap->policy))td->td_frame->a0;

	return (0);
}

static inline int
CHERIABI_SYS_sched_rr_get_interval_fill_uap(struct thread *td,
    struct sched_rr_get_interval_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] pid_t pid */
	uap->pid = (__typeof__(uap->pid))td->td_frame->a0;

	/* [1] _Out_ struct timespec * interval */
	{
		int error;
		register_t reqperms = (CHERI_PERM_STORE);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_sched_rr_get_interval, 1);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->interval),
		    &tmpcap, sizeof(*uap->interval), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_utrace_fill_uap(struct thread *td,
    struct utrace_args *uap)
{
	struct chericap tmpcap __unused;

	/* [1] size_t len */
	uap->len = (__typeof__(uap->len))td->td_frame->a0;

	/* [0] _In_reads_bytes_(len) const void * addr */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_utrace, 0);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->addr),
		    &tmpcap, 1 * uap->len, reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_cheriabi_kldsym_fill_uap(struct thread *td,
    struct cheriabi_kldsym_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] int fileid */
	uap->fileid = (__typeof__(uap->fileid))td->td_frame->a0;

	/* [1] int cmd */
	uap->cmd = (__typeof__(uap->cmd))td->td_frame->a1;

	/* [2] _In_ struct kld_sym_lookup_c * data */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD|CHERI_PERM_LOAD_CAP);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_kldsym, 2);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->data),
		    &tmpcap, sizeof(*uap->data), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_cheriabi_jail_fill_uap(struct thread *td,
    struct cheriabi_jail_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] _In_ struct jail_c * jailp */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD|CHERI_PERM_LOAD_CAP);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_jail, 0);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->jailp),
		    &tmpcap, sizeof(*uap->jailp), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_sigprocmask_fill_uap(struct thread *td,
    struct sigprocmask_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] int how */
	uap->how = (__typeof__(uap->how))td->td_frame->a0;

	/* [1] _In_opt_ const sigset_t * set */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_sigprocmask, 1);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->set),
		    &tmpcap, sizeof(*uap->set), reqperms, 1);
		if (error != 0)
			return (error);
	}

	/* [2] _Out_opt_ sigset_t * oset */
	{
		int error;
		register_t reqperms = (CHERI_PERM_STORE);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_sigprocmask, 2);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->oset),
		    &tmpcap, sizeof(*uap->oset), reqperms, 1);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_sigsuspend_fill_uap(struct thread *td,
    struct sigsuspend_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] _In_ const sigset_t * sigmask */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_sigsuspend, 0);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->sigmask),
		    &tmpcap, sizeof(*uap->sigmask), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_sigpending_fill_uap(struct thread *td,
    struct sigpending_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] _In_ sigset_t * set */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_sigpending, 0);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->set),
		    &tmpcap, sizeof(*uap->set), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_cheriabi_sigtimedwait_fill_uap(struct thread *td,
    struct cheriabi_sigtimedwait_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] _In_ const sigset_t * set */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_sigtimedwait, 0);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->set),
		    &tmpcap, sizeof(*uap->set), reqperms, 0);
		if (error != 0)
			return (error);
	}

	/* [1] _Out_opt_ struct siginfo_c * info */
	{
		int error;
		register_t reqperms = (CHERI_PERM_STORE|CHERI_PERM_STORE_CAP);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_sigtimedwait, 1);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->info),
		    &tmpcap, sizeof(*uap->info), reqperms, 1);
		if (error != 0)
			return (error);
	}

	/* [2] _In_ const struct timespec * timeout */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_sigtimedwait, 2);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->timeout),
		    &tmpcap, sizeof(*uap->timeout), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_cheriabi_sigwaitinfo_fill_uap(struct thread *td,
    struct cheriabi_sigwaitinfo_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] _In_ const sigset_t * set */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_sigwaitinfo, 0);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->set),
		    &tmpcap, sizeof(*uap->set), reqperms, 0);
		if (error != 0)
			return (error);
	}

	/* [1] _Out_opt_ struct siginfo_c * info */
	{
		int error;
		register_t reqperms = (CHERI_PERM_STORE|CHERI_PERM_STORE_CAP);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_sigwaitinfo, 1);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->info),
		    &tmpcap, sizeof(*uap->info), reqperms, 1);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS___acl_get_file_fill_uap(struct thread *td,
    struct __acl_get_file_args *uap)
{
	struct chericap tmpcap __unused;

	/* [1] acl_type_t type */
	uap->type = (__typeof__(uap->type))td->td_frame->a0;

	/* [0] _In_z_ const char * path */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS___acl_get_file, 0);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->path),
		    &tmpcap, sizeof(*uap->path), reqperms, 0);
		if (error != 0)
			return (error);
	}

	/* [2] _Out_ struct acl * aclp */
	{
		int error;
		register_t reqperms = (CHERI_PERM_STORE);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS___acl_get_file, 2);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->aclp),
		    &tmpcap, sizeof(*uap->aclp), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS___acl_set_file_fill_uap(struct thread *td,
    struct __acl_set_file_args *uap)
{
	struct chericap tmpcap __unused;

	/* [1] acl_type_t type */
	uap->type = (__typeof__(uap->type))td->td_frame->a0;

	/* [0] _In_z_ const char * path */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS___acl_set_file, 0);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->path),
		    &tmpcap, sizeof(*uap->path), reqperms, 0);
		if (error != 0)
			return (error);
	}

	/* [2] _In_ struct acl * aclp */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS___acl_set_file, 2);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->aclp),
		    &tmpcap, sizeof(*uap->aclp), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS___acl_get_fd_fill_uap(struct thread *td,
    struct __acl_get_fd_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] int filedes */
	uap->filedes = (__typeof__(uap->filedes))td->td_frame->a0;

	/* [1] acl_type_t type */
	uap->type = (__typeof__(uap->type))td->td_frame->a1;

	/* [2] _Out_ struct acl * aclp */
	{
		int error;
		register_t reqperms = (CHERI_PERM_STORE);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS___acl_get_fd, 2);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->aclp),
		    &tmpcap, sizeof(*uap->aclp), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS___acl_set_fd_fill_uap(struct thread *td,
    struct __acl_set_fd_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] int filedes */
	uap->filedes = (__typeof__(uap->filedes))td->td_frame->a0;

	/* [1] acl_type_t type */
	uap->type = (__typeof__(uap->type))td->td_frame->a1;

	/* [2] _In_ struct acl * aclp */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS___acl_set_fd, 2);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->aclp),
		    &tmpcap, sizeof(*uap->aclp), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS___acl_delete_file_fill_uap(struct thread *td,
    struct __acl_delete_file_args *uap)
{
	struct chericap tmpcap __unused;

	/* [1] acl_type_t type */
	uap->type = (__typeof__(uap->type))td->td_frame->a0;

	/* [0] _In_z_ const char * path */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS___acl_delete_file, 0);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->path),
		    &tmpcap, sizeof(*uap->path), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS___acl_delete_fd_fill_uap(struct thread *td,
    struct __acl_delete_fd_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] int filedes */
	uap->filedes = (__typeof__(uap->filedes))td->td_frame->a0;

	/* [1] acl_type_t type */
	uap->type = (__typeof__(uap->type))td->td_frame->a1;

	return (0);
}

static inline int
CHERIABI_SYS___acl_aclcheck_file_fill_uap(struct thread *td,
    struct __acl_aclcheck_file_args *uap)
{
	struct chericap tmpcap __unused;

	/* [1] acl_type_t type */
	uap->type = (__typeof__(uap->type))td->td_frame->a0;

	/* [0] _In_z_ const char * path */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS___acl_aclcheck_file, 0);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->path),
		    &tmpcap, sizeof(*uap->path), reqperms, 0);
		if (error != 0)
			return (error);
	}

	/* [2] _In_ struct acl * aclp */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS___acl_aclcheck_file, 2);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->aclp),
		    &tmpcap, sizeof(*uap->aclp), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS___acl_aclcheck_fd_fill_uap(struct thread *td,
    struct __acl_aclcheck_fd_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] int filedes */
	uap->filedes = (__typeof__(uap->filedes))td->td_frame->a0;

	/* [1] acl_type_t type */
	uap->type = (__typeof__(uap->type))td->td_frame->a1;

	/* [2] _In_ struct acl * aclp */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS___acl_aclcheck_fd, 2);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->aclp),
		    &tmpcap, sizeof(*uap->aclp), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_extattrctl_fill_uap(struct thread *td,
    struct extattrctl_args *uap)
{
	struct chericap tmpcap __unused;

	/* [1] int cmd */
	uap->cmd = (__typeof__(uap->cmd))td->td_frame->a0;

	/* [3] int attrnamespace */
	uap->attrnamespace = (__typeof__(uap->attrnamespace))td->td_frame->a1;

	/* [0] _In_z_ const char * path */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_extattrctl, 0);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->path),
		    &tmpcap, sizeof(*uap->path), reqperms, 0);
		if (error != 0)
			return (error);
	}

	/* [2] _In_z_opt_ const char * filename */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_extattrctl, 2);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->filename),
		    &tmpcap, sizeof(*uap->filename), reqperms, 1);
		if (error != 0)
			return (error);
	}

	/* [4] _In_z_ const char * attrname */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_extattrctl, 4);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->attrname),
		    &tmpcap, sizeof(*uap->attrname), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_extattr_set_file_fill_uap(struct thread *td,
    struct extattr_set_file_args *uap)
{
	struct chericap tmpcap __unused;

	/* [1] int attrnamespace */
	uap->attrnamespace = (__typeof__(uap->attrnamespace))td->td_frame->a0;

	/* [4] size_t nbytes */
	uap->nbytes = (__typeof__(uap->nbytes))td->td_frame->a1;

	/* [0] _In_z_ const char * path */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_extattr_set_file, 0);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->path),
		    &tmpcap, sizeof(*uap->path), reqperms, 0);
		if (error != 0)
			return (error);
	}

	/* [2] _In_z_ const char * attrname */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_extattr_set_file, 2);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->attrname),
		    &tmpcap, sizeof(*uap->attrname), reqperms, 0);
		if (error != 0)
			return (error);
	}

	/* [3] _In_reads_bytes_(nbytes) void * data */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_extattr_set_file, 3);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->data),
		    &tmpcap, 1 * uap->nbytes, reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_extattr_get_file_fill_uap(struct thread *td,
    struct extattr_get_file_args *uap)
{
	struct chericap tmpcap __unused;

	/* [1] int attrnamespace */
	uap->attrnamespace = (__typeof__(uap->attrnamespace))td->td_frame->a0;

	/* [4] size_t nbytes */
	uap->nbytes = (__typeof__(uap->nbytes))td->td_frame->a1;

	/* [0] _In_z_ const char * path */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_extattr_get_file, 0);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->path),
		    &tmpcap, sizeof(*uap->path), reqperms, 0);
		if (error != 0)
			return (error);
	}

	/* [2] _In_z_ const char * attrname */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_extattr_get_file, 2);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->attrname),
		    &tmpcap, sizeof(*uap->attrname), reqperms, 0);
		if (error != 0)
			return (error);
	}

	/* [3] _Out_writes_bytes_(nbytes) void * data */
	{
		int error;
		register_t reqperms = (CHERI_PERM_STORE);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_extattr_get_file, 3);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->data),
		    &tmpcap, 1 * uap->nbytes, reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_extattr_delete_file_fill_uap(struct thread *td,
    struct extattr_delete_file_args *uap)
{
	struct chericap tmpcap __unused;

	/* [1] int attrnamespace */
	uap->attrnamespace = (__typeof__(uap->attrnamespace))td->td_frame->a0;

	/* [0] _In_z_ const char * path */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_extattr_delete_file, 0);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->path),
		    &tmpcap, sizeof(*uap->path), reqperms, 0);
		if (error != 0)
			return (error);
	}

	/* [2] _In_z_ const char * attrname */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_extattr_delete_file, 2);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->attrname),
		    &tmpcap, sizeof(*uap->attrname), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_cheriabi_aio_waitcomplete_fill_uap(struct thread *td,
    struct cheriabi_aio_waitcomplete_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] _Outptr_result_maybenull_ struct aiocb_c ** aiocbp */
	{
		int error;
		register_t reqperms = (CHERI_PERM_STORE|CHERI_PERM_STORE_CAP);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_aio_waitcomplete, 0);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->aiocbp),
		    &tmpcap, sizeof(*uap->aiocbp), reqperms, 0);
		if (error != 0)
			return (error);
	}

	/* [1] _In_opt_ struct timespec * timeout */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_aio_waitcomplete, 1);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->timeout),
		    &tmpcap, sizeof(*uap->timeout), reqperms, 1);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_getresuid_fill_uap(struct thread *td,
    struct getresuid_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] _Out_opt_ uid_t * ruid */
	{
		int error;
		register_t reqperms = (CHERI_PERM_STORE);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_getresuid, 0);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->ruid),
		    &tmpcap, sizeof(*uap->ruid), reqperms, 1);
		if (error != 0)
			return (error);
	}

	/* [1] _Out_opt_ uid_t * euid */
	{
		int error;
		register_t reqperms = (CHERI_PERM_STORE);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_getresuid, 1);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->euid),
		    &tmpcap, sizeof(*uap->euid), reqperms, 1);
		if (error != 0)
			return (error);
	}

	/* [2] _Out_opt_ uid_t * suid */
	{
		int error;
		register_t reqperms = (CHERI_PERM_STORE);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_getresuid, 2);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->suid),
		    &tmpcap, sizeof(*uap->suid), reqperms, 1);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_getresgid_fill_uap(struct thread *td,
    struct getresgid_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] _Out_opt_ gid_t * rgid */
	{
		int error;
		register_t reqperms = (CHERI_PERM_STORE);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_getresgid, 0);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->rgid),
		    &tmpcap, sizeof(*uap->rgid), reqperms, 1);
		if (error != 0)
			return (error);
	}

	/* [1] _Out_opt_ gid_t * egid */
	{
		int error;
		register_t reqperms = (CHERI_PERM_STORE);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_getresgid, 1);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->egid),
		    &tmpcap, sizeof(*uap->egid), reqperms, 1);
		if (error != 0)
			return (error);
	}

	/* [2] _Out_opt_ gid_t * sgid */
	{
		int error;
		register_t reqperms = (CHERI_PERM_STORE);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_getresgid, 2);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->sgid),
		    &tmpcap, sizeof(*uap->sgid), reqperms, 1);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_cheriabi_kevent_fill_uap(struct thread *td,
    struct cheriabi_kevent_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] int fd */
	uap->fd = (__typeof__(uap->fd))td->td_frame->a0;

	/* [2] int nchanges */
	uap->nchanges = (__typeof__(uap->nchanges))td->td_frame->a1;

	/* [4] int nevents */
	uap->nevents = (__typeof__(uap->nevents))td->td_frame->a2;

	/* [1] _In_reads_opt_(nchanges) const struct kevent_c * changelist */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD|CHERI_PERM_LOAD_CAP);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_kevent, 1);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->changelist),
		    &tmpcap, (sizeof(*uap->changelist) * uap->nchanges), reqperms, 1);
		if (error != 0)
			return (error);
	}

	/* [3] _In_reads_opt_(nevents) struct kevent_c * eventlist */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD|CHERI_PERM_LOAD_CAP);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_kevent, 3);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->eventlist),
		    &tmpcap, (sizeof(*uap->eventlist) * uap->nevents), reqperms, 1);
		if (error != 0)
			return (error);
	}

	/* [5] _In_opt_ const struct timespec * timeout */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_kevent, 5);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->timeout),
		    &tmpcap, sizeof(*uap->timeout), reqperms, 1);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_extattr_set_fd_fill_uap(struct thread *td,
    struct extattr_set_fd_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] int fd */
	uap->fd = (__typeof__(uap->fd))td->td_frame->a0;

	/* [1] int attrnamespace */
	uap->attrnamespace = (__typeof__(uap->attrnamespace))td->td_frame->a1;

	/* [4] size_t nbytes */
	uap->nbytes = (__typeof__(uap->nbytes))td->td_frame->a2;

	/* [2] _In_z_ const char * attrname */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_extattr_set_fd, 2);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->attrname),
		    &tmpcap, sizeof(*uap->attrname), reqperms, 0);
		if (error != 0)
			return (error);
	}

	/* [3] _In_reads_bytes_(nbytes) void * data */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_extattr_set_fd, 3);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->data),
		    &tmpcap, 1 * uap->nbytes, reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_extattr_get_fd_fill_uap(struct thread *td,
    struct extattr_get_fd_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] int fd */
	uap->fd = (__typeof__(uap->fd))td->td_frame->a0;

	/* [1] int attrnamespace */
	uap->attrnamespace = (__typeof__(uap->attrnamespace))td->td_frame->a1;

	/* [4] size_t nbytes */
	uap->nbytes = (__typeof__(uap->nbytes))td->td_frame->a2;

	/* [2] _In_z_ const char * attrname */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_extattr_get_fd, 2);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->attrname),
		    &tmpcap, sizeof(*uap->attrname), reqperms, 0);
		if (error != 0)
			return (error);
	}

	/* [3] _Out_writes_bytes_(nbytes) void * data */
	{
		int error;
		register_t reqperms = (CHERI_PERM_STORE);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_extattr_get_fd, 3);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->data),
		    &tmpcap, 1 * uap->nbytes, reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_extattr_delete_fd_fill_uap(struct thread *td,
    struct extattr_delete_fd_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] int fd */
	uap->fd = (__typeof__(uap->fd))td->td_frame->a0;

	/* [1] int attrnamespace */
	uap->attrnamespace = (__typeof__(uap->attrnamespace))td->td_frame->a1;

	/* [2] _In_z_ const char * attrname */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_extattr_delete_fd, 2);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->attrname),
		    &tmpcap, sizeof(*uap->attrname), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS___setugid_fill_uap(struct thread *td,
    struct __setugid_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] int flag */
	uap->flag = (__typeof__(uap->flag))td->td_frame->a0;

	return (0);
}

static inline int
CHERIABI_SYS_eaccess_fill_uap(struct thread *td,
    struct eaccess_args *uap)
{
	struct chericap tmpcap __unused;

	/* [1] int amode */
	uap->amode = (__typeof__(uap->amode))td->td_frame->a0;

	/* [0] _In_z_ char * path */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_eaccess, 0);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->path),
		    &tmpcap, sizeof(*uap->path), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_cheriabi_nmount_fill_uap(struct thread *td,
    struct cheriabi_nmount_args *uap)
{
	struct chericap tmpcap __unused;

	/* [1] unsigned int iovcnt */
	uap->iovcnt = (__typeof__(uap->iovcnt))td->td_frame->a0;

	/* [2] int flags */
	uap->flags = (__typeof__(uap->flags))td->td_frame->a1;

	/* [0] _In_reads_(iovcnt) struct iovec_c * iovp */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD|CHERI_PERM_LOAD_CAP);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_nmount, 0);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->iovp),
		    &tmpcap, (sizeof(*uap->iovp) * uap->iovcnt), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_cheriabi___mac_get_proc_fill_uap(struct thread *td,
    struct cheriabi___mac_get_proc_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] _In_ struct mac_c * mac_p */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD|CHERI_PERM_LOAD_CAP);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi___mac_get_proc, 0);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->mac_p),
		    &tmpcap, sizeof(*uap->mac_p), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_cheriabi___mac_set_proc_fill_uap(struct thread *td,
    struct cheriabi___mac_set_proc_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] _In_ struct mac_c * mac_p */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD|CHERI_PERM_LOAD_CAP);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi___mac_set_proc, 0);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->mac_p),
		    &tmpcap, sizeof(*uap->mac_p), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_cheriabi___mac_get_fd_fill_uap(struct thread *td,
    struct cheriabi___mac_get_fd_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] int fd */
	uap->fd = (__typeof__(uap->fd))td->td_frame->a0;

	/* [1] _In_ struct mac_c * mac_p */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD|CHERI_PERM_LOAD_CAP);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi___mac_get_fd, 1);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->mac_p),
		    &tmpcap, sizeof(*uap->mac_p), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_cheriabi___mac_get_file_fill_uap(struct thread *td,
    struct cheriabi___mac_get_file_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] _In_z_ const char * path_p */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi___mac_get_file, 0);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->path_p),
		    &tmpcap, sizeof(*uap->path_p), reqperms, 0);
		if (error != 0)
			return (error);
	}

	/* [1] _In_ struct mac_c * mac_p */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD|CHERI_PERM_LOAD_CAP);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi___mac_get_file, 1);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->mac_p),
		    &tmpcap, sizeof(*uap->mac_p), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_cheriabi___mac_set_fd_fill_uap(struct thread *td,
    struct cheriabi___mac_set_fd_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] int fd */
	uap->fd = (__typeof__(uap->fd))td->td_frame->a0;

	/* [1] _In_ struct mac_c * mac_p */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD|CHERI_PERM_LOAD_CAP);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi___mac_set_fd, 1);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->mac_p),
		    &tmpcap, sizeof(*uap->mac_p), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_cheriabi___mac_set_file_fill_uap(struct thread *td,
    struct cheriabi___mac_set_file_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] _In_z_ const char * path_p */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi___mac_set_file, 0);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->path_p),
		    &tmpcap, sizeof(*uap->path_p), reqperms, 0);
		if (error != 0)
			return (error);
	}

	/* [1] _In_ struct mac_c * mac_p */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD|CHERI_PERM_LOAD_CAP);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi___mac_set_file, 1);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->mac_p),
		    &tmpcap, sizeof(*uap->mac_p), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_kenv_fill_uap(struct thread *td,
    struct kenv_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] int what */
	uap->what = (__typeof__(uap->what))td->td_frame->a0;

	/* [3] int len */
	uap->len = (__typeof__(uap->len))td->td_frame->a1;

	/* [1] _In_z_ const char * name */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_kenv, 1);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->name),
		    &tmpcap, sizeof(*uap->name), reqperms, 0);
		if (error != 0)
			return (error);
	}

	/* [2] _Inout_ char * value */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD|CHERI_PERM_STORE);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_kenv, 2);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->value),
		    &tmpcap, sizeof(*uap->value), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_lchflags_fill_uap(struct thread *td,
    struct lchflags_args *uap)
{
	struct chericap tmpcap __unused;

	/* [1] u_long flags */
	uap->flags = (__typeof__(uap->flags))td->td_frame->a0;

	/* [0] _In_z_ const char * path */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_lchflags, 0);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->path),
		    &tmpcap, sizeof(*uap->path), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_uuidgen_fill_uap(struct thread *td,
    struct uuidgen_args *uap)
{
	struct chericap tmpcap __unused;

	/* [1] int count */
	uap->count = (__typeof__(uap->count))td->td_frame->a0;

	/* [0] _Out_writes_(count) struct uuid * store */
	{
		int error;
		register_t reqperms = (CHERI_PERM_STORE);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_uuidgen, 0);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->store),
		    &tmpcap, (sizeof(*uap->store) * uap->count), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_cheriabi_sendfile_fill_uap(struct thread *td,
    struct cheriabi_sendfile_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] int fd */
	uap->fd = (__typeof__(uap->fd))td->td_frame->a0;

	/* [1] int s */
	uap->s = (__typeof__(uap->s))td->td_frame->a1;

	/* [2] off_t offset */
	uap->offset = (__typeof__(uap->offset))td->td_frame->a2;

	/* [3] size_t nbytes */
	uap->nbytes = (__typeof__(uap->nbytes))td->td_frame->a3;

	/* [6] int flags */
	uap->flags = (__typeof__(uap->flags))td->td_frame->a4;

	/* [4] _In_opt_ struct sf_hdtr_c * hdtr */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD|CHERI_PERM_LOAD_CAP);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_sendfile, 4);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->hdtr),
		    &tmpcap, sizeof(*uap->hdtr), reqperms, 1);
		if (error != 0)
			return (error);
	}

	/* [5] _Out_opt_ off_t * sbytes */
	{
		int error;
		register_t reqperms = (CHERI_PERM_STORE);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_sendfile, 5);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->sbytes),
		    &tmpcap, sizeof(*uap->sbytes), reqperms, 1);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int	CHERIABI_SYS_mac_syscall_fill_uap(struct thread *td,
    struct mac_syscall_args *uap);

static inline int
CHERIABI_SYS_getfsstat_fill_uap(struct thread *td,
    struct getfsstat_args *uap)
{
	struct chericap tmpcap __unused;

	/* [1] long bufsize */
	uap->bufsize = (__typeof__(uap->bufsize))td->td_frame->a0;

	/* [2] int mode */
	uap->mode = (__typeof__(uap->mode))td->td_frame->a1;

	/* [0] _Out_writes_bytes_opt_(bufsize) struct statfs * buf */
	{
		int error;
		register_t reqperms = (CHERI_PERM_STORE);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_getfsstat, 0);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->buf),
		    &tmpcap, 1 * uap->bufsize, reqperms, 1);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_statfs_fill_uap(struct thread *td,
    struct statfs_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] _In_z_ char * path */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_statfs, 0);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->path),
		    &tmpcap, sizeof(*uap->path), reqperms, 0);
		if (error != 0)
			return (error);
	}

	/* [1] _Out_ struct statfs * buf */
	{
		int error;
		register_t reqperms = (CHERI_PERM_STORE);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_statfs, 1);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->buf),
		    &tmpcap, sizeof(*uap->buf), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_fstatfs_fill_uap(struct thread *td,
    struct fstatfs_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] int fd */
	uap->fd = (__typeof__(uap->fd))td->td_frame->a0;

	/* [1] _Out_ struct statfs * buf */
	{
		int error;
		register_t reqperms = (CHERI_PERM_STORE);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_fstatfs, 1);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->buf),
		    &tmpcap, sizeof(*uap->buf), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_fhstatfs_fill_uap(struct thread *td,
    struct fhstatfs_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] _In_ const struct fhandle * u_fhp */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_fhstatfs, 0);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->u_fhp),
		    &tmpcap, sizeof(*uap->u_fhp), reqperms, 0);
		if (error != 0)
			return (error);
	}

	/* [1] _Out_ struct statfs * buf */
	{
		int error;
		register_t reqperms = (CHERI_PERM_STORE);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_fhstatfs, 1);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->buf),
		    &tmpcap, sizeof(*uap->buf), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_cheriabi___mac_get_pid_fill_uap(struct thread *td,
    struct cheriabi___mac_get_pid_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] pid_t pid */
	uap->pid = (__typeof__(uap->pid))td->td_frame->a0;

	/* [1] _In_ struct mac_c * mac_p */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD|CHERI_PERM_LOAD_CAP);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi___mac_get_pid, 1);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->mac_p),
		    &tmpcap, sizeof(*uap->mac_p), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_cheriabi___mac_get_link_fill_uap(struct thread *td,
    struct cheriabi___mac_get_link_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] _In_z_ const char * path_p */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi___mac_get_link, 0);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->path_p),
		    &tmpcap, sizeof(*uap->path_p), reqperms, 0);
		if (error != 0)
			return (error);
	}

	/* [1] _In_ struct mac_c * mac_p */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD|CHERI_PERM_LOAD_CAP);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi___mac_get_link, 1);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->mac_p),
		    &tmpcap, sizeof(*uap->mac_p), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_cheriabi___mac_set_link_fill_uap(struct thread *td,
    struct cheriabi___mac_set_link_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] _In_z_ const char * path_p */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi___mac_set_link, 0);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->path_p),
		    &tmpcap, sizeof(*uap->path_p), reqperms, 0);
		if (error != 0)
			return (error);
	}

	/* [1] _In_ struct mac_c * mac_p */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD|CHERI_PERM_LOAD_CAP);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi___mac_set_link, 1);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->mac_p),
		    &tmpcap, sizeof(*uap->mac_p), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_extattr_set_link_fill_uap(struct thread *td,
    struct extattr_set_link_args *uap)
{
	struct chericap tmpcap __unused;

	/* [1] int attrnamespace */
	uap->attrnamespace = (__typeof__(uap->attrnamespace))td->td_frame->a0;

	/* [4] size_t nbytes */
	uap->nbytes = (__typeof__(uap->nbytes))td->td_frame->a1;

	/* [0] _In_z_ const char * path */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_extattr_set_link, 0);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->path),
		    &tmpcap, sizeof(*uap->path), reqperms, 0);
		if (error != 0)
			return (error);
	}

	/* [2] _In_z_ const char * attrname */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_extattr_set_link, 2);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->attrname),
		    &tmpcap, sizeof(*uap->attrname), reqperms, 0);
		if (error != 0)
			return (error);
	}

	/* [3] _In_reads_bytes_(nbytes) void * data */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_extattr_set_link, 3);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->data),
		    &tmpcap, 1 * uap->nbytes, reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_extattr_get_link_fill_uap(struct thread *td,
    struct extattr_get_link_args *uap)
{
	struct chericap tmpcap __unused;

	/* [1] int attrnamespace */
	uap->attrnamespace = (__typeof__(uap->attrnamespace))td->td_frame->a0;

	/* [4] size_t nbytes */
	uap->nbytes = (__typeof__(uap->nbytes))td->td_frame->a1;

	/* [0] _In_z_ const char * path */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_extattr_get_link, 0);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->path),
		    &tmpcap, sizeof(*uap->path), reqperms, 0);
		if (error != 0)
			return (error);
	}

	/* [2] _In_z_ const char * attrname */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_extattr_get_link, 2);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->attrname),
		    &tmpcap, sizeof(*uap->attrname), reqperms, 0);
		if (error != 0)
			return (error);
	}

	/* [3] _Out_writes_bytes_(nbytes) void * data */
	{
		int error;
		register_t reqperms = (CHERI_PERM_STORE);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_extattr_get_link, 3);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->data),
		    &tmpcap, 1 * uap->nbytes, reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_extattr_delete_link_fill_uap(struct thread *td,
    struct extattr_delete_link_args *uap)
{
	struct chericap tmpcap __unused;

	/* [1] int attrnamespace */
	uap->attrnamespace = (__typeof__(uap->attrnamespace))td->td_frame->a0;

	/* [0] _In_z_ const char * path */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_extattr_delete_link, 0);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->path),
		    &tmpcap, sizeof(*uap->path), reqperms, 0);
		if (error != 0)
			return (error);
	}

	/* [2] _In_z_ const char * attrname */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_extattr_delete_link, 2);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->attrname),
		    &tmpcap, sizeof(*uap->attrname), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_cheriabi___mac_execve_fill_uap(struct thread *td,
    struct cheriabi___mac_execve_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] _In_z_ char * fname */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi___mac_execve, 0);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->fname),
		    &tmpcap, sizeof(*uap->fname), reqperms, 0);
		if (error != 0)
			return (error);
	}

	/* [1] _In_ struct chericap * argv */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi___mac_execve, 1);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->argv),
		    &tmpcap, sizeof(*uap->argv), reqperms, 0);
		if (error != 0)
			return (error);
	}

	/* [2] _In_ struct chericap * envv */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi___mac_execve, 2);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->envv),
		    &tmpcap, sizeof(*uap->envv), reqperms, 0);
		if (error != 0)
			return (error);
	}

	/* [3] _In_ struct mac_c * mac_p */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD|CHERI_PERM_LOAD_CAP);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi___mac_execve, 3);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->mac_p),
		    &tmpcap, sizeof(*uap->mac_p), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_cheriabi_sigaction_fill_uap(struct thread *td,
    struct cheriabi_sigaction_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] int sig */
	uap->sig = (__typeof__(uap->sig))td->td_frame->a0;

	/* [1] _In_opt_ struct sigaction_c * act */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD|CHERI_PERM_LOAD_CAP);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_sigaction, 1);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->act),
		    &tmpcap, sizeof(*uap->act), reqperms, 1);
		if (error != 0)
			return (error);
	}

	/* [2] _Out_opt_ struct sigaction_c * oact */
	{
		int error;
		register_t reqperms = (CHERI_PERM_STORE|CHERI_PERM_STORE_CAP);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_sigaction, 2);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->oact),
		    &tmpcap, sizeof(*uap->oact), reqperms, 1);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_cheriabi_sigreturn_fill_uap(struct thread *td,
    struct cheriabi_sigreturn_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] _In_ const ucontext_t_c * sigcntxp */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD|CHERI_PERM_LOAD_CAP);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_sigreturn, 0);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->sigcntxp),
		    &tmpcap, sizeof(*uap->sigcntxp), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_cheriabi_getcontext_fill_uap(struct thread *td,
    struct cheriabi_getcontext_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] _Out_ ucontext_t_c * ucp */
	{
		int error;
		register_t reqperms = (CHERI_PERM_STORE|CHERI_PERM_STORE_CAP);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_getcontext, 0);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->ucp),
		    &tmpcap, sizeof(*uap->ucp), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_cheriabi_setcontext_fill_uap(struct thread *td,
    struct cheriabi_setcontext_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] _In_ const ucontext_t_c * ucp */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD|CHERI_PERM_LOAD_CAP);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_setcontext, 0);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->ucp),
		    &tmpcap, sizeof(*uap->ucp), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_cheriabi_swapcontext_fill_uap(struct thread *td,
    struct cheriabi_swapcontext_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] _Out_ ucontext_t_c * oucp */
	{
		int error;
		register_t reqperms = (CHERI_PERM_STORE|CHERI_PERM_STORE_CAP);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_swapcontext, 0);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->oucp),
		    &tmpcap, sizeof(*uap->oucp), reqperms, 0);
		if (error != 0)
			return (error);
	}

	/* [1] _In_ const ucontext_t_c * ucp */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD|CHERI_PERM_LOAD_CAP);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_swapcontext, 1);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->ucp),
		    &tmpcap, sizeof(*uap->ucp), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_swapoff_fill_uap(struct thread *td,
    struct swapoff_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] _In_z_ const char * name */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_swapoff, 0);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->name),
		    &tmpcap, sizeof(*uap->name), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS___acl_get_link_fill_uap(struct thread *td,
    struct __acl_get_link_args *uap)
{
	struct chericap tmpcap __unused;

	/* [1] acl_type_t type */
	uap->type = (__typeof__(uap->type))td->td_frame->a0;

	/* [0] _In_z_ const char * path */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS___acl_get_link, 0);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->path),
		    &tmpcap, sizeof(*uap->path), reqperms, 0);
		if (error != 0)
			return (error);
	}

	/* [2] _Out_ struct acl * aclp */
	{
		int error;
		register_t reqperms = (CHERI_PERM_STORE);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS___acl_get_link, 2);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->aclp),
		    &tmpcap, sizeof(*uap->aclp), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS___acl_set_link_fill_uap(struct thread *td,
    struct __acl_set_link_args *uap)
{
	struct chericap tmpcap __unused;

	/* [1] acl_type_t type */
	uap->type = (__typeof__(uap->type))td->td_frame->a0;

	/* [0] _In_z_ const char * path */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS___acl_set_link, 0);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->path),
		    &tmpcap, sizeof(*uap->path), reqperms, 0);
		if (error != 0)
			return (error);
	}

	/* [2] _In_ struct acl * aclp */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS___acl_set_link, 2);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->aclp),
		    &tmpcap, sizeof(*uap->aclp), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS___acl_delete_link_fill_uap(struct thread *td,
    struct __acl_delete_link_args *uap)
{
	struct chericap tmpcap __unused;

	/* [1] acl_type_t type */
	uap->type = (__typeof__(uap->type))td->td_frame->a0;

	/* [0] _In_z_ const char * path */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS___acl_delete_link, 0);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->path),
		    &tmpcap, sizeof(*uap->path), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS___acl_aclcheck_link_fill_uap(struct thread *td,
    struct __acl_aclcheck_link_args *uap)
{
	struct chericap tmpcap __unused;

	/* [1] acl_type_t type */
	uap->type = (__typeof__(uap->type))td->td_frame->a0;

	/* [0] _In_z_ const char * path */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS___acl_aclcheck_link, 0);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->path),
		    &tmpcap, sizeof(*uap->path), reqperms, 0);
		if (error != 0)
			return (error);
	}

	/* [2] _In_ struct acl * aclp */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS___acl_aclcheck_link, 2);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->aclp),
		    &tmpcap, sizeof(*uap->aclp), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_sigwait_fill_uap(struct thread *td,
    struct sigwait_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] _In_ const sigset_t * set */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_sigwait, 0);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->set),
		    &tmpcap, sizeof(*uap->set), reqperms, 0);
		if (error != 0)
			return (error);
	}

	/* [1] _Out_ int * sig */
	{
		int error;
		register_t reqperms = (CHERI_PERM_STORE);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_sigwait, 1);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->sig),
		    &tmpcap, sizeof(*uap->sig), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_cheriabi_thr_create_fill_uap(struct thread *td,
    struct cheriabi_thr_create_args *uap)
{
	struct chericap tmpcap __unused;

	/* [2] int flags */
	uap->flags = (__typeof__(uap->flags))td->td_frame->a0;

	/* [0] _In_ ucontext_t_c * ctx */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD|CHERI_PERM_LOAD_CAP);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_thr_create, 0);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->ctx),
		    &tmpcap, sizeof(*uap->ctx), reqperms, 0);
		if (error != 0)
			return (error);
	}

	/* [1] _Out_ long * id */
	{
		int error;
		register_t reqperms = (CHERI_PERM_STORE);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_thr_create, 1);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->id),
		    &tmpcap, sizeof(*uap->id), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_thr_exit_fill_uap(struct thread *td,
    struct thr_exit_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] _Out_opt_ long * state */
	{
		int error;
		register_t reqperms = (CHERI_PERM_STORE);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_thr_exit, 0);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->state),
		    &tmpcap, sizeof(*uap->state), reqperms, 1);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_thr_self_fill_uap(struct thread *td,
    struct thr_self_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] _Out_ long * id */
	{
		int error;
		register_t reqperms = (CHERI_PERM_STORE);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_thr_self, 0);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->id),
		    &tmpcap, sizeof(*uap->id), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_thr_kill_fill_uap(struct thread *td,
    struct thr_kill_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] long id */
	uap->id = (__typeof__(uap->id))td->td_frame->a0;

	/* [1] int sig */
	uap->sig = (__typeof__(uap->sig))td->td_frame->a1;

	return (0);
}

static inline int
CHERIABI_SYS_jail_attach_fill_uap(struct thread *td,
    struct jail_attach_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] int jid */
	uap->jid = (__typeof__(uap->jid))td->td_frame->a0;

	return (0);
}

static inline int
CHERIABI_SYS_extattr_list_fd_fill_uap(struct thread *td,
    struct extattr_list_fd_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] int fd */
	uap->fd = (__typeof__(uap->fd))td->td_frame->a0;

	/* [1] int attrnamespace */
	uap->attrnamespace = (__typeof__(uap->attrnamespace))td->td_frame->a1;

	/* [3] size_t nbytes */
	uap->nbytes = (__typeof__(uap->nbytes))td->td_frame->a2;

	/* [2] _Out_writes_bytes_opt_(nbytes) void * data */
	{
		int error;
		register_t reqperms = (CHERI_PERM_STORE);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_extattr_list_fd, 2);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->data),
		    &tmpcap, 1 * uap->nbytes, reqperms, 1);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_extattr_list_file_fill_uap(struct thread *td,
    struct extattr_list_file_args *uap)
{
	struct chericap tmpcap __unused;

	/* [1] int attrnamespace */
	uap->attrnamespace = (__typeof__(uap->attrnamespace))td->td_frame->a0;

	/* [3] size_t nbytes */
	uap->nbytes = (__typeof__(uap->nbytes))td->td_frame->a1;

	/* [0] _In_z_ const char * path */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_extattr_list_file, 0);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->path),
		    &tmpcap, sizeof(*uap->path), reqperms, 0);
		if (error != 0)
			return (error);
	}

	/* [2] _Out_writes_bytes_opt_(nbytes) void * data */
	{
		int error;
		register_t reqperms = (CHERI_PERM_STORE);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_extattr_list_file, 2);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->data),
		    &tmpcap, 1 * uap->nbytes, reqperms, 1);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_extattr_list_link_fill_uap(struct thread *td,
    struct extattr_list_link_args *uap)
{
	struct chericap tmpcap __unused;

	/* [1] int attrnamespace */
	uap->attrnamespace = (__typeof__(uap->attrnamespace))td->td_frame->a0;

	/* [3] size_t nbytes */
	uap->nbytes = (__typeof__(uap->nbytes))td->td_frame->a1;

	/* [0] _In_z_ const char * path */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_extattr_list_link, 0);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->path),
		    &tmpcap, sizeof(*uap->path), reqperms, 0);
		if (error != 0)
			return (error);
	}

	/* [2] _Out_writes_bytes_opt_(nbytes) void * data */
	{
		int error;
		register_t reqperms = (CHERI_PERM_STORE);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_extattr_list_link, 2);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->data),
		    &tmpcap, 1 * uap->nbytes, reqperms, 1);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_ksem_timedwait_fill_uap(struct thread *td,
    struct ksem_timedwait_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] semid_t id */
	uap->id = (__typeof__(uap->id))td->td_frame->a0;

	/* [1] _In_opt_ const struct timespec * abstime */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_ksem_timedwait, 1);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->abstime),
		    &tmpcap, sizeof(*uap->abstime), reqperms, 1);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_thr_suspend_fill_uap(struct thread *td,
    struct thr_suspend_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] _In_opt_ const struct timespec * timeout */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_thr_suspend, 0);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->timeout),
		    &tmpcap, sizeof(*uap->timeout), reqperms, 1);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_thr_wake_fill_uap(struct thread *td,
    struct thr_wake_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] long id */
	uap->id = (__typeof__(uap->id))td->td_frame->a0;

	return (0);
}

static inline int
CHERIABI_SYS_kldunloadf_fill_uap(struct thread *td,
    struct kldunloadf_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] int fileid */
	uap->fileid = (__typeof__(uap->fileid))td->td_frame->a0;

	/* [1] int flags */
	uap->flags = (__typeof__(uap->flags))td->td_frame->a1;

	return (0);
}

static inline int
CHERIABI_SYS_audit_fill_uap(struct thread *td,
    struct audit_args *uap)
{
	struct chericap tmpcap __unused;

	/* [1] u_int length */
	uap->length = (__typeof__(uap->length))td->td_frame->a0;

	/* [0] _In_reads_bytes_(length) const void * record */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_audit, 0);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->record),
		    &tmpcap, 1 * uap->length, reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int	CHERIABI_SYS_auditon_fill_uap(struct thread *td,
    struct auditon_args *uap);

static inline int
CHERIABI_SYS_getauid_fill_uap(struct thread *td,
    struct getauid_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] _Out_ uid_t * auid */
	{
		int error;
		register_t reqperms = (CHERI_PERM_STORE);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_getauid, 0);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->auid),
		    &tmpcap, sizeof(*uap->auid), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_setauid_fill_uap(struct thread *td,
    struct setauid_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] _In_ uid_t * auid */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_setauid, 0);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->auid),
		    &tmpcap, sizeof(*uap->auid), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_getaudit_fill_uap(struct thread *td,
    struct getaudit_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] _Out_ struct auditinfo * auditinfo */
	{
		int error;
		register_t reqperms = (CHERI_PERM_STORE);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_getaudit, 0);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->auditinfo),
		    &tmpcap, sizeof(*uap->auditinfo), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_setaudit_fill_uap(struct thread *td,
    struct setaudit_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] _In_ struct auditinfo * auditinfo */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_setaudit, 0);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->auditinfo),
		    &tmpcap, sizeof(*uap->auditinfo), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_getaudit_addr_fill_uap(struct thread *td,
    struct getaudit_addr_args *uap)
{
	struct chericap tmpcap __unused;

	/* [1] u_int length */
	uap->length = (__typeof__(uap->length))td->td_frame->a0;

	/* [0] _Out_writes_bytes_(length) struct auditinfo_addr * auditinfo_addr */
	{
		int error;
		register_t reqperms = (CHERI_PERM_STORE);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_getaudit_addr, 0);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->auditinfo_addr),
		    &tmpcap, 1 * uap->length, reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_setaudit_addr_fill_uap(struct thread *td,
    struct setaudit_addr_args *uap)
{
	struct chericap tmpcap __unused;

	/* [1] u_int length */
	uap->length = (__typeof__(uap->length))td->td_frame->a0;

	/* [0] _In_reads_bytes_(length) struct auditinfo_addr * auditinfo_addr */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_setaudit_addr, 0);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->auditinfo_addr),
		    &tmpcap, 1 * uap->length, reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_auditctl_fill_uap(struct thread *td,
    struct auditctl_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] _In_z_ const char * path */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_auditctl, 0);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->path),
		    &tmpcap, sizeof(*uap->path), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int	CHERIABI_SYS__umtx_op_fill_uap(struct thread *td,
    struct _umtx_op_args *uap);

static inline int
CHERIABI_SYS_cheriabi_thr_new_fill_uap(struct thread *td,
    struct cheriabi_thr_new_args *uap)
{
	struct chericap tmpcap __unused;

	/* [1] int param_size */
	uap->param_size = (__typeof__(uap->param_size))td->td_frame->a0;

	/* [0] _In_ struct thr_param_c * param */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD|CHERI_PERM_LOAD_CAP);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_thr_new, 0);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->param),
		    &tmpcap, sizeof(*uap->param), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int	CHERIABI_SYS_cheriabi_sigqueue_fill_uap(struct thread *td,
    struct cheriabi_sigqueue_args *uap);

static inline int
CHERIABI_SYS_kmq_open_fill_uap(struct thread *td,
    struct kmq_open_args *uap)
{
	struct chericap tmpcap __unused;

	/* [1] int flags */
	uap->flags = (__typeof__(uap->flags))td->td_frame->a0;

	/* [2] mode_t mode */
	uap->mode = (__typeof__(uap->mode))td->td_frame->a1;

	/* [0] _In_z_ const char * path */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_kmq_open, 0);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->path),
		    &tmpcap, sizeof(*uap->path), reqperms, 0);
		if (error != 0)
			return (error);
	}

	/* [3] _In_opt_ const struct mq_attr * attr */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_kmq_open, 3);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->attr),
		    &tmpcap, sizeof(*uap->attr), reqperms, 1);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_kmq_setattr_fill_uap(struct thread *td,
    struct kmq_setattr_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] int mqd */
	uap->mqd = (__typeof__(uap->mqd))td->td_frame->a0;

	/* [1] _In_opt_ const struct mq_attr * attr */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_kmq_setattr, 1);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->attr),
		    &tmpcap, sizeof(*uap->attr), reqperms, 1);
		if (error != 0)
			return (error);
	}

	/* [2] _Out_opt_ struct mq_attr * oattr */
	{
		int error;
		register_t reqperms = (CHERI_PERM_STORE);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_kmq_setattr, 2);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->oattr),
		    &tmpcap, sizeof(*uap->oattr), reqperms, 1);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_kmq_timedreceive_fill_uap(struct thread *td,
    struct kmq_timedreceive_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] int mqd */
	uap->mqd = (__typeof__(uap->mqd))td->td_frame->a0;

	/* [2] size_t msg_len */
	uap->msg_len = (__typeof__(uap->msg_len))td->td_frame->a1;

	/* [1] _Out_writes_bytes_(msg_len) char * msg_ptr */
	{
		int error;
		register_t reqperms = (CHERI_PERM_STORE);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_kmq_timedreceive, 1);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->msg_ptr),
		    &tmpcap, 1 * uap->msg_len, reqperms, 0);
		if (error != 0)
			return (error);
	}

	/* [3] _Out_opt_ unsigned * msg_prio */
	{
		int error;
		register_t reqperms = (CHERI_PERM_STORE);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_kmq_timedreceive, 3);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->msg_prio),
		    &tmpcap, sizeof(*uap->msg_prio), reqperms, 1);
		if (error != 0)
			return (error);
	}

	/* [4] _In_opt_ const struct timespec * abs_timeout */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_kmq_timedreceive, 4);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->abs_timeout),
		    &tmpcap, sizeof(*uap->abs_timeout), reqperms, 1);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_kmq_timedsend_fill_uap(struct thread *td,
    struct kmq_timedsend_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] int mqd */
	uap->mqd = (__typeof__(uap->mqd))td->td_frame->a0;

	/* [2] size_t msg_len */
	uap->msg_len = (__typeof__(uap->msg_len))td->td_frame->a1;

	/* [3] unsigned msg_prio */
	uap->msg_prio = (__typeof__(uap->msg_prio))td->td_frame->a2;

	/* [1] _In_reads_bytes_(msg_len) const char * msg_ptr */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_kmq_timedsend, 1);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->msg_ptr),
		    &tmpcap, 1 * uap->msg_len, reqperms, 0);
		if (error != 0)
			return (error);
	}

	/* [4] _In_opt_ const struct timespec * abs_timeout */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_kmq_timedsend, 4);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->abs_timeout),
		    &tmpcap, sizeof(*uap->abs_timeout), reqperms, 1);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_cheriabi_kmq_notify_fill_uap(struct thread *td,
    struct cheriabi_kmq_notify_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] int mqd */
	uap->mqd = (__typeof__(uap->mqd))td->td_frame->a0;

	/* [1] _In_opt_ const struct sigevent_c * sigev */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD|CHERI_PERM_LOAD_CAP);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_kmq_notify, 1);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->sigev),
		    &tmpcap, sizeof(*uap->sigev), reqperms, 1);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_kmq_unlink_fill_uap(struct thread *td,
    struct kmq_unlink_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] _In_z_ const char * path */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_kmq_unlink, 0);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->path),
		    &tmpcap, sizeof(*uap->path), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_cheriabi_abort2_fill_uap(struct thread *td,
    struct cheriabi_abort2_args *uap)
{
	struct chericap tmpcap __unused;

	/* [1] int nargs */
	uap->nargs = (__typeof__(uap->nargs))td->td_frame->a0;

	/* [0] _In_z_ const char * why */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_abort2, 0);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->why),
		    &tmpcap, sizeof(*uap->why), reqperms, 0);
		if (error != 0)
			return (error);
	}

	/* [2] _In_reads_(nargs) struct chericap * args */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_abort2, 2);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->args),
		    &tmpcap, (sizeof(*uap->args) * uap->nargs), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_thr_set_name_fill_uap(struct thread *td,
    struct thr_set_name_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] long id */
	uap->id = (__typeof__(uap->id))td->td_frame->a0;

	/* [1] _In_z_ const char * name */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_thr_set_name, 1);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->name),
		    &tmpcap, sizeof(*uap->name), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_cheriabi_aio_fsync_fill_uap(struct thread *td,
    struct cheriabi_aio_fsync_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] int op */
	uap->op = (__typeof__(uap->op))td->td_frame->a0;

	/* [1] _In_ struct aiocb_c * aiocbp */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD|CHERI_PERM_LOAD_CAP);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_aio_fsync, 1);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->aiocbp),
		    &tmpcap, sizeof(*uap->aiocbp), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_rtprio_thread_fill_uap(struct thread *td,
    struct rtprio_thread_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] int function */
	uap->function = (__typeof__(uap->function))td->td_frame->a0;

	/* [1] lwpid_t lwpid */
	uap->lwpid = (__typeof__(uap->lwpid))td->td_frame->a1;

	/* [2] _Inout_ struct rtprio * rtp */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD|CHERI_PERM_STORE);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_rtprio_thread, 2);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->rtp),
		    &tmpcap, sizeof(*uap->rtp), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_sctp_peeloff_fill_uap(struct thread *td,
    struct sctp_peeloff_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] int sd */
	uap->sd = (__typeof__(uap->sd))td->td_frame->a0;

	/* [1] uint32_t name */
	uap->name = (__typeof__(uap->name))td->td_frame->a1;

	return (0);
}

static inline int
CHERIABI_SYS_sctp_generic_sendmsg_fill_uap(struct thread *td,
    struct sctp_generic_sendmsg_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] int sd */
	uap->sd = (__typeof__(uap->sd))td->td_frame->a0;

	/* [2] int mlen */
	uap->mlen = (__typeof__(uap->mlen))td->td_frame->a1;

	/* [4] socklen_t tolen */
	uap->tolen = (__typeof__(uap->tolen))td->td_frame->a2;

	/* [6] int flags */
	uap->flags = (__typeof__(uap->flags))td->td_frame->a3;

	/* [1] _In_reads_bytes_(mlen) void * msg */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_sctp_generic_sendmsg, 1);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->msg),
		    &tmpcap, 1 * uap->mlen, reqperms, 0);
		if (error != 0)
			return (error);
	}

	/* [3] _In_reads_bytes_(tolen) struct sockaddr * to */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_sctp_generic_sendmsg, 3);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->to),
		    &tmpcap, 1 * uap->tolen, reqperms, 0);
		if (error != 0)
			return (error);
	}

	/* [5] _In_opt_ struct sctp_sndrcvinfo * sinfo */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_sctp_generic_sendmsg, 5);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->sinfo),
		    &tmpcap, sizeof(*uap->sinfo), reqperms, 1);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_cheriabi_sctp_generic_sendmsg_iov_fill_uap(struct thread *td,
    struct cheriabi_sctp_generic_sendmsg_iov_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] int sd */
	uap->sd = (__typeof__(uap->sd))td->td_frame->a0;

	/* [2] int iovlen */
	uap->iovlen = (__typeof__(uap->iovlen))td->td_frame->a1;

	/* [4] socklen_t tolen */
	uap->tolen = (__typeof__(uap->tolen))td->td_frame->a2;

	/* [6] int flags */
	uap->flags = (__typeof__(uap->flags))td->td_frame->a3;

	/* [1] _In_reads_(iovlen) struct iovec_c * iov */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD|CHERI_PERM_LOAD_CAP);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_sctp_generic_sendmsg_iov, 1);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->iov),
		    &tmpcap, (sizeof(*uap->iov) * uap->iovlen), reqperms, 0);
		if (error != 0)
			return (error);
	}

	/* [3] _In_reads_bytes_(tolen) struct sockaddr * to */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_sctp_generic_sendmsg_iov, 3);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->to),
		    &tmpcap, 1 * uap->tolen, reqperms, 0);
		if (error != 0)
			return (error);
	}

	/* [5] _In_opt_ struct sctp_sndrcvinfo * sinfo */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_sctp_generic_sendmsg_iov, 5);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->sinfo),
		    &tmpcap, sizeof(*uap->sinfo), reqperms, 1);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_cheriabi_sctp_generic_recvmsg_fill_uap(struct thread *td,
    struct cheriabi_sctp_generic_recvmsg_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] int sd */
	uap->sd = (__typeof__(uap->sd))td->td_frame->a0;

	/* [2] int iovlen */
	uap->iovlen = (__typeof__(uap->iovlen))td->td_frame->a1;

	/* [1] _In_reads_(iovlen) struct iovec_c * iov */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD|CHERI_PERM_LOAD_CAP);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_sctp_generic_recvmsg, 1);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->iov),
		    &tmpcap, (sizeof(*uap->iov) * uap->iovlen), reqperms, 0);
		if (error != 0)
			return (error);
	}

	/* [4] _Out_ socklen_t * fromlenaddr */
	{
		int error;
		register_t reqperms = (CHERI_PERM_STORE);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_sctp_generic_recvmsg, 4);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->fromlenaddr),
		    &tmpcap, sizeof(*uap->fromlenaddr), reqperms, 0);
		if (error != 0)
			return (error);
	}

	/* [5] _In_opt_ struct sctp_sndrcvinfo * sinfo */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_sctp_generic_recvmsg, 5);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->sinfo),
		    &tmpcap, sizeof(*uap->sinfo), reqperms, 1);
		if (error != 0)
			return (error);
	}

	/* [6] _Out_opt_ int * msg_flags */
	{
		int error;
		register_t reqperms = (CHERI_PERM_STORE);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_sctp_generic_recvmsg, 6);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->msg_flags),
		    &tmpcap, sizeof(*uap->msg_flags), reqperms, 1);
		if (error != 0)
			return (error);
	}

	/* [3] _Out_writes_bytes_(*fromlenaddr) struct sockaddr * from */
	{
		int error;
		register_t reqperms = (CHERI_PERM_STORE);

		if (uap->fromlenaddr == NULL) {
			uap->from = NULL;
		} else {
			size_t reqlen;
			if (sizeof(*uap->fromlenaddr) == 2)
				reqlen = fuword16(uap->fromlenaddr);
			else if (sizeof(*uap->fromlenaddr) == 4)
				reqlen = fuword32(uap->fromlenaddr);
			else if (sizeof(*uap->fromlenaddr) == 8)
				reqlen = fuword64(uap->fromlenaddr);
			else
				panic("unhandled dependant argument size %zu", sizeof(*uap->fromlenaddr));
			if (reqlen == -1)
				return (EINVAL);
			cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_sctp_generic_recvmsg, 3);
			error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->from),
			    &tmpcap, reqlen, reqperms, 0);
			if (error != 0)
				return (error);
		}
	}

	return (0);
}

static inline int
CHERIABI_SYS_pread_fill_uap(struct thread *td,
    struct pread_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] int fd */
	uap->fd = (__typeof__(uap->fd))td->td_frame->a0;

	/* [2] size_t nbyte */
	uap->nbyte = (__typeof__(uap->nbyte))td->td_frame->a1;

	/* [3] off_t offset */
	uap->offset = (__typeof__(uap->offset))td->td_frame->a2;

	/* [1] _Out_writes_bytes_(nbyte) void * buf */
	{
		int error;
		register_t reqperms = (CHERI_PERM_STORE);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_pread, 1);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->buf),
		    &tmpcap, 1 * uap->nbyte, reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_pwrite_fill_uap(struct thread *td,
    struct pwrite_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] int fd */
	uap->fd = (__typeof__(uap->fd))td->td_frame->a0;

	/* [2] size_t nbyte */
	uap->nbyte = (__typeof__(uap->nbyte))td->td_frame->a1;

	/* [3] off_t offset */
	uap->offset = (__typeof__(uap->offset))td->td_frame->a2;

	/* [1] _Out_writes_bytes_(nbyte) const void * buf */
	{
		int error;
		register_t reqperms = (CHERI_PERM_STORE);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_pwrite, 1);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->buf),
		    &tmpcap, 1 * uap->nbyte, reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_cheriabi_mmap_fill_uap(struct thread *td,
    struct cheriabi_mmap_args *uap)
{
	struct chericap tmpcap __unused;

	/* [1] size_t len */
	uap->len = (__typeof__(uap->len))td->td_frame->a0;

	/* [2] int prot */
	uap->prot = (__typeof__(uap->prot))td->td_frame->a1;

	/* [3] int flags */
	uap->flags = (__typeof__(uap->flags))td->td_frame->a2;

	/* [4] int fd */
	uap->fd = (__typeof__(uap->fd))td->td_frame->a3;

	/* [5] off_t pos */
	uap->pos = (__typeof__(uap->pos))td->td_frame->a4;

	/* [0] _Pagerange_vmmap_opt_(len) void * addr */
	{
		int error;
		register_t reqperms = (CHERI_PERM_CHERIABI_VMMAP);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_mmap, 0);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->addr),
		    &tmpcap, uap->len, reqperms, 1);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_lseek_fill_uap(struct thread *td,
    struct lseek_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] int fd */
	uap->fd = (__typeof__(uap->fd))td->td_frame->a0;

	/* [1] off_t offset */
	uap->offset = (__typeof__(uap->offset))td->td_frame->a1;

	/* [2] int whence */
	uap->whence = (__typeof__(uap->whence))td->td_frame->a2;

	return (0);
}

static inline int
CHERIABI_SYS_truncate_fill_uap(struct thread *td,
    struct truncate_args *uap)
{
	struct chericap tmpcap __unused;

	/* [1] off_t length */
	uap->length = (__typeof__(uap->length))td->td_frame->a0;

	/* [0] _In_z_ const char * path */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_truncate, 0);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->path),
		    &tmpcap, sizeof(*uap->path), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_ftruncate_fill_uap(struct thread *td,
    struct ftruncate_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] int fd */
	uap->fd = (__typeof__(uap->fd))td->td_frame->a0;

	/* [1] off_t length */
	uap->length = (__typeof__(uap->length))td->td_frame->a1;

	return (0);
}

static inline int
CHERIABI_SYS_thr_kill2_fill_uap(struct thread *td,
    struct thr_kill2_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] pid_t pid */
	uap->pid = (__typeof__(uap->pid))td->td_frame->a0;

	/* [1] long id */
	uap->id = (__typeof__(uap->id))td->td_frame->a1;

	/* [2] int sig */
	uap->sig = (__typeof__(uap->sig))td->td_frame->a2;

	return (0);
}

static inline int	CHERIABI_SYS_shm_open_fill_uap(struct thread *td,
    struct shm_open_args *uap);

static inline int
CHERIABI_SYS_shm_unlink_fill_uap(struct thread *td,
    struct shm_unlink_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] _In_z_ const char * path */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_shm_unlink, 0);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->path),
		    &tmpcap, sizeof(*uap->path), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_cpuset_fill_uap(struct thread *td,
    struct cpuset_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] _Out_ cpusetid_t * setid */
	{
		int error;
		register_t reqperms = (CHERI_PERM_STORE);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cpuset, 0);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->setid),
		    &tmpcap, sizeof(*uap->setid), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_cpuset_setid_fill_uap(struct thread *td,
    struct cpuset_setid_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] cpuwhich_t which */
	uap->which = (__typeof__(uap->which))td->td_frame->a0;

	/* [1] id_t id */
	uap->id = (__typeof__(uap->id))td->td_frame->a1;

	/* [2] cpusetid_t setid */
	uap->setid = (__typeof__(uap->setid))td->td_frame->a2;

	return (0);
}

static inline int
CHERIABI_SYS_cpuset_getid_fill_uap(struct thread *td,
    struct cpuset_getid_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] cpulevel_t level */
	uap->level = (__typeof__(uap->level))td->td_frame->a0;

	/* [1] cpuwhich_t which */
	uap->which = (__typeof__(uap->which))td->td_frame->a1;

	/* [2] id_t id */
	uap->id = (__typeof__(uap->id))td->td_frame->a2;

	/* [3] _Out_ cpusetid_t * setid */
	{
		int error;
		register_t reqperms = (CHERI_PERM_STORE);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cpuset_getid, 3);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->setid),
		    &tmpcap, sizeof(*uap->setid), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_cpuset_getaffinity_fill_uap(struct thread *td,
    struct cpuset_getaffinity_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] cpulevel_t level */
	uap->level = (__typeof__(uap->level))td->td_frame->a0;

	/* [1] cpuwhich_t which */
	uap->which = (__typeof__(uap->which))td->td_frame->a1;

	/* [2] id_t id */
	uap->id = (__typeof__(uap->id))td->td_frame->a2;

	/* [3] size_t cpusetsize */
	uap->cpusetsize = (__typeof__(uap->cpusetsize))td->td_frame->a3;

	/* [4] _Out_ cpuset_t * mask */
	{
		int error;
		register_t reqperms = (CHERI_PERM_STORE);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cpuset_getaffinity, 4);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->mask),
		    &tmpcap, sizeof(*uap->mask), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_cpuset_setaffinity_fill_uap(struct thread *td,
    struct cpuset_setaffinity_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] cpulevel_t level */
	uap->level = (__typeof__(uap->level))td->td_frame->a0;

	/* [1] cpuwhich_t which */
	uap->which = (__typeof__(uap->which))td->td_frame->a1;

	/* [2] id_t id */
	uap->id = (__typeof__(uap->id))td->td_frame->a2;

	/* [3] size_t cpusetsize */
	uap->cpusetsize = (__typeof__(uap->cpusetsize))td->td_frame->a3;

	/* [4] _Out_ const cpuset_t * mask */
	{
		int error;
		register_t reqperms = (CHERI_PERM_STORE);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cpuset_setaffinity, 4);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->mask),
		    &tmpcap, sizeof(*uap->mask), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_faccessat_fill_uap(struct thread *td,
    struct faccessat_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] int fd */
	uap->fd = (__typeof__(uap->fd))td->td_frame->a0;

	/* [2] int amode */
	uap->amode = (__typeof__(uap->amode))td->td_frame->a1;

	/* [3] int flag */
	uap->flag = (__typeof__(uap->flag))td->td_frame->a2;

	/* [1] _In_z_ const char * path */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_faccessat, 1);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->path),
		    &tmpcap, sizeof(*uap->path), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_fchmodat_fill_uap(struct thread *td,
    struct fchmodat_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] int fd */
	uap->fd = (__typeof__(uap->fd))td->td_frame->a0;

	/* [2] mode_t mode */
	uap->mode = (__typeof__(uap->mode))td->td_frame->a1;

	/* [3] int flag */
	uap->flag = (__typeof__(uap->flag))td->td_frame->a2;

	/* [1] _In_z_ const char * path */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_fchmodat, 1);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->path),
		    &tmpcap, sizeof(*uap->path), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_fchownat_fill_uap(struct thread *td,
    struct fchownat_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] int fd */
	uap->fd = (__typeof__(uap->fd))td->td_frame->a0;

	/* [2] uid_t uid */
	uap->uid = (__typeof__(uap->uid))td->td_frame->a1;

	/* [3] gid_t gid */
	uap->gid = (__typeof__(uap->gid))td->td_frame->a2;

	/* [4] int flag */
	uap->flag = (__typeof__(uap->flag))td->td_frame->a3;

	/* [1] _In_z_ const char * path */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_fchownat, 1);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->path),
		    &tmpcap, sizeof(*uap->path), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_cheriabi_fexecve_fill_uap(struct thread *td,
    struct cheriabi_fexecve_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] int fd */
	uap->fd = (__typeof__(uap->fd))td->td_frame->a0;

	/* [1] _In_ struct chericap * argv */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_fexecve, 1);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->argv),
		    &tmpcap, sizeof(*uap->argv), reqperms, 0);
		if (error != 0)
			return (error);
	}

	/* [2] _In_ struct chericap * envv */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_fexecve, 2);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->envv),
		    &tmpcap, sizeof(*uap->envv), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_fstatat_fill_uap(struct thread *td,
    struct fstatat_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] int fd */
	uap->fd = (__typeof__(uap->fd))td->td_frame->a0;

	/* [3] int flag */
	uap->flag = (__typeof__(uap->flag))td->td_frame->a1;

	/* [1] _In_z_ const char * path */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_fstatat, 1);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->path),
		    &tmpcap, sizeof(*uap->path), reqperms, 0);
		if (error != 0)
			return (error);
	}

	/* [2] _Out_ struct stat * buf */
	{
		int error;
		register_t reqperms = (CHERI_PERM_STORE);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_fstatat, 2);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->buf),
		    &tmpcap, sizeof(*uap->buf), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_futimesat_fill_uap(struct thread *td,
    struct futimesat_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] int fd */
	uap->fd = (__typeof__(uap->fd))td->td_frame->a0;

	/* [1] _In_z_ const char * path */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_futimesat, 1);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->path),
		    &tmpcap, sizeof(*uap->path), reqperms, 0);
		if (error != 0)
			return (error);
	}

	/* [2] _In_reads_(2) const struct timeval * times */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_futimesat, 2);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->times),
		    &tmpcap, (sizeof(*uap->times) * 2), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_linkat_fill_uap(struct thread *td,
    struct linkat_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] int fd1 */
	uap->fd1 = (__typeof__(uap->fd1))td->td_frame->a0;

	/* [2] int fd2 */
	uap->fd2 = (__typeof__(uap->fd2))td->td_frame->a1;

	/* [4] int flag */
	uap->flag = (__typeof__(uap->flag))td->td_frame->a2;

	/* [1] _In_z_ const char * path1 */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_linkat, 1);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->path1),
		    &tmpcap, sizeof(*uap->path1), reqperms, 0);
		if (error != 0)
			return (error);
	}

	/* [3] _In_z_ const char * path2 */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_linkat, 3);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->path2),
		    &tmpcap, sizeof(*uap->path2), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_mkdirat_fill_uap(struct thread *td,
    struct mkdirat_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] int fd */
	uap->fd = (__typeof__(uap->fd))td->td_frame->a0;

	/* [2] mode_t mode */
	uap->mode = (__typeof__(uap->mode))td->td_frame->a1;

	/* [1] _In_z_ const char * path */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_mkdirat, 1);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->path),
		    &tmpcap, sizeof(*uap->path), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_mkfifoat_fill_uap(struct thread *td,
    struct mkfifoat_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] int fd */
	uap->fd = (__typeof__(uap->fd))td->td_frame->a0;

	/* [2] mode_t mode */
	uap->mode = (__typeof__(uap->mode))td->td_frame->a1;

	/* [1] _In_z_ const char * path */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_mkfifoat, 1);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->path),
		    &tmpcap, sizeof(*uap->path), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_mknodat_fill_uap(struct thread *td,
    struct mknodat_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] int fd */
	uap->fd = (__typeof__(uap->fd))td->td_frame->a0;

	/* [2] mode_t mode */
	uap->mode = (__typeof__(uap->mode))td->td_frame->a1;

	/* [3] dev_t dev */
	uap->dev = (__typeof__(uap->dev))td->td_frame->a2;

	/* [1] _In_z_ const char * path */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_mknodat, 1);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->path),
		    &tmpcap, sizeof(*uap->path), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_openat_fill_uap(struct thread *td,
    struct openat_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] int fd */
	uap->fd = (__typeof__(uap->fd))td->td_frame->a0;

	/* [2] int flag */
	uap->flag = (__typeof__(uap->flag))td->td_frame->a1;

	/* [3] mode_t mode */
	uap->mode = (__typeof__(uap->mode))td->td_frame->a2;

	/* [1] _In_z_ const char * path */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_openat, 1);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->path),
		    &tmpcap, sizeof(*uap->path), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_readlinkat_fill_uap(struct thread *td,
    struct readlinkat_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] int fd */
	uap->fd = (__typeof__(uap->fd))td->td_frame->a0;

	/* [3] size_t bufsize */
	uap->bufsize = (__typeof__(uap->bufsize))td->td_frame->a1;

	/* [1] _In_z_ const char * path */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_readlinkat, 1);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->path),
		    &tmpcap, sizeof(*uap->path), reqperms, 0);
		if (error != 0)
			return (error);
	}

	/* [2] _Out_writes_bytes_(bufsize) char * buf */
	{
		int error;
		register_t reqperms = (CHERI_PERM_STORE);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_readlinkat, 2);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->buf),
		    &tmpcap, 1 * uap->bufsize, reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_renameat_fill_uap(struct thread *td,
    struct renameat_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] int oldfd */
	uap->oldfd = (__typeof__(uap->oldfd))td->td_frame->a0;

	/* [2] int newfd */
	uap->newfd = (__typeof__(uap->newfd))td->td_frame->a1;

	/* [1] _In_z_ const char * old */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_renameat, 1);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->old),
		    &tmpcap, sizeof(*uap->old), reqperms, 0);
		if (error != 0)
			return (error);
	}

	/* [3] _In_z_ const char * new */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_renameat, 3);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->new),
		    &tmpcap, sizeof(*uap->new), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_symlinkat_fill_uap(struct thread *td,
    struct symlinkat_args *uap)
{
	struct chericap tmpcap __unused;

	/* [1] int fd */
	uap->fd = (__typeof__(uap->fd))td->td_frame->a0;

	/* [0] _In_z_ const char * path1 */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_symlinkat, 0);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->path1),
		    &tmpcap, sizeof(*uap->path1), reqperms, 0);
		if (error != 0)
			return (error);
	}

	/* [2] _In_z_ const char * path2 */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_symlinkat, 2);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->path2),
		    &tmpcap, sizeof(*uap->path2), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_unlinkat_fill_uap(struct thread *td,
    struct unlinkat_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] int fd */
	uap->fd = (__typeof__(uap->fd))td->td_frame->a0;

	/* [2] int flag */
	uap->flag = (__typeof__(uap->flag))td->td_frame->a1;

	/* [1] _In_z_ const char * path */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_unlinkat, 1);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->path),
		    &tmpcap, sizeof(*uap->path), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_posix_openpt_fill_uap(struct thread *td,
    struct posix_openpt_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] int flags */
	uap->flags = (__typeof__(uap->flags))td->td_frame->a0;

	return (0);
}

static inline int
CHERIABI_SYS_gssd_syscall_fill_uap(struct thread *td,
    struct gssd_syscall_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] _In_z_ const char * path */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_gssd_syscall, 0);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->path),
		    &tmpcap, sizeof(*uap->path), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_cheriabi_jail_get_fill_uap(struct thread *td,
    struct cheriabi_jail_get_args *uap)
{
	struct chericap tmpcap __unused;

	/* [1] unsigned int iovcnt */
	uap->iovcnt = (__typeof__(uap->iovcnt))td->td_frame->a0;

	/* [2] int flags */
	uap->flags = (__typeof__(uap->flags))td->td_frame->a1;

	/* [0] _In_reads_(iovcnt) struct iovec_c * iovp */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD|CHERI_PERM_LOAD_CAP);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_jail_get, 0);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->iovp),
		    &tmpcap, (sizeof(*uap->iovp) * uap->iovcnt), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_cheriabi_jail_set_fill_uap(struct thread *td,
    struct cheriabi_jail_set_args *uap)
{
	struct chericap tmpcap __unused;

	/* [1] unsigned int iovcnt */
	uap->iovcnt = (__typeof__(uap->iovcnt))td->td_frame->a0;

	/* [2] int flags */
	uap->flags = (__typeof__(uap->flags))td->td_frame->a1;

	/* [0] _In_reads_(iovcnt) struct iovec_c * iovp */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD|CHERI_PERM_LOAD_CAP);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_jail_set, 0);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->iovp),
		    &tmpcap, (sizeof(*uap->iovp) * uap->iovcnt), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_jail_remove_fill_uap(struct thread *td,
    struct jail_remove_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] int jid */
	uap->jid = (__typeof__(uap->jid))td->td_frame->a0;

	return (0);
}

static inline int
CHERIABI_SYS_closefrom_fill_uap(struct thread *td,
    struct closefrom_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] int lowfd */
	uap->lowfd = (__typeof__(uap->lowfd))td->td_frame->a0;

	return (0);
}

static inline int	CHERIABI_SYS_cheriabi___semctl_fill_uap(struct thread *td,
    struct cheriabi___semctl_args *uap);

static inline int
CHERIABI_SYS_cheriabi_msgctl_fill_uap(struct thread *td,
    struct cheriabi_msgctl_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] int msqid */
	uap->msqid = (__typeof__(uap->msqid))td->td_frame->a0;

	/* [1] int cmd */
	uap->cmd = (__typeof__(uap->cmd))td->td_frame->a1;

	/* [2] _Inout_opt_ struct msqid_ds_c * buf */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD|CHERI_PERM_LOAD_CAP|CHERI_PERM_STORE|CHERI_PERM_STORE_CAP);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_msgctl, 2);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->buf),
		    &tmpcap, sizeof(*uap->buf), reqperms, 1);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_shmctl_fill_uap(struct thread *td,
    struct shmctl_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] int shmid */
	uap->shmid = (__typeof__(uap->shmid))td->td_frame->a0;

	/* [1] int cmd */
	uap->cmd = (__typeof__(uap->cmd))td->td_frame->a1;

	/* [2] _Inout_opt_ struct shmid_ds * buf */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD|CHERI_PERM_STORE);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_shmctl, 2);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->buf),
		    &tmpcap, sizeof(*uap->buf), reqperms, 1);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_lpathconf_fill_uap(struct thread *td,
    struct lpathconf_args *uap)
{
	struct chericap tmpcap __unused;

	/* [1] int name */
	uap->name = (__typeof__(uap->name))td->td_frame->a0;

	/* [0] _In_z_ const char * path */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_lpathconf, 0);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->path),
		    &tmpcap, sizeof(*uap->path), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS___cap_rights_get_fill_uap(struct thread *td,
    struct __cap_rights_get_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] int version */
	uap->version = (__typeof__(uap->version))td->td_frame->a0;

	/* [1] int fd */
	uap->fd = (__typeof__(uap->fd))td->td_frame->a1;

	/* [2] _Out_ cap_rights_t * rightsp */
	{
		int error;
		register_t reqperms = (CHERI_PERM_STORE);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS___cap_rights_get, 2);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->rightsp),
		    &tmpcap, sizeof(*uap->rightsp), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_cap_getmode_fill_uap(struct thread *td,
    struct cap_getmode_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] _Out_ u_int * modep */
	{
		int error;
		register_t reqperms = (CHERI_PERM_STORE);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cap_getmode, 0);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->modep),
		    &tmpcap, sizeof(*uap->modep), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_pdfork_fill_uap(struct thread *td,
    struct pdfork_args *uap)
{
	struct chericap tmpcap __unused;

	/* [1] int flags */
	uap->flags = (__typeof__(uap->flags))td->td_frame->a0;

	/* [0] _Out_ int * fdp */
	{
		int error;
		register_t reqperms = (CHERI_PERM_STORE);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_pdfork, 0);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->fdp),
		    &tmpcap, sizeof(*uap->fdp), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_pdkill_fill_uap(struct thread *td,
    struct pdkill_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] int fd */
	uap->fd = (__typeof__(uap->fd))td->td_frame->a0;

	/* [1] int signum */
	uap->signum = (__typeof__(uap->signum))td->td_frame->a1;

	return (0);
}

static inline int
CHERIABI_SYS_pdgetpid_fill_uap(struct thread *td,
    struct pdgetpid_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] int fd */
	uap->fd = (__typeof__(uap->fd))td->td_frame->a0;

	/* [1] _Out_ pid_t * pidp */
	{
		int error;
		register_t reqperms = (CHERI_PERM_STORE);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_pdgetpid, 1);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->pidp),
		    &tmpcap, sizeof(*uap->pidp), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int	CHERIABI_SYS_pselect_fill_uap(struct thread *td,
    struct pselect_args *uap);

static inline int
CHERIABI_SYS_getloginclass_fill_uap(struct thread *td,
    struct getloginclass_args *uap)
{
	struct chericap tmpcap __unused;

	/* [1] size_t namelen */
	uap->namelen = (__typeof__(uap->namelen))td->td_frame->a0;

	/* [0] _Out_writes_z_(namelen) char * namebuf */
	{
		int error;
		register_t reqperms = (CHERI_PERM_STORE);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_getloginclass, 0);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->namebuf),
		    &tmpcap, (sizeof(*uap->namebuf) * uap->namelen), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_setloginclass_fill_uap(struct thread *td,
    struct setloginclass_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] _In_z_ const char * namebuf */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_setloginclass, 0);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->namebuf),
		    &tmpcap, sizeof(*uap->namebuf), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_rctl_get_racct_fill_uap(struct thread *td,
    struct rctl_get_racct_args *uap)
{
	struct chericap tmpcap __unused;

	/* [1] size_t inbuflen */
	uap->inbuflen = (__typeof__(uap->inbuflen))td->td_frame->a0;

	/* [3] size_t outbuflen */
	uap->outbuflen = (__typeof__(uap->outbuflen))td->td_frame->a1;

	/* [0] _In_reads_bytes_(inbuflen) const void * inbufp */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_rctl_get_racct, 0);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->inbufp),
		    &tmpcap, 1 * uap->inbuflen, reqperms, 0);
		if (error != 0)
			return (error);
	}

	/* [2] _Out_writes_bytes_(outbuflen) void * outbufp */
	{
		int error;
		register_t reqperms = (CHERI_PERM_STORE);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_rctl_get_racct, 2);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->outbufp),
		    &tmpcap, 1 * uap->outbuflen, reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_rctl_get_rules_fill_uap(struct thread *td,
    struct rctl_get_rules_args *uap)
{
	struct chericap tmpcap __unused;

	/* [1] size_t inbuflen */
	uap->inbuflen = (__typeof__(uap->inbuflen))td->td_frame->a0;

	/* [3] size_t outbuflen */
	uap->outbuflen = (__typeof__(uap->outbuflen))td->td_frame->a1;

	/* [0] _In_reads_bytes_(inbuflen) const void * inbufp */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_rctl_get_rules, 0);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->inbufp),
		    &tmpcap, 1 * uap->inbuflen, reqperms, 0);
		if (error != 0)
			return (error);
	}

	/* [2] _Out_writes_bytes_(outbuflen) void * outbufp */
	{
		int error;
		register_t reqperms = (CHERI_PERM_STORE);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_rctl_get_rules, 2);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->outbufp),
		    &tmpcap, 1 * uap->outbuflen, reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_rctl_get_limits_fill_uap(struct thread *td,
    struct rctl_get_limits_args *uap)
{
	struct chericap tmpcap __unused;

	/* [1] size_t inbuflen */
	uap->inbuflen = (__typeof__(uap->inbuflen))td->td_frame->a0;

	/* [3] size_t outbuflen */
	uap->outbuflen = (__typeof__(uap->outbuflen))td->td_frame->a1;

	/* [0] _In_reads_bytes_(inbuflen) const void * inbufp */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_rctl_get_limits, 0);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->inbufp),
		    &tmpcap, 1 * uap->inbuflen, reqperms, 0);
		if (error != 0)
			return (error);
	}

	/* [2] _Out_writes_bytes_(outbuflen) void * outbufp */
	{
		int error;
		register_t reqperms = (CHERI_PERM_STORE);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_rctl_get_limits, 2);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->outbufp),
		    &tmpcap, 1 * uap->outbuflen, reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_rctl_add_rule_fill_uap(struct thread *td,
    struct rctl_add_rule_args *uap)
{
	struct chericap tmpcap __unused;

	/* [1] size_t inbuflen */
	uap->inbuflen = (__typeof__(uap->inbuflen))td->td_frame->a0;

	/* [3] size_t outbuflen */
	uap->outbuflen = (__typeof__(uap->outbuflen))td->td_frame->a1;

	/* [0] _In_reads_bytes_(inbuflen) const void * inbufp */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_rctl_add_rule, 0);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->inbufp),
		    &tmpcap, 1 * uap->inbuflen, reqperms, 0);
		if (error != 0)
			return (error);
	}

	/* [2] _Out_writes_bytes_(outbuflen) void * outbufp */
	{
		int error;
		register_t reqperms = (CHERI_PERM_STORE);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_rctl_add_rule, 2);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->outbufp),
		    &tmpcap, 1 * uap->outbuflen, reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_rctl_remove_rule_fill_uap(struct thread *td,
    struct rctl_remove_rule_args *uap)
{
	struct chericap tmpcap __unused;

	/* [1] size_t inbuflen */
	uap->inbuflen = (__typeof__(uap->inbuflen))td->td_frame->a0;

	/* [3] size_t outbuflen */
	uap->outbuflen = (__typeof__(uap->outbuflen))td->td_frame->a1;

	/* [0] _In_reads_bytes_(inbuflen) const void * inbufp */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_rctl_remove_rule, 0);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->inbufp),
		    &tmpcap, 1 * uap->inbuflen, reqperms, 0);
		if (error != 0)
			return (error);
	}

	/* [2] _Out_writes_bytes_(outbuflen) void * outbufp */
	{
		int error;
		register_t reqperms = (CHERI_PERM_STORE);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_rctl_remove_rule, 2);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->outbufp),
		    &tmpcap, 1 * uap->outbuflen, reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_posix_fallocate_fill_uap(struct thread *td,
    struct posix_fallocate_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] int fd */
	uap->fd = (__typeof__(uap->fd))td->td_frame->a0;

	/* [1] off_t offset */
	uap->offset = (__typeof__(uap->offset))td->td_frame->a1;

	/* [2] off_t len */
	uap->len = (__typeof__(uap->len))td->td_frame->a2;

	return (0);
}

static inline int
CHERIABI_SYS_posix_fadvise_fill_uap(struct thread *td,
    struct posix_fadvise_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] int fd */
	uap->fd = (__typeof__(uap->fd))td->td_frame->a0;

	/* [1] off_t offset */
	uap->offset = (__typeof__(uap->offset))td->td_frame->a1;

	/* [2] off_t len */
	uap->len = (__typeof__(uap->len))td->td_frame->a2;

	/* [3] int advice */
	uap->advice = (__typeof__(uap->advice))td->td_frame->a3;

	return (0);
}

static inline int
CHERIABI_SYS_cheriabi_wait6_fill_uap(struct thread *td,
    struct cheriabi_wait6_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] int idtype */
	uap->idtype = (__typeof__(uap->idtype))td->td_frame->a0;

	/* [1] id_t id */
	uap->id = (__typeof__(uap->id))td->td_frame->a1;

	/* [3] int options */
	uap->options = (__typeof__(uap->options))td->td_frame->a2;

	/* [2] _Out_opt_ int * status */
	{
		int error;
		register_t reqperms = (CHERI_PERM_STORE);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_wait6, 2);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->status),
		    &tmpcap, sizeof(*uap->status), reqperms, 1);
		if (error != 0)
			return (error);
	}

	/* [4] _Out_opt_ struct __wrusage * wrusage */
	{
		int error;
		register_t reqperms = (CHERI_PERM_STORE);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_wait6, 4);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->wrusage),
		    &tmpcap, sizeof(*uap->wrusage), reqperms, 1);
		if (error != 0)
			return (error);
	}

	/* [5] _Out_opt_ struct siginfo_c * info */
	{
		int error;
		register_t reqperms = (CHERI_PERM_STORE|CHERI_PERM_STORE_CAP);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_wait6, 5);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->info),
		    &tmpcap, sizeof(*uap->info), reqperms, 1);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_cap_rights_limit_fill_uap(struct thread *td,
    struct cap_rights_limit_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] int fd */
	uap->fd = (__typeof__(uap->fd))td->td_frame->a0;

	/* [1] _In_ cap_rights_t * rightsp */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cap_rights_limit, 1);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->rightsp),
		    &tmpcap, sizeof(*uap->rightsp), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_cap_ioctls_limit_fill_uap(struct thread *td,
    struct cap_ioctls_limit_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] int fd */
	uap->fd = (__typeof__(uap->fd))td->td_frame->a0;

	/* [2] size_t ncmds */
	uap->ncmds = (__typeof__(uap->ncmds))td->td_frame->a1;

	/* [1] _In_reads_(ncmds) const u_long * cmds */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cap_ioctls_limit, 1);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->cmds),
		    &tmpcap, (sizeof(*uap->cmds) * uap->ncmds), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_cap_ioctls_get_fill_uap(struct thread *td,
    struct cap_ioctls_get_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] int fd */
	uap->fd = (__typeof__(uap->fd))td->td_frame->a0;

	/* [2] size_t maxcmds */
	uap->maxcmds = (__typeof__(uap->maxcmds))td->td_frame->a1;

	/* [1] _Out_writes_(maxcmds) u_long * cmds */
	{
		int error;
		register_t reqperms = (CHERI_PERM_STORE);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cap_ioctls_get, 1);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->cmds),
		    &tmpcap, (sizeof(*uap->cmds) * uap->maxcmds), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_cap_fcntls_limit_fill_uap(struct thread *td,
    struct cap_fcntls_limit_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] int fd */
	uap->fd = (__typeof__(uap->fd))td->td_frame->a0;

	/* [1] uint32_t fcntlrights */
	uap->fcntlrights = (__typeof__(uap->fcntlrights))td->td_frame->a1;

	return (0);
}

static inline int
CHERIABI_SYS_cap_fcntls_get_fill_uap(struct thread *td,
    struct cap_fcntls_get_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] int fd */
	uap->fd = (__typeof__(uap->fd))td->td_frame->a0;

	/* [1] _Out_ uint32_t * fcntlrightsp */
	{
		int error;
		register_t reqperms = (CHERI_PERM_STORE);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cap_fcntls_get, 1);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->fcntlrightsp),
		    &tmpcap, sizeof(*uap->fcntlrightsp), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_bindat_fill_uap(struct thread *td,
    struct bindat_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] int fd */
	uap->fd = (__typeof__(uap->fd))td->td_frame->a0;

	/* [1] int s */
	uap->s = (__typeof__(uap->s))td->td_frame->a1;

	/* [3] socklen_t namelen */
	uap->namelen = (__typeof__(uap->namelen))td->td_frame->a2;

	/* [2] _In_reads_bytes_(namelen) const struct sockaddr * name */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_bindat, 2);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->name),
		    &tmpcap, 1 * uap->namelen, reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_connectat_fill_uap(struct thread *td,
    struct connectat_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] int fd */
	uap->fd = (__typeof__(uap->fd))td->td_frame->a0;

	/* [1] int s */
	uap->s = (__typeof__(uap->s))td->td_frame->a1;

	/* [3] socklen_t namelen */
	uap->namelen = (__typeof__(uap->namelen))td->td_frame->a2;

	/* [2] _In_reads_bytes_(namelen) const struct sockaddr * name */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_connectat, 2);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->name),
		    &tmpcap, 1 * uap->namelen, reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_chflagsat_fill_uap(struct thread *td,
    struct chflagsat_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] int fd */
	uap->fd = (__typeof__(uap->fd))td->td_frame->a0;

	/* [2] u_long flags */
	uap->flags = (__typeof__(uap->flags))td->td_frame->a1;

	/* [3] int atflag */
	uap->atflag = (__typeof__(uap->atflag))td->td_frame->a2;

	/* [1] _In_z_ const char * path */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_chflagsat, 1);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->path),
		    &tmpcap, sizeof(*uap->path), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_accept4_fill_uap(struct thread *td,
    struct accept4_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] int s */
	uap->s = (__typeof__(uap->s))td->td_frame->a0;

	/* [3] int flags */
	uap->flags = (__typeof__(uap->flags))td->td_frame->a1;

	/* [2] _Inout_opt_ socklen_t *__restrict anamelen */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD|CHERI_PERM_STORE);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_accept4, 2);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->anamelen),
		    &tmpcap, sizeof(*uap->anamelen), reqperms, 1);
		if (error != 0)
			return (error);
	}

	/* [1] _Out_writes_bytes_opt_(*anamelen) struct sockaddr *__restrict name */
	{
		int error;
		register_t reqperms = (CHERI_PERM_STORE);

		if (uap->anamelen == NULL) {
			uap->name = NULL;
		} else {
			size_t reqlen;
			if (sizeof(*uap->anamelen) == 2)
				reqlen = fuword16(uap->anamelen);
			else if (sizeof(*uap->anamelen) == 4)
				reqlen = fuword32(uap->anamelen);
			else if (sizeof(*uap->anamelen) == 8)
				reqlen = fuword64(uap->anamelen);
			else
				panic("unhandled dependant argument size %zu", sizeof(*uap->anamelen));
			if (reqlen == -1)
				return (EINVAL);
			cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_accept4, 1);
			error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->name),
			    &tmpcap, reqlen, reqperms, 1);
			if (error != 0)
				return (error);
		}
	}

	return (0);
}

static inline int
CHERIABI_SYS_pipe2_fill_uap(struct thread *td,
    struct pipe2_args *uap)
{
	struct chericap tmpcap __unused;

	/* [1] int flags */
	uap->flags = (__typeof__(uap->flags))td->td_frame->a0;

	/* [0] _Out_writes_(2) int * fildes */
	{
		int error;
		register_t reqperms = (CHERI_PERM_STORE);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_pipe2, 0);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->fildes),
		    &tmpcap, (sizeof(*uap->fildes) * 2), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_cheriabi_aio_mlock_fill_uap(struct thread *td,
    struct cheriabi_aio_mlock_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] _In_ struct aiocb_c * aiocbp */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD|CHERI_PERM_LOAD_CAP);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_cheriabi_aio_mlock, 0);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->aiocbp),
		    &tmpcap, sizeof(*uap->aiocbp), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int	CHERIABI_SYS_cheriabi_procctl_fill_uap(struct thread *td,
    struct cheriabi_procctl_args *uap);

static inline int
CHERIABI_SYS_ppoll_fill_uap(struct thread *td,
    struct ppoll_args *uap)
{
	struct chericap tmpcap __unused;

	/* [1] u_int nfds */
	uap->nfds = (__typeof__(uap->nfds))td->td_frame->a0;

	/* [0] _Inout_updates_(nfds) struct pollfd * fds */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD|CHERI_PERM_STORE);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_ppoll, 0);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->fds),
		    &tmpcap, (sizeof(*uap->fds) * uap->nfds), reqperms, 0);
		if (error != 0)
			return (error);
	}

	/* [2] _In_opt_ const struct timespec * ts */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_ppoll, 2);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->ts),
		    &tmpcap, sizeof(*uap->ts), reqperms, 1);
		if (error != 0)
			return (error);
	}

	/* [3] _In_opt_ const sigset_t * set */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_ppoll, 3);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->set),
		    &tmpcap, sizeof(*uap->set), reqperms, 1);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_futimens_fill_uap(struct thread *td,
    struct futimens_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] int fd */
	uap->fd = (__typeof__(uap->fd))td->td_frame->a0;

	/* [1] _In_reads_(2) const struct timespec * times */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_futimens, 1);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->times),
		    &tmpcap, (sizeof(*uap->times) * 2), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_utimensat_fill_uap(struct thread *td,
    struct utimensat_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] int fd */
	uap->fd = (__typeof__(uap->fd))td->td_frame->a0;

	/* [3] int flag */
	uap->flag = (__typeof__(uap->flag))td->td_frame->a1;

	/* [1] _In_z_ const char * path */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_utimensat, 1);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->path),
		    &tmpcap, sizeof(*uap->path), reqperms, 0);
		if (error != 0)
			return (error);
	}

	/* [2] _In_reads_(2) const struct timespec * times */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_utimensat, 2);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->times),
		    &tmpcap, (sizeof(*uap->times) * 2), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_numa_getaffinity_fill_uap(struct thread *td,
    struct numa_getaffinity_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] cpuwhich_t which */
	uap->which = (__typeof__(uap->which))td->td_frame->a0;

	/* [1] id_t id */
	uap->id = (__typeof__(uap->id))td->td_frame->a1;

	/* [2] _Out_ struct vm_domain_policy_entry * policy */
	{
		int error;
		register_t reqperms = (CHERI_PERM_STORE);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_numa_getaffinity, 2);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->policy),
		    &tmpcap, sizeof(*uap->policy), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_numa_setaffinity_fill_uap(struct thread *td,
    struct numa_setaffinity_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] cpuwhich_t which */
	uap->which = (__typeof__(uap->which))td->td_frame->a0;

	/* [1] id_t id */
	uap->id = (__typeof__(uap->id))td->td_frame->a1;

	/* [2] _In_ const struct vm_domain_policy_entry * policy */
	{
		int error;
		register_t reqperms = (CHERI_PERM_LOAD);

		cheriabi_fetch_syscall_arg(td, &tmpcap, CHERIABI_SYS_numa_setaffinity, 2);
		error = cheriabi_cap_to_ptr(__DECONST(caddr_t *, &uap->policy),
		    &tmpcap, sizeof(*uap->policy), reqperms, 0);
		if (error != 0)
			return (error);
	}

	return (0);
}

static inline int
CHERIABI_SYS_fdatasync_fill_uap(struct thread *td,
    struct fdatasync_args *uap)
{
	struct chericap tmpcap __unused;

	/* [0] int fd */
	uap->fd = (__typeof__(uap->fd))td->td_frame->a0;

	return (0);
}

#endif /* !_SYS_COMPAT_CHERIABI_FILL_UAP_H_ */
