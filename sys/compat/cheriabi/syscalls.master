 $FreeBSD$
;	from: @(#)syscalls.master	8.2 (Berkeley) 1/13/94
;	from: src/sys/kern/syscalls.master 1.107
;
; System call name/number master file.
; Processed to created init_sysent.c, syscalls.c and syscall.h.

; Columns: number audit type name alt{name,tag,rtyp}/comments
;	number	system call number, must be in order
;	audit	the audit event associated with the system call
;		A value of AUE_NULL means no auditing, but it also means that
;		there is no audit event for the call at this time. For the
;		case where the event exists, but we don't want auditing, the
;		event should be #defined to AUE_NULL in audit_kevents.h.
;	type	one of STD, OBSOL, UNIMPL, COMPAT, COMPAT4, COMPAT6,
;		COMPAT7, NODEF, NOARGS, NOPROTO, NOSTD
;		The COMPAT* options may be combined with one or more NO*
;		options separated by '|' with no spaces (e.g. COMPAT|NOARGS)
;	name	psuedo-prototype of syscall routine
;		If one of the following alts is different, then all appear:
;	altname	name of system call if different
;	alttag	name of args struct tag if different from [o]`name'"_args"
;	altrtyp	return type if not int (bogus - syscalls always return int)
;		for UNIMPL/OBSOL, name continues with comments

; types:
;	STD	always included
;	COMPAT	included on COMPAT #ifdef
;	COMPAT4	included on COMPAT4 #ifdef (FreeBSD 4 compat)
;	COMPAT6	included on COMPAT6 #ifdef (FreeBSD 6 compat)
;	COMPAT7	included on COMPAT7 #ifdef (FreeBSD 7 compat)
;	OBSOL	obsolete, not included in system, only specifies name
;	UNIMPL	not implemented, placeholder only
;	NOSTD	implemented but as a lkm that can be statically
;		compiled in; sysent entry will be filled with lkmressys
;		so the SYSCALL_MODULE macro works
;	NOARGS	same as STD except do not create structure in sys/sysproto.h
;	NODEF	same as STD except only have the entry in the syscall table
;		added.  Meaning - do not create structure or function
;		prototype in sys/sysproto.h
;	NOPARSE	don't attempt to generate an argument parse.  Intended
;		for use in cases where annotation is insufficient to
;		accurately check arguments.
;	NOPROTO	same as STD except do not create structure or
;		function prototype in sys/sysproto.h.  Does add a
;		definition to syscall.h besides adding a sysent.

; #ifdef's, etc. may be included, and are copied to the output files.

#include <sys/param.h>
#include <sys/sysent.h>
#include <sys/sysproto.h>
#include <sys/mount.h>
#include <sys/socket.h>
#include <sys/user.h>
#include <compat/cheriabi/cheriabi.h>
#include <compat/cheriabi/cheriabi_proto.h>

#if !defined(PAD64_REQUIRED) && (defined(__powerpc__) || defined(__mips__))
#define PAD64_REQUIRED
#endif

; Reserved/unimplemented system calls in the range 0-150 inclusive
; are reserved for use in future Berkeley releases.
; Additional system calls implemented in vendor and other
; redistributions should be placed in the reserved range at the end
; of the current calls.

0	AUE_NULL	STD	{ int cheriabi_syscall(int number); }
1	AUE_EXIT	NOPROTO|NOSTUB	{ void sys_exit(int rval); } exit \
				    sys_exit_args void
2	AUE_FORK	NOPROTO	{ int fork(void); }
3	AUE_READ	STD	{ ssize_t cheriabi_read(int fd, \
				    _Out_writes_bytes_(nbyte) \
				    void * __capability buf, \
				    size_t nbyte); }
4	AUE_WRITE	STD	{ ssize_t cheriabi_write(int fd, \
				    _In_reads_bytes_(nbyte) \
				    const void * __capability buf, \
				    size_t nbyte); }
5	AUE_OPEN_RWTC	STD|VARARG	{ int cheriabi_open( \
				    _In_z_ const char * __capability path, \
				    int flags, \
				    mode_t mode); }
6	AUE_CLOSE	NOPROTO	{ int close(int fd); }
7	AUE_WAIT4	STD	{ int cheriabi_wait4(int pid, \
				    _Out_opt_ int * __capability status, \
				    int options, \
				    _Out_opt_ \
				    struct rusage * __capability rusage); }
8	AUE_CREAT	OBSOL	old creat
9	AUE_LINK	STD	{ int cheriabi_link( \
				    _In_z_ const char * __capability path, \
				    _In_z_ const char * __capability to); }
10	AUE_UNLINK	STD	{ int cheriabi_unlink( \
				    _In_z_ const char * __capability path); }
11	AUE_NULL	OBSOL	execv
12	AUE_CHDIR	STD	{ int cheriabi_chdir( \
				    _In_z_ const char * __capability path); }
13	AUE_FCHDIR	NOPROTO	{ int fchdir(int fd); }
14	AUE_MKNOD	OBSOL	fbsd11_mknod
15	AUE_CHMOD	STD	{ int cheriabi_chmod( \
				    _In_z_ const char * __capability path, \
				    mode_t mode); }
16	AUE_CHOWN	STD	{ int cheriabi_chown( \
				    _In_z_ const char * __capability path, \
				    int uid, int gid); }
17	AUE_NULL	OBSOL	obreak
18	AUE_GETFSSTAT	OBSOL	getstatfs
19	AUE_LSEEK	OBSOL	lseek
20	AUE_GETPID	NOPROTO	{ pid_t getpid(void); }
; XXX-BD: should be OBSOL, but need to fix amd
21	AUE_MOUNT	STD	{ int cheriabi_mount( \
				    _In_z_ const char * __capability type, \
				    _In_z_ const char * __capability path, \
				    int flags, \
				    _In_opt_ void * __capability data); }
22	AUE_UMOUNT	STD	{ int cheriabi_unmount( \
				    _In_z_ const char * __capability path, \
				    int flags); }
23	AUE_SETUID	NOPROTO	{ int setuid(uid_t uid); }
24	AUE_GETUID	NOPROTO	{ uid_t getuid(void); }
25	AUE_GETEUID	NOPROTO	{ uid_t geteuid(void); }
26	AUE_PTRACE	NOPROTO	{ int ptrace(int req, pid_t pid, \
				    _Inout_opt_ caddr_t addr, int data); }
27	AUE_RECVMSG	STD	{ ssize_t cheriabi_recvmsg(int s, \
				    _Inout_ struct msghdr_c * __capability msg, \
				    int flags); }
28	AUE_SENDMSG	STD	{ ssize_t cheriabi_sendmsg(int s, \
				    _In_ const struct msghdr_c * __capability msg, \
				    int flags); }
29	AUE_RECVFROM	STD	{ ssize_t cheriabi_recvfrom(int s, \
				    _Out_writes_bytes_(len) \
				    void * __capability buf, \
				    size_t len, int flags, \
				    _Out_writes_bytes_opt_(*fromlenaddr) \
				    struct sockaddr * __restrict __capability from, \
				    _Inout_opt_ \
				    __socklen_t * __restrict __capability fromlenaddr); }
30	AUE_ACCEPT	STD	{ int cheriabi_accept(int s, \
				    _Out_writes_bytes_opt_(*anamelen) \
				    struct sockaddr * __restrict __capability name, \
				    _Inout_opt_ __socklen_t * __capability anamelen); }
31	AUE_GETPEERNAME	STD	{ int cheriabi_getpeername(int fdes, \
				    _Out_writes_bytes_(*alen) \
				    struct sockaddr * __restrict __capability asa, \
				    _Inout_ __socklen_t * __capability alen); }
32	AUE_GETSOCKNAME	STD	{ int cheriabi_getsockname(int fdes, \
				    _Out_writes_bytes_(*alen) \
				    struct sockaddr * __restrict __capability  asa, \
				    _Inout_ __socklen_t * __capability alen); }
33	AUE_ACCESS	STD	{ int cheriabi_access( \
				    _In_z_ const char * __capability path, \
				    int amode); }
34	AUE_CHFLAGS	STD	{ int cheriabi_chflags( \
				    _In_z_ const char * __capability path, \
				    u_long flags); }
35	AUE_FCHFLAGS	NOPROTO	{ int fchflags(int fd, u_long flags); }
36	AUE_SYNC	NOPROTO	{ int sync(void); }
37	AUE_KILL	NOPROTO	{ int kill(int pid, int signum); }
38	AUE_STAT	OBSOL	stat
39	AUE_GETPPID	NOPROTO	{ pid_t getppid(void); }
40	AUE_LSTAT	OBSOL	lstat
41	AUE_DUP		NOPROTO	{ int dup(u_int fd); }
42	AUE_PIPE	OBSOL	pipe
43	AUE_GETEGID	NOPROTO	{ gid_t getegid(void); }
44	AUE_PROFILE	STD	{ int cheriabi_profil( \
				    _Out_writes_bytes_(size) \
				    void * __capability samples, \
				    size_t size, size_t offset, u_int scale); }
45	AUE_KTRACE	STD	{ int cheriabi_ktrace( \
				    _In_z_ const char * __capability fname, \
				    int ops, int facs, int pid); }
46	AUE_SIGACTION	OBSOL	sigaction
47	AUE_GETGID	NOPROTO	{ gid_t getgid(void); }
48	AUE_SIGPROCMASK	OBSOL	sigprocmask
49	AUE_GETLOGIN	STD	{ int cheriabi_getlogin( \
				    _Out_writes_z_(namelen) \
				    char * __capability namebuf, \
				    u_int namelen); }
50	AUE_SETLOGIN	STD	{ int cheriabi_setlogin( \
				    _In_z_ const char * __capability namebuf); }
51	AUE_ACCT	STD	{ int cheriabi_acct( \
				    _In_z_ const char * __capability path); }
52	AUE_SIGPENDING	OBSOL	sigpending
53	AUE_SIGALTSTACK	STD	{ int cheriabi_sigaltstack( \
				    _In_opt_ const cheriabi_stack_t * __capability ss, \
				    _Out_opt_ cheriabi_stack_t * __capability oss); }
54	AUE_NULL	STD|NOPARSE|VARARG|NOSTUB	{ int cheriabi_ioctl( \
				    int fd, u_long com, \
				    _Inout_opt_ void *data); }
55	AUE_REBOOT	NOPROTO	{ int reboot(int opt); }
56	AUE_REVOKE	STD	{ int cheriabi_revoke( \
				    _In_z_ const char * __capability path); }
57	AUE_SYMLINK	STD	{ int cheriabi_symlink( \
				    _In_z_ const char * __capability path, \
				    _In_z_ const char * __capability link); }
58	AUE_READLINK	STD	{ ssize_t cheriabi_readlink( \
				    _In_z_ const char * __capability path, \
				    _Out_writes_z_(count) \
				    char * __capability buf, \
				    size_t count); }
; XXX-BD: Arguably argv and envv are _In_z_, but the SAL documentation is
; inconsistant about NUL terminated string, vs NULL terminted array so
; _In_ for now.
59	AUE_EXECVE	STD|NOSTUB	{ int cheriabi_execve( \
				    _In_z_ const char * __capability fname, \
				    _In_ void * __capability * __capability argv, \
				    _In_ void * __capability * __capability envv); }
60	AUE_UMASK	NOPROTO	{ mode_t umask(mode_t newmask); }
61	AUE_CHROOT	STD	{ int cheriabi_chroot( \
				    _In_z_ const char * __capability path); }
62	AUE_FSTAT	OBSOL	fstat
63	AUE_NULL	OBSOL	ogetkerninfo
64	AUE_NULL	OBSOL	getpagesize
; XXX-BD: msync may not need/want _Pagerange_ as it doesn't alter the map
65	AUE_MSYNC	STD	{ int cheriabi_msync( \
				    _Pagerange_(len) void * __capability addr, \
				    size_t len, int flags); }
66	AUE_VFORK	NOPROTO	{ int vfork(void); }
67	AUE_NULL	OBSOL	vread
68	AUE_NULL	OBSOL	vwrite
69	AUE_SBRK	OBSOL	sbrk
70	AUE_SSTK	OBSOL	sstk
71	AUE_MMAP	OBSOL	mmap
72	AUE_O_VADVISE	OBSOL	ovadvise
73	AUE_MUNMAP	STD	{ int cheriabi_munmap( \
				    _Pagerange_vmmap_(len) \
				    void * __capability addr, \
				    size_t len); }
74	AUE_MPROTECT	STD	{ int cheriabi_mprotect( \
				    _Pagerange_(len) const void *addr, \
				    size_t len, int prot); }
; XXX-BD: MADV_FREE does change the map.  MADV_NOCORE has adversarial value.
; MADV_CORE is probably an error if not a page.  Others don't really need
; _Pagerange_.
75	AUE_MADVISE	STD	{ int cheriabi_madvise( \
				    _Pagerange_(len) void * __capability addr, \
				    size_t len, int behav); }
76	AUE_NULL	OBSOL	vhangup
77	AUE_NULL	OBSOL	vlimit
; XXX-BD: missing round up of len for misaligned addr
78	AUE_MINCORE	STD	{ int cheriabi_mincore( \
				    _Pagerange_opt_(len) \
				    const void * __capability addr, \
				    size_t len, \
				    _Out_writes_bytes_(len/PAGE_SIZE) \
				    char * __capability vec); }
79	AUE_GETGROUPS	STD	{ int cheriabi_getgroups(u_int gidsetsize, \
				    _Out_writes_opt_(gidsetsize) \
				    gid_t * __capability gidset); }
80	AUE_SETGROUPS	STD	{ int cheriabi_setgroups(u_int gidsetsize, \
				    _In_reads_(gidsetsize) \
				    const gid_t * __capability gidset); }
81	AUE_GETPGRP	NOPROTO	{ int getpgrp(void); }
82	AUE_SETPGRP	NOPROTO	{ int setpgid(int pid, int pgid); }
83	AUE_SETITIMER	STD	{ int cheriabi_setitimer(int which, \
				    _In_ \
				    const struct itimerval * __capability itv, \
				    _Out_opt_ \
				    struct itimerval * __capability oitv); }
84	AUE_NULL	OBSOL	owait
85	AUE_SWAPON	STD	{ int cheriabi_swapon( \
				    _In_z_ const char * __capability name); }
86	AUE_GETITIMER	STD	{ int cheriabi_getitimer(int which, \
				    _Out_ \
				    struct itimerval * __capability itv); }
87	AUE_O_GETHOSTNAME	OBSOL	ogethostname
88	AUE_O_SETHOSTNAME	OBSOL	osethostname
89	AUE_GETDTABLESIZE	NOPROTO	{ int getdtablesize(void); }
90	AUE_DUP2	NOPROTO	{ int dup2(u_int from, u_int to); }
91	AUE_NULL	UNIMPL	getdopt
; XXX-BD: no practical way to check arg
92	AUE_FCNTL	NOPROTO|NOPARSE|VARARG	{ int fcntl(int fd, int cmd, \
				    intptr_t arg); }
93	AUE_SELECT	STD	{ int cheriabi_select(int nd, \
				    _Inout_opt_ fd_set * __capability in, \
				    _Inout_opt_ fd_set * __capability ou, \
				    _Inout_opt_ fd_set * __capability ex, \
				    _In_opt_ \
				    struct timeval * __capability tv); }
94	AUE_NULL	UNIMPL	setdopt
95	AUE_FSYNC	NOPROTO	{ int fsync(int fd); }
96	AUE_SETPRIORITY	NOPROTO	{ int setpriority(int which, int who, \
				    int prio); }
97	AUE_SOCKET	NOPROTO	{ int socket(int domain, int type, \
				    int protocol); }
98	AUE_CONNECT	STD	{ int cheriabi_connect(int s, \
				    _In_reads_bytes_(namelen) \
				    const struct sockaddr * __capability name, \
				    __socklen_t namelen); }
99	AUE_NULL	OBSOL	oaccept
100	AUE_GETPRIORITY	NOPROTO	{ int getpriority(int which, int who); }
101	AUE_NULL	OBSOL	osend
102	AUE_NULL	OBSOL	orecv
103	AUE_NULL	OBSOL	sigreturn
104	AUE_BIND	STD	{ int cheriabi_bind(int s, \
				    _In_reads_bytes_(namelen) \
				    const struct sockaddr * __capability name, \
				    __socklen_t namelen); }
105	AUE_SETSOCKOPT	STD	{ int cheriabi_setsockopt(int s, int level, \
				    int name, \
				    _In_reads_bytes_opt_(valsize) \
				    const void * __capability val, \
				    __socklen_t valsize); }
106	AUE_LISTEN	NOPROTO	{ int listen(int s, int backlog); }
107	AUE_NULL	OBSOL	vtimes
108	AUE_O_SIGVEC	OBSOL	sigvec
109	AUE_O_SIGBLOCK	OBSOL	sigblock
110	AUE_O_SIGSETMASK	OBSOL	sigsetmask
111	AUE_SIGSUSPEND	OBSOL	sigsuspend
112	AUE_O_SIGSTACK	OBSOL	sigstack
113	AUE_NULL	OBSOL	orecvmsg
114	AUE_NULL	OBSOL	osendmsg
115	AUE_NULL	OBSOL	vtrace
116	AUE_GETTIMEOFDAY	STD	{ int cheriabi_gettimeofday( \
				    _Out_ struct timeval * __capability tp, \
				    _Out_opt_ \
				    struct timezone * __capability tzp); }
117	AUE_GETRUSAGE	STD	{ int cheriabi_getrusage(int who, \
				    _Out_ struct rusage * __capability rusage); }
118	AUE_GETSOCKOPT	STD	{ int cheriabi_getsockopt(int s, int level, \
				    int name, \
				    _Out_writes_bytes_opt_(*avalsize) \
				    void * __capability val, \
				    _Inout_ __socklen_t * __capability avalsize); }
119	AUE_NULL	UNIMPL	resuba (BSD/OS 2.x)
120	AUE_READV	STD	{ int cheriabi_readv(int fd, \
				    _Inout_updates_(iovcnt) \
				    struct iovec_c * __capability iovp, \
				    u_int iovcnt); }
121	AUE_WRITEV	STD	{ int cheriabi_writev(int fd, \
				    _In_reads_opt_(iovcnt) \
				    struct iovec_c * __capability iovp, \
				    u_int iovcnt); }
122	AUE_SETTIMEOFDAY	STD	{ int cheriabi_settimeofday( \
				    _In_ \
				    const struct timeval * __capability tv, \
				    _In_opt_ \
				    const struct timezone * __capability tzp); }
123	AUE_FCHOWN	NOPROTO	{ int fchown(int fd, int uid, int gid); }
124	AUE_FCHMOD	NOPROTO	{ int fchmod(int fd, mode_t mode); }
125	AUE_RECVFROM	OBSOL	orecvfrom
126	AUE_SETREUID	NOPROTO	{ int setreuid(int ruid, int euid); }
127	AUE_SETREGID	NOPROTO	{ int setregid(int rgid, int egid); }
128	AUE_RENAME	STD	{ int cheriabi_rename( \
				    _In_z_ const char * __capability from, \
				    _In_z_ const char * __capability to); }
129	AUE_TRUNCATE	OBSOL	truncate
130	AUE_FTRUNCATE	OBSOL	ftruncate
131	AUE_FLOCK	NOPROTO	{ int flock(int fd, int how); }
132	AUE_MKFIFO	STD	{ int cheriabi_mkfifo( \
				    _In_z_ const char * __capability path, \
				    mode_t mode); }
133	AUE_SENDTO	STD	{ ssize_t cheriabi_sendto(int s, \
				    _In_reads_bytes_(len) \
				    const void * __capability buf, \
				    size_t len, int flags, \
				    _In_reads_bytes_opt_(tolen) \
				    const struct sockaddr * __capability to, \
				    __socklen_t tolen); }
134	AUE_SHUTDOWN	NOPROTO	{ int shutdown(int s, int how); }
135	AUE_SOCKETPAIR	STD	{ int cheriabi_socketpair(int domain, \
				    int type, int protocol, \
				    _Out_writes_(2) int * __capability rsv); }
136	AUE_MKDIR	STD	{ int cheriabi_mkdir( \
				    _In_z_ const char * __capability path, \
				    mode_t mode); }
137	AUE_RMDIR	STD	{ int cheriabi_rmdir( \
				    _In_z_ const char * __capability path); }
138	AUE_UTIMES	STD	{ int cheriabi_utimes( \
				    _In_z_ const char * __capability path, \
				    _In_ \
				    const struct timeval * __capability tptr); }
139	AUE_NULL	OBSOL	sigreturn
140	AUE_ADJTIME	STD	{ int cheriabi_adjtime( \
				    _In_ \
				    const struct timeval * __capability delta, \
				    _Out_opt_ \
				    struct timeval * __capability olddelta); }
141	AUE_GETPEERNAME	OBSOL	ogetpeername
142	AUE_SYSCTL	OBSOL	ogethostid
143	AUE_SYSCTL	OBSOL	sethostid
144	AUE_GETRLIMIT	OBSOL	getrlimit
145	AUE_SETRLIMIT	OBSOL	setrlimit
146	AUE_KILLPG	OBSOL	killpg
147	AUE_SETSID	NOPROTO	{ int setsid(void); }
148	AUE_QUOTACTL	STD	{ int cheriabi_quotactl( \
				    _In_z_ const char * __capability path, \
				    int cmd, int uid, \
				    _In_ void * __capability arg); }
149	AUE_O_QUOTA	OBSOL oquota
150	AUE_GETSOCKNAME	OBSOL ogetsockname

; Syscalls 151-180 inclusive are reserved for vendor-specific
; system calls.  (This includes various calls added for compatibity
; with other Unix variants.)
; Some of these calls are now supported by BSD...
151	AUE_NULL	UNIMPL	sem_lock (BSD/OS 2.x)
152	AUE_NULL	UNIMPL	sem_wakeup (BSD/OS 2.x)
153	AUE_NULL	UNIMPL	asyncdaemon (BSD/OS 2.x)
; 154 is initialised by the NLM code, if present.
154	AUE_NULL	NOSTD|NOSTUB	{ int cheriabi_nlm_syscall(int debug_level, \
				    int grace_period , int addr_count, \
				    _In_reads_(addr_count) \
				    void * __capability * __capability addrs); }
; 155 is initialized by the NFS code, if present.
155	AUE_NFS_SVC	NOSTD	{ int cheriabi_nfssvc(int flag, \
				    void * __capability argp); }
156	AUE_GETDIRENTRIES OBSOL getdirentries
157	AUE_STATFS	OBSOL	statfs
158	AUE_FSTATFS	OBSOL	fstatfs
159	AUE_NULL	UNIMPL	nosys
160	AUE_LGETFH	STD	{ int cheriabi_lgetfh( \
				    _In_z_ const char * __capability fname, \
				    _Out_ struct fhandle * __capability fhp); }
161	AUE_NFS_GETFH	STD	{ int cheriabi_getfh( \
				    _In_z_ const char * __capability fname, \
				    _Out_ struct fhandle * __capability fhp); }
162	AUE_NULL	OBSOL	getdomainname
163	AUE_NULL	OBSOL	setdomainname
164	AUE_NULL	OBSOL	uname
; XXX-BD params is basically uncheckable
165	AUE_SYSARCH	STD|NOPARSE	{ int cheriabi_sysarch(int op, \
				    char *parms); }
; XXX-BD rtp is _In_ or _Out_ depending on function
166	AUE_RTPRIO	STD	{ int cheriabi_rtprio(int function, pid_t pid, \
				    _Inout_ struct rtprio * __capability rtp); }
167	AUE_NULL	UNIMPL	nosys
168	AUE_NULL	UNIMPL	nosys
169	AUE_SEMSYS	OBSOL	semsys
170	AUE_MSGSYS	OBSOL	msgsys
171	AUE_SHMSYS	OBSOL	shmsys
172	AUE_NULL	UNIMPL	nosys
173	AUE_PREAD	OBSOL	pread
174	AUE_PWRITE	OBSOL	pwrite
175	AUE_SETFIB	NOPROTO	{ int setfib(int fibnum); }
176	AUE_NTP_ADJTIME	STD	{ int cheriabi_ntp_adjtime( \
				    _Inout_ struct timex * __capability tp); }
177	AUE_NULL	UNIMPL	sfork (BSD/OS 2.x)
178	AUE_NULL	UNIMPL	getdescriptor (BSD/OS 2.x)
179	AUE_NULL	UNIMPL	setdescriptor (BSD/OS 2.x)
180	AUE_NULL	UNIMPL	nosys

; Syscalls 181-199 are used by/reserved for BSD
181	AUE_SETGID	NOPROTO	{ int setgid(gid_t gid); }
182	AUE_SETEGID	NOPROTO	{ int setegid(gid_t egid); }
183	AUE_SETEUID	NOPROTO	{ int seteuid(uid_t euid); }
184	AUE_NULL	UNIMPL	lfs_bmapv
185	AUE_NULL	UNIMPL	lfs_markv
186	AUE_NULL	UNIMPL	lfs_segclean
187	AUE_NULL	UNIMPL	lfs_segwait
188	AUE_STAT	OBSOL	fbsd11_stat
189	AUE_FSTAT	OBSOL	fbsd11_fstat
190	AUE_LSTAT	OBSOL	fbsd11_lstat
191	AUE_PATHCONF	STD	{ int cheriabi_pathconf( \
				    _In_z_ const char * __capability path, \
				    int name); }
192	AUE_FPATHCONF	NOPROTO	{ int fpathconf(int fd, int name); }
193	AUE_NULL	UNIMPL	nosys
194	AUE_GETRLIMIT	STD	{ int cheriabi_getrlimit(u_int which, \
				    _Out_ struct rlimit * __capability rlp); }
195	AUE_SETRLIMIT	STD	{ int cheriabi_setrlimit(u_int which, \
				    _In_ struct rlimit * __capability rlp); }
196	AUE_GETDIRENTRIES	OBSOL	fbsd11_getdirentries
197	AUE_MMAP	OBSOL	mmap
198	AUE_NULL	OBSOL	__syscall
199	AUE_LSEEK	OBSOL	lseek
200	AUE_TRUNCATE	OBSOL	truncate
201	AUE_FTRUNCATE	OBSOL	ftruncate
202	AUE_SYSCTL	STD	{ int cheriabi___sysctl( \
				    _In_reads_(namelen) \
				    int * __capability name, \
				    u_int namelen, \
				    _Out_writes_bytes_opt_(*oldlenp) \
				    void * __capability old, \
				    _Inout_opt_ size_t * __capability oldlenp, \
				    _In_reads_bytes_opt_(newlen) \
				    void * __capability new, \
				    size_t newlen); }
; XXX-BD: unclear if these really require _Pagerange_.  It's mostly
; harmless to lock memory you don't own, but unlocking could cause (e.g.)
; keys to leak to swap so could be malicous.
203	AUE_MLOCK	NOPROTO	{ int mlock( \
				    _Pagerange_(len) const void *addr, \
				    size_t len); }
204	AUE_MUNLOCK	NOPROTO	{ int munlock( \
				    _Pagerange_(len) const void *addr, \
				    size_t len); }
205	AUE_UNDELETE	STD	{ int cheriabi_undelete( \
				    _In_z_ const char * __capability path); }
206	AUE_FUTIMES	STD	{ int cheriabi_futimes(int fd, \
				    _In_reads_(2) \
				    const struct timeval * __capability tptr); }
207	AUE_GETPGID	NOPROTO	{ int getpgid(pid_t pid); }
208	AUE_NULL	UNIMPL	newreboot (NetBSD)
209	AUE_POLL	STD	{ int cheriabi_poll( \
				    _Inout_updates_(nfds) \
				    struct pollfd * __capability fds, \
				    u_int nfds, int timeout); }

;
; The following are reserved for loadable syscalls
;
210	AUE_NULL	NODEF|NOTSTATIC	lkmnosys lkmnosys nosys_args int
211	AUE_NULL	NODEF|NOTSTATIC	lkmnosys lkmnosys nosys_args int
212	AUE_NULL	NODEF|NOTSTATIC	lkmnosys lkmnosys nosys_args int
213	AUE_NULL	NODEF|NOTSTATIC	lkmnosys lkmnosys nosys_args int
214	AUE_NULL	NODEF|NOTSTATIC	lkmnosys lkmnosys nosys_args int
215	AUE_NULL	NODEF|NOTSTATIC	lkmnosys lkmnosys nosys_args int
216	AUE_NULL	NODEF|NOTSTATIC	lkmnosys lkmnosys nosys_args int
217	AUE_NULL	NODEF|NOTSTATIC	lkmnosys lkmnosys nosys_args int
218	AUE_NULL	NODEF|NOTSTATIC	lkmnosys lkmnosys nosys_args int
219	AUE_NULL	NODEF|NOTSTATIC	lkmnosys lkmnosys nosys_args int

;
; The following were introduced with NetBSD/4.4Lite-2
; They are initialized by their respective modules/sysinits
; XXX PROBLEM!!
220	AUE_SEMCTL	OBSOL	__semctl
221	AUE_SEMGET	NOSTD|NOPROTO	{ int semget(key_t key, int nsems, \
				    int semflg); }
222	AUE_SEMOP	NOSTD	{ int cheriabi_semop(int semid, \
				    _In_reads_(nsops) \
				    struct sembuf * __capability sops, \
				    u_int nsops); }
223	AUE_NULL	UNIMPL	semconfig
224	AUE_MSGCTL	OBSOL	msgctl
225	AUE_MSGGET	NOSTD|NOPROTO	{ int msgget(key_t key, int msgflg); }
226	AUE_MSGSND	NOSTD	{ int cheriabi_msgsnd(int msqid, \
				    _In_reads_bytes_(msgsz) \
				    void * __capability msgp, \
				    size_t msgsz, int msgflg); }
227	AUE_MSGRCV	NOSTD	{ int cheriabi_msgrcv(int msqid, \
				    _Out_writes_bytes_(msgsz) \
				    void * __capability msgp, \
				    size_t msgsz, long msgtyp, int msgflg); }
228	AUE_SHMAT	NOSTD	{ void *cheriabi_shmat( int shmid, \
				    _Pagerange_vmmap_opt_(1) \
				    void * __capability shmaddr, \
				    int shmflg); }
229	AUE_SHMCTL	OBSOL	shmctl
230	AUE_SHMDT	NOSTD	{ int cheriabi_shmdt( \
				    _Pagerange_vmmap_(1) \
				    void * __capability shmaddr); }
231	AUE_SHMGET	NOSTD|NOPROTO	{ int shmget(key_t key, int size, \
				    int shmflg); }
232	AUE_NULL	STD	{ int cheriabi_clock_gettime( \
				    clockid_t clock_id, \
				    _Out_ struct timespec * __capability tp); }
233	AUE_CLOCK_SETTIME	STD	{ int cheriabi_clock_settime( \
				    clockid_t clock_id, \
				    _In_ \
				    const struct timespec * __capability tp); }
234	AUE_NULL	STD	{ int cheriabi_clock_getres(clockid_t clock_id, \
				    _Out_ struct timespec * __capability tp); }
235	AUE_NULL	STD	{ int cheriabi_ktimer_create(\
				    clockid_t clock_id, \
				    _In_ struct sigevent_c * __capability evp, \
				    _Out_ int * __capability timerid); }
236	AUE_NULL	NOPROTO	{ int ktimer_delete(int timerid); }
237	AUE_NULL	STD	{ int cheriabi_ktimer_settime(int timerid,\
				    int flags, \
				    _In_ const \
				    struct itimerspec * __capability value, \
				    _Out_opt_ \
				    struct itimerspec * __capability ovalue); }
238	AUE_NULL	STD	{ int cheriabi_ktimer_gettime(int timerid, \
				    _Out_ \
				    struct itimerspec * __capability value); }
239	AUE_NULL	NOPROTO	{ int ktimer_getoverrun(int timerid); }
240	AUE_NULL	STD	{ int cheriabi_nanosleep( \
				    _In_ \
				    const struct timespec * __capability rqtp, \
				    _Out_opt_ \
				    struct timespec * __capability rmtp); }
241	AUE_NULL	STD	{ int cheriabi_ffclock_getcounter( \
				    _Out_ \
				    ffcounter * __capability ffcount); }
242	AUE_NULL	STD	{ int cheriabi_ffclock_setestimate( \
				    _In_ struct ffclock_estimate * __capability cest); }
243	AUE_NULL	STD	{ int cheriabi_ffclock_getestimate( \
				    _Out_ struct ffclock_estimate * __capability cest); }
244	AUE_NULL	STD	{ int cheriabi_clock_nanosleep( \
				    clockid_t clock_id, int flags, \
				    _In_ \
				    const struct timespec * __capability rqtp, \
				    _Out_opt_ \
				    struct timespec * __capability rmtp); }
245	AUE_NULL	UNIMPL	nosys
246	AUE_NULL	UNIMPL	nosys
247	AUE_NULL	STD	{ int cheriabi_clock_getcpuclockid2(id_t id, \
				    int which, \
				    _Out_ clockid_t * __capability clock_id); }
248	AUE_NULL	STD	{ int cheriabi_ntp_gettime(\
				    _Out_ \
				    struct ntptimeval * __capability ntvp); }
249	AUE_NULL	UNIMPL	nosys
; syscall numbers initially used in OpenBSD
250	AUE_MINHERIT	NOPROTO	{ int minherit( \
				    _Pagerange_(len) void *addr, \
				    size_t len, int inherit); }
251	AUE_RFORK	NOPROTO	{ int rfork(int flags); }
252	AUE_POLL	UNIMPL	openbsd_poll
253	AUE_ISSETUGID	NOPROTO	{ int issetugid(void); }
254	AUE_LCHOWN	STD	{ int cheriabi_lchown( \
				    _In_z_ const char * __capability path, \
				    int uid, int gid); }
255	AUE_AIO_READ	STD	{ int cheriabi_aio_read( \
				    _Inout_ struct aiocb_c * __capability \
				    aiocbp); }
256	AUE_AIO_WRITE	STD	{ int cheriabi_aio_write( \
				    _Inout_ struct aiocb_c * __capability \
				    aiocbp); }
257	AUE_LIO_LISTIO	STD	{ int cheriabi_lio_listio(int mode, \
				    _Inout_updates_(nent) \
				    struct aiocb_c * const __capability * __capability acb_list, \
				    int nent, \
				    _In_opt_ struct sigevent_c * __capability sig); }
258	AUE_NULL	STD	{ int cheriabi_kbounce( \
				    _In_reads_bytes_(len) \
				    const void * __capability src, \
				    _Out_writes_bytes_(len) \
				    void * __capability dst, \
				    size_t len, int flags); }
259	AUE_NULL	UNIMPL	nosys
260	AUE_NULL	UNIMPL	nosys
261	AUE_NULL	UNIMPL	nosys
262	AUE_NULL	UNIMPL	nosys
263	AUE_NULL	UNIMPL	nosys
264	AUE_NULL	UNIMPL	nosys
265	AUE_NULL	UNIMPL	nosys
266	AUE_NULL	UNIMPL	nosys
267	AUE_NULL	UNIMPL	nosys
268	AUE_NULL	UNIMPL	nosys
269	AUE_NULL	UNIMPL	nosys
270	AUE_NULL	UNIMPL	nosys
271	AUE_NULL	UNIMPL	nosys
272	AUE_O_GETDENTS	OBSOL	fbsd11_getdents
273	AUE_NULL	UNIMPL	nosys
274	AUE_LCHMOD	STD	{ int cheriabi_lchmod( \
				    _In_z_ const char * __capability path, \
				    mode_t mode); }
275	AUE_LCHOWN	UNIMPL	netbsd_lchown
276	AUE_LUTIMES	STD	{ int cheriabi_lutimes( \
				    _In_z_ const char * __capability path, \
				    _In_ const struct timeval * __capability tptr); }
277	AUE_MSYNC	UNIMPL	netbsd_msync
278	AUE_STAT	UNIMPL	freebsd11_nstat
279	AUE_FSTAT	UNIMPL	freebsd11_nfstat
280	AUE_LSTAT	UNIMPL	freebsd11_nlstat
281	AUE_NULL	UNIMPL	nosys
282	AUE_NULL	UNIMPL	nosys
283	AUE_NULL	UNIMPL	nosys
284	AUE_NULL	UNIMPL	nosys
285	AUE_NULL	UNIMPL	nosys
286	AUE_NULL	UNIMPL	nosys
287	AUE_NULL	UNIMPL	nosys
288	AUE_NULL	UNIMPL	nosys
; 289 and 290 from NetBSD (OpenBSD: 267 and 268)
289	AUE_PREADV	STD	{ ssize_t cheriabi_preadv(int fd, \
				    _In_reads_(iovcnt) \
				    struct iovec_c * __capability iovp, \
				    u_int iovcnt, off_t offset); }
290	AUE_PWRITEV	STD	{ ssize_t cheriabi_pwritev(int fd, \
				    _In_reads_(iovcnt) \
				    struct iovec_c * __capability iovp, \
				    u_int iovcnt, off_t offset); }
291	AUE_NULL	UNIMPL	nosys
292	AUE_NULL	UNIMPL	nosys
293	AUE_NULL	UNIMPL	nosys
294	AUE_NULL	UNIMPL	nosys
295	AUE_NULL	UNIMPL	nosys
296	AUE_NULL	UNIMPL	nosys
; XXX 297 is 300 in NetBSD 
297	AUE_FHSTATFS	OBSOL	fhstatfs
298	AUE_FHOPEN	STD	{ int cheriabi_fhopen( \
				    _In_ const struct fhandle * __capability u_fhp, \
			 	    int flags); }
299	AUE_FHSTAT	OBSOL	fbsd11_fhstat
; syscall numbers for FreeBSD
300	AUE_NULL	NOPROTO	{ int modnext(int modid); }
301	AUE_NULL	STD	{ int cheriabi_modstat(int modid, \
				    _Out_ struct module_stat * __capability stat); }
302	AUE_NULL	NOPROTO	{ int modfnext(int modid); }
303	AUE_NULL	STD	{ int cheriabi_modfind(_In_z_ const char * __capability name); }
304	AUE_MODLOAD	STD	{ int cheriabi_kldload( \
				    _In_z_ const char * __capability file); }
305	AUE_MODUNLOAD	NOPROTO	{ int kldunload(int fileid); }
306	AUE_NULL	STD	{ int cheriabi_kldfind( \
				    _In_z_ const char * __capability file); }
307	AUE_NULL	NOPROTO	{ int kldnext(int fileid); }
308	AUE_NULL	STD	{ int cheriabi_kldstat(int fileid, \
				    _Out_ struct kld_file_stat_c * __capability stat); }
309	AUE_NULL	NOPROTO	{ int kldfirstmod(int fileid); }
310	AUE_GETSID	NOPROTO	{ int getsid(pid_t pid); }
311	AUE_SETRESUID	NOPROTO	{ int setresuid(uid_t ruid, uid_t euid, \
				    uid_t suid); }
312	AUE_SETRESGID	NOPROTO	{ int setresgid(gid_t rgid, gid_t egid, \
				    gid_t sgid); }
313	AUE_NULL	OBSOL	signanosleep
314	AUE_AIO_RETURN	STD	{ int cheriabi_aio_return( \
				    _Inout_ struct aiocb_c * __capability \
				    aiocbp); }
315	AUE_AIO_SUSPEND	STD	{ int cheriabi_aio_suspend( \
				    _Inout_updates_(nent) \
				    struct aiocb_c * const __capability * __capability aiocbp, \
				    int nent, \
				    _In_opt_ const struct timespec * __capability timeout); }
; XXX-BD: Requiring load is technically excessive
316	AUE_AIO_CANCEL	STD	{ int cheriabi_aio_cancel(int fd, \
				    _In_opt_ struct aiocb_c * __capability aiocbp); }
317	AUE_AIO_ERROR	STD	{ int cheriabi_aio_error( \
				    _In_ struct aiocb_c * __capability aiocbp); }
318	AUE_AIO_READ	OBSOL	oaio_read
319	AUE_AIO_WRITE	OBSOL	oaio_write
320	AUE_LIO_LISTIO	OBSOL	olio_listio
321	AUE_NULL	OBSOL	yield
322	AUE_NULL	OBSOL	thr_sleep
323	AUE_NULL	OBSOL	thr_wakeup
; XXX-BD: are mlockall and munlockall ok in CheriABI?
324	AUE_MLOCKALL	NOPROTO	{ int mlockall(int how); }
325	AUE_MUNLOCKALL	NOPROTO	{ int munlockall(void); }
326	AUE_GETCWD	STD	{ int cheriabi___getcwd( \
				    _Out_writes_z_(buflen) \
				    char * __capability buf, \
				    size_t buflen); }
327	AUE_NULL	STD	{ int cheriabi_sched_setparam (pid_t pid, \
				    _In_ const struct sched_param * __capability param); }
328	AUE_NULL	STD	{ int cheriabi_sched_getparam (pid_t pid, \
				    _Out_ struct sched_param * __capability param); }

329	AUE_NULL	STD	{ int cheriabi_sched_setscheduler (pid_t pid, \
				    int policy, \
				    _In_ const struct sched_param * __capability param); }
330	AUE_NULL	NOPROTO	{ int sched_getscheduler (pid_t pid); }

331	AUE_NULL	NOPROTO	{ int sched_yield (void); }
332	AUE_NULL	NOPROTO	{ int sched_get_priority_max (int policy); }
333	AUE_NULL	NOPROTO	{ int sched_get_priority_min (int policy); }
334	AUE_NULL	STD	{ int cheriabi_sched_rr_get_interval (pid_t pid, \
				    _Out_ struct timespec * __capability interval); }
335	AUE_NULL	STD	{ int cheriabi_utrace( \
				    _In_reads_bytes_(len) \
				    const void * __capability addr, \
				    size_t len); }
336	AUE_SENDFILE	OBSOL	sendfile
337	AUE_NULL	STD	{ int cheriabi_kldsym(int fileid, int cmd, \
				    _In_ struct kld_sym_lookup_c * __capability data); }
338	AUE_JAIL	STD	{ int cheriabi_jail( \
				    _In_ struct jail_c * __capability jailp); }
339	AUE_NULL	UNIMPL	nnpfs_syscall
340	AUE_SIGPROCMASK	STD	{ int cheriabi_sigprocmask(int how, \
				    _In_opt_ \
				    const sigset_t * __capability set, \
				    _Out_opt_ sigset_t * __capability oset); }
341	AUE_SIGSUSPEND	STD	{ int cheriabi_sigsuspend( \
				    _In_ const sigset_t * __capability sigmask); }
342	AUE_SIGACTION	OBSOL	sigaction
343	AUE_SIGPENDING	STD	{ int cheriabi_sigpending( \
				    _In_ sigset_t * __capability set); }
344	AUE_SIGRETURN	OBSOL	sigreturn
345	AUE_SIGWAIT	STD	{ int cheriabi_sigtimedwait( \
				    _In_ const sigset_t * __capability set, \
				    _Out_opt_ struct siginfo_c * __capability info, \
				    _In_opt_ const struct timespec * __capability timeout); }
346	AUE_NULL	STD	{ int cheriabi_sigwaitinfo( \
				    _In_ const sigset_t * __capability set, \
				    _Out_opt_ struct siginfo_c * __capability info); }
347	AUE_ACL_GET_FILE	STD	{ int cheriabi___acl_get_file( \
				    _In_z_ const char * __capability path, \
				    acl_type_t type, \
				    _Out_ struct acl * __capability aclp); }
348	AUE_ACL_SET_FILE	STD	{ int cheriabi___acl_set_file( \
				    _In_z_ const char * __capability path, \
				    acl_type_t type, \
				    _In_ struct acl * __capability aclp); }
349	AUE_ACL_GET_FD	STD	{ int cheriabi___acl_get_fd(int filedes, \
				    acl_type_t type, \
				    _Out_ struct acl * __capability aclp); }
350	AUE_ACL_SET_FD	STD	{ int cheriabi___acl_set_fd(int filedes, \
				    acl_type_t type, \
				    _In_ struct acl * __capability aclp); }
351	AUE_ACL_DELETE_FILE	STD	{ int cheriabi___acl_delete_file( \
				    _In_z_ const char * __capability path, \
				    acl_type_t type); }
352	AUE_ACL_DELETE_FD	NOPROTO	{ int __acl_delete_fd( \
				    int filedes, acl_type_t type); }
353	AUE_ACL_CHECK_FILE	STD	{ int cheriabi___acl_aclcheck_file( \
				    _In_z_ const char * __capability path, \
				    acl_type_t type, \
				    _In_ struct acl * __capability aclp); }
354	AUE_ACL_CHECK_FD	STD	{ int cheriabi___acl_aclcheck_fd( \
				    int filedes, acl_type_t type, \
				    _In_ struct acl * __capability aclp); }
355	AUE_EXTATTRCTL	STD	{ int cheriabi_extattrctl( \
				    _In_z_ const char * __capability path, \
				    int cmd, \
				    _In_z_opt_ \
				    const char * __capability filename, \
				    int attrnamespace, \
				    _In_z_ const char * __capability attrname); }
356	AUE_EXTATTR_SET_FILE	STD	{ ssize_t cheriabi_extattr_set_file( \
				    _In_z_ const char * __capability path, \
				    int attrnamespace, \
				    _In_z_ const char * __capability attrname, \
				    _In_reads_bytes_(nbytes) \
				    void * __capability data, \
				    size_t nbytes); }
357	AUE_EXTATTR_GET_FILE	STD	{ ssize_t cheriabi_extattr_get_file( \
				    _In_z_ const char * __capability path, \
				    int attrnamespace, \
				    _In_z_ const char * __capability attrname, \
				    _Out_writes_bytes_(nbytes) \
				    void * __capability data, \
				    size_t nbytes); }
358	AUE_EXTATTR_DELETE_FILE	STD	{ int cheriabi_extattr_delete_file( \
				    _In_z_ const char * __capability path, \
				    int attrnamespace, \
				    _In_z_ const char * __capability attrname); }
359	AUE_AIO_WAITCOMPLETE	STD	{ int cheriabi_aio_waitcomplete( \
				    _Outptr_result_maybenull_ \
				    struct aiocb_c * __capability * __capability aiocbp, \
				    _In_opt_ struct timespec * __capability timeout); }
360	AUE_GETRESUID	STD	{ int cheriabi_getresuid( \
				    _Out_opt_ uid_t * __capability ruid, \
				    _Out_opt_ uid_t * __capability euid, \
				    _Out_opt_ uid_t * __capability suid); }
361	AUE_GETRESGID	STD	{ int cheriabi_getresgid( \
				    _Out_opt_ gid_t * __capability rgid, \
				    _Out_opt_ gid_t * __capability egid, \
				    _Out_opt_ gid_t * __capability sgid); }
362	AUE_KQUEUE	NOPROTO	{ int kqueue(void); }
363	AUE_NULL	UNIMPL	kevent11
364	AUE_NULL	UNIMPL	__cap_get_proc
365	AUE_NULL	UNIMPL	__cap_set_proc
366	AUE_NULL	UNIMPL	__cap_get_fd
367	AUE_NULL	UNIMPL	__cap_get_file
368	AUE_NULL	UNIMPL	__cap_set_fd
369	AUE_NULL	UNIMPL	__cap_set_file
370	AUE_NULL	UNIMPL	nosys
371	AUE_EXTATTR_SET_FD	STD	{ ssize_t cheriabi_extattr_set_fd(\
				    int fd, int attrnamespace, \
				    _In_z_ const char * __capability attrname, \
				    _In_reads_bytes_(nbytes) \
				    void * __capability data, \
				    size_t nbytes); }
372	AUE_EXTATTR_GET_FD	STD	{ ssize_t cheriabi_extattr_get_fd(\
				    int fd, int attrnamespace, \
				    _In_z_ const char * __capability attrname, \
				    _Out_writes_bytes_(nbytes) \
				    void * __capability data, \
				    size_t nbytes); }
373	AUE_EXTATTR_DELETE_FD	STD	{ int cheriabi_extattr_delete_fd(\
				    int fd, int attrnamespace, \
				    _In_z_ const char * __capability attrname); }
374	AUE_SETUGID	NOPROTO	{ int __setugid(int flag); }
375	AUE_NULL	UNIMPL	nfsclnt
376	AUE_EACCESS	STD	{ int cheriabi_eaccess( \
				    _In_z_ char * __capability path, \
				    int amode); }
377	AUE_NULL	UNIMPL	afs3_syscall
378	AUE_NMOUNT	STD	{ int cheriabi_nmount( \
				    _In_reads_(iovcnt) \
				    struct iovec_c * __capability iovp, \
				    unsigned int iovcnt, int flags); }
379	AUE_NULL	OBSOL	kse_exit
380	AUE_NULL	OBSOL	kse_wakeup
381	AUE_NULL	OBSOL	kse_create
382	AUE_NULL	OBSOL	kse_thr_interrupt
383	AUE_NULL	OBSOL	kse_release
384	AUE_NULL	STD	{ int cheriabi___mac_get_proc( \
				    _In_ struct mac_c * __capability mac_p); }
385	AUE_NULL	STD	{ int cheriabi___mac_set_proc( \
				    _In_ struct mac_c * __capability mac_p); }
386	AUE_NULL	STD	{ int cheriabi___mac_get_fd(int fd, \
				    _In_ struct mac_c * __capability mac_p); }
387	AUE_NULL	STD	{ int cheriabi___mac_get_file( \
				    _In_z_ const char * __capability path_p, \
				    _In_ struct mac_c * __capability mac_p); }
388	AUE_NULL	STD	{ int cheriabi___mac_set_fd(int fd, \
				    _In_ struct mac_c * __capability mac_p); }
389	AUE_NULL	STD	{ int cheriabi___mac_set_file( \
				    _In_z_ const char * __capability path_p, \
				    _In_ struct mac_c * __capability mac_p); }
; XXX-BD: Required permissions on value depend on what.  _updates_ would
; cause failure in checks fail if a read-only capability was passed.
390	AUE_NULL	STD	{ int cheriabi_kenv(int what, \
				    _In_z_opt_ const char * __capability name, \
				    _Inout_updates_opt_(len) \
				    char * __capability value, int len); }
391	AUE_LCHFLAGS	STD	{ int cheriabi_lchflags( \
				    _In_z_ const char * __capability path, \
				    u_long flags); }
392	AUE_NULL	STD	{ int cheriabi_uuidgen( \
				    _Out_writes_(count) \
				    struct uuid * __capability store, \
				    int count); }
393	AUE_SENDFILE	STD	{ int cheriabi_sendfile(int fd, int s, \
				    off_t offset, \
				    size_t nbytes, \
				    _In_opt_ struct sf_hdtr_c * __capability hdtr, \
				    _Out_opt_ off_t * __capability sbytes, \
				    int flags); }
394	AUE_NULL	STD	{ int cheriabi_mac_syscall( \
				    _In_z_ const char * __capability policy, \
				    int call, \
				    _In_opt_ void * __capability arg); }
395	AUE_GETFSSTAT	OBSOL	fbsd11_getfsstat
396	AUE_STATFS	OBSOL	fbsd11_statfs
397	AUE_FSTATFS	OBSOL	fbsd11_ftatfs
398	AUE_FHSTATFS	OBSOL	fbsd11_fhstat
399	AUE_NULL	UNIMPL	nosys
400	AUE_SEMCLOSE	OBSOL	ksem_close
401	AUE_SEMPOST	OBSOL	ksem_post
402	AUE_SEMWAIT	OBSOL	ksem_wait
403	AUE_SEMTRYWAIT	OBSOL	ksem_trywait
404	AUE_SEMINIT	OBSOL	ksem_init
405	AUE_SEMOPEN	OBSOL	ksem_open
406	AUE_SEMUNLINK	OBSOL	ksem_unlink
407	AUE_SEMGETVALUE	OBSOL	ksem_getvalue
408	AUE_SEMDESTROY	OBSOL	ksem_destroy
409	AUE_NULL	STD	{ int cheriabi___mac_get_pid(pid_t pid, \
				    _In_ struct mac_c * __capability mac_p); }
410	AUE_NULL	STD	{ int cheriabi___mac_get_link( \
				    _In_z_ const char * __capability path_p, \
				    _In_ struct mac_c * __capability mac_p); }
411	AUE_NULL	STD	{ int cheriabi___mac_set_link( \
				    _In_z_ const char * __capability path_p, \
				    _In_ struct mac_c * __capability mac_p); }
412	AUE_EXTATTR_SET_LINK	STD	{ ssize_t cheriabi_extattr_set_link( \
				    _In_z_ const char * __capability path, \
				    int attrnamespace, \
				    _In_z_ const char * __capability attrname, \
				    _In_reads_bytes_(nbytes) \
				    void * __capability data, \
				    size_t nbytes); }
413	AUE_EXTATTR_GET_LINK	STD	{ ssize_t cheriabi_extattr_get_link( \
				    _In_z_ const char * __capability path, \
				    int attrnamespace, \
				    _In_z_ const char * __capability attrname, \
				    _Out_writes_bytes_(nbytes) \
				    void * __capability data, \
				    size_t nbytes); }
414	AUE_EXTATTR_DELETE_LINK	STD	{ int cheriabi_extattr_delete_link( \
				    _In_z_ const char * __capability path, \
				    int attrnamespace, \
				    _In_z_ const char * __capability attrname); }
415	AUE_NULL	STD|NOSTUB	{ int cheriabi___mac_execve( \
				    _In_z_ char * __capability fname, \
				    _In_ void * __capability * __capability argv, \
				    _In_ void * __capability * __capability envv, \
				    _In_ struct mac_c * __capability mac_p); }
416	AUE_SIGACTION	STD	{ int cheriabi_sigaction(int sig, \
				    _In_opt_ struct sigaction_c * __capability act, \
				    _Out_opt_ struct sigaction_c * __capability oact); }
417	AUE_SIGRETURN	STD	{ int cheriabi_sigreturn( \
				    _In_ const ucontext_c_t * __capability sigcntxp); }
418	AUE_NULL	UNIMPL	__xstat
419	AUE_NULL	UNIMPL	__xfstat
420	AUE_NULL	UNIMPL	__xlstat
421	AUE_NULL	STD	{ int cheriabi_getcontext( \
				    _Out_ ucontext_c_t * __capability ucp); }
422	AUE_NULL	STD	{ int cheriabi_setcontext( \
				    _In_ const ucontext_c_t * __capability ucp); }
423	AUE_NULL	STD	{ int cheriabi_swapcontext( \
				    _Out_ ucontext_c_t * __capability oucp, \
				    _In_ const ucontext_c_t * __capability ucp); }
424	AUE_SWAPOFF	STD	{ int cheriabi_swapoff( \
				    _In_z_ const char * __capability name); }
425	AUE_ACL_GET_LINK	STD	{ int cheriabi___acl_get_link( \
				    _In_z_ const char * __capability path, \
				    acl_type_t type, \
				    _Out_ struct acl * __capability aclp); }
426	AUE_ACL_SET_LINK	STD	{ int cheriabi___acl_set_link( \
				    _In_z_ const char * __capability path, \
				    acl_type_t type, \
				    _In_ struct acl * __capability aclp); }
427	AUE_ACL_DELETE_LINK	STD	{ int cheriabi___acl_delete_link( \
				    _In_z_ const char * __capability path, \
				    acl_type_t type); }
428	AUE_ACL_CHECK_LINK	STD	{ int cheriabi___acl_aclcheck_link( \
				    _In_z_ const char * __capability path, \
				    acl_type_t type, \
				    _In_ struct acl * __capability aclp); }
429	AUE_SIGWAIT	STD	{ int cheriabi_sigwait( \
				    _In_ const sigset_t * __capability set, \
				    _Out_ int * __capability sig); }
430	AUE_THR_CREATE	STD	{ int cheriabi_thr_create( \
				    _In_ ucontext_c_t * __capability ctx, \
				    _Out_ long * __capability id, int flags); }
431	AUE_THR_EXIT	STD|NOSTUB	{ void cheriabi_thr_exit( \
				    _Out_opt_ long * __capability state); }
432	AUE_NULL	STD	{ int cheriabi_thr_self( \
				    _Out_ long * __capability id); }
433	AUE_THR_KILL	NOPROTO	{ int thr_kill(long id, int sig); }
434	AUE_NULL	UNIMPL	nosys
435	AUE_NULL	UNIMPL	nosys
436	AUE_JAIL_ATTACH	NOPROTO	{ int jail_attach(int jid); }
437	AUE_EXTATTR_LIST_FD	STD	{ ssize_t cheriabi_extattr_list_fd(\
				    int fd, int attrnamespace, \
				    _Out_writes_bytes_opt_(nbytes) \
				    void * __capability data, \
				    size_t nbytes); }
438	AUE_EXTATTR_LIST_FILE	STD	{ ssize_t cheriabi_extattr_list_file( \
				    _In_z_ const char * __capability path, \
				    int attrnamespace, \
				    _Out_writes_bytes_opt_(nbytes) \
				    void * __capability data, size_t nbytes); }
439	AUE_EXTATTR_LIST_LINK	STD	{ ssize_t cheriabi_extattr_list_link( \
				    _In_z_ const char * __capability path, \
				    int attrnamespace, \
				    _Out_writes_bytes_opt_(nbytes) \
				    void * __capability data, size_t nbytes); }
440	AUE_NULL	OBSOL	kse_switchin
441	AUE_SEMWAIT	OBSOL	ksem_timedwait
442	AUE_NULL	STD	{ int cheriabi_thr_suspend( \
				    _In_opt_ \
				    const struct timespec * __capability timeout); }
443	AUE_NULL	NOPROTO	{ int thr_wake(long id); }
444	AUE_MODUNLOAD	NOPROTO	{ int kldunloadf(int fileid, int flags); }
445	AUE_AUDIT	STD	{ int cheriabi_audit( \
				    _In_reads_bytes_(length) \
				    const void * __capability record, \
				    u_int length); }
446	AUE_AUDITON	STD	{ int cheriabi_auditon(int cmd, \
				    _In_opt_ void * __capability data, \
				    u_int length); }
447	AUE_GETAUID	STD	{ int cheriabi_getauid( \
				    _Out_ uid_t * __capability auid); }
448	AUE_SETAUID	STD	{ int cheriabi_setauid( \
				    _In_ uid_t * __capability auid); }
449	AUE_GETAUDIT	STD	{ int cheriabi_getaudit( \
				    _Out_ struct auditinfo * __capability auditinfo); }
450	AUE_SETAUDIT	STD	{ int cheriabi_setaudit( \
				    _In_ struct auditinfo * __capability auditinfo); }
451	AUE_GETAUDIT_ADDR	STD	{ int cheriabi_getaudit_addr( \
				    _Out_writes_bytes_(length) \
				    struct auditinfo_addr * __capability auditinfo_addr, \
				    u_int length); }
452	AUE_SETAUDIT_ADDR	STD	{ int cheriabi_setaudit_addr( \
				    _In_reads_bytes_(length) \
				    struct auditinfo_addr * __capability auditinfo_addr, \
				    u_int length); }
453	AUE_AUDITCTL	STD	{ int cheriabi_auditctl( \
				    _In_z_ const char * __capability path); }
; XXX-BD: args pretty much unauditable
454	AUE_NULL	NOPROTO|NOPARSE	{ int _umtx_op(void *obj, int op,\
				    u_long val, void *uaddr1, \
				    void *uaddr2); }
455	AUE_THR_NEW	STD	{ int cheriabi_thr_new(	\
				    _In_ struct thr_param_c * __capability param, \
				    int param_size); }
456	AUE_NULL	STD	{ int cheriabi_sigqueue(pid_t pid, \
				    int signum, void * __capability value); }
457	AUE_MQ_OPEN	NOSTD	{ int cheriabi_kmq_open( \
				    _In_z_ const char * __capability path, \
				    int flags, mode_t mode, \
				    _In_opt_ const struct mq_attr * __capability attr); }
458	AUE_MQ_SETATTR	NOSTD	{ int cheriabi_kmq_setattr(int mqd, \
				    _In_opt_ const struct mq_attr * __capability attr, \
				    _Out_opt_ struct mq_attr * __capability oattr); }
459	AUE_MQ_TIMEDRECEIVE	NOSTD	{ int cheriabi_kmq_timedreceive( \
				    int mqd, \
				    _Out_writes_bytes_(msg_len) \
				    char * __capability msg_ptr, \
				    size_t msg_len, \
				    _Out_opt_ unsigned * __capability msg_prio, \
				    _In_opt_ \
				    const struct timespec * __capability abs_timeout); }
460	AUE_MQ_TIMEDSEND	NOSTD	{ int cheriabi_kmq_timedsend(int mqd, \
				    _In_reads_bytes_(msg_len) \
				    const char * __capability msg_ptr, \
				    size_t msg_len, unsigned msg_prio, \
				    _In_opt_ \
				    const struct timespec * __capability abs_timeout); }
461	AUE_MQ_NOTIFY	NOSTD	{ int cheriabi_kmq_notify(int mqd,	\
				    _In_opt_ const struct sigevent_c * __capability sigev); }
462	AUE_MQ_UNLINK	NOSTD	{ int cheriabi_kmq_unlink( \
				    _In_z_ const char * __capability path); }
463	AUE_NULL	STD|NOSTUB	{ void cheriabi_abort2( \
				    _In_z_ const char * __capability why, \
				    int nargs, \
				    _In_reads_(nargs) void * __capability * \
				    __capability args); }
464	AUE_NULL 	STD	{ int cheriabi_thr_set_name(long id, \
				    _In_z_ const char * __capability name); }
465	AUE_AIO_FSYNC	STD	{ int cheriabi_aio_fsync(int op, \
				    _Inout_ struct aiocb_c * __capability \
				    aiocbp); }
; XXX-BD: _In_ if RTP_SET, _Out_ if RTP_LOOKUP
466	AUE_RTPRIO	STD	{ int cheriabi_rtprio_thread(int function, \
				    lwpid_t lwpid, \
				    _Inout_ struct rtprio * __capability rtp); }
467	AUE_NULL	UNIMPL	nosys
468	AUE_NULL	UNIMPL	nosys
469	AUE_NULL	UNIMPL	__getpath_fromfd
470	AUE_NULL	UNIMPL	__getpath_fromaddr
471	AUE_SCTP_PEELOFF	NOPROTO|NOSTD	{ int sctp_peeloff(int sd, \
				     uint32_t name); }
; The sctp_generic_* syscall symbols are not exported from libc and thus
; stubs can not be generated.
472	AUE_SCTP_GENERIC_SENDMSG	NOSTD|NOSTUB	{ int cheriabi_sctp_generic_sendmsg( \
				    int sd, \
				    _In_reads_bytes_(mlen) void * __capability msg, \
				    int mlen, \
				    _In_reads_bytes_(tolen) \
				    struct sockaddr * __capability to, \
				    __socklen_t tolen, \
				    _In_opt_ struct sctp_sndrcvinfo * __capability sinfo, \
				    int flags); }
473	AUE_SCTP_GENERIC_SENDMSG_IOV	NOSTD|NOSTUB	{ int cheriabi_sctp_generic_sendmsg_iov( \
				    int sd, \
				    _In_reads_(iovlen) struct iovec_c * __capability iov, \
				    int iovlen, \
				    _In_reads_bytes_(tolen) \
				    struct sockaddr * __capability to, \
				    __socklen_t tolen, \
				    _In_opt_ struct sctp_sndrcvinfo * __capability sinfo, \
				    int flags); }
474	AUE_SCTP_GENERIC_RECVMSG	NOSTD|NOSTUB	{ int cheriabi_sctp_generic_recvmsg( \
				    int sd, \
				    _In_reads_(iovlen) struct iovec_c * __capability iov, \
				    int iovlen, \
				    _Out_writes_bytes_(*fromlenaddr) \
				    struct sockaddr * __capability from, \
				    _Out_ __socklen_t * __capability fromlenaddr, \
				    _In_opt_ struct sctp_sndrcvinfo * __capability sinfo, \
				    _Out_opt_ int * __capability msg_flags); }
475	AUE_PREAD	STD	{ ssize_t cheriabi_pread(int fd, \
				    _Out_writes_bytes_(nbyte) \
				    void * __capability buf, \
				    size_t nbyte, off_t offset); }
476	AUE_PWRITE	STD	{ ssize_t cheriabi_pwrite(int fd, \
				    _Out_writes_bytes_(nbyte) \
				    const void * __capability buf, \
				    size_t nbyte, off_t offset); }
477	AUE_MMAP	STD { void *cheriabi_mmap( \
				    _Pagerange_vmmap_opt_(len) void * __capability addr, \
				    size_t len, int prot, int flags, int fd, \
				    off_t pos); }
478	AUE_LSEEK	NOPROTO	{ off_t lseek(int fd, off_t offset, \
				    int whence); }
479	AUE_TRUNCATE	STD	{ int cheriabi_truncate( \
				    _In_z_ const char * __capability path, \
				    off_t length); }
480	AUE_FTRUNCATE	NOPROTO	{ int ftruncate(int fd, off_t length); }
481	AUE_THR_KILL2	NOPROTO	{ int thr_kill2(pid_t pid, long id, int sig); }
482	AUE_SHMOPEN	STD	{ int cheriabi_shm_open( \
				    _In_z_ const char * __capability path, \
				    int flags, mode_t mode); }
483	AUE_SHMUNLINK	STD	{ int cheriabi_shm_unlink( \
				    _In_z_ const char * __capability path); }
484	AUE_NULL	STD	{ int cheriabi_cpuset( \
				    _Out_ cpusetid_t * __capability setid); }
485	AUE_NULL	NOPROTO	{ int cpuset_setid(cpuwhich_t which, \
				    id_t id, cpusetid_t setid); }
486	AUE_NULL	STD	{ int cheriabi_cpuset_getid(cpulevel_t level, \
				    cpuwhich_t which, id_t id, \
				    _Out_ cpusetid_t * __capability setid); }
487	AUE_NULL	STD	{ int cheriabi_cpuset_getaffinity( \
				    cpulevel_t level, cpuwhich_t which, \
				    id_t id, size_t cpusetsize, \
				    _Out_ cpuset_t * __capability mask); }
488	AUE_NULL	STD	{ int cheriabi_cpuset_setaffinity( \
				    cpulevel_t level, cpuwhich_t which, \
				    id_t id, size_t cpusetsize, \
				    _Out_ const cpuset_t * __capability mask); }
489	AUE_FACCESSAT	STD	{ int cheriabi_faccessat(int fd, \
				    _In_z_ const char * __capability path, \
				    int amode, int flag); }
490	AUE_FCHMODAT	STD	{ int cheriabi_fchmodat(int fd, \
				    _In_z_ const char * __capability path, \
				    mode_t mode, int flag); }
491	AUE_FCHOWNAT	STD	{ int cheriabi_fchownat(int fd, \
				    _In_z_ const char * __capability path, \
				    uid_t uid, gid_t gid, int flag); }
492	AUE_FEXECVE	STD|NOSTUB	{ int cheriabi_fexecve(int fd, \
				    _In_ void * __capability * __capability argv, \
				    _In_ void * __capability * __capability envv); }
493	AUE_FSTATAT	OBSOL	fbsd11_fstatat
494	AUE_FUTIMESAT	STD	{ int cheriabi_futimesat(int fd, \
				    _In_z_ const char * __capability path, \
				    _In_reads_(2) \
				    const struct timeval * __capability times); }
495	AUE_LINKAT	STD	{ int cheriabi_linkat(int fd1, \
				    _In_z_ const char * __capability path1, \
				    int fd2, \
				    _In_z_ const char * __capability path2, \
				    int flag); }
496	AUE_MKDIRAT	STD	{ int cheriabi_mkdirat(int fd, \
				    _In_z_ const char * __capability path, \
				    mode_t mode); }
497	AUE_MKFIFOAT	STD	{ int cheriabi_mkfifoat(int fd, \
				    _In_z_ const char * __capability path, \
				    mode_t mode); }
498	AUE_MKNODAT	OBSOL	fbsd11_mknodat
499	AUE_OPENAT_RWTC	STD|VARARG	{ int cheriabi_openat(int fd, \
				    _In_z_ const char * __capability path, \
				    int flag, mode_t mode); }
500	AUE_READLINKAT	STD	{ int cheriabi_readlinkat(int fd, \
				    _In_z_ const char * __capability path, \
				    _Out_writes_bytes_(bufsize) \
				    char * __capability buf, \
				    size_t bufsize); }
501	AUE_RENAMEAT	STD	{ int cheriabi_renameat(int oldfd, \
				    _In_z_ const char * __capability old, \
				    int newfd, \
				    _In_z_ const char * __capability new); }
502	AUE_SYMLINKAT	STD	{ int cheriabi_symlinkat( \
				    _In_z_ const char * __capability path1, \
				    int fd, \
				    _In_z_ const char * __capability path2); }
503	AUE_UNLINKAT	STD	{ int cheriabi_unlinkat(int fd, \
				    _In_z_ const char * __capability path, \
				    int flag); }
504	AUE_POSIX_OPENPT	NOPROTO	{ int posix_openpt(int flags); }
; 505 is initialised by the kgssapi code, if present.
505	AUE_NULL	NOSTD	{ int cheriabi_gssd_syscall( \
				    _In_z_ const char * __capability path); }
506	AUE_JAIL_GET	STD	{ int cheriabi_jail_get(_In_reads_(iovcnt) \
				    struct iovec_c * __capability iovp, \
				    unsigned int iovcnt, int flags); }
507	AUE_JAIL_SET	STD	{ int cheriabi_jail_set(_In_reads_(iovcnt) \
				    struct iovec_c * __capability iovp, \
				    unsigned int iovcnt, int flags); }
508	AUE_JAIL_REMOVE	NOPROTO	{ int jail_remove(int jid); }
509	AUE_CLOSEFROM	NOPROTO	{ int closefrom(int lowfd); }
510	AUE_SEMCTL	NOSTD { int cheriabi___semctl(int semid, int semnum, \
				    int cmd, \
				    union semun_c * __capability arg); }
; XXX-BD: technically IPC_SET doesn't require _Out_ permissions
511	AUE_MSGCTL	NOSTD { int cheriabi_msgctl(int msqid, int cmd, \
				    _Inout_opt_ \
				    struct msqid_ds_c * __capability buf); }
; XXX: technically buf is sometimes _In_ and sometimes _Out_
512	AUE_SHMCTL	NOSTD	{ int cheriabi_shmctl(int shmid, int cmd, \
				    _Inout_opt_ \
				    struct shmid_ds * __capability buf); }
513	AUE_LPATHCONF	STD	{ int cheriabi_lpathconf( \
				    _In_z_ const char * __capability path, \
				    int name); }
514	AUE_NULL	OBSOL	cap_new
515	AUE_CAP_RIGHTS_GET	STD	{ int cheriabi___cap_rights_get( \
				    int version, \
				    int fd, \
				    _Out_ cap_rights_t * __capability rightsp); }
516	AUE_CAP_ENTER	NOPROTO	{ int cap_enter(void); }
517	AUE_CAP_GETMODE	STD	{ int cheriabi_cap_getmode( \
				    _Out_ u_int * __capability modep); }
518	AUE_PDFORK	STD	{ int cheriabi_pdfork( \
				    _Out_ int * __capability fdp, int flags); }
519	AUE_PDKILL	NOPROTO	{ int pdkill(int fd, int signum); }
520	AUE_PDGETPID	STD	{ int cheriabi_pdgetpid(int fd, \
				    _Out_ pid_t * __capability pidp); }
521	AUE_PDWAIT	UNIMPL	pdwait4
522	AUE_SELECT	STD	{ int cheriabi_pselect(int nd, \
				    _Inout_opt_ fd_set * __capability in, \
				    _Inout_opt_ fd_set * __capability ou, \
				    _Inout_opt_ fd_set * __capability ex, \
				    _In_opt_ \
				    const struct timespec * __capability ts, \
				    _In_opt_ \
				    const sigset_t * __capability sm); }
523	AUE_GETLOGINCLASS	STD	{ int cheriabi_getloginclass( \
				    _Out_writes_z_(namelen) \
				    char * __capability namebuf, \
				    size_t namelen); }
524	AUE_SETLOGINCLASS	STD	{ int cheriabi_setloginclass( \
				    _In_z_ const char * __capability namebuf); }
525	AUE_NULL	STD	{ int cheriabi_rctl_get_racct( \
				    _In_reads_bytes_(inbuflen) \
				    const void * __capability inbufp, \
				    size_t inbuflen, \
				    _Out_writes_bytes_(outbuflen) \
				    void * __capability outbufp, \
				    size_t outbuflen); }
526	AUE_NULL	STD	{ int cheriabi_rctl_get_rules( \
				    _In_reads_bytes_(inbuflen) \
				    const void * __capability inbufp, \
				    size_t inbuflen, \
				    _Out_writes_bytes_(outbuflen) \
				    void * __capability outbufp, \
				    size_t outbuflen); }
527	AUE_NULL	STD	{ int cheriabi_rctl_get_limits( \
				    _In_reads_bytes_(inbuflen) \
				    const void * __capability inbufp, \
				    size_t inbuflen, \
				    _Out_writes_bytes_(outbuflen) \
				    void * __capability outbufp, \
				    size_t outbuflen); }
528	AUE_NULL	STD	{ int cheriabi_rctl_add_rule( \
				    _In_reads_bytes_(inbuflen) \
				    const void * __capability inbufp, \
				    size_t inbuflen, \
				    _Out_writes_bytes_(outbuflen) \
				    void * __capability outbufp, \
				    size_t outbuflen); }
529	AUE_NULL	STD	{ int cheriabi_rctl_remove_rule( \
				    _In_reads_bytes_(inbuflen) \
				    const void * __capability inbufp, \
				    size_t inbuflen, \
				    _Out_writes_bytes_(outbuflen) \
				    void * __capability outbufp, \
				    size_t outbuflen); }
530	AUE_POSIX_FALLOCATE	NOPROTO	{ int posix_fallocate(int fd,\
				    off_t offset, off_t len); }
531	AUE_POSIX_FADVISE	NOPROTO	{ int posix_fadvise(int fd, \
				    off_t offset, off_t len, int advice); }
532	AUE_WAIT6	STD	{ int cheriabi_wait6(int idtype, id_t id, \
				    _Out_opt_ int * __capability status, \
				    int options, \
				    _Out_opt_ \
				    struct __wrusage * __capability wrusage, \
				    _Out_opt_ \
				    struct siginfo_c * __capability info); }
533	AUE_CAP_RIGHTS_LIMIT	STD	{ \
				    int cheriabi_cap_rights_limit(int fd, \
				    _In_ cap_rights_t * __capability rightsp); }
534	AUE_CAP_IOCTLS_LIMIT	STD	{ \
				    int cheriabi_cap_ioctls_limit(int fd, \
				    _In_reads_(ncmds) \
				    const u_long * __capability cmds, \
				    size_t ncmds); }
535	AUE_CAP_IOCTLS_GET	STD	{ \
				    ssize_t cheriabi_cap_ioctls_get(int fd, \
				    _Out_writes_(maxcmds) \
				    u_long * __capability cmds, \
				    size_t maxcmds); }
536	AUE_CAP_FCNTLS_LIMIT	NOPROTO	{ int cap_fcntls_limit(int fd, \
				    uint32_t fcntlrights); }
537	AUE_CAP_FCNTLS_GET	STD	{ int cheriabi_cap_fcntls_get(int fd, \
				    _Out_ uint32_t * __capability fcntlrightsp); }
538	AUE_BINDAT	STD	{ int cheriabi_bindat(int fd, int s, \
				    _In_reads_bytes_(namelen) \
				    const struct sockaddr * __capability name, \
				    __socklen_t namelen); }
539	AUE_CONNECTAT	STD	{ int cheriabi_connectat(int fd, int s, \
				    _In_reads_bytes_(namelen) \
				    const struct sockaddr * __capability name, \
				    __socklen_t namelen); }
540	AUE_CHFLAGSAT	STD	{ int cheriabi_chflagsat(int fd, \
				    _In_z_ const char * __capability path, \
				    u_long flags, int atflag); }
541	AUE_ACCEPT	STD	{ int cheriabi_accept4(int s, \
				    _Out_writes_bytes_opt_(*anamelen) \
				    struct sockaddr * __restrict __capability name, \
				    _Inout_opt_ \
				    __socklen_t * __restrict __capability anamelen, \
				    int flags); }
542	AUE_PIPE	STD	{ int cheriabi_pipe2( \
				    _Out_writes_(2) int * __capability fildes, \
				    int flags); }
543	AUE_AIO_MLOCK	STD	{ int cheriabi_aio_mlock( \
				    _Inout_ struct aiocb_c * __capability \
				    aiocbp); }
544	AUE_PROCCTL	STD	{ int cheriabi_procctl(int idtype, \
				    id_t id, int com, \
				    void * __capability data); }
545	AUE_POLL	STD	{ int cheriabi_ppoll( \
				    _Inout_updates_(nfds) \
				    struct pollfd * __capability fds, \
				    u_int nfds, \
				    _In_opt_ \
				    const struct timespec * __capability ts, \
				    _In_opt_ const sigset_t * __capability set); }
546	AUE_FUTIMES	STD	{ int cheriabi_futimens(int fd, \
				    _In_reads_(2) \
				    const struct timespec * __capability \
				    times); }
547	AUE_FUTIMESAT	STD	{ int cheriabi_utimensat(int fd, \
				    _In_z_ const char * __capability path, \
				    _In_reads_(2) \
				    const struct timespec * __capability times, \
				    int flag); }
548	AUE_NULL	UNIMPL	freebsd11_numa_getaffinity
549	AUE_NULL	UNIMPL	freebsd11_numa_setaffinity
550	AUE_FSYNC	NOPROTO	{ int fdatasync(int fd); }
551	AUE_FSTAT	STD	{ int cheriabi_fstat(int fd, \
				    _Out_ struct stat * __capability sb); }
552	AUE_FSTATAT	STD	{ int cheriabi_fstatat(int fd, \
				    _In_z_ const char * __capability path, \
                                    _Out_ struct stat * __capability buf, \
				    int flag); }
553	AUE_FHSTAT	STD	{ int cheriabi_fhstat( \
				    _In_ const struct fhandle * __capability u_fhp, \
                                    _Out_ struct stat * __capability sb); }
554	AUE_GETDIRENTRIES STD { ssize_t cheriabi_getdirentries(int fd, \
				    _Out_writes_bytes_(count) \
				    char * __capability buf, \
                                    size_t count, \
				    _Out_ off_t * __capability basep); }
555	AUE_STATFS	STD	{ int cheriabi_statfs( \
				    _In_z_ char * __capability path, \
				    _Out_ struct statfs * __capability buf); }
556	AUE_FSTATFS	STD	{ int cheriabi_fstatfs(int fd, \
				    _Out_ struct statfs * __capability buf); }
557	AUE_GETFSSTAT	STD	{ int cheriabi_getfsstat( \
				    _Out_writes_bytes_opt_(bufsize) \
				    struct statfs * __capability buf, \
                                    long bufsize, int mode); }
558	AUE_FHSTATFS	STD	{ int cheriabi_fhstatfs( \
				    _In_ const struct fhandle * __capability u_fhp, \
                                    _Out_ struct statfs * __capability buf); }
559	AUE_MKNODAT	STD	{ int cheriabi_mknodat(int fd, \
				    _In_z_ const char * __capability path, \
				    mode_t mode, dev_t dev); }
560	AUE_KEVENT	STD	{ int cheriabi_kevent(int fd, \
				    _In_reads_opt_(nchanges) \
				    const struct kevent_c * __capability changelist, \
				    int nchanges, \
				    _In_reads_opt_(nevents) \
				    struct kevent_c * __capability eventlist, \
				    int nevents, \
				    _In_opt_ const struct timespec * __capability timeout); }
