/*-
 *   BSD LICENSE
 *
 *   Copyright (c) 2016 Broadcom, All Rights Reserved.
 *   The term Broadcom refers to Broadcom Limited and/or its subsidiaries
 *
 *   Redistribution and use in source and binary forms, with or without
 *   modification, are permitted provided that the following conditions
 *   are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in
 *       the documentation and/or other materials provided with the
 *       distribution.
 *
 *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 *   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 *   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 *   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 *   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 *   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/cdefs.h>
__FBSDID("$FreeBSD$");

/*
 * Copyright(c) 2001-2021, Broadcom. All rights reserved. The
 * term Broadcom refers to Broadcom Inc. and/or its subsidiaries.
 * Proprietary and Confidential Information.
 *
 * This source file is the property of Broadcom Corporation, and
 * may not be copied or distributed in any isomorphic form without
 * the prior written consent of Broadcom Corporation.
 *
 * DO NOT MODIFY!!! This file is automatically generated.
 */

#ifndef _HSI_STRUCT_DEF_EXTERNAL_H_
#define _HSI_STRUCT_DEF_EXTERNAL_H_

/* This is the HWRM command header. */
/* hwrm_cmd_hdr (size:128b/16B) */

typedef struct hwrm_cmd_hdr {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
} hwrm_cmd_hdr_t, *phwrm_cmd_hdr_t;

/* This is the HWRM response header. */
/* hwrm_resp_hdr (size:64b/8B) */

typedef struct hwrm_resp_hdr {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
} hwrm_resp_hdr_t, *phwrm_resp_hdr_t;

/*
 * TLV encapsulated message. Use the TLV type field of the
 * TLV to determine the type of message encapsulated.
 */
#define CMD_DISCR_TLV_ENCAP UINT32_C(0x8000)
#define CMD_DISCR_LAST	CMD_DISCR_TLV_ENCAP


/* HWRM request message */
#define TLV_TYPE_HWRM_REQUEST			UINT32_C(0x1)
/* HWRM response message */
#define TLV_TYPE_HWRM_RESPONSE		UINT32_C(0x2)
/* RoCE slow path command */
#define TLV_TYPE_ROCE_SP_COMMAND		UINT32_C(0x3)
/* RoCE slow path command to query CC Gen1 support. */
#define TLV_TYPE_QUERY_ROCE_CC_GEN1		UINT32_C(0x4)
/* RoCE slow path command to modify CC Gen1 support. */
#define TLV_TYPE_MODIFY_ROCE_CC_GEN1		UINT32_C(0x5)
/* Engine CKV - The Alias key EC curve and ECC public key information. */
#define TLV_TYPE_ENGINE_CKV_ALIAS_ECC_PUBLIC_KEY UINT32_C(0x8001)
/* Engine CKV - Initialization vector. */
#define TLV_TYPE_ENGINE_CKV_IV		UINT32_C(0x8003)
/* Engine CKV - Authentication tag. */
#define TLV_TYPE_ENGINE_CKV_AUTH_TAG		UINT32_C(0x8004)
/* Engine CKV - The encrypted data. */
#define TLV_TYPE_ENGINE_CKV_CIPHERTEXT	UINT32_C(0x8005)
/* Engine CKV - Supported host_algorithms. */
#define TLV_TYPE_ENGINE_CKV_HOST_ALGORITHMS	UINT32_C(0x8006)
/* Engine CKV - The Host EC curve name and ECC public key information. */
#define TLV_TYPE_ENGINE_CKV_HOST_ECC_PUBLIC_KEY  UINT32_C(0x8007)
/* Engine CKV - The ECDSA signature. */
#define TLV_TYPE_ENGINE_CKV_ECDSA_SIGNATURE	UINT32_C(0x8008)
/* Engine CKV - The firmware EC curve name and ECC public key information. */
#define TLV_TYPE_ENGINE_CKV_FW_ECC_PUBLIC_KEY	UINT32_C(0x8009)
/* Engine CKV - Supported firmware algorithms. */
#define TLV_TYPE_ENGINE_CKV_FW_ALGORITHMS	UINT32_C(0x800a)
#define TLV_TYPE_LAST			TLV_TYPE_ENGINE_CKV_FW_ALGORITHMS


/* tlv (size:64b/8B) */

typedef struct tlv {
	/*
	 * The command discriminator is used to differentiate between various
	 * types of HWRM messages. This includes legacy HWRM and RoCE slowpath
	 * command messages as well as newer TLV encapsulated HWRM commands.
	 *
	 * For TLV encapsulated messages this field must be 0x8000.
	 */
	uint16_t	cmd_discr;
	uint8_t	reserved_8b;
	uint8_t	flags;
	/*
	 * Indicates the presence of additional TLV encapsulated data
	 * follows this TLV.
	 */
	#define TLV_FLAGS_MORE	UINT32_C(0x1)
	/* Last TLV in a sequence of TLVs. */
		#define TLV_FLAGS_MORE_LAST	UINT32_C(0x0)
	/* More TLVs follow this TLV. */
		#define TLV_FLAGS_MORE_NOT_LAST  UINT32_C(0x1)
	/*
	 * When an HWRM receiver detects a TLV type that it does not
	 * support with the TLV required flag set, the receiver must
	 * reject the HWRM message with an error code indicating an
	 * unsupported TLV type.
	 */
	#define TLV_FLAGS_REQUIRED	UINT32_C(0x2)
	/* No */
		#define TLV_FLAGS_REQUIRED_NO	(UINT32_C(0x0) << 1)
	/* Yes */
		#define TLV_FLAGS_REQUIRED_YES   (UINT32_C(0x1) << 1)
		#define TLV_FLAGS_REQUIRED_LAST TLV_FLAGS_REQUIRED_YES
	/*
	 * This field defines the TLV type value which is divided into
	 * two ranges to differentiate between global and local TLV types.
	 * Global TLV types must be unique across all defined TLV types.
	 * Local TLV types are valid only for extensions to a given
	 * HWRM message and may be repeated across different HWRM message
	 * types. There is a direct correlation of each HWRM message type
	 * to a single global TLV type value.
	 *
	 * Global TLV range: `0 - (63k-1)`
	 *
	 * Local TLV range: `63k - (64k-1)`
	 */
	uint16_t	tlv_type;
	/*
	 * Length of the message data encapsulated by this TLV in bytes.
	 * This length does not include the size of the TLV header itself
	 * and it must be an integer multiple of 8B.
	 */
	uint16_t	length;
} tlv_t, *ptlv_t;

/* Input */
/* input (size:128b/16B) */

typedef struct input {
	/*
	 * This value indicates what type of request this is.  The format
	 * for the rest of the command is determined by this field.
	 */
	uint16_t	req_type;
	/*
	 * This value indicates the what completion ring the request will
	 * be optionally completed on.  If the value is -1, then no
	 * CR completion will be generated.  Any other value must be a
	 * valid CR ring_id value for this function.
	 */
	uint16_t	cmpl_ring;
	/* This value indicates the command sequence number. */
	uint16_t	seq_id;
	/*
	 * Target ID of this command.
	 *
	 * 0x0 - 0xFFF8 - Used for function ids
	 * 0xFFF8 - 0xFFFE - Reserved for internal processors
	 * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * This is the host address where the response will be written
	 * when the request is complete.  This area must be 16B aligned
	 * and must be cleared to zero before the request is made.
	 */
	uint64_t	resp_addr;
} input_t, *pinput_t;

/* Output */
/* output (size:64b/8B) */

typedef struct output {
	/*
	 * Pass/Fail or error type
	 *
	 * Note: receiver to verify the in parameters, and fail the call
	 * with an error when appropriate
	 */
	uint16_t	error_code;
	/* This field returns the type of original request. */
	uint16_t	req_type;
	/* This field provides original sequence number of the command. */
	uint16_t	seq_id;
	/*
	 * This field is the length of the response in bytes.  The
	 * last byte of the response is a valid flag that will read
	 * as '1' when the command has been completely written to
	 * memory.
	 */
	uint16_t	resp_len;
} output_t, *poutput_t;

/* Short Command Structure */
/* hwrm_short_input (size:128b/16B) */

typedef struct hwrm_short_input {
	/*
	 * This field indicates the type of request in the request buffer.
	 * The format for the rest of the command (request) is determined
	 * by this field.
	 */
	uint16_t	req_type;
	/*
	 * This field indicates a signature that is used to identify short
	 * form of the command listed here. This field shall be set to
	 * 17185 (0x4321).
	 */
	uint16_t	signature;
	/* Signature indicating this is a short form of HWRM command */
	#define HWRM_SHORT_INPUT_SIGNATURE_SHORT_CMD UINT32_C(0x4321)
	#define HWRM_SHORT_INPUT_SIGNATURE_LAST	HWRM_SHORT_INPUT_SIGNATURE_SHORT_CMD
	/* The target ID of the command */
	uint16_t	target_id;
	/* Default target_id (0x0) to maintain compatibility with old driver */
	#define HWRM_SHORT_INPUT_TARGET_ID_DEFAULT UINT32_C(0x0)
	/* Reserved for user-space HWRM interface */
	#define HWRM_SHORT_INPUT_TARGET_ID_TOOLS   UINT32_C(0xfffd)
	#define HWRM_SHORT_INPUT_TARGET_ID_LAST   HWRM_SHORT_INPUT_TARGET_ID_TOOLS
	/* This value indicates the length of the request. */
	uint16_t	size;
	/*
	 * This is the host address where the request was written.
	 * This area must be 16B aligned.
	 */
	uint64_t	req_addr;
} hwrm_short_input_t, *phwrm_short_input_t;

#define GET_HWRM_REQ_TYPE(x) \
	(((x) < 0x80) ? \
	((x) == 0x0 ? "HWRM_VER_GET": \
	((x) == 0xb ? "HWRM_FUNC_ECHO_RESPONSE": \
	((x) == 0xc ? "HWRM_ERROR_RECOVERY_QCFG": \
	((x) == 0xd ? "HWRM_FUNC_DRV_IF_CHANGE": \
	((x) == 0xe ? "HWRM_FUNC_BUF_UNRGTR": \
	((x) == 0xf ? "HWRM_FUNC_VF_CFG": \
	((x) == 0x10 ? "HWRM_RESERVED1": \
	((x) == 0x11 ? "HWRM_FUNC_RESET": \
	((x) == 0x12 ? "HWRM_FUNC_GETFID": \
	((x) == 0x13 ? "HWRM_FUNC_VF_ALLOC": \
	((x) == 0x14 ? "HWRM_FUNC_VF_FREE": \
	((x) == 0x15 ? "HWRM_FUNC_QCAPS": \
	((x) == 0x16 ? "HWRM_FUNC_QCFG": \
	((x) == 0x17 ? "HWRM_FUNC_CFG": \
	((x) == 0x18 ? "HWRM_FUNC_QSTATS": \
	((x) == 0x19 ? "HWRM_FUNC_CLR_STATS": \
	((x) == 0x1a ? "HWRM_FUNC_DRV_UNRGTR": \
	((x) == 0x1b ? "HWRM_FUNC_VF_RESC_FREE": \
	((x) == 0x1c ? "HWRM_FUNC_VF_VNIC_IDS_QUERY": \
	((x) == 0x1d ? "HWRM_FUNC_DRV_RGTR": \
	((x) == 0x1e ? "HWRM_FUNC_DRV_QVER": \
	((x) == 0x1f ? "HWRM_FUNC_BUF_RGTR": \
	((x) == 0x20 ? "HWRM_PORT_PHY_CFG": \
	((x) == 0x21 ? "HWRM_PORT_MAC_CFG": \
	((x) == 0x22 ? "HWRM_PORT_TS_QUERY": \
	((x) == 0x23 ? "HWRM_PORT_QSTATS": \
	((x) == 0x24 ? "HWRM_PORT_LPBK_QSTATS": \
	((x) == 0x25 ? "HWRM_PORT_CLR_STATS": \
	((x) == 0x26 ? "HWRM_PORT_LPBK_CLR_STATS": \
	((x) == 0x27 ? "HWRM_PORT_PHY_QCFG": \
	((x) == 0x28 ? "HWRM_PORT_MAC_QCFG": \
	((x) == 0x29 ? "HWRM_PORT_MAC_PTP_QCFG": \
	((x) == 0x2a ? "HWRM_PORT_PHY_QCAPS": \
	((x) == 0x2b ? "HWRM_PORT_PHY_I2C_WRITE": \
	((x) == 0x2c ? "HWRM_PORT_PHY_I2C_READ": \
	((x) == 0x2d ? "HWRM_PORT_LED_CFG": \
	((x) == 0x2e ? "HWRM_PORT_LED_QCFG": \
	((x) == 0x2f ? "HWRM_PORT_LED_QCAPS": \
	((x) == 0x30 ? "HWRM_QUEUE_QPORTCFG": \
	((x) == 0x31 ? "HWRM_QUEUE_QCFG": \
	((x) == 0x32 ? "HWRM_QUEUE_CFG": \
	((x) == 0x33 ? "HWRM_FUNC_VLAN_CFG": \
	((x) == 0x34 ? "HWRM_FUNC_VLAN_QCFG": \
	((x) == 0x35 ? "HWRM_QUEUE_PFCENABLE_QCFG": \
	((x) == 0x36 ? "HWRM_QUEUE_PFCENABLE_CFG": \
	((x) == 0x37 ? "HWRM_QUEUE_PRI2COS_QCFG": \
	((x) == 0x38 ? "HWRM_QUEUE_PRI2COS_CFG": \
	((x) == 0x39 ? "HWRM_QUEUE_COS2BW_QCFG": \
	((x) == 0x3a ? "HWRM_QUEUE_COS2BW_CFG": \
	((x) == 0x3b ? "HWRM_QUEUE_DSCP_QCAPS": \
	((x) == 0x3c ? "HWRM_QUEUE_DSCP2PRI_QCFG": \
	((x) == 0x3d ? "HWRM_QUEUE_DSCP2PRI_CFG": \
	((x) == 0x40 ? "HWRM_VNIC_ALLOC": \
	((x) == 0x41 ? "HWRM_VNIC_FREE": \
	((x) == 0x42 ? "HWRM_VNIC_CFG": \
	((x) == 0x43 ? "HWRM_VNIC_QCFG": \
	((x) == 0x44 ? "HWRM_VNIC_TPA_CFG": \
	((x) == 0x45 ? "HWRM_VNIC_TPA_QCFG": \
	((x) == 0x46 ? "HWRM_VNIC_RSS_CFG": \
	((x) == 0x47 ? "HWRM_VNIC_RSS_QCFG": \
	((x) == 0x48 ? "HWRM_VNIC_PLCMODES_CFG": \
	((x) == 0x49 ? "HWRM_VNIC_PLCMODES_QCFG": \
	((x) == 0x4a ? "HWRM_VNIC_QCAPS": \
	((x) == 0x4b ? "HWRM_VNIC_UPDATE": \
	((x) == 0x50 ? "HWRM_RING_ALLOC": \
	((x) == 0x51 ? "HWRM_RING_FREE": \
	((x) == 0x52 ? "HWRM_RING_CMPL_RING_QAGGINT_PARAMS": \
	((x) == 0x53 ? "HWRM_RING_CMPL_RING_CFG_AGGINT_PARAMS": \
	((x) == 0x54 ? "HWRM_RING_AGGINT_QCAPS": \
	((x) == 0x55 ? "HWRM_RING_SCHQ_ALLOC": \
	((x) == 0x56 ? "HWRM_RING_SCHQ_CFG": \
	((x) == 0x57 ? "HWRM_RING_SCHQ_FREE": \
	((x) == 0x5e ? "HWRM_RING_RESET": \
	((x) == 0x60 ? "HWRM_RING_GRP_ALLOC": \
	((x) == 0x61 ? "HWRM_RING_GRP_FREE": \
	((x) == 0x62 ? "HWRM_RING_CFG": \
	((x) == 0x63 ? "HWRM_RING_QCFG": \
	((x) == 0x64 ? "HWRM_RESERVED5": \
	((x) == 0x65 ? "HWRM_RESERVED6": \
	((x) == 0x70 ? "HWRM_VNIC_RSS_COS_LB_CTX_ALLOC": \
	((x) == 0x71 ? "HWRM_VNIC_RSS_COS_LB_CTX_FREE": \
	"Unknown decode" ))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))) : \
	(((x) < 0x100) ? \
	((x) == 0x80 ? "HWRM_QUEUE_MPLS_QCAPS": \
	((x) == 0x81 ? "HWRM_QUEUE_MPLSTC2PRI_QCFG": \
	((x) == 0x82 ? "HWRM_QUEUE_MPLSTC2PRI_CFG": \
	((x) == 0x83 ? "HWRM_QUEUE_VLANPRI_QCAPS": \
	((x) == 0x84 ? "HWRM_QUEUE_VLANPRI2PRI_QCFG": \
	((x) == 0x85 ? "HWRM_QUEUE_VLANPRI2PRI_CFG": \
	((x) == 0x86 ? "HWRM_QUEUE_GLOBAL_CFG": \
	((x) == 0x87 ? "HWRM_QUEUE_GLOBAL_QCFG": \
	((x) == 0x90 ? "HWRM_CFA_L2_FILTER_ALLOC": \
	((x) == 0x91 ? "HWRM_CFA_L2_FILTER_FREE": \
	((x) == 0x92 ? "HWRM_CFA_L2_FILTER_CFG": \
	((x) == 0x93 ? "HWRM_CFA_L2_SET_RX_MASK": \
	((x) == 0x94 ? "HWRM_CFA_VLAN_ANTISPOOF_CFG": \
	((x) == 0x95 ? "HWRM_CFA_TUNNEL_FILTER_ALLOC": \
	((x) == 0x96 ? "HWRM_CFA_TUNNEL_FILTER_FREE": \
	((x) == 0x97 ? "HWRM_CFA_ENCAP_RECORD_ALLOC": \
	((x) == 0x98 ? "HWRM_CFA_ENCAP_RECORD_FREE": \
	((x) == 0x99 ? "HWRM_CFA_NTUPLE_FILTER_ALLOC": \
	((x) == 0x9a ? "HWRM_CFA_NTUPLE_FILTER_FREE": \
	((x) == 0x9b ? "HWRM_CFA_NTUPLE_FILTER_CFG": \
	((x) == 0x9c ? "HWRM_CFA_EM_FLOW_ALLOC": \
	((x) == 0x9d ? "HWRM_CFA_EM_FLOW_FREE": \
	((x) == 0x9e ? "HWRM_CFA_EM_FLOW_CFG": \
	((x) == 0xa0 ? "HWRM_TUNNEL_DST_PORT_QUERY": \
	((x) == 0xa1 ? "HWRM_TUNNEL_DST_PORT_ALLOC": \
	((x) == 0xa2 ? "HWRM_TUNNEL_DST_PORT_FREE": \
	((x) == 0xaf ? "HWRM_STAT_CTX_ENG_QUERY": \
	((x) == 0xb0 ? "HWRM_STAT_CTX_ALLOC": \
	((x) == 0xb1 ? "HWRM_STAT_CTX_FREE": \
	((x) == 0xb2 ? "HWRM_STAT_CTX_QUERY": \
	((x) == 0xb3 ? "HWRM_STAT_CTX_CLR_STATS": \
	((x) == 0xb4 ? "HWRM_PORT_QSTATS_EXT": \
	((x) == 0xb5 ? "HWRM_PORT_PHY_MDIO_WRITE": \
	((x) == 0xb6 ? "HWRM_PORT_PHY_MDIO_READ": \
	((x) == 0xb7 ? "HWRM_PORT_PHY_MDIO_BUS_ACQUIRE": \
	((x) == 0xb8 ? "HWRM_PORT_PHY_MDIO_BUS_RELEASE": \
	((x) == 0xb9 ? "HWRM_PORT_QSTATS_EXT_PFC_WD": \
	((x) == 0xba ? "HWRM_RESERVED7": \
	((x) == 0xbb ? "HWRM_PORT_TX_FIR_CFG": \
	((x) == 0xbc ? "HWRM_PORT_TX_FIR_QCFG": \
	((x) == 0xbd ? "HWRM_PORT_ECN_QSTATS": \
	((x) == 0xbe ? "HWRM_FW_LIVEPATCH_QUERY": \
	((x) == 0xbf ? "HWRM_FW_LIVEPATCH": \
	((x) == 0xc0 ? "HWRM_FW_RESET": \
	((x) == 0xc1 ? "HWRM_FW_QSTATUS": \
	((x) == 0xc2 ? "HWRM_FW_HEALTH_CHECK": \
	((x) == 0xc3 ? "HWRM_FW_SYNC": \
	((x) == 0xc4 ? "HWRM_FW_STATE_QCAPS": \
	((x) == 0xc5 ? "HWRM_FW_STATE_QUIESCE": \
	((x) == 0xc6 ? "HWRM_FW_STATE_BACKUP": \
	((x) == 0xc7 ? "HWRM_FW_STATE_RESTORE": \
	((x) == 0xc8 ? "HWRM_FW_SET_TIME": \
	((x) == 0xc9 ? "HWRM_FW_GET_TIME": \
	((x) == 0xca ? "HWRM_FW_SET_STRUCTURED_DATA": \
	((x) == 0xcb ? "HWRM_FW_GET_STRUCTURED_DATA": \
	((x) == 0xcc ? "HWRM_FW_IPC_MAILBOX": \
	((x) == 0xcd ? "HWRM_FW_ECN_CFG": \
	((x) == 0xce ? "HWRM_FW_ECN_QCFG": \
	((x) == 0xcf ? "HWRM_FW_SECURE_CFG": \
	((x) == 0xd0 ? "HWRM_EXEC_FWD_RESP": \
	((x) == 0xd1 ? "HWRM_REJECT_FWD_RESP": \
	((x) == 0xd2 ? "HWRM_FWD_RESP": \
	((x) == 0xd3 ? "HWRM_FWD_ASYNC_EVENT_CMPL": \
	((x) == 0xd4 ? "HWRM_OEM_CMD": \
	((x) == 0xd5 ? "HWRM_PORT_PRBS_TEST": \
	((x) == 0xd6 ? "HWRM_PORT_SFP_SIDEBAND_CFG": \
	((x) == 0xd7 ? "HWRM_PORT_SFP_SIDEBAND_QCFG": \
	((x) == 0xd8 ? "HWRM_FW_STATE_UNQUIESCE": \
	((x) == 0xd9 ? "HWRM_PORT_DSC_DUMP": \
	((x) == 0xe0 ? "HWRM_TEMP_MONITOR_QUERY": \
	((x) == 0xe1 ? "HWRM_REG_POWER_QUERY": \
	((x) == 0xe2 ? "HWRM_CORE_FREQUENCY_QUERY": \
	((x) == 0xe3 ? "HWRM_REG_POWER_HISTOGRAM": \
	((x) == 0xf0 ? "HWRM_WOL_FILTER_ALLOC": \
	((x) == 0xf1 ? "HWRM_WOL_FILTER_FREE": \
	((x) == 0xf2 ? "HWRM_WOL_FILTER_QCFG": \
	((x) == 0xf3 ? "HWRM_WOL_REASON_QCFG": \
	((x) == 0xf4 ? "HWRM_CFA_METER_QCAPS": \
	((x) == 0xf5 ? "HWRM_CFA_METER_PROFILE_ALLOC": \
	((x) == 0xf6 ? "HWRM_CFA_METER_PROFILE_FREE": \
	((x) == 0xf7 ? "HWRM_CFA_METER_PROFILE_CFG": \
	((x) == 0xf8 ? "HWRM_CFA_METER_INSTANCE_ALLOC": \
	((x) == 0xf9 ? "HWRM_CFA_METER_INSTANCE_FREE": \
	((x) == 0xfa ? "HWRM_CFA_METER_INSTANCE_CFG": \
	((x) == 0xfd ? "HWRM_CFA_VFR_ALLOC": \
	((x) == 0xfe ? "HWRM_CFA_VFR_FREE": \
	"Unknown decode" )))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))) : \
	(((x) < 0x180) ? \
	((x) == 0x100 ? "HWRM_CFA_VF_PAIR_ALLOC": \
	((x) == 0x101 ? "HWRM_CFA_VF_PAIR_FREE": \
	((x) == 0x102 ? "HWRM_CFA_VF_PAIR_INFO": \
	((x) == 0x103 ? "HWRM_CFA_FLOW_ALLOC": \
	((x) == 0x104 ? "HWRM_CFA_FLOW_FREE": \
	((x) == 0x105 ? "HWRM_CFA_FLOW_FLUSH": \
	((x) == 0x106 ? "HWRM_CFA_FLOW_STATS": \
	((x) == 0x107 ? "HWRM_CFA_FLOW_INFO": \
	((x) == 0x108 ? "HWRM_CFA_DECAP_FILTER_ALLOC": \
	((x) == 0x109 ? "HWRM_CFA_DECAP_FILTER_FREE": \
	((x) == 0x10a ? "HWRM_CFA_VLAN_ANTISPOOF_QCFG": \
	((x) == 0x10b ? "HWRM_CFA_REDIRECT_TUNNEL_TYPE_ALLOC": \
	((x) == 0x10c ? "HWRM_CFA_REDIRECT_TUNNEL_TYPE_FREE": \
	((x) == 0x10d ? "HWRM_CFA_PAIR_ALLOC": \
	((x) == 0x10e ? "HWRM_CFA_PAIR_FREE": \
	((x) == 0x10f ? "HWRM_CFA_PAIR_INFO": \
	((x) == 0x110 ? "HWRM_FW_IPC_MSG": \
	((x) == 0x111 ? "HWRM_CFA_REDIRECT_TUNNEL_TYPE_INFO": \
	((x) == 0x112 ? "HWRM_CFA_REDIRECT_QUERY_TUNNEL_TYPE": \
	((x) == 0x113 ? "HWRM_CFA_FLOW_AGING_TIMER_RESET": \
	((x) == 0x114 ? "HWRM_CFA_FLOW_AGING_CFG": \
	((x) == 0x115 ? "HWRM_CFA_FLOW_AGING_QCFG": \
	((x) == 0x116 ? "HWRM_CFA_FLOW_AGING_QCAPS": \
	((x) == 0x117 ? "HWRM_CFA_CTX_MEM_RGTR": \
	((x) == 0x118 ? "HWRM_CFA_CTX_MEM_UNRGTR": \
	((x) == 0x119 ? "HWRM_CFA_CTX_MEM_QCTX": \
	((x) == 0x11a ? "HWRM_CFA_CTX_MEM_QCAPS": \
	((x) == 0x11b ? "HWRM_CFA_COUNTER_QCAPS": \
	((x) == 0x11c ? "HWRM_CFA_COUNTER_CFG": \
	((x) == 0x11d ? "HWRM_CFA_COUNTER_QCFG": \
	((x) == 0x11e ? "HWRM_CFA_COUNTER_QSTATS": \
	((x) == 0x11f ? "HWRM_CFA_TCP_FLAG_PROCESS_QCFG": \
	((x) == 0x120 ? "HWRM_CFA_EEM_QCAPS": \
	((x) == 0x121 ? "HWRM_CFA_EEM_CFG": \
	((x) == 0x122 ? "HWRM_CFA_EEM_QCFG": \
	((x) == 0x123 ? "HWRM_CFA_EEM_OP": \
	((x) == 0x124 ? "HWRM_CFA_ADV_FLOW_MGNT_QCAPS": \
	((x) == 0x125 ? "HWRM_CFA_TFLIB": \
	((x) == 0x126 ? "HWRM_CFA_LAG_GROUP_MEMBER_RGTR": \
	((x) == 0x127 ? "HWRM_CFA_LAG_GROUP_MEMBER_UNRGTR": \
	((x) == 0x12e ? "HWRM_ENGINE_CKV_STATUS": \
	((x) == 0x12f ? "HWRM_ENGINE_CKV_CKEK_ADD": \
	((x) == 0x130 ? "HWRM_ENGINE_CKV_CKEK_DELETE": \
	((x) == 0x131 ? "HWRM_ENGINE_CKV_KEY_ADD": \
	((x) == 0x132 ? "HWRM_ENGINE_CKV_KEY_DELETE": \
	((x) == 0x133 ? "HWRM_ENGINE_CKV_FLUSH": \
	((x) == 0x134 ? "HWRM_ENGINE_CKV_RNG_GET": \
	((x) == 0x135 ? "HWRM_ENGINE_CKV_KEY_GEN": \
	((x) == 0x136 ? "HWRM_ENGINE_CKV_KEY_LABEL_CFG": \
	((x) == 0x137 ? "HWRM_ENGINE_CKV_KEY_LABEL_QCFG": \
	((x) == 0x13c ? "HWRM_ENGINE_QG_CONFIG_QUERY": \
	((x) == 0x13d ? "HWRM_ENGINE_QG_QUERY": \
	((x) == 0x13e ? "HWRM_ENGINE_QG_METER_PROFILE_CONFIG_QUERY": \
	((x) == 0x13f ? "HWRM_ENGINE_QG_METER_PROFILE_QUERY": \
	((x) == 0x140 ? "HWRM_ENGINE_QG_METER_PROFILE_ALLOC": \
	((x) == 0x141 ? "HWRM_ENGINE_QG_METER_PROFILE_FREE": \
	((x) == 0x142 ? "HWRM_ENGINE_QG_METER_QUERY": \
	((x) == 0x143 ? "HWRM_ENGINE_QG_METER_BIND": \
	((x) == 0x144 ? "HWRM_ENGINE_QG_METER_UNBIND": \
	((x) == 0x145 ? "HWRM_ENGINE_QG_FUNC_BIND": \
	((x) == 0x146 ? "HWRM_ENGINE_SG_CONFIG_QUERY": \
	((x) == 0x147 ? "HWRM_ENGINE_SG_QUERY": \
	((x) == 0x148 ? "HWRM_ENGINE_SG_METER_QUERY": \
	((x) == 0x149 ? "HWRM_ENGINE_SG_METER_CONFIG": \
	((x) == 0x14a ? "HWRM_ENGINE_SG_QG_BIND": \
	((x) == 0x14b ? "HWRM_ENGINE_QG_SG_UNBIND": \
	((x) == 0x154 ? "HWRM_ENGINE_CONFIG_QUERY": \
	((x) == 0x155 ? "HWRM_ENGINE_STATS_CONFIG": \
	((x) == 0x156 ? "HWRM_ENGINE_STATS_CLEAR": \
	((x) == 0x157 ? "HWRM_ENGINE_STATS_QUERY": \
	((x) == 0x158 ? "HWRM_ENGINE_STATS_QUERY_CONTINUOUS_ERROR": \
	((x) == 0x15e ? "HWRM_ENGINE_RQ_ALLOC": \
	((x) == 0x15f ? "HWRM_ENGINE_RQ_FREE": \
	((x) == 0x160 ? "HWRM_ENGINE_CQ_ALLOC": \
	((x) == 0x161 ? "HWRM_ENGINE_CQ_FREE": \
	((x) == 0x162 ? "HWRM_ENGINE_NQ_ALLOC": \
	((x) == 0x163 ? "HWRM_ENGINE_NQ_FREE": \
	((x) == 0x164 ? "HWRM_ENGINE_ON_DIE_RQE_CREDITS": \
	((x) == 0x165 ? "HWRM_ENGINE_FUNC_QCFG": \
	"Unknown decode" ))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))) : \
	(((x) < 0x200) ? \
	((x) == 0x190 ? "HWRM_FUNC_RESOURCE_QCAPS": \
	((x) == 0x191 ? "HWRM_FUNC_VF_RESOURCE_CFG": \
	((x) == 0x192 ? "HWRM_FUNC_BACKING_STORE_QCAPS": \
	((x) == 0x193 ? "HWRM_FUNC_BACKING_STORE_CFG": \
	((x) == 0x194 ? "HWRM_FUNC_BACKING_STORE_QCFG": \
	((x) == 0x195 ? "HWRM_FUNC_VF_BW_CFG": \
	((x) == 0x196 ? "HWRM_FUNC_VF_BW_QCFG": \
	((x) == 0x197 ? "HWRM_FUNC_HOST_PF_IDS_QUERY": \
	((x) == 0x198 ? "HWRM_FUNC_QSTATS_EXT": \
	((x) == 0x199 ? "HWRM_STAT_EXT_CTX_QUERY": \
	((x) == 0x19a ? "HWRM_FUNC_SPD_CFG": \
	((x) == 0x19b ? "HWRM_FUNC_SPD_QCFG": \
	((x) == 0x19c ? "HWRM_FUNC_PTP_PIN_QCFG": \
	((x) == 0x19d ? "HWRM_FUNC_PTP_PIN_CFG": \
	((x) == 0x19e ? "HWRM_FUNC_PTP_CFG": \
	((x) == 0x19f ? "HWRM_FUNC_PTP_TS_QUERY": \
	"Unknown decode" )))))))))))))))) : \
	(((x) < 0x280) ? \
	((x) == 0x200 ? "HWRM_SELFTEST_QLIST": \
	((x) == 0x201 ? "HWRM_SELFTEST_EXEC": \
	((x) == 0x202 ? "HWRM_SELFTEST_IRQ": \
	((x) == 0x203 ? "HWRM_SELFTEST_RETRIEVE_SERDES_DATA": \
	((x) == 0x204 ? "HWRM_PCIE_QSTATS": \
	((x) == 0x205 ? "HWRM_MFG_FRU_WRITE_CONTROL": \
	((x) == 0x206 ? "HWRM_MFG_TIMERS_QUERY": \
	((x) == 0x207 ? "HWRM_MFG_OTP_CFG": \
	((x) == 0x208 ? "HWRM_MFG_OTP_QCFG": \
	((x) == 0x209 ? "HWRM_MFG_HDMA_TEST": \
	((x) == 0x20a ? "HWRM_MFG_FRU_EEPROM_WRITE": \
	((x) == 0x20b ? "HWRM_MFG_FRU_EEPROM_READ": \
	((x) == 0x20c ? "HWRM_MFG_SOC_IMAGE": \
	((x) == 0x20d ? "HWRM_MFG_SOC_QSTATUS": \
	((x) == 0x20e ? "HWRM_MFG_PARAM_SEEPROM_SYNC": \
	((x) == 0x20f ? "HWRM_MFG_PARAM_SEEPROM_READ": \
	((x) == 0x210 ? "HWRM_MFG_PARAM_SEEPROM_HEALTH": \
	"Unknown decode" ))))))))))))))))) : \
	(((x) < 0x300) ? \
	((x) == 0x2bc ? "HWRM_TF": \
	((x) == 0x2bd ? "HWRM_TF_VERSION_GET": \
	((x) == 0x2c6 ? "HWRM_TF_SESSION_OPEN": \
	((x) == 0x2c7 ? "HWRM_TF_SESSION_ATTACH": \
	((x) == 0x2c8 ? "HWRM_TF_SESSION_REGISTER": \
	((x) == 0x2c9 ? "HWRM_TF_SESSION_UNREGISTER": \
	((x) == 0x2ca ? "HWRM_TF_SESSION_CLOSE": \
	((x) == 0x2cb ? "HWRM_TF_SESSION_QCFG": \
	((x) == 0x2cc ? "HWRM_TF_SESSION_RESC_QCAPS": \
	((x) == 0x2cd ? "HWRM_TF_SESSION_RESC_ALLOC": \
	((x) == 0x2ce ? "HWRM_TF_SESSION_RESC_FREE": \
	((x) == 0x2cf ? "HWRM_TF_SESSION_RESC_FLUSH": \
	((x) == 0x2d0 ? "HWRM_TF_SESSION_RESC_INFO": \
	((x) == 0x2da ? "HWRM_TF_TBL_TYPE_GET": \
	((x) == 0x2db ? "HWRM_TF_TBL_TYPE_SET": \
	((x) == 0x2dc ? "HWRM_TF_TBL_TYPE_BULK_GET": \
	((x) == 0x2e2 ? "HWRM_TF_CTXT_MEM_ALLOC": \
	((x) == 0x2e3 ? "HWRM_TF_CTXT_MEM_FREE": \
	((x) == 0x2e4 ? "HWRM_TF_CTXT_MEM_RGTR": \
	((x) == 0x2e5 ? "HWRM_TF_CTXT_MEM_UNRGTR": \
	((x) == 0x2e6 ? "HWRM_TF_EXT_EM_QCAPS": \
	((x) == 0x2e7 ? "HWRM_TF_EXT_EM_OP": \
	((x) == 0x2e8 ? "HWRM_TF_EXT_EM_CFG": \
	((x) == 0x2e9 ? "HWRM_TF_EXT_EM_QCFG": \
	((x) == 0x2ea ? "HWRM_TF_EM_INSERT": \
	((x) == 0x2eb ? "HWRM_TF_EM_DELETE": \
	((x) == 0x2ec ? "HWRM_TF_EM_HASH_INSERT": \
	((x) == 0x2ed ? "HWRM_TF_EM_MOVE": \
	((x) == 0x2f8 ? "HWRM_TF_TCAM_SET": \
	((x) == 0x2f9 ? "HWRM_TF_TCAM_GET": \
	((x) == 0x2fa ? "HWRM_TF_TCAM_MOVE": \
	((x) == 0x2fb ? "HWRM_TF_TCAM_FREE": \
	((x) == 0x2fc ? "HWRM_TF_GLOBAL_CFG_SET": \
	((x) == 0x2fd ? "HWRM_TF_GLOBAL_CFG_GET": \
	((x) == 0x2fe ? "HWRM_TF_IF_TBL_SET": \
	((x) == 0x2ff ? "HWRM_TF_IF_TBL_GET": \
	"Unknown decode" )))))))))))))))))))))))))))))))))))) : \
	(((x) < 0x480) ? \
	((x) == 0x400 ? "HWRM_SV": \
	"Unknown decode" ) : \
	(((x) < 0xff80) ? \
	((x) == 0xff10 ? "HWRM_DBG_READ_DIRECT": \
	((x) == 0xff11 ? "HWRM_DBG_READ_INDIRECT": \
	((x) == 0xff12 ? "HWRM_DBG_WRITE_DIRECT": \
	((x) == 0xff13 ? "HWRM_DBG_WRITE_INDIRECT": \
	((x) == 0xff14 ? "HWRM_DBG_DUMP": \
	((x) == 0xff15 ? "HWRM_DBG_ERASE_NVM": \
	((x) == 0xff16 ? "HWRM_DBG_CFG": \
	((x) == 0xff17 ? "HWRM_DBG_COREDUMP_LIST": \
	((x) == 0xff18 ? "HWRM_DBG_COREDUMP_INITIATE": \
	((x) == 0xff19 ? "HWRM_DBG_COREDUMP_RETRIEVE": \
	((x) == 0xff1a ? "HWRM_DBG_FW_CLI": \
	((x) == 0xff1b ? "HWRM_DBG_I2C_CMD": \
	((x) == 0xff1c ? "HWRM_DBG_RING_INFO_GET": \
	((x) == 0xff1d ? "HWRM_DBG_CRASHDUMP_HEADER": \
	((x) == 0xff1e ? "HWRM_DBG_CRASHDUMP_ERASE": \
	((x) == 0xff1f ? "HWRM_DBG_DRV_TRACE": \
	((x) == 0xff20 ? "HWRM_DBG_QCAPS": \
	((x) == 0xff21 ? "HWRM_DBG_QCFG": \
	((x) == 0xff22 ? "HWRM_DBG_CRASHDUMP_MEDIUM_CFG": \
	((x) == 0xff23 ? "HWRM_DBG_USEQ_ALLOC": \
	((x) == 0xff24 ? "HWRM_DBG_USEQ_FREE": \
	((x) == 0xff25 ? "HWRM_DBG_USEQ_FLUSH": \
	((x) == 0xff26 ? "HWRM_DBG_USEQ_QCAPS": \
	((x) == 0xff27 ? "HWRM_DBG_USEQ_CW_CFG": \
	((x) == 0xff28 ? "HWRM_DBG_USEQ_SCHED_CFG": \
	((x) == 0xff29 ? "HWRM_DBG_USEQ_RUN": \
	((x) == 0xff2a ? "HWRM_DBG_USEQ_DELIVERY_REQ": \
	((x) == 0xff2b ? "HWRM_DBG_USEQ_RESP_HDR": \
	"Unknown decode" )))))))))))))))))))))))))))) : \
	(((x) <= 0xffff) ? \
	((x) == 0xffed ? "HWRM_NVM_REQ_ARBITRATION": \
	((x) == 0xffee ? "HWRM_NVM_FACTORY_DEFAULTS": \
	((x) == 0xffef ? "HWRM_NVM_VALIDATE_OPTION": \
	((x) == 0xfff0 ? "HWRM_NVM_FLUSH": \
	((x) == 0xfff1 ? "HWRM_NVM_GET_VARIABLE": \
	((x) == 0xfff2 ? "HWRM_NVM_SET_VARIABLE": \
	((x) == 0xfff3 ? "HWRM_NVM_INSTALL_UPDATE": \
	((x) == 0xfff4 ? "HWRM_NVM_MODIFY": \
	((x) == 0xfff5 ? "HWRM_NVM_VERIFY_UPDATE": \
	((x) == 0xfff6 ? "HWRM_NVM_GET_DEV_INFO": \
	((x) == 0xfff7 ? "HWRM_NVM_ERASE_DIR_ENTRY": \
	((x) == 0xfff8 ? "HWRM_NVM_MOD_DIR_ENTRY": \
	((x) == 0xfff9 ? "HWRM_NVM_FIND_DIR_ENTRY": \
	((x) == 0xfffa ? "HWRM_NVM_GET_DIR_ENTRIES": \
	((x) == 0xfffb ? "HWRM_NVM_GET_DIR_INFO": \
	((x) == 0xfffc ? "HWRM_NVM_RAW_DUMP": \
	((x) == 0xfffd ? "HWRM_NVM_READ": \
	((x) == 0xfffe ? "HWRM_NVM_WRITE": \
	((x) == 0xffff ? "HWRM_NVM_RAW_WRITE_BLK": \
	"Unknown decode" ))))))))))))))))))) : \
	"Unknown decode" )))))))))


/*
 * Command numbering
 * # NOTE - definitions already in hwrm_req_type, in hwrm_types.yaml
 * #	So only structure definition is provided here.
 */
/* cmd_nums (size:64b/8B) */

typedef struct cmd_nums {
	/*
	 * This version of the specification defines the commands listed in
	 * the table below. The following are general implementation
	 * requirements for these commands:
	 *
	 * # All commands listed below that are marked neither
	 * reserved nor experimental shall be implemented by the HWRM.
	 * # A HWRM client compliant to this specification should not use
	 * commands outside of the list below.
	 * # A HWRM client compliant to this specification should not use
	 * command numbers marked reserved below.
	 * # A command marked experimental below may not be implemented
	 * by the HWRM.
	 * # A command marked experimental may change in the
	 * future version of the HWRM specification.
	 * # A command not listed below may be implemented by the HWRM.
	 * The behavior of commands that are not listed below is outside
	 * the scope of this specification.
	 */
	uint16_t	req_type;
	#define HWRM_VER_GET				UINT32_C(0x0)
	#define HWRM_FUNC_ECHO_RESPONSE		UINT32_C(0xb)
	#define HWRM_ERROR_RECOVERY_QCFG		UINT32_C(0xc)
	#define HWRM_FUNC_DRV_IF_CHANGE		UINT32_C(0xd)
	#define HWRM_FUNC_BUF_UNRGTR			UINT32_C(0xe)
	#define HWRM_FUNC_VF_CFG			UINT32_C(0xf)
	/* Reserved for future use. */
	#define HWRM_RESERVED1				UINT32_C(0x10)
	#define HWRM_FUNC_RESET			UINT32_C(0x11)
	#define HWRM_FUNC_GETFID			UINT32_C(0x12)
	#define HWRM_FUNC_VF_ALLOC			UINT32_C(0x13)
	#define HWRM_FUNC_VF_FREE			UINT32_C(0x14)
	#define HWRM_FUNC_QCAPS			UINT32_C(0x15)
	#define HWRM_FUNC_QCFG				UINT32_C(0x16)
	#define HWRM_FUNC_CFG				UINT32_C(0x17)
	#define HWRM_FUNC_QSTATS			UINT32_C(0x18)
	#define HWRM_FUNC_CLR_STATS			UINT32_C(0x19)
	#define HWRM_FUNC_DRV_UNRGTR			UINT32_C(0x1a)
	#define HWRM_FUNC_VF_RESC_FREE			UINT32_C(0x1b)
	#define HWRM_FUNC_VF_VNIC_IDS_QUERY		UINT32_C(0x1c)
	#define HWRM_FUNC_DRV_RGTR			UINT32_C(0x1d)
	#define HWRM_FUNC_DRV_QVER			UINT32_C(0x1e)
	#define HWRM_FUNC_BUF_RGTR			UINT32_C(0x1f)
	#define HWRM_PORT_PHY_CFG			UINT32_C(0x20)
	#define HWRM_PORT_MAC_CFG			UINT32_C(0x21)
	/* Experimental */
	#define HWRM_PORT_TS_QUERY			UINT32_C(0x22)
	#define HWRM_PORT_QSTATS			UINT32_C(0x23)
	#define HWRM_PORT_LPBK_QSTATS			UINT32_C(0x24)
	/* Experimental */
	#define HWRM_PORT_CLR_STATS			UINT32_C(0x25)
	/* Experimental */
	#define HWRM_PORT_LPBK_CLR_STATS		UINT32_C(0x26)
	#define HWRM_PORT_PHY_QCFG			UINT32_C(0x27)
	#define HWRM_PORT_MAC_QCFG			UINT32_C(0x28)
	/* Experimental */
	#define HWRM_PORT_MAC_PTP_QCFG			UINT32_C(0x29)
	#define HWRM_PORT_PHY_QCAPS			UINT32_C(0x2a)
	#define HWRM_PORT_PHY_I2C_WRITE		UINT32_C(0x2b)
	#define HWRM_PORT_PHY_I2C_READ			UINT32_C(0x2c)
	#define HWRM_PORT_LED_CFG			UINT32_C(0x2d)
	#define HWRM_PORT_LED_QCFG			UINT32_C(0x2e)
	#define HWRM_PORT_LED_QCAPS			UINT32_C(0x2f)
	#define HWRM_QUEUE_QPORTCFG			UINT32_C(0x30)
	#define HWRM_QUEUE_QCFG			UINT32_C(0x31)
	#define HWRM_QUEUE_CFG				UINT32_C(0x32)
	#define HWRM_FUNC_VLAN_CFG			UINT32_C(0x33)
	#define HWRM_FUNC_VLAN_QCFG			UINT32_C(0x34)
	#define HWRM_QUEUE_PFCENABLE_QCFG		UINT32_C(0x35)
	#define HWRM_QUEUE_PFCENABLE_CFG		UINT32_C(0x36)
	#define HWRM_QUEUE_PRI2COS_QCFG		UINT32_C(0x37)
	#define HWRM_QUEUE_PRI2COS_CFG			UINT32_C(0x38)
	#define HWRM_QUEUE_COS2BW_QCFG			UINT32_C(0x39)
	#define HWRM_QUEUE_COS2BW_CFG			UINT32_C(0x3a)
	#define HWRM_QUEUE_DSCP_QCAPS			UINT32_C(0x3b)
	#define HWRM_QUEUE_DSCP2PRI_QCFG		UINT32_C(0x3c)
	#define HWRM_QUEUE_DSCP2PRI_CFG		UINT32_C(0x3d)
	#define HWRM_VNIC_ALLOC			UINT32_C(0x40)
	#define HWRM_VNIC_FREE				UINT32_C(0x41)
	#define HWRM_VNIC_CFG				UINT32_C(0x42)
	#define HWRM_VNIC_QCFG				UINT32_C(0x43)
	#define HWRM_VNIC_TPA_CFG			UINT32_C(0x44)
	/* Experimental */
	#define HWRM_VNIC_TPA_QCFG			UINT32_C(0x45)
	#define HWRM_VNIC_RSS_CFG			UINT32_C(0x46)
	#define HWRM_VNIC_RSS_QCFG			UINT32_C(0x47)
	#define HWRM_VNIC_PLCMODES_CFG			UINT32_C(0x48)
	#define HWRM_VNIC_PLCMODES_QCFG		UINT32_C(0x49)
	#define HWRM_VNIC_QCAPS			UINT32_C(0x4a)
	/* Updates specific fields in RX VNIC structure */
	#define HWRM_VNIC_UPDATE			UINT32_C(0x4b)
	#define HWRM_RING_ALLOC			UINT32_C(0x50)
	#define HWRM_RING_FREE				UINT32_C(0x51)
	#define HWRM_RING_CMPL_RING_QAGGINT_PARAMS	UINT32_C(0x52)
	#define HWRM_RING_CMPL_RING_CFG_AGGINT_PARAMS	UINT32_C(0x53)
	#define HWRM_RING_AGGINT_QCAPS			UINT32_C(0x54)
	#define HWRM_RING_SCHQ_ALLOC			UINT32_C(0x55)
	#define HWRM_RING_SCHQ_CFG			UINT32_C(0x56)
	#define HWRM_RING_SCHQ_FREE			UINT32_C(0x57)
	#define HWRM_RING_RESET			UINT32_C(0x5e)
	#define HWRM_RING_GRP_ALLOC			UINT32_C(0x60)
	#define HWRM_RING_GRP_FREE			UINT32_C(0x61)
	#define HWRM_RING_CFG				UINT32_C(0x62)
	#define HWRM_RING_QCFG				UINT32_C(0x63)
	/* Reserved for future use. */
	#define HWRM_RESERVED5				UINT32_C(0x64)
	/* Reserved for future use. */
	#define HWRM_RESERVED6				UINT32_C(0x65)
	#define HWRM_VNIC_RSS_COS_LB_CTX_ALLOC		UINT32_C(0x70)
	#define HWRM_VNIC_RSS_COS_LB_CTX_FREE		UINT32_C(0x71)
	#define HWRM_QUEUE_MPLS_QCAPS			UINT32_C(0x80)
	#define HWRM_QUEUE_MPLSTC2PRI_QCFG		UINT32_C(0x81)
	#define HWRM_QUEUE_MPLSTC2PRI_CFG		UINT32_C(0x82)
	#define HWRM_QUEUE_VLANPRI_QCAPS		UINT32_C(0x83)
	#define HWRM_QUEUE_VLANPRI2PRI_QCFG		UINT32_C(0x84)
	#define HWRM_QUEUE_VLANPRI2PRI_CFG		UINT32_C(0x85)
	#define HWRM_QUEUE_GLOBAL_CFG			UINT32_C(0x86)
	#define HWRM_QUEUE_GLOBAL_QCFG			UINT32_C(0x87)
	#define HWRM_CFA_L2_FILTER_ALLOC		UINT32_C(0x90)
	#define HWRM_CFA_L2_FILTER_FREE		UINT32_C(0x91)
	#define HWRM_CFA_L2_FILTER_CFG			UINT32_C(0x92)
	#define HWRM_CFA_L2_SET_RX_MASK		UINT32_C(0x93)
	#define HWRM_CFA_VLAN_ANTISPOOF_CFG		UINT32_C(0x94)
	#define HWRM_CFA_TUNNEL_FILTER_ALLOC		UINT32_C(0x95)
	#define HWRM_CFA_TUNNEL_FILTER_FREE		UINT32_C(0x96)
	/* Experimental */
	#define HWRM_CFA_ENCAP_RECORD_ALLOC		UINT32_C(0x97)
	/* Experimental */
	#define HWRM_CFA_ENCAP_RECORD_FREE		UINT32_C(0x98)
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC		UINT32_C(0x99)
	#define HWRM_CFA_NTUPLE_FILTER_FREE		UINT32_C(0x9a)
	#define HWRM_CFA_NTUPLE_FILTER_CFG		UINT32_C(0x9b)
	/* Experimental */
	#define HWRM_CFA_EM_FLOW_ALLOC			UINT32_C(0x9c)
	/* Experimental */
	#define HWRM_CFA_EM_FLOW_FREE			UINT32_C(0x9d)
	/* Experimental */
	#define HWRM_CFA_EM_FLOW_CFG			UINT32_C(0x9e)
	#define HWRM_TUNNEL_DST_PORT_QUERY		UINT32_C(0xa0)
	#define HWRM_TUNNEL_DST_PORT_ALLOC		UINT32_C(0xa1)
	#define HWRM_TUNNEL_DST_PORT_FREE		UINT32_C(0xa2)
	#define HWRM_STAT_CTX_ENG_QUERY		UINT32_C(0xaf)
	#define HWRM_STAT_CTX_ALLOC			UINT32_C(0xb0)
	#define HWRM_STAT_CTX_FREE			UINT32_C(0xb1)
	#define HWRM_STAT_CTX_QUERY			UINT32_C(0xb2)
	#define HWRM_STAT_CTX_CLR_STATS		UINT32_C(0xb3)
	#define HWRM_PORT_QSTATS_EXT			UINT32_C(0xb4)
	#define HWRM_PORT_PHY_MDIO_WRITE		UINT32_C(0xb5)
	#define HWRM_PORT_PHY_MDIO_READ		UINT32_C(0xb6)
	#define HWRM_PORT_PHY_MDIO_BUS_ACQUIRE		UINT32_C(0xb7)
	#define HWRM_PORT_PHY_MDIO_BUS_RELEASE		UINT32_C(0xb8)
	#define HWRM_PORT_QSTATS_EXT_PFC_WD		UINT32_C(0xb9)
	/* Reserved. */
	#define HWRM_RESERVED7				UINT32_C(0xba)
	#define HWRM_PORT_TX_FIR_CFG			UINT32_C(0xbb)
	#define HWRM_PORT_TX_FIR_QCFG			UINT32_C(0xbc)
	#define HWRM_PORT_ECN_QSTATS			UINT32_C(0xbd)
	#define HWRM_FW_LIVEPATCH_QUERY		UINT32_C(0xbe)
	#define HWRM_FW_LIVEPATCH			UINT32_C(0xbf)
	#define HWRM_FW_RESET				UINT32_C(0xc0)
	#define HWRM_FW_QSTATUS			UINT32_C(0xc1)
	#define HWRM_FW_HEALTH_CHECK			UINT32_C(0xc2)
	#define HWRM_FW_SYNC				UINT32_C(0xc3)
	#define HWRM_FW_STATE_QCAPS			UINT32_C(0xc4)
	#define HWRM_FW_STATE_QUIESCE			UINT32_C(0xc5)
	#define HWRM_FW_STATE_BACKUP			UINT32_C(0xc6)
	#define HWRM_FW_STATE_RESTORE			UINT32_C(0xc7)
	/* Experimental */
	#define HWRM_FW_SET_TIME			UINT32_C(0xc8)
	/* Experimental */
	#define HWRM_FW_GET_TIME			UINT32_C(0xc9)
	/* Experimental */
	#define HWRM_FW_SET_STRUCTURED_DATA		UINT32_C(0xca)
	/* Experimental */
	#define HWRM_FW_GET_STRUCTURED_DATA		UINT32_C(0xcb)
	/* Experimental */
	#define HWRM_FW_IPC_MAILBOX			UINT32_C(0xcc)
	#define HWRM_FW_ECN_CFG			UINT32_C(0xcd)
	#define HWRM_FW_ECN_QCFG			UINT32_C(0xce)
	#define HWRM_FW_SECURE_CFG			UINT32_C(0xcf)
	#define HWRM_EXEC_FWD_RESP			UINT32_C(0xd0)
	#define HWRM_REJECT_FWD_RESP			UINT32_C(0xd1)
	#define HWRM_FWD_RESP				UINT32_C(0xd2)
	#define HWRM_FWD_ASYNC_EVENT_CMPL		UINT32_C(0xd3)
	#define HWRM_OEM_CMD				UINT32_C(0xd4)
	/* Tells the fw to run PRBS test on a given port and lane. */
	#define HWRM_PORT_PRBS_TEST			UINT32_C(0xd5)
	#define HWRM_PORT_SFP_SIDEBAND_CFG		UINT32_C(0xd6)
	#define HWRM_PORT_SFP_SIDEBAND_QCFG		UINT32_C(0xd7)
	#define HWRM_FW_STATE_UNQUIESCE		UINT32_C(0xd8)
	/* Tells the fw to collect dsc dump on a given port and lane. */
	#define HWRM_PORT_DSC_DUMP			UINT32_C(0xd9)
	#define HWRM_TEMP_MONITOR_QUERY		UINT32_C(0xe0)
	#define HWRM_REG_POWER_QUERY			UINT32_C(0xe1)
	#define HWRM_CORE_FREQUENCY_QUERY		UINT32_C(0xe2)
	#define HWRM_REG_POWER_HISTOGRAM		UINT32_C(0xe3)
	#define HWRM_WOL_FILTER_ALLOC			UINT32_C(0xf0)
	#define HWRM_WOL_FILTER_FREE			UINT32_C(0xf1)
	#define HWRM_WOL_FILTER_QCFG			UINT32_C(0xf2)
	#define HWRM_WOL_REASON_QCFG			UINT32_C(0xf3)
	/* Experimental */
	#define HWRM_CFA_METER_QCAPS			UINT32_C(0xf4)
	/* Experimental */
	#define HWRM_CFA_METER_PROFILE_ALLOC		UINT32_C(0xf5)
	/* Experimental */
	#define HWRM_CFA_METER_PROFILE_FREE		UINT32_C(0xf6)
	/* Experimental */
	#define HWRM_CFA_METER_PROFILE_CFG		UINT32_C(0xf7)
	/* Experimental */
	#define HWRM_CFA_METER_INSTANCE_ALLOC		UINT32_C(0xf8)
	/* Experimental */
	#define HWRM_CFA_METER_INSTANCE_FREE		UINT32_C(0xf9)
	/* Experimental */
	#define HWRM_CFA_METER_INSTANCE_CFG		UINT32_C(0xfa)
	/* Experimental */
	#define HWRM_CFA_VFR_ALLOC			UINT32_C(0xfd)
	/* Experimental */
	#define HWRM_CFA_VFR_FREE			UINT32_C(0xfe)
	/* Experimental */
	#define HWRM_CFA_VF_PAIR_ALLOC			UINT32_C(0x100)
	/* Experimental */
	#define HWRM_CFA_VF_PAIR_FREE			UINT32_C(0x101)
	/* Experimental */
	#define HWRM_CFA_VF_PAIR_INFO			UINT32_C(0x102)
	/* Experimental */
	#define HWRM_CFA_FLOW_ALLOC			UINT32_C(0x103)
	/* Experimental */
	#define HWRM_CFA_FLOW_FREE			UINT32_C(0x104)
	/* Experimental */
	#define HWRM_CFA_FLOW_FLUSH			UINT32_C(0x105)
	/* Experimental */
	#define HWRM_CFA_FLOW_STATS			UINT32_C(0x106)
	/* Experimental */
	#define HWRM_CFA_FLOW_INFO			UINT32_C(0x107)
	/* Experimental */
	#define HWRM_CFA_DECAP_FILTER_ALLOC		UINT32_C(0x108)
	/* Experimental */
	#define HWRM_CFA_DECAP_FILTER_FREE		UINT32_C(0x109)
	#define HWRM_CFA_VLAN_ANTISPOOF_QCFG		UINT32_C(0x10a)
	#define HWRM_CFA_REDIRECT_TUNNEL_TYPE_ALLOC	UINT32_C(0x10b)
	#define HWRM_CFA_REDIRECT_TUNNEL_TYPE_FREE	UINT32_C(0x10c)
	/* Experimental */
	#define HWRM_CFA_PAIR_ALLOC			UINT32_C(0x10d)
	/* Experimental */
	#define HWRM_CFA_PAIR_FREE			UINT32_C(0x10e)
	/* Experimental */
	#define HWRM_CFA_PAIR_INFO			UINT32_C(0x10f)
	/* Experimental */
	#define HWRM_FW_IPC_MSG			UINT32_C(0x110)
	#define HWRM_CFA_REDIRECT_TUNNEL_TYPE_INFO	UINT32_C(0x111)
	#define HWRM_CFA_REDIRECT_QUERY_TUNNEL_TYPE	UINT32_C(0x112)
	/* Experimental */
	#define HWRM_CFA_FLOW_AGING_TIMER_RESET	UINT32_C(0x113)
	/* Experimental */
	#define HWRM_CFA_FLOW_AGING_CFG		UINT32_C(0x114)
	/* Experimental */
	#define HWRM_CFA_FLOW_AGING_QCFG		UINT32_C(0x115)
	/* Experimental */
	#define HWRM_CFA_FLOW_AGING_QCAPS		UINT32_C(0x116)
	/* Experimental */
	#define HWRM_CFA_CTX_MEM_RGTR			UINT32_C(0x117)
	/* Experimental */
	#define HWRM_CFA_CTX_MEM_UNRGTR		UINT32_C(0x118)
	/* Experimental */
	#define HWRM_CFA_CTX_MEM_QCTX			UINT32_C(0x119)
	/* Experimental */
	#define HWRM_CFA_CTX_MEM_QCAPS			UINT32_C(0x11a)
	/* Experimental */
	#define HWRM_CFA_COUNTER_QCAPS			UINT32_C(0x11b)
	/* Experimental */
	#define HWRM_CFA_COUNTER_CFG			UINT32_C(0x11c)
	/* Experimental */
	#define HWRM_CFA_COUNTER_QCFG			UINT32_C(0x11d)
	/* Experimental */
	#define HWRM_CFA_COUNTER_QSTATS		UINT32_C(0x11e)
	/* Experimental */
	#define HWRM_CFA_TCP_FLAG_PROCESS_QCFG		UINT32_C(0x11f)
	/* Experimental */
	#define HWRM_CFA_EEM_QCAPS			UINT32_C(0x120)
	/* Experimental */
	#define HWRM_CFA_EEM_CFG			UINT32_C(0x121)
	/* Experimental */
	#define HWRM_CFA_EEM_QCFG			UINT32_C(0x122)
	/* Experimental */
	#define HWRM_CFA_EEM_OP			UINT32_C(0x123)
	/* Experimental */
	#define HWRM_CFA_ADV_FLOW_MGNT_QCAPS		UINT32_C(0x124)
	/* Experimental - DEPRECATED */
	#define HWRM_CFA_TFLIB				UINT32_C(0x125)
	/* Experimental */
	#define HWRM_CFA_LAG_GROUP_MEMBER_RGTR		UINT32_C(0x126)
	/* Experimental */
	#define HWRM_CFA_LAG_GROUP_MEMBER_UNRGTR	UINT32_C(0x127)
	/* Engine CKV - Get the current allocation status of keys provisioned in the key vault. */
	#define HWRM_ENGINE_CKV_STATUS			UINT32_C(0x12e)
	/* Engine CKV - Add a new CKEK used to encrypt keys. */
	#define HWRM_ENGINE_CKV_CKEK_ADD		UINT32_C(0x12f)
	/* Engine CKV - Delete a previously added CKEK. */
	#define HWRM_ENGINE_CKV_CKEK_DELETE		UINT32_C(0x130)
	/* Engine CKV - Add a new key to the key vault. */
	#define HWRM_ENGINE_CKV_KEY_ADD		UINT32_C(0x131)
	/* Engine CKV - Delete a key from the key vault. */
	#define HWRM_ENGINE_CKV_KEY_DELETE		UINT32_C(0x132)
	/* Engine CKV - Delete all keys from the key vault. */
	#define HWRM_ENGINE_CKV_FLUSH			UINT32_C(0x133)
	/* Engine CKV - Get random data. */
	#define HWRM_ENGINE_CKV_RNG_GET		UINT32_C(0x134)
	/* Engine CKV - Generate and encrypt a new AES key. */
	#define HWRM_ENGINE_CKV_KEY_GEN		UINT32_C(0x135)
	/* Engine CKV - Configure a label index with a label value. */
	#define HWRM_ENGINE_CKV_KEY_LABEL_CFG		UINT32_C(0x136)
	/* Engine CKV - Query a label */
	#define HWRM_ENGINE_CKV_KEY_LABEL_QCFG		UINT32_C(0x137)
	/* Engine - Query the available queue groups configuration. */
	#define HWRM_ENGINE_QG_CONFIG_QUERY		UINT32_C(0x13c)
	/* Engine - Query the queue groups assigned to a function. */
	#define HWRM_ENGINE_QG_QUERY			UINT32_C(0x13d)
	/* Engine - Query the available queue group meter profile configuration. */
	#define HWRM_ENGINE_QG_METER_PROFILE_CONFIG_QUERY UINT32_C(0x13e)
	/* Engine - Query the configuration of a queue group meter profile. */
	#define HWRM_ENGINE_QG_METER_PROFILE_QUERY	UINT32_C(0x13f)
	/* Engine - Allocate a queue group meter profile. */
	#define HWRM_ENGINE_QG_METER_PROFILE_ALLOC	UINT32_C(0x140)
	/* Engine - Free a queue group meter profile. */
	#define HWRM_ENGINE_QG_METER_PROFILE_FREE	UINT32_C(0x141)
	/* Engine - Query the meters assigned to a queue group. */
	#define HWRM_ENGINE_QG_METER_QUERY		UINT32_C(0x142)
	/* Engine - Bind a queue group meter profile to a queue group. */
	#define HWRM_ENGINE_QG_METER_BIND		UINT32_C(0x143)
	/* Engine - Unbind a queue group meter profile from a queue group. */
	#define HWRM_ENGINE_QG_METER_UNBIND		UINT32_C(0x144)
	/* Engine - Bind a queue group to a function. */
	#define HWRM_ENGINE_QG_FUNC_BIND		UINT32_C(0x145)
	/* Engine - Query the scheduling group configuration. */
	#define HWRM_ENGINE_SG_CONFIG_QUERY		UINT32_C(0x146)
	/* Engine - Query the queue groups assigned to a scheduling group. */
	#define HWRM_ENGINE_SG_QUERY			UINT32_C(0x147)
	/* Engine - Query the configuration of a scheduling group's meter profiles. */
	#define HWRM_ENGINE_SG_METER_QUERY		UINT32_C(0x148)
	/* Engine - Configure a scheduling group's meter profiles. */
	#define HWRM_ENGINE_SG_METER_CONFIG		UINT32_C(0x149)
	/* Engine - Bind a queue group to a scheduling group. */
	#define HWRM_ENGINE_SG_QG_BIND			UINT32_C(0x14a)
	/* Engine - Unbind a queue group from its scheduling group. */
	#define HWRM_ENGINE_QG_SG_UNBIND		UINT32_C(0x14b)
	/* Engine - Query the Engine configuration. */
	#define HWRM_ENGINE_CONFIG_QUERY		UINT32_C(0x154)
	/* Engine - Configure the statistics accumulator for an Engine. */
	#define HWRM_ENGINE_STATS_CONFIG		UINT32_C(0x155)
	/* Engine - Clear the statistics accumulator for an Engine. */
	#define HWRM_ENGINE_STATS_CLEAR		UINT32_C(0x156)
	/* Engine - Query the statistics accumulator for an Engine. */
	#define HWRM_ENGINE_STATS_QUERY		UINT32_C(0x157)
	/* Engine - Query statistics counters for continuous errors from all CDDIP Engines. */
	#define HWRM_ENGINE_STATS_QUERY_CONTINUOUS_ERROR  UINT32_C(0x158)
	/* Engine - Allocate an Engine RQ. */
	#define HWRM_ENGINE_RQ_ALLOC			UINT32_C(0x15e)
	/* Engine - Free an Engine RQ. */
	#define HWRM_ENGINE_RQ_FREE			UINT32_C(0x15f)
	/* Engine - Allocate an Engine CQ. */
	#define HWRM_ENGINE_CQ_ALLOC			UINT32_C(0x160)
	/* Engine - Free an Engine CQ. */
	#define HWRM_ENGINE_CQ_FREE			UINT32_C(0x161)
	/* Engine - Allocate an NQ. */
	#define HWRM_ENGINE_NQ_ALLOC			UINT32_C(0x162)
	/* Engine - Free an NQ. */
	#define HWRM_ENGINE_NQ_FREE			UINT32_C(0x163)
	/* Engine - Set the on-die RQE credit update location. */
	#define HWRM_ENGINE_ON_DIE_RQE_CREDITS		UINT32_C(0x164)
	/* Engine - Query the engine function configuration. */
	#define HWRM_ENGINE_FUNC_QCFG			UINT32_C(0x165)
	/* Experimental */
	#define HWRM_FUNC_RESOURCE_QCAPS		UINT32_C(0x190)
	/* Experimental */
	#define HWRM_FUNC_VF_RESOURCE_CFG		UINT32_C(0x191)
	/* Experimental */
	#define HWRM_FUNC_BACKING_STORE_QCAPS		UINT32_C(0x192)
	/* Experimental */
	#define HWRM_FUNC_BACKING_STORE_CFG		UINT32_C(0x193)
	/* Experimental */
	#define HWRM_FUNC_BACKING_STORE_QCFG		UINT32_C(0x194)
	/* Configures the BW of any VF */
	#define HWRM_FUNC_VF_BW_CFG			UINT32_C(0x195)
	/* Queries the BW of any VF */
	#define HWRM_FUNC_VF_BW_QCFG			UINT32_C(0x196)
	/* Queries pf ids belong to specified host(s) */
	#define HWRM_FUNC_HOST_PF_IDS_QUERY		UINT32_C(0x197)
	/* Queries extended stats per function */
	#define HWRM_FUNC_QSTATS_EXT			UINT32_C(0x198)
	/* Queries extended statistics context */
	#define HWRM_STAT_EXT_CTX_QUERY		UINT32_C(0x199)
	/* Configure SoC packet DMA settings */
	#define HWRM_FUNC_SPD_CFG			UINT32_C(0x19a)
	/* Query SoC packet DMA settings */
	#define HWRM_FUNC_SPD_QCFG			UINT32_C(0x19b)
	/* PTP - Queries configuration of timesync IO pins. */
	#define HWRM_FUNC_PTP_PIN_QCFG			UINT32_C(0x19c)
	/* PTP - Configuration of timesync IO pins. */
	#define HWRM_FUNC_PTP_PIN_CFG			UINT32_C(0x19d)
	/* PTP - Configuration for disciplining PHC. */
	#define HWRM_FUNC_PTP_CFG			UINT32_C(0x19e)
	/* PTP - Queries for PHC timestamps. */
	#define HWRM_FUNC_PTP_TS_QUERY			UINT32_C(0x19f)
	/* Experimental */
	#define HWRM_SELFTEST_QLIST			UINT32_C(0x200)
	/* Experimental */
	#define HWRM_SELFTEST_EXEC			UINT32_C(0x201)
	/* Experimental */
	#define HWRM_SELFTEST_IRQ			UINT32_C(0x202)
	/* Experimental */
	#define HWRM_SELFTEST_RETRIEVE_SERDES_DATA	UINT32_C(0x203)
	/* Experimental */
	#define HWRM_PCIE_QSTATS			UINT32_C(0x204)
	/* Experimental */
	#define HWRM_MFG_FRU_WRITE_CONTROL		UINT32_C(0x205)
	/* Returns the current value of a free running counter from the device. */
	#define HWRM_MFG_TIMERS_QUERY			UINT32_C(0x206)
	/* Experimental */
	#define HWRM_MFG_OTP_CFG			UINT32_C(0x207)
	/* Experimental */
	#define HWRM_MFG_OTP_QCFG			UINT32_C(0x208)
	/*
	 * Tells the fw to run the DMA read from the host and DMA write
	 * to the host test.
	 */
	#define HWRM_MFG_HDMA_TEST			UINT32_C(0x209)
	/* Tells the fw to program the fru memory */
	#define HWRM_MFG_FRU_EEPROM_WRITE		UINT32_C(0x20a)
	/* Tells the fw to read the fru memory */
	#define HWRM_MFG_FRU_EEPROM_READ		UINT32_C(0x20b)
	/* Used to provision SoC software images */
	#define HWRM_MFG_SOC_IMAGE			UINT32_C(0x20c)
	/* Retrieves the SoC status and image provisioning information */
	#define HWRM_MFG_SOC_QSTATUS			UINT32_C(0x20d)
	/* Tells the fw to program the seeprom memory */
	#define HWRM_MFG_PARAM_SEEPROM_SYNC		UINT32_C(0x20e)
	/* Tells the fw to read the seeprom memory */
	#define HWRM_MFG_PARAM_SEEPROM_READ		UINT32_C(0x20f)
	/* Tells the fw to get the health of seeprom data */
	#define HWRM_MFG_PARAM_SEEPROM_HEALTH		UINT32_C(0x210)
	/* Experimental */
	#define HWRM_TF				UINT32_C(0x2bc)
	/* Experimental */
	#define HWRM_TF_VERSION_GET			UINT32_C(0x2bd)
	/* Experimental */
	#define HWRM_TF_SESSION_OPEN			UINT32_C(0x2c6)
	/* Experimental */
	#define HWRM_TF_SESSION_ATTACH			UINT32_C(0x2c7)
	/* Experimental */
	#define HWRM_TF_SESSION_REGISTER		UINT32_C(0x2c8)
	/* Experimental */
	#define HWRM_TF_SESSION_UNREGISTER		UINT32_C(0x2c9)
	/* Experimental */
	#define HWRM_TF_SESSION_CLOSE			UINT32_C(0x2ca)
	/* Experimental */
	#define HWRM_TF_SESSION_QCFG			UINT32_C(0x2cb)
	/* Experimental */
	#define HWRM_TF_SESSION_RESC_QCAPS		UINT32_C(0x2cc)
	/* Experimental */
	#define HWRM_TF_SESSION_RESC_ALLOC		UINT32_C(0x2cd)
	/* Experimental */
	#define HWRM_TF_SESSION_RESC_FREE		UINT32_C(0x2ce)
	/* Experimental */
	#define HWRM_TF_SESSION_RESC_FLUSH		UINT32_C(0x2cf)
	/* Experimental */
	#define HWRM_TF_SESSION_RESC_INFO		UINT32_C(0x2d0)
	/* Experimental */
	#define HWRM_TF_TBL_TYPE_GET			UINT32_C(0x2da)
	/* Experimental */
	#define HWRM_TF_TBL_TYPE_SET			UINT32_C(0x2db)
	/* Experimental */
	#define HWRM_TF_TBL_TYPE_BULK_GET		UINT32_C(0x2dc)
	/* Experimental */
	#define HWRM_TF_CTXT_MEM_ALLOC			UINT32_C(0x2e2)
	/* Experimental */
	#define HWRM_TF_CTXT_MEM_FREE			UINT32_C(0x2e3)
	/* Experimental */
	#define HWRM_TF_CTXT_MEM_RGTR			UINT32_C(0x2e4)
	/* Experimental */
	#define HWRM_TF_CTXT_MEM_UNRGTR		UINT32_C(0x2e5)
	/* Experimental */
	#define HWRM_TF_EXT_EM_QCAPS			UINT32_C(0x2e6)
	/* Experimental */
	#define HWRM_TF_EXT_EM_OP			UINT32_C(0x2e7)
	/* Experimental */
	#define HWRM_TF_EXT_EM_CFG			UINT32_C(0x2e8)
	/* Experimental */
	#define HWRM_TF_EXT_EM_QCFG			UINT32_C(0x2e9)
	/* Experimental */
	#define HWRM_TF_EM_INSERT			UINT32_C(0x2ea)
	/* Experimental */
	#define HWRM_TF_EM_DELETE			UINT32_C(0x2eb)
	/* Experimental */
	#define HWRM_TF_EM_HASH_INSERT			UINT32_C(0x2ec)
	/* Experimental */
	#define HWRM_TF_EM_MOVE			UINT32_C(0x2ed)
	/* Experimental */
	#define HWRM_TF_TCAM_SET			UINT32_C(0x2f8)
	/* Experimental */
	#define HWRM_TF_TCAM_GET			UINT32_C(0x2f9)
	/* Experimental */
	#define HWRM_TF_TCAM_MOVE			UINT32_C(0x2fa)
	/* Experimental */
	#define HWRM_TF_TCAM_FREE			UINT32_C(0x2fb)
	/* Experimental */
	#define HWRM_TF_GLOBAL_CFG_SET			UINT32_C(0x2fc)
	/* Experimental */
	#define HWRM_TF_GLOBAL_CFG_GET			UINT32_C(0x2fd)
	/* Experimental */
	#define HWRM_TF_IF_TBL_SET			UINT32_C(0x2fe)
	/* Experimental */
	#define HWRM_TF_IF_TBL_GET			UINT32_C(0x2ff)
	/* Experimental */
	#define HWRM_SV				UINT32_C(0x400)
	/* Experimental */
	#define HWRM_DBG_READ_DIRECT			UINT32_C(0xff10)
	/* Experimental */
	#define HWRM_DBG_READ_INDIRECT			UINT32_C(0xff11)
	/* Experimental */
	#define HWRM_DBG_WRITE_DIRECT			UINT32_C(0xff12)
	/* Experimental */
	#define HWRM_DBG_WRITE_INDIRECT		UINT32_C(0xff13)
	#define HWRM_DBG_DUMP				UINT32_C(0xff14)
	/* Experimental */
	#define HWRM_DBG_ERASE_NVM			UINT32_C(0xff15)
	/* Experimental */
	#define HWRM_DBG_CFG				UINT32_C(0xff16)
	/* Experimental */
	#define HWRM_DBG_COREDUMP_LIST			UINT32_C(0xff17)
	/* Experimental */
	#define HWRM_DBG_COREDUMP_INITIATE		UINT32_C(0xff18)
	/* Experimental */
	#define HWRM_DBG_COREDUMP_RETRIEVE		UINT32_C(0xff19)
	/* Experimental */
	#define HWRM_DBG_FW_CLI			UINT32_C(0xff1a)
	/*  */
	#define HWRM_DBG_I2C_CMD			UINT32_C(0xff1b)
	/*  */
	#define HWRM_DBG_RING_INFO_GET			UINT32_C(0xff1c)
	/* Experimental */
	#define HWRM_DBG_CRASHDUMP_HEADER		UINT32_C(0xff1d)
	/* Experimental */
	#define HWRM_DBG_CRASHDUMP_ERASE		UINT32_C(0xff1e)
	/* Send driver debug information to firmware */
	#define HWRM_DBG_DRV_TRACE			UINT32_C(0xff1f)
	/* Query debug capabilities of firmware */
	#define HWRM_DBG_QCAPS				UINT32_C(0xff20)
	/* Retrieve debug settings of firmware */
	#define HWRM_DBG_QCFG				UINT32_C(0xff21)
	/* Set destination parameters for crashdump medium */
	#define HWRM_DBG_CRASHDUMP_MEDIUM_CFG		UINT32_C(0xff22)
	/* Experimental */
	#define HWRM_DBG_USEQ_ALLOC			UINT32_C(0xff23)
	/* Experimental */
	#define HWRM_DBG_USEQ_FREE			UINT32_C(0xff24)
	/* Experimental */
	#define HWRM_DBG_USEQ_FLUSH			UINT32_C(0xff25)
	/* Experimental */
	#define HWRM_DBG_USEQ_QCAPS			UINT32_C(0xff26)
	/* Experimental */
	#define HWRM_DBG_USEQ_CW_CFG			UINT32_C(0xff27)
	/* Experimental */
	#define HWRM_DBG_USEQ_SCHED_CFG		UINT32_C(0xff28)
	/* Experimental */
	#define HWRM_DBG_USEQ_RUN			UINT32_C(0xff29)
	/* Experimental */
	#define HWRM_DBG_USEQ_DELIVERY_REQ		UINT32_C(0xff2a)
	/* Experimental */
	#define HWRM_DBG_USEQ_RESP_HDR			UINT32_C(0xff2b)
	#define HWRM_NVM_REQ_ARBITRATION		UINT32_C(0xffed)
	/* Experimental */
	#define HWRM_NVM_FACTORY_DEFAULTS		UINT32_C(0xffee)
	#define HWRM_NVM_VALIDATE_OPTION		UINT32_C(0xffef)
	#define HWRM_NVM_FLUSH				UINT32_C(0xfff0)
	#define HWRM_NVM_GET_VARIABLE			UINT32_C(0xfff1)
	#define HWRM_NVM_SET_VARIABLE			UINT32_C(0xfff2)
	#define HWRM_NVM_INSTALL_UPDATE		UINT32_C(0xfff3)
	#define HWRM_NVM_MODIFY			UINT32_C(0xfff4)
	#define HWRM_NVM_VERIFY_UPDATE			UINT32_C(0xfff5)
	#define HWRM_NVM_GET_DEV_INFO			UINT32_C(0xfff6)
	#define HWRM_NVM_ERASE_DIR_ENTRY		UINT32_C(0xfff7)
	#define HWRM_NVM_MOD_DIR_ENTRY			UINT32_C(0xfff8)
	#define HWRM_NVM_FIND_DIR_ENTRY		UINT32_C(0xfff9)
	#define HWRM_NVM_GET_DIR_ENTRIES		UINT32_C(0xfffa)
	#define HWRM_NVM_GET_DIR_INFO			UINT32_C(0xfffb)
	#define HWRM_NVM_RAW_DUMP			UINT32_C(0xfffc)
	#define HWRM_NVM_READ				UINT32_C(0xfffd)
	#define HWRM_NVM_WRITE				UINT32_C(0xfffe)
	#define HWRM_NVM_RAW_WRITE_BLK			UINT32_C(0xffff)
	#define HWRM_LAST				HWRM_NVM_RAW_WRITE_BLK
	uint16_t	unused_0[3];
} cmd_nums_t, *pcmd_nums_t;

/* Return Codes */
/* ret_codes (size:64b/8B) */

typedef struct ret_codes {
	uint16_t	error_code;
	/* Request was successfully executed by the HWRM. */
	#define HWRM_ERR_CODE_SUCCESS			UINT32_C(0x0)
	/* The HWRM failed to execute the request. */
	#define HWRM_ERR_CODE_FAIL			UINT32_C(0x1)
	/*
	 * The request contains invalid argument(s) or input
	 * parameters.
	 */
	#define HWRM_ERR_CODE_INVALID_PARAMS		UINT32_C(0x2)
	/*
	 * The requester is not allowed to access the requested
	 * resource. This error code shall be provided in a
	 * response to a request to query or modify an existing
	 * resource that is not accessible by the requester.
	 */
	#define HWRM_ERR_CODE_RESOURCE_ACCESS_DENIED	UINT32_C(0x3)
	/*
	 * The HWRM is unable to allocate the requested resource.
	 * This code only applies to requests for HWRM resource
	 * allocations.
	 */
	#define HWRM_ERR_CODE_RESOURCE_ALLOC_ERROR	UINT32_C(0x4)
	/*
	 * Invalid combination of flags is specified in the
	 * request.
	 */
	#define HWRM_ERR_CODE_INVALID_FLAGS		UINT32_C(0x5)
	/*
	 * Invalid combination of enables fields is specified in
	 * the request.
	 */
	#define HWRM_ERR_CODE_INVALID_ENABLES		UINT32_C(0x6)
	/*
	 * Request contains a required TLV that is not supported by
	 * the installed version of firmware.
	 */
	#define HWRM_ERR_CODE_UNSUPPORTED_TLV		UINT32_C(0x7)
	/*
	 * No firmware buffer available to accept the request. Driver
	 * should retry the request.
	 */
	#define HWRM_ERR_CODE_NO_BUFFER			UINT32_C(0x8)
	/*
	 * This error code is only reported by firmware when some
	 * sub-option of a supported HWRM command is unsupported.
	 */
	#define HWRM_ERR_CODE_UNSUPPORTED_OPTION_ERR	UINT32_C(0x9)
	/*
	 * This error code is only reported by firmware when the specific
	 * request is not able to process when the HOT reset in progress.
	 */
	#define HWRM_ERR_CODE_HOT_RESET_PROGRESS	UINT32_C(0xa)
	/*
	 * This error code is only reported by firmware when the registered
	 * driver instances are not capable of hot reset.
	 */
	#define HWRM_ERR_CODE_HOT_RESET_FAIL		UINT32_C(0xb)
	/*
	 * This error code is only reported by the firmware when during
	 * flow allocation when a request for a flow counter fails because
	 * the number of flow counters are exhausted.
	 */
	#define HWRM_ERR_CODE_NO_FLOW_COUNTER_DURING_ALLOC UINT32_C(0xc)
	/*
	 * This error code is only reported by firmware when the registered
	 * driver instances requested to offloaded a flow but was unable to because
	 * the requested key's hash collides with the installed keys.
	 */
	#define HWRM_ERR_CODE_KEY_HASH_COLLISION	UINT32_C(0xd)
	/*
	 * This error code is only reported by firmware when the registered
	 * driver instances requested to offloaded a flow but was unable to because
	 * the same key has already been installed.
	 */
	#define HWRM_ERR_CODE_KEY_ALREADY_EXISTS	UINT32_C(0xe)
	/*
	 * Generic HWRM execution error that represents an
	 * internal error.
	 */
	#define HWRM_ERR_CODE_HWRM_ERROR		UINT32_C(0xf)
	/*
	 * Firmware is unable to service the request at the present time. Caller
	 * may try again later.
	 */
	#define HWRM_ERR_CODE_BUSY			UINT32_C(0x10)
	/*
	 * This error code is reported by Firmware when an operation requested
	 * by the host is not allowed due to a secure lock violation.
	 */
	#define HWRM_ERR_CODE_RESOURCE_LOCKED		UINT32_C(0x11)
	/*
	 * This value indicates that the HWRM response is in TLV format and
	 * should be interpreted as one or more TLVs starting with the
	 * hwrm_resp_hdr TLV. This value is not an indication of any error
	 * by itself, just an indication that the response should be parsed
	 * as TLV and the actual error code will be in the hwrm_resp_hdr TLV.
	 */
	#define HWRM_ERR_CODE_TLV_ENCAPSULATED_RESPONSE	UINT32_C(0x8000)
	/* Unknown error */
	#define HWRM_ERR_CODE_UNKNOWN_ERR		UINT32_C(0xfffe)
	/* Unsupported or invalid command */
	#define HWRM_ERR_CODE_CMD_NOT_SUPPORTED		UINT32_C(0xffff)
	#define HWRM_ERR_CODE_LAST			HWRM_ERR_CODE_CMD_NOT_SUPPORTED
	uint16_t	unused_0[3];
} ret_codes_t, *pret_codes_t;

#define GET_HWRM_ERROR_CODE(x) \
	(((x) < 0x80) ? \
	((x) == 0x0 ? "SUCCESS": \
	((x) == 0x1 ? "FAIL": \
	((x) == 0x2 ? "INVALID_PARAMS": \
	((x) == 0x3 ? "RESOURCE_ACCESS_DENIED": \
	((x) == 0x4 ? "RESOURCE_ALLOC_ERROR": \
	((x) == 0x5 ? "INVALID_FLAGS": \
	((x) == 0x6 ? "INVALID_ENABLES": \
	((x) == 0x7 ? "UNSUPPORTED_TLV": \
	((x) == 0x8 ? "NO_BUFFER": \
	((x) == 0x9 ? "UNSUPPORTED_OPTION_ERR": \
	((x) == 0xa ? "HOT_RESET_PROGRESS": \
	((x) == 0xb ? "HOT_RESET_FAIL": \
	((x) == 0xc ? "NO_FLOW_COUNTER_DURING_ALLOC": \
	((x) == 0xd ? "KEY_HASH_COLLISION": \
	((x) == 0xe ? "KEY_ALREADY_EXISTS": \
	((x) == 0xf ? "HWRM_ERROR": \
	((x) == 0x10 ? "BUSY": \
	((x) == 0x11 ? "RESOURCE_LOCKED": \
	"Unknown decode" )))))))))))))))))) : \
	(((x) < 0x8080) ? \
	((x) == 0x8000 ? "TLV_ENCAPSULATED_RESPONSE": \
	"Unknown decode" ) : \
	(((x) <= 0xffff) ? \
	((x) == 0xfffe ? "UNKNOWN_ERR": \
	((x) == 0xffff ? "CMD_NOT_SUPPORTED": \
	"Unknown decode" )) : \
	"Unknown decode" )))


/* Output */
/* hwrm_err_output (size:128b/16B) */

typedef struct hwrm_err_output {
	/*
	 * Pass/Fail or error type
	 *
	 * Note: receiver to verify the in parameters, and fail the call
	 * with an error when appropriate
	 */
	uint16_t	error_code;
	/* This field returns the type of original request. */
	uint16_t	req_type;
	/* This field provides original sequence number of the command. */
	uint16_t	seq_id;
	/*
	 * This field is the length of the response in bytes.  The
	 * last byte of the response is a valid flag that will read
	 * as '1' when the command has been completely written to
	 * memory.
	 */
	uint16_t	resp_len;
	/* debug info for this error response. */
	uint32_t	opaque_0;
	/* debug info for this error response. */
	uint16_t	opaque_1;
	/*
	 * In the case of an error response, command specific error
	 * code is returned in this field.
	 */
	uint8_t	cmd_err;
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_err_output_t, *phwrm_err_output_t;

/*
 * Following is the signature for HWRM message field that indicates not
 * applicable (All F's). Need to cast it the size of the field if needed.
 */
#define HWRM_NA_SIGNATURE ((uint32_t)(-1))
/* hwrm_func_buf_rgtr */
#define HWRM_MAX_REQ_LEN 128
/* hwrm_cfa_flow_info */
#define HWRM_MAX_RESP_LEN 704
/* 7 bit indirection table index. */
#define HW_HASH_INDEX_SIZE 0x80
#define HW_HASH_KEY_SIZE 40
/* valid key for HWRM response */
#define HWRM_RESP_VALID_KEY 1
/* Reserved for BONO processor */
#define HWRM_TARGET_ID_BONO 0xFFF8
/* Reserved for KONG processor */
#define HWRM_TARGET_ID_KONG 0xFFF9
/* Reserved for APE processor */
#define HWRM_TARGET_ID_APE 0xFFFA
/*
 * This value will be used by tools for User-space HWRM Interface.
 * When tool execute any HWRM command with this target_id, firmware
 * will copy the response and/or data payload via register space instead
 * of DMAing it.
 */
#define HWRM_TARGET_ID_TOOLS 0xFFFD
#define HWRM_VERSION_MAJOR 1
#define HWRM_VERSION_MINOR 10
#define HWRM_VERSION_UPDATE 2
/* non-zero means beta version */
#define HWRM_VERSION_RSVD 34
#define HWRM_VERSION_STR "1.10.2.34"

/****************
 * hwrm_ver_get *
 ****************/


/* hwrm_ver_get_input (size:192b/24B) */

typedef struct hwrm_ver_get_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * This field represents the major version of HWRM interface
	 * specification supported by the driver HWRM implementation.
	 * The interface major version is intended to change only when
	 * non backward compatible changes are made to the HWRM
	 * interface specification.
	 */
	uint8_t	hwrm_intf_maj;
	/*
	 * This field represents the minor version of HWRM interface
	 * specification supported by the driver HWRM implementation.
	 * A change in interface minor version is used to reflect
	 * significant backward compatible modification to HWRM
	 * interface specification.
	 * This can be due to addition or removal of functionality.
	 * HWRM interface specifications with the same major version
	 * but different minor versions are compatible.
	 */
	uint8_t	hwrm_intf_min;
	/*
	 * This field represents the update version of HWRM interface
	 * specification supported by the driver HWRM implementation.
	 * The interface update version is used to reflect minor
	 * changes or bug fixes to a released HWRM interface
	 * specification.
	 */
	uint8_t	hwrm_intf_upd;
	uint8_t	unused_0[5];
} hwrm_ver_get_input_t, *phwrm_ver_get_input_t;

/* hwrm_ver_get_output (size:1408b/176B) */

typedef struct hwrm_ver_get_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * This field represents the major version of HWRM interface
	 * specification supported by the HWRM implementation.
	 * The interface major version is intended to change only when
	 * non backward compatible changes are made to the HWRM
	 * interface specification.
	 * A HWRM implementation that is compliant with this
	 * specification shall provide value of 1 in this field.
	 */
	uint8_t	hwrm_intf_maj_8b;
	/*
	 * This field represents the minor version of HWRM interface
	 * specification supported by the HWRM implementation.
	 * A change in interface minor version is used to reflect
	 * significant backward compatible modification to HWRM
	 * interface specification.
	 * This can be due to addition or removal of functionality.
	 * HWRM interface specifications with the same major version
	 * but different minor versions are compatible.
	 * A HWRM implementation that is compliant with this
	 * specification shall provide value of 2 in this field.
	 */
	uint8_t	hwrm_intf_min_8b;
	/*
	 * This field represents the update version of HWRM interface
	 * specification supported by the HWRM implementation.
	 * The interface update version is used to reflect minor
	 * changes or bug fixes to a released HWRM interface
	 * specification.
	 * A HWRM implementation that is compliant with this
	 * specification shall provide value of 2 in this field.
	 */
	uint8_t	hwrm_intf_upd_8b;
	uint8_t	hwrm_intf_rsvd_8b;
	/*
	 * This field represents the major version of HWRM firmware.
	 * A change in firmware major version represents a major
	 * firmware release.
	 */
	uint8_t	hwrm_fw_maj_8b;
	/*
	 * This field represents the minor version of HWRM firmware.
	 * A change in firmware minor version represents significant
	 * firmware functionality changes.
	 */
	uint8_t	hwrm_fw_min_8b;
	/*
	 * This field represents the build version of HWRM firmware.
	 * A change in firmware build version represents bug fixes
	 * to a released firmware.
	 */
	uint8_t	hwrm_fw_bld_8b;
	/*
	 * This field is a reserved field. This field can be used to
	 * represent firmware branches or customer specific releases
	 * tied to a specific (major,minor,update) version of the
	 * HWRM firmware.
	 */
	uint8_t	hwrm_fw_rsvd_8b;
	/*
	 * This field represents the major version of mgmt firmware.
	 * A change in major version represents a major release.
	 */
	uint8_t	mgmt_fw_maj_8b;
	/*
	 * This field represents the minor version of mgmt firmware.
	 * A change in minor version represents significant
	 * functionality changes.
	 */
	uint8_t	mgmt_fw_min_8b;
	/*
	 * This field represents the build version of mgmt firmware.
	 * A change in update version represents bug fixes.
	 */
	uint8_t	mgmt_fw_bld_8b;
	/*
	 * This field is a reserved field. This field can be used to
	 * represent firmware branches or customer specific releases
	 * tied to a specific (major,minor,update) version
	 */
	uint8_t	mgmt_fw_rsvd_8b;
	/*
	 * This field represents the major version of network
	 * control firmware.
	 * A change in major version represents a major release.
	 */
	uint8_t	netctrl_fw_maj_8b;
	/*
	 * This field represents the minor version of network
	 * control firmware.
	 * A change in minor version represents significant
	 * functionality changes.
	 */
	uint8_t	netctrl_fw_min_8b;
	/*
	 * This field represents the build version of network
	 * control firmware.
	 * A change in update version represents bug fixes.
	 */
	uint8_t	netctrl_fw_bld_8b;
	/*
	 * This field is a reserved field. This field can be used to
	 * represent firmware branches or customer specific releases
	 * tied to a specific (major,minor,update) version
	 */
	uint8_t	netctrl_fw_rsvd_8b;
	/*
	 * This field is used to indicate device's capabilities and
	 * configurations.
	 */
	uint32_t	dev_caps_cfg;
	/*
	 * If set to 1, then secure firmware update behavior
	 * is supported.
	 * If set to 0, then secure firmware update behavior is
	 * not supported.
	 */
	#define HWRM_VER_GET_OUTPUT_DEV_CAPS_CFG_SECURE_FW_UPD_SUPPORTED		UINT32_C(0x1)
	/*
	 * If set to 1, then firmware based DCBX agent is supported.
	 * If set to 0, then firmware based DCBX agent capability
	 * is not supported on this device.
	 */
	#define HWRM_VER_GET_OUTPUT_DEV_CAPS_CFG_FW_DCBX_AGENT_SUPPORTED		UINT32_C(0x2)
	/*
	 * If set to 1, then HWRM short command format is supported.
	 * If set to 0, then HWRM short command format is not supported.
	 */
	#define HWRM_VER_GET_OUTPUT_DEV_CAPS_CFG_SHORT_CMD_SUPPORTED			UINT32_C(0x4)
	/*
	 * If set to 1, then HWRM short command format is required.
	 * If set to 0, then HWRM short command format is not required.
	 */
	#define HWRM_VER_GET_OUTPUT_DEV_CAPS_CFG_SHORT_CMD_REQUIRED			UINT32_C(0x8)
	/*
	 * If set to 1, then the KONG host mailbox channel is supported.
	 * If set to 0, then the KONG host mailbox channel is not supported.
	 * By default, this flag should be 0 for older version of core firmware.
	 */
	#define HWRM_VER_GET_OUTPUT_DEV_CAPS_CFG_KONG_MB_CHNL_SUPPORTED		UINT32_C(0x10)
	/*
	 * If set to 1, then the 64bit flow handle is supported in addition to the
	 * legacy 16bit flow handle. If set to 0, then the 64bit flow handle is not
	 * supported. By default, this flag should be 0 for older version of core firmware.
	 */
	#define HWRM_VER_GET_OUTPUT_DEV_CAPS_CFG_FLOW_HANDLE_64BIT_SUPPORTED		UINT32_C(0x20)
	/*
	 * If set to 1, then filter type can be provided in filter_alloc or filter_cfg
	 * filter types like L2 for l2 traffic and ROCE for roce & l2 traffic.
	 * If set to 0, then filter types not supported.
	 * By default, this flag should be 0 for older version of core firmware.
	 */
	#define HWRM_VER_GET_OUTPUT_DEV_CAPS_CFG_L2_FILTER_TYPES_ROCE_OR_L2_SUPPORTED	UINT32_C(0x40)
	/*
	 * If set to 1, firmware is capable to support virtio vSwitch offload model.
	 * If set to 0, firmware can't supported virtio vSwitch offload model.
	 * By default, this flag should be 0 for older version of core firmware.
	 */
	#define HWRM_VER_GET_OUTPUT_DEV_CAPS_CFG_VIRTIO_VSWITCH_OFFLOAD_SUPPORTED	UINT32_C(0x80)
	/*
	 * If set to 1, firmware is capable to support trusted VF.
	 * If set to 0, firmware is not capable to support trusted VF.
	 * By default, this flag should be 0 for older version of core firmware.
	 */
	#define HWRM_VER_GET_OUTPUT_DEV_CAPS_CFG_TRUSTED_VF_SUPPORTED			UINT32_C(0x100)
	/*
	 * If set to 1, firmware is capable to support flow aging.
	 * If set to 0, firmware is not capable to support flow aging.
	 * By default, this flag should be 0 for older version of core firmware.
	 */
	#define HWRM_VER_GET_OUTPUT_DEV_CAPS_CFG_FLOW_AGING_SUPPORTED			UINT32_C(0x200)
	/*
	 * If set to 1, firmware is capable to support advanced flow counters like,
	 * Meter drop counters and EEM counters.
	 * If set to 0, firmware is not capable to support advanced flow counters.
	 * By default, this flag should be 0 for older version of core firmware.
	 */
	#define HWRM_VER_GET_OUTPUT_DEV_CAPS_CFG_ADV_FLOW_COUNTERS_SUPPORTED		UINT32_C(0x400)
	/*
	 * If set to 1, the firmware is able to support the use of the CFA
	 * Extended Exact Match(EEM) feature.
	 * If set to 0, firmware is not capable to support the use of the
	 * CFA EEM feature.
	 * By default, this flag should be 0 for older version of core firmware.
	 */
	#define HWRM_VER_GET_OUTPUT_DEV_CAPS_CFG_CFA_EEM_SUPPORTED			UINT32_C(0x800)
	/*
	 * If set to 1, the firmware is able to support advance CFA flow management
	 * features reported in the HWRM_CFA_FLOW_MGNT_QCAPS.
	 * If set to 0, then the firmware doesn’t support the advance CFA flow management
	 * features.
	 * By default, this flag should be 0 for older version of core firmware.
	 */
	#define HWRM_VER_GET_OUTPUT_DEV_CAPS_CFG_CFA_ADV_FLOW_MGNT_SUPPORTED		UINT32_C(0x1000)
	/*
	 * Deprecated and replaced with cfa_truflow_supported.
	 * If set to 1, the firmware is able to support TFLIB features.
	 * If set to 0, then the firmware doesn’t support TFLIB features.
	 * By default, this flag should be 0 for older version of core firmware.
	 */
	#define HWRM_VER_GET_OUTPUT_DEV_CAPS_CFG_CFA_TFLIB_SUPPORTED			UINT32_C(0x2000)
	/*
	 * If set to 1, the firmware is able to support TruFlow features.
	 * If set to 0, then the firmware doesn’t support TruFlow features.
	 * By default, this flag should be 0 for older version of
	 * core firmware.
	 */
	#define HWRM_VER_GET_OUTPUT_DEV_CAPS_CFG_CFA_TRUFLOW_SUPPORTED			UINT32_C(0x4000)
	/*
	 * This field represents the major version of RoCE firmware.
	 * A change in major version represents a major release.
	 */
	uint8_t	roce_fw_maj_8b;
	/*
	 * This field represents the minor version of RoCE firmware.
	 * A change in minor version represents significant
	 * functionality changes.
	 */
	uint8_t	roce_fw_min_8b;
	/*
	 * This field represents the build version of RoCE firmware.
	 * A change in update version represents bug fixes.
	 */
	uint8_t	roce_fw_bld_8b;
	/*
	 * This field is a reserved field. This field can be used to
	 * represent firmware branches or customer specific releases
	 * tied to a specific (major,minor,update) version
	 */
	uint8_t	roce_fw_rsvd_8b;
	/*
	 * This field represents the name of HWRM FW (ASCII chars
	 * with NULL at the end).
	 */
	char	hwrm_fw_name[16];
	/*
	 * This field represents the name of mgmt FW (ASCII chars
	 * with NULL at the end).
	 */
	char	mgmt_fw_name[16];
	/*
	 * This field represents the name of network control
	 * firmware (ASCII chars with NULL at the end).
	 */
	char	netctrl_fw_name[16];
	/* This field represents the active board package name. */
	char	active_pkg_name[16];
	/*
	 * This field represents the name of RoCE FW (ASCII chars
	 * with NULL at the end).
	 */
	char	roce_fw_name[16];
	/* This field returns the chip number. */
	uint16_t	chip_num;
	/* This field returns the revision of chip. */
	uint8_t	chip_rev;
	/* This field returns the chip metal number. */
	uint8_t	chip_metal;
	/* This field returns the bond id of the chip. */
	uint8_t	chip_bond_id;
	/* This value indicates the type of platform used for chip implementation. */
	uint8_t	chip_platform_type;
	/* ASIC */
	#define HWRM_VER_GET_OUTPUT_CHIP_PLATFORM_TYPE_ASIC	UINT32_C(0x0)
	/* FPGA platform of the chip. */
	#define HWRM_VER_GET_OUTPUT_CHIP_PLATFORM_TYPE_FPGA	UINT32_C(0x1)
	/* Palladium platform of the chip. */
	#define HWRM_VER_GET_OUTPUT_CHIP_PLATFORM_TYPE_PALLADIUM UINT32_C(0x2)
	#define HWRM_VER_GET_OUTPUT_CHIP_PLATFORM_TYPE_LAST	HWRM_VER_GET_OUTPUT_CHIP_PLATFORM_TYPE_PALLADIUM
	/*
	 * This field returns the maximum value of request window that
	 * is supported by the HWRM. The request window is mapped
	 * into device address space using MMIO.
	 */
	uint16_t	max_req_win_len;
	/*
	 * This field returns the maximum value of response buffer in
	 * bytes.
	 */
	uint16_t	max_resp_len;
	/*
	 * This field returns the default request timeout value in
	 * milliseconds.
	 */
	uint16_t	def_req_timeout;
	/*
	 * This field will indicate if any subsystems is not fully
	 * initialized.
	 */
	uint8_t	flags;
	/*
	 * If set to 1, it will indicate to host drivers that firmware is
	 * not ready to start full blown HWRM commands. Host drivers should
	 * re-try HWRM_VER_GET with some timeout period. The timeout period
	 * can be selected up to 5 seconds. Host drivers should also check
	 * for dev_not_rdy_backing_store to identify if flag is set due to
	 * backing store not been available.
	 * For Example, PCIe hot-plug:
	 *	Hot plug timing is system dependent. It generally takes up to
	 *	600 miliseconds for firmware to clear DEV_NOT_RDY flag.
	 * If set to 0, device is ready to accept all HWRM commands.
	 */
	#define HWRM_VER_GET_OUTPUT_FLAGS_DEV_NOT_RDY		UINT32_C(0x1)
	/*
	 * If set to 1, external version present.
	 * If set to 0, external version not present.
	 */
	#define HWRM_VER_GET_OUTPUT_FLAGS_EXT_VER_AVAIL		UINT32_C(0x2)
	/*
	 * Firmware sets this flag along with dev_not_rdy flag to indicate
	 * host drivers that it has not completed resource initialization
	 * required for data path operations. Host drivers should not send
	 * any HWRM command that requires data path resources. Firmware will
	 * fail those commands with HWRM_ERR_CODE_BUSY. Host drivers can retry
	 * those commands once both the flags are cleared.
	 * If this flag and dev_not_rdy flag are set to 0, device is ready
	 * to accept all HWRM commands.
	 */
	#define HWRM_VER_GET_OUTPUT_FLAGS_DEV_NOT_RDY_BACKING_STORE	UINT32_C(0x4)
	uint8_t	unused_0[2];
	/*
	 * For backward compatibility this field must be set to 1.
	 * Older drivers might look for this field to be 1 before
	 * processing the message.
	 */
	uint8_t	always_1;
	/*
	 * This field represents the major version of HWRM interface
	 * specification supported by the HWRM implementation.
	 * The interface major version is intended to change only when
	 * non backward compatible changes are made to the HWRM
	 * interface specification. A HWRM implementation that is
	 * compliant with this specification shall provide value of 1
	 * in this field.
	 */
	uint16_t	hwrm_intf_major;
	/*
	 * This field represents the minor version of HWRM interface
	 * specification supported by the HWRM implementation.
	 * A change in interface minor version is used to reflect
	 * significant backward compatible modification to HWRM
	 * interface specification. This can be due to addition or
	 * removal of functionality. HWRM interface specifications
	 * with the same major version but different minor versions are
	 * compatible. A HWRM implementation that is compliant with
	 * this specification shall provide value of 2 in this field.
	 */
	uint16_t	hwrm_intf_minor;
	/*
	 * This field represents the update version of HWRM interface
	 * specification supported by the HWRM implementation. The
	 * interface update version is used to reflect minor changes or
	 * bug fixes to a released HWRM interface specification.
	 * A HWRM implementation that is compliant with this
	 * specification shall provide value of 2 in this field.
	 */
	uint16_t	hwrm_intf_build;
	/*
	 * This field represents the patch version of HWRM interface
	 * specification supported by the HWRM implementation.
	 */
	uint16_t	hwrm_intf_patch;
	/*
	 * This field represents the major version of HWRM firmware.
	 * A change in firmware major version represents a major
	 * firmware release.
	 */
	uint16_t	hwrm_fw_major;
	/*
	 * This field represents the minor version of HWRM firmware.
	 * A change in firmware minor version represents significant
	 * firmware functionality changes.
	 */
	uint16_t	hwrm_fw_minor;
	/*
	 * This field represents the build version of HWRM firmware.
	 * A change in firmware build version represents bug fixes to
	 * a released firmware.
	 */
	uint16_t	hwrm_fw_build;
	/*
	 * This field is a reserved field.
	 * This field can be used to represent firmware branches or customer
	 * specific releases tied to a specific (major,minor,update) version
	 * of the HWRM firmware.
	 */
	uint16_t	hwrm_fw_patch;
	/*
	 * This field represents the major version of mgmt firmware.
	 * A change in major version represents a major release.
	 */
	uint16_t	mgmt_fw_major;
	/*
	 * This field represents the minor version of HWRM firmware.
	 * A change in firmware minor version represents significant
	 * firmware functionality changes.
	 */
	uint16_t	mgmt_fw_minor;
	/*
	 * This field represents the build version of mgmt firmware.
	 * A change in update version represents bug fixes.
	 */
	uint16_t	mgmt_fw_build;
	/*
	 * This field is a reserved field. This field can be used to
	 * represent firmware branches or customer specific releases
	 * tied to a specific (major,minor,update) version.
	 */
	uint16_t	mgmt_fw_patch;
	/*
	 * This field represents the major version of network control
	 * firmware. A change in major version represents
	 * a major release.
	 */
	uint16_t	netctrl_fw_major;
	/*
	 * This field represents the minor version of network control
	 * firmware. A change in minor version represents significant
	 * functionality changes.
	 */
	uint16_t	netctrl_fw_minor;
	/*
	 * This field represents the build version of network control
	 * firmware. A change in update version represents bug fixes.
	 */
	uint16_t	netctrl_fw_build;
	/*
	 * This field is a reserved field. This field can be used to
	 * represent firmware branches or customer specific releases
	 * tied to a specific (major,minor,update) version
	 */
	uint16_t	netctrl_fw_patch;
	/*
	 * This field represents the major version of RoCE firmware.
	 * A change in major version represents a major release.
	 */
	uint16_t	roce_fw_major;
	/*
	 * This field represents the minor version of RoCE firmware.
	 * A change in minor version represents significant
	 * functionality changes.
	 */
	uint16_t	roce_fw_minor;
	/*
	 * This field represents the build version of RoCE firmware.
	 * A change in update version represents bug fixes.
	 */
	uint16_t	roce_fw_build;
	/*
	 * This field is a reserved field. This field can be used to
	 * represent firmware branches or customer specific releases
	 * tied to a specific (major,minor,update) version
	 */
	uint16_t	roce_fw_patch;
	/*
	 * This field returns the maximum extended request length acceptable
	 * by the device which allows requests greater than mailbox size when
	 * used with the short cmd request format.
	 */
	uint16_t	max_ext_req_len;
	uint8_t	unused_1[5];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_ver_get_output_t, *phwrm_ver_get_output_t;

/* cfa_bds_read_cmd_data_msg (size:128b/16B) */

typedef struct cfa_bds_read_cmd_data_msg {
	/* This value selects the format for the mid-path command for the CFA. */
	uint8_t	opcode;
	/*
	 * This is read command. From 32 to 128B can be read from a table
	 * using this command.
	 */
	#define CFA_BDS_READ_CMD_DATA_MSG_OPCODE_READ UINT32_C(0x0)
	#define CFA_BDS_READ_CMD_DATA_MSG_OPCODE_LAST CFA_BDS_READ_CMD_DATA_MSG_OPCODE_READ
	/* This value selects the table type to be acted upon. */
	uint8_t	table_type;
	/* This value selects the table type to be acted upon. */
	#define CFA_BDS_READ_CMD_DATA_MSG_TABLE_TYPE_MASK  UINT32_C(0xf)
	#define CFA_BDS_READ_CMD_DATA_MSG_TABLE_TYPE_SFT   0
	/* This command acts on the action table of the specified scope. */
		#define CFA_BDS_READ_CMD_DATA_MSG_TABLE_TYPE_ACTION  UINT32_C(0x0)
	/* This command acts on the exact match table of the specified scope. */
		#define CFA_BDS_READ_CMD_DATA_MSG_TABLE_TYPE_EM	UINT32_C(0x1)
		#define CFA_BDS_READ_CMD_DATA_MSG_TABLE_TYPE_LAST   CFA_BDS_READ_CMD_DATA_MSG_TABLE_TYPE_EM
	/* This value selects which table scope will be accessed. */
	uint8_t	table_scope;
	#define CFA_BDS_READ_CMD_DATA_MSG_TABLE_SCOPE_MASK UINT32_C(0x1f)
	#define CFA_BDS_READ_CMD_DATA_MSG_TABLE_SCOPE_SFT 0
	/*
	 * This value identifies the number of 32B units will be accessed. A
	 * value of zero is invalid. Maximum value is 4.
	 */
	uint8_t	data_size;
	#define CFA_BDS_READ_CMD_DATA_MSG_DATA_SIZE_MASK UINT32_C(0x7)
	#define CFA_BDS_READ_CMD_DATA_MSG_DATA_SIZE_SFT 0
	/* This is the 32B index into the selected table to access. */
	uint32_t	table_index;
	#define CFA_BDS_READ_CMD_DATA_MSG_TABLE_INDEX_MASK UINT32_C(0x3ffffff)
	#define CFA_BDS_READ_CMD_DATA_MSG_TABLE_INDEX_SFT 0
	/*
	 * This is the 64b host address where you want the data returned to. The
	 * data will be written to the same function as the one that owns the SQ
	 * this command is read from. The bottom two bits of this value must be
	 * zero. The size of the write is controlled by the data_size field.
	 */
	uint64_t	host_address;
} cfa_bds_read_cmd_data_msg_t, *pcfa_bds_read_cmd_data_msg_t;

/* cfa_bds_write_cmd_data_msg (size:1152b/144B) */

typedef struct cfa_bds_write_cmd_data_msg {
	/* This value selects the format for the mid-path command for the CFA. */
	uint8_t	opcode;
	/*
	 * This is write command. From 32 to 128B can be written to a table
	 * using this command.
	 */
	#define CFA_BDS_WRITE_CMD_DATA_MSG_OPCODE_WRITE UINT32_C(0x1)
	#define CFA_BDS_WRITE_CMD_DATA_MSG_OPCODE_LAST CFA_BDS_WRITE_CMD_DATA_MSG_OPCODE_WRITE
	/* This value selects the table type to be acted upon. */
	uint8_t	write_thru_table_type;
	/* This value selects the table type to be acted upon. */
	#define CFA_BDS_WRITE_CMD_DATA_MSG_TABLE_TYPE_MASK  UINT32_C(0xf)
	#define CFA_BDS_WRITE_CMD_DATA_MSG_TABLE_TYPE_SFT   0
	/* This command acts on the action table of the specified scope. */
		#define CFA_BDS_WRITE_CMD_DATA_MSG_TABLE_TYPE_ACTION  UINT32_C(0x0)
	/* This command acts on the exact match table of the specified scope. */
		#define CFA_BDS_WRITE_CMD_DATA_MSG_TABLE_TYPE_EM	UINT32_C(0x1)
		#define CFA_BDS_WRITE_CMD_DATA_MSG_TABLE_TYPE_LAST   CFA_BDS_WRITE_CMD_DATA_MSG_TABLE_TYPE_EM
	/*
	 * Indicates write-through control. Indicates write-through when set,
	 * or write back when cleared.
	 */
	#define CFA_BDS_WRITE_CMD_DATA_MSG_WRITE_THRU	UINT32_C(0x10)
	/* This value selects which table scope will be accessed. */
	uint8_t	table_scope;
	#define CFA_BDS_WRITE_CMD_DATA_MSG_TABLE_SCOPE_MASK UINT32_C(0x1f)
	#define CFA_BDS_WRITE_CMD_DATA_MSG_TABLE_SCOPE_SFT 0
	/*
	 * This value identifies the number of 32B units will be accessed. A
	 * value of zero is invalid. Maximum value is 4.
	 */
	uint8_t	data_size;
	#define CFA_BDS_WRITE_CMD_DATA_MSG_DATA_SIZE_MASK UINT32_C(0x7)
	#define CFA_BDS_WRITE_CMD_DATA_MSG_DATA_SIZE_SFT 0
	/* This is the 32B index into the selected table to access. */
	uint32_t	table_index;
	#define CFA_BDS_WRITE_CMD_DATA_MSG_TABLE_INDEX_MASK UINT32_C(0x3ffffff)
	#define CFA_BDS_WRITE_CMD_DATA_MSG_TABLE_INDEX_SFT 0
	uint32_t	unused0;
	uint32_t	unused1;
	/*
	 * This is the data to be written. Data length is determined by the
	 * data_size field. The bd_cnt in the encapsulating BD must also be set
	 * correctly to ensure that the BD is processed correctly and the full
	 * WRITE_CMD message is extracted from the BD.
	 */
	uint32_t	dta[32];
} cfa_bds_write_cmd_data_msg_t, *pcfa_bds_write_cmd_data_msg_t;

/* cfa_bds_read_clr_cmd_data_msg (size:256b/32B) */

typedef struct cfa_bds_read_clr_cmd_data_msg {
	/* This value selects the format for the mid-path command for the CFA. */
	uint8_t	opcode;
	/*
	 * This is read-clear command. 32B can be read from a table and
	 * a 16b mask can be used to clear specific 16b units after the
	 * read as an atomic operation.
	 */
	#define CFA_BDS_READ_CLR_CMD_DATA_MSG_OPCODE_READ_CLR UINT32_C(0x2)
	#define CFA_BDS_READ_CLR_CMD_DATA_MSG_OPCODE_LAST	CFA_BDS_READ_CLR_CMD_DATA_MSG_OPCODE_READ_CLR
	/* This value selects the table type to be acted upon. */
	uint8_t	table_type;
	/* This value selects the table type to be acted upon. */
	#define CFA_BDS_READ_CLR_CMD_DATA_MSG_TABLE_TYPE_MASK  UINT32_C(0xf)
	#define CFA_BDS_READ_CLR_CMD_DATA_MSG_TABLE_TYPE_SFT   0
	/* This command acts on the action table of the specified scope. */
		#define CFA_BDS_READ_CLR_CMD_DATA_MSG_TABLE_TYPE_ACTION  UINT32_C(0x0)
	/* This command acts on the exact match table of the specified scope. */
		#define CFA_BDS_READ_CLR_CMD_DATA_MSG_TABLE_TYPE_EM	UINT32_C(0x1)
		#define CFA_BDS_READ_CLR_CMD_DATA_MSG_TABLE_TYPE_LAST   CFA_BDS_READ_CLR_CMD_DATA_MSG_TABLE_TYPE_EM
	/* This value selects which table scope will be accessed. */
	uint8_t	table_scope;
	#define CFA_BDS_READ_CLR_CMD_DATA_MSG_TABLE_SCOPE_MASK UINT32_C(0x1f)
	#define CFA_BDS_READ_CLR_CMD_DATA_MSG_TABLE_SCOPE_SFT 0
	/*
	 * This value identifies the number of 32B units will be accessed.
	 * Always set the value to 1.
	 */
	uint8_t	data_size;
	#define CFA_BDS_READ_CLR_CMD_DATA_MSG_DATA_SIZE_MASK UINT32_C(0x7)
	#define CFA_BDS_READ_CLR_CMD_DATA_MSG_DATA_SIZE_SFT 0
	/* This is the 32B index into the selected table to access. */
	uint32_t	table_index;
	#define CFA_BDS_READ_CLR_CMD_DATA_MSG_TABLE_INDEX_MASK UINT32_C(0x3ffffff)
	#define CFA_BDS_READ_CLR_CMD_DATA_MSG_TABLE_INDEX_SFT 0
	/*
	 * This is the 64b host address where you want the data returned to. The
	 * data will be written to the same function as the one that owns the SQ
	 * this command is read from. The bottom two bits of this value must be
	 * zero. The size of the write is controlled by the data_size field.
	 */
	uint64_t	host_address;
	/*
	 * This is active high clear mask for the 32B of data that this command
	 * can read. Bit 0 of the field will clear bits 15:0 of the first word
	 * of data read when set to '1'.
	 */
	uint16_t	clear_mask;
	uint16_t	unused0[3];
	uint16_t	unused1[4];
} cfa_bds_read_clr_cmd_data_msg_t, *pcfa_bds_read_clr_cmd_data_msg_t;

/* cfa_bds_em_insert_cmd_data_msg (size:1152b/144B) */

typedef struct cfa_bds_em_insert_cmd_data_msg {
	/* This value selects the format for the mid-path command for the CFA. */
	uint8_t	opcode;
	/*
	 * An exact match table insert will be attempted into the table.
	 * If there is a free location in the bucket, the payload will
	 * be written to the bucket.
	 */
	#define CFA_BDS_EM_INSERT_CMD_DATA_MSG_OPCODE_EM_INSERT UINT32_C(0x3)
	#define CFA_BDS_EM_INSERT_CMD_DATA_MSG_OPCODE_LAST	CFA_BDS_EM_INSERT_CMD_DATA_MSG_OPCODE_EM_INSERT
	/*
	 * Indicates write-through control. Indicates write-through when set,
	 * or write back when cleared.
	 */
	uint8_t	write_thru;
	#define CFA_BDS_EM_INSERT_CMD_DATA_MSG_UNUSED_MASK	UINT32_C(0xf)
	#define CFA_BDS_EM_INSERT_CMD_DATA_MSG_UNUSED_SFT	0
	/*
	 * Indicates write-through control. Indicates write-through when set,
	 * or write back when cleared.
	 */
	#define CFA_BDS_EM_INSERT_CMD_DATA_MSG_WRITE_THRU	UINT32_C(0x10)
	/* This value selects which table scope will be accessed. */
	uint8_t	table_scope;
	#define CFA_BDS_EM_INSERT_CMD_DATA_MSG_TABLE_SCOPE_MASK UINT32_C(0x1f)
	#define CFA_BDS_EM_INSERT_CMD_DATA_MSG_TABLE_SCOPE_SFT 0
	/*
	 * This value identifies the number of 32B units will be accessed. A
	 * value of zero is invalid. Maximum value is 4.
	 */
	uint8_t	data_size;
	#define CFA_BDS_EM_INSERT_CMD_DATA_MSG_DATA_SIZE_MASK UINT32_C(0x7)
	#define CFA_BDS_EM_INSERT_CMD_DATA_MSG_DATA_SIZE_SFT 0
	/* This is the 32B index into the selected table to access. */
	uint32_t	table_index;
	#define CFA_BDS_EM_INSERT_CMD_DATA_MSG_TABLE_INDEX_MASK UINT32_C(0x3ffffff)
	#define CFA_BDS_EM_INSERT_CMD_DATA_MSG_TABLE_INDEX_SFT 0
	/*
	 * This is the 64b host address where you want the data returned to. The
	 * data will be written to the same function as the one that owns the SQ
	 */
	uint64_t	host_address;
	/*
	 * This is the Exact Match Lookup Record. Data length is determined by
	 * the data_size field. The bd_cnt in the encapsulating BD must also be
	 */
	uint32_t	dta[32];
} cfa_bds_em_insert_cmd_data_msg_t, *pcfa_bds_em_insert_cmd_data_msg_t;

/* cfa_bds_em_delete_cmd_data_msg (size:256b/32B) */

typedef struct cfa_bds_em_delete_cmd_data_msg {
	/* This value selects the format for the mid-path command for the CFA. */
	uint8_t	opcode;
	/* An exact match table delete will be attempted. */
	#define CFA_BDS_EM_DELETE_CMD_DATA_MSG_OPCODE_EM_DELETE UINT32_C(0x4)
	#define CFA_BDS_EM_DELETE_CMD_DATA_MSG_OPCODE_LAST	CFA_BDS_EM_DELETE_CMD_DATA_MSG_OPCODE_EM_DELETE
	/*
	 * Indicates write-through control. Indicates write-through when set,
	 * or write back when cleared.
	 */
	uint8_t	write_thru;
	#define CFA_BDS_EM_DELETE_CMD_DATA_MSG_UNUSED_MASK	UINT32_C(0xf)
	#define CFA_BDS_EM_DELETE_CMD_DATA_MSG_UNUSED_SFT	0
	/*
	 * Indicates write-through control. Indicates write-through when set,
	 * or write back when cleared.
	 */
	#define CFA_BDS_EM_DELETE_CMD_DATA_MSG_WRITE_THRU	UINT32_C(0x10)
	/* This value selects which table scope will be accessed. */
	uint8_t	table_scope;
	#define CFA_BDS_EM_DELETE_CMD_DATA_MSG_TABLE_SCOPE_MASK UINT32_C(0x1f)
	#define CFA_BDS_EM_DELETE_CMD_DATA_MSG_TABLE_SCOPE_SFT 0
	/*
	 * This value identifies the number of 32B units will be accessed. A
	 * value of zero is invalid. Maximum value is 4.
	 */
	uint8_t	data_size;
	#define CFA_BDS_EM_DELETE_CMD_DATA_MSG_DATA_SIZE_MASK UINT32_C(0x7)
	#define CFA_BDS_EM_DELETE_CMD_DATA_MSG_DATA_SIZE_SFT 0
	uint32_t	unused0;
	/*
	 * This is the 64b host address where you want the data returned to. The
	 * data will be written to the same function as the one that owns the SQ
	 */
	uint64_t	host_address;
	/*
	 * This is the Exact Match Lookup Record. Data length is determined by
	 * the data_size field. The bd_cnt in the encapsulating BD must also be
	 */
	uint64_t	dta;
	uint64_t	unused1;
} cfa_bds_em_delete_cmd_data_msg_t, *pcfa_bds_em_delete_cmd_data_msg_t;

/* cfa_bds_invalidate_cmd_data_msg (size:128b/16B) */

typedef struct cfa_bds_invalidate_cmd_data_msg {
	/* This value selects the format for the mid-path command for the CFA. */
	uint8_t	opcode;
	/*
	 * The specified table area will be invalidated. If it is needed.
	 * again, it will be read from the backing store.
	 */
	#define CFA_BDS_INVALIDATE_CMD_DATA_MSG_OPCODE_INVALIDATE UINT32_C(0x5)
	#define CFA_BDS_INVALIDATE_CMD_DATA_MSG_OPCODE_LAST	CFA_BDS_INVALIDATE_CMD_DATA_MSG_OPCODE_INVALIDATE
	/* This value selects the table type to be acted upon. */
	uint8_t	table_type;
	/* This value selects the table type to be acted upon. */
	#define CFA_BDS_INVALIDATE_CMD_DATA_MSG_TABLE_TYPE_MASK  UINT32_C(0xf)
	#define CFA_BDS_INVALIDATE_CMD_DATA_MSG_TABLE_TYPE_SFT   0
	/* This command acts on the action table of the specified scope. */
		#define CFA_BDS_INVALIDATE_CMD_DATA_MSG_TABLE_TYPE_ACTION  UINT32_C(0x0)
	/* This command acts on the exact match table of the specified scope. */
		#define CFA_BDS_INVALIDATE_CMD_DATA_MSG_TABLE_TYPE_EM	UINT32_C(0x1)
		#define CFA_BDS_INVALIDATE_CMD_DATA_MSG_TABLE_TYPE_LAST   CFA_BDS_INVALIDATE_CMD_DATA_MSG_TABLE_TYPE_EM
	/* This value selects which table scope will be accessed. */
	uint8_t	table_scope;
	#define CFA_BDS_INVALIDATE_CMD_DATA_MSG_TABLE_SCOPE_MASK UINT32_C(0x1f)
	#define CFA_BDS_INVALIDATE_CMD_DATA_MSG_TABLE_SCOPE_SFT 0
	/* This value specifies the number of cache lines to invalidate. */
	uint8_t	data_size;
	#define CFA_BDS_INVALIDATE_CMD_DATA_MSG_DATA_SIZE_MASK UINT32_C(0x7)
	#define CFA_BDS_INVALIDATE_CMD_DATA_MSG_DATA_SIZE_SFT 0
	/* This is the 32B index into the selected table to access. */
	uint32_t	table_index;
	#define CFA_BDS_INVALIDATE_CMD_DATA_MSG_TABLE_INDEX_MASK UINT32_C(0x3ffffff)
	#define CFA_BDS_INVALIDATE_CMD_DATA_MSG_TABLE_INDEX_SFT 0
	uint64_t	unused;
} cfa_bds_invalidate_cmd_data_msg_t, *pcfa_bds_invalidate_cmd_data_msg_t;

/* cfa_bds_event_collect_cmd_data_msg (size:128b/16B) */

typedef struct cfa_bds_event_collect_cmd_data_msg {
	/* This value selects the format for the mid-path command for the CFA. */
	uint8_t	opcode;
	/* Reads notification messages from the Host Notification Queue. */
	#define CFA_BDS_EVENT_COLLECT_CMD_DATA_MSG_OPCODE_EVENT_COLLECT UINT32_C(0x6)
	#define CFA_BDS_EVENT_COLLECT_CMD_DATA_MSG_OPCODE_LAST	CFA_BDS_EVENT_COLLECT_CMD_DATA_MSG_OPCODE_EVENT_COLLECT
	uint8_t	unused0;
	/* This value selects which table scope will be accessed. */
	uint8_t	table_scope;
	#define CFA_BDS_EVENT_COLLECT_CMD_DATA_MSG_TABLE_SCOPE_MASK UINT32_C(0x1f)
	#define CFA_BDS_EVENT_COLLECT_CMD_DATA_MSG_TABLE_SCOPE_SFT 0
	/*
	 * This value identifies the number of 32B units will be accessed. A
	 * value of zero is invalid. Maximum value is 4.
	 */
	uint8_t	data_size;
	#define CFA_BDS_EVENT_COLLECT_CMD_DATA_MSG_DATA_SIZE_MASK UINT32_C(0x7)
	#define CFA_BDS_EVENT_COLLECT_CMD_DATA_MSG_DATA_SIZE_SFT 0
	uint32_t	unused1;
	/*
	 * This is the 64b host address where you want the data returned to. The
	 * data will be written to the same function as the one that owns the SQ
	 */
	uint64_t	host_address;
} cfa_bds_event_collect_cmd_data_msg_t, *pcfa_bds_event_collect_cmd_data_msg_t;

/* ce_bds_add_data_msg (size:512b/64B) */

typedef struct ce_bds_add_data_msg {
	uint32_t	version_algorithm_kid_opcode;
	/*
	 * This value selects the operation for the mid-path command for the
	 * crypto blocks.
	 */
	#define CE_BDS_ADD_DATA_MSG_OPCODE_MASK		UINT32_C(0xf)
	#define CE_BDS_ADD_DATA_MSG_OPCODE_SFT		0
	/*
	 * This is the add command. Using this opcode, Host Driver can add
	 * information required for kTLS processing. The information is
	 * updated in the CFCK context.
	 */
		#define CE_BDS_ADD_DATA_MSG_OPCODE_ADD		UINT32_C(0x1)
		#define CE_BDS_ADD_DATA_MSG_OPCODE_LAST		CE_BDS_ADD_DATA_MSG_OPCODE_ADD
	/*
	 * This field is the Crypto Context ID. The KID is used to store
	 * information used by the associated kTLS offloaded connection.
	 */
	#define CE_BDS_ADD_DATA_MSG_KID_MASK		UINT32_C(0xfffff0)
	#define CE_BDS_ADD_DATA_MSG_KID_SFT		4
	/*
	 * Currently only two algorithms are supported, AES_GCM_128 and
	 * AES_GCM_256. Additional bits for future growth.
	 */
	#define CE_BDS_ADD_DATA_MSG_ALGORITHM_MASK		UINT32_C(0xf000000)
	#define CE_BDS_ADD_DATA_MSG_ALGORITHM_SFT		24
	/* AES_GCM_128 Algorithm */
	#define CE_BDS_ADD_DATA_MSG_ALGORITHM_AES_GCM_128	UINT32_C(0x1000000)
	/* AES_GCM_256 Algorithm */
	#define CE_BDS_ADD_DATA_MSG_ALGORITHM_AES_GCM_256	UINT32_C(0x2000000)
	/*
	 * Version number of TLS connection. HW will provide registers that
	 * converts the 4b encoded version number to 16b of actual version
	 * number in the TLS Header. * Initialized --> By mid-path command *
	 * Updated --> Never though another mid-path command will result in an
	 * update.
	 */
	#define CE_BDS_ADD_DATA_MSG_VERSION_MASK		UINT32_C(0xf0000000)
	#define CE_BDS_ADD_DATA_MSG_VERSION_SFT		28
	/* TLS1.2 Version */
		#define CE_BDS_ADD_DATA_MSG__TLS1_2			(UINT32_C(0x0) << 28)
	/* TLS1.3 Version */
		#define CE_BDS_ADD_DATA_MSG__TLS1_3			(UINT32_C(0x1) << 28)
		#define CE_BDS_ADD_DATA_MSG__LAST			CE_BDS_ADD_DATA_MSG__TLS1_3
	/*
	 * Command Type in the TLS header. HW will provide registers that
	 * converts the 3b encoded command type to 8b of actual command type in
	 * the TLS Header. * Initialized --> By mid-path command * Updated -->
	 * Never though another mid-path command will result in an update
	 */
	uint8_t	cmd_type;
	#define CE_BDS_ADD_DATA_MSG_CMD_TYPE_MASK UINT32_C(0x7)
	#define CE_BDS_ADD_DATA_MSG_CMD_TYPE_SFT 0
	/* Application */
		#define CE_BDS_ADD_DATA_MSG_CMD_TYPE_APP   UINT32_C(0x0)
		#define CE_BDS_ADD_DATA_MSG_CMD_TYPE_LAST CE_BDS_ADD_DATA_MSG_CMD_TYPE_APP
	uint8_t	unused0[3];
	/*
	 * Salt is part of the nonce that is used as the Initial Vector (IV) in
	 * AES-GCM cipher suites. These are exchanged as part of the handshake
	 * process and is either the client_write_iv (when the client is
	 * sending) or server_write_iv (when the server is sending). In
	 * TLS1.2, 4B of Salt is concatenated with 8B of explicit_nonce to
	 * generate the 12B of IV. In TLS1.3, 8B of TLS record sequence number
	 * is zero padded to 12B and then xor'ed with the 4B of salt to generate
	 * the 12B of IV. This value is initialized by this mid-path command.
	 */
	uint32_t	salt;
	uint32_t	unused1;
	/*
	 * This field keeps track of the TCP sequence number that is expected as
	 * the first byte in the next TCP packet. This field is calculated by HW
	 * using the output of the parser. The field is initialized as part of
	 * the Mid-path BD download/update of a kTLS connection. For every TCP
	 * packet processed, TCE HW will update the value to Current packet TCP
	 * sequence number + Current packet TCP Payload Length.
	 */
	uint32_t	pkt_tcp_seq_num;
	/*
	 * This field maintains the TCP sequence number of the first byte in the
	 * header of the active TLS record. This field is initialized as part of
	 * the Mid-path BD download/update of a kTLS connection. For every
	 * record that is processed, TCE HW copies the value from the
	 * next_tls_header_tcp_seq_num field.
	 */
	uint32_t	tls_header_tcp_seq_num;
	/*
	 * This is sequence number for the TLS record in a particular session.
	 * In TLS1.2, record sequence number is part of the Associated Data (AD)
	 * in the AEAD algorithm. In TLS1.3, record sequence number is part of
	 * the Initial Vector (IV). The field is initialized as part of the
	 * mid-path BD download/update of a kTLS connection. TCE HW increments
	 * the field after that for every record processed as it parses the TCP
	 * packet.
	 */
	uint64_t	record_seq_num;
	/*
	 * Key used for encrypting or decrypting TLS records. The Key is
	 * exchanged during the hand-shake protocol by the client-server and
	 * provided to HW through this mid-path BD.
	 */
	uint32_t	session_key[8];
} ce_bds_add_data_msg_t, *pce_bds_add_data_msg_t;

/* ce_bds_delete_data_msg (size:64b/8B) */

typedef struct ce_bds_delete_data_msg {
	uint32_t	kid_opcode;
	/*
	 * This value selects the operation for the mid-path command for the
	 * crypto blocks.
	 */
	#define CE_BDS_DELETE_DATA_MSG_OPCODE_MASK  UINT32_C(0xf)
	#define CE_BDS_DELETE_DATA_MSG_OPCODE_SFT   0
	/*
	 * This is the delete command. Using this opcode, the host Driver
	 * can remove a key context from the CFCK. If context is deleted
	 * and packets with the same KID come through the pipeline, the
	 * following actions are taken. For transmit packets, no crypto
	 * operation will be performed, payload will be zero'ed out. For
	 * receive packets, no crypto operation will be performed,
	 * payload will be unmodified.
	 */
		#define CE_BDS_DELETE_DATA_MSG_OPCODE_DELETE  UINT32_C(0x2)
		#define CE_BDS_DELETE_DATA_MSG_OPCODE_LAST   CE_BDS_DELETE_DATA_MSG_OPCODE_DELETE
	/*
	 * This field is the Crypto Context ID. The KID is used to store
	 * information used by the associated kTLS offloaded connection.
	 */
	#define CE_BDS_DELETE_DATA_MSG_KID_MASK	UINT32_C(0xfffff0)
	#define CE_BDS_DELETE_DATA_MSG_KID_SFT	4
	uint32_t	unused0;
} ce_bds_delete_data_msg_t, *pce_bds_delete_data_msg_t;

/* ce_bds_resync_resp_ack_msg (size:128b/16B) */

typedef struct ce_bds_resync_resp_ack_msg {
	uint32_t	resync_status_kid_opcode;
	/*
	 * This value selects the operation for the mid-path command for the
	 * crypto blocks.
	 */
	#define CE_BDS_RESYNC_RESP_ACK_MSG_OPCODE_MASK	UINT32_C(0xf)
	#define CE_BDS_RESYNC_RESP_ACK_MSG_OPCODE_SFT	0
	/*
	 * This command is used by the driver as a response to the resync
	 * request sent by the crypto engine.
	 */
		#define CE_BDS_RESYNC_RESP_ACK_MSG_OPCODE_RESYNC	UINT32_C(0x3)
		#define CE_BDS_RESYNC_RESP_ACK_MSG_OPCODE_LAST	CE_BDS_RESYNC_RESP_ACK_MSG_OPCODE_RESYNC
	/*
	 * This field is the Crypto Context ID. The KID is used to store
	 * information used by the associated kTLS offloaded connection.
	 */
	#define CE_BDS_RESYNC_RESP_ACK_MSG_KID_MASK	UINT32_C(0xfffff0)
	#define CE_BDS_RESYNC_RESP_ACK_MSG_KID_SFT	4
	/*
	 * This field indicates if the resync request resulted in a success or
	 * a failure.
	 */
	#define CE_BDS_RESYNC_RESP_ACK_MSG_RESYNC_STATUS	UINT32_C(0x1000000)
	/*
	 * An ACK indicates that the driver was able to find the TLS record
	 * associated with TCP sequence number provided by the HW
	 */
		#define CE_BDS_RESYNC_RESP_ACK_MSG_RESYNC_STATUS_ACK   (UINT32_C(0x0) << 24)
		#define CE_BDS_RESYNC_RESP_ACK_MSG_RESYNC_STATUS_LAST CE_BDS_RESYNC_RESP_ACK_MSG_RESYNC_STATUS_ACK
	/*
	 * This field is the echo of the TCP sequence number provided in the
	 * resync request by the HW. If HW sent multiple resync requests, it
	 * only tracks the latest TCP sequence number. When the response from
	 * the Driver doesn't match the latest request, HW will drop the resync
	 * response.
	 */
	uint32_t	resync_record_tcp_seq_num;
	/*
	 * This field indicates the TLS record sequence number associated with
	 * the resync request. HW will take this number and add the delta records
	 * it has found since sending the resync request, update the context and
	 * resume decrypting records.
	 */
	uint64_t	resync_record_seq_num;
} ce_bds_resync_resp_ack_msg_t, *pce_bds_resync_resp_ack_msg_t;

/* ce_bds_resync_resp_nack_msg (size:64b/8B) */

typedef struct ce_bds_resync_resp_nack_msg {
	uint32_t	resync_status_kid_opcode;
	/*
	 * This value selects the operation for the mid-path command for the
	 * crypto blocks.
	 */
	#define CE_BDS_RESYNC_RESP_NACK_MSG_OPCODE_MASK	UINT32_C(0xf)
	#define CE_BDS_RESYNC_RESP_NACK_MSG_OPCODE_SFT	0
	/*
	 * This command is used by the driver as a response to the resync
	 * request sent by the crypto engine.
	 */
		#define CE_BDS_RESYNC_RESP_NACK_MSG_OPCODE_RESYNC	UINT32_C(0x3)
		#define CE_BDS_RESYNC_RESP_NACK_MSG_OPCODE_LAST	CE_BDS_RESYNC_RESP_NACK_MSG_OPCODE_RESYNC
	/*
	 * This field is the Crypto Context ID. The KID is used to store
	 * information used by the associated kTLS offloaded connection.
	 */
	#define CE_BDS_RESYNC_RESP_NACK_MSG_KID_MASK	UINT32_C(0xfffff0)
	#define CE_BDS_RESYNC_RESP_NACK_MSG_KID_SFT	4
	/*
	 * This field indicates if the resync request resulted in a success or
	 * a failure.
	 */
	#define CE_BDS_RESYNC_RESP_NACK_MSG_RESYNC_STATUS	UINT32_C(0x1000000)
	/*
	 * An NAK indicates that the driver wasn't able to find the TLS
	 * record associated with TCP sequence number provided by the HW
	 */
		#define CE_BDS_RESYNC_RESP_NACK_MSG_RESYNC_STATUS_NACK  (UINT32_C(0x1) << 24)
		#define CE_BDS_RESYNC_RESP_NACK_MSG_RESYNC_STATUS_LAST CE_BDS_RESYNC_RESP_NACK_MSG_RESYNC_STATUS_NACK
	/*
	 * This field is the echo of the TCP sequence number provided in the
	 * resync request by the HW. If HW sent multiple resync requests, it
	 * only tracks the latest TCP sequence number. When the response from
	 * the Driver doesn't match the latest request, HW will drop the resync
	 * response.
	 */
	uint32_t	resync_record_tcp_seq_num;
} ce_bds_resync_resp_nack_msg_t, *pce_bds_resync_resp_nack_msg_t;

/* crypto_presync_bd_cmd (size:256b/32B) */

typedef struct crypto_presync_bd_cmd {
	uint8_t	flags;
	/*
	 * Typically, presync BDs are used for packet retransmissions. Source
	 * port sends all the packets in order over the network to destination
	 * port and packets get dropped in the network. The destination port
	 * will request retranmission of dropped packets and source port driver
	 * will send presync BD to setup the transmitter appropriately. It will
	 * provide the start and end TCP sequence number of the data to be
	 * transmitted. HW keeps two sets of context variable, one for in order
	 * traffic and one for retransmission traffic. HW is designed to
	 * transmit everything posted in the presync BD and return to in order
	 * mode after that. No inorder context variables are updated in the
	 * process. There is a special case where packets can be dropped
	 * between the TCP stack and Device Driver (Berkeley Packet Filter for
	 * ex) and HW still needs to transmit rest of the traffic. In this
	 * mode, driver will send a presync BD as if it is a retransmission but
	 * at the end of the transmission, the in order variables need to be
	 * updated. This flag is used by driver to indicate that in order
	 * variables needs to be updated at the end of completing the task
	 * associated with the presync BD.
	 */
	#define CRYPTO_PRESYNC_BD_CMD_FLAGS_UPDATE_IN_ORDER_VAR	UINT32_C(0x1)
	uint8_t	unused0;
	uint16_t	unused1;
	/*
	 * This field maintains the TCP sequence number of the first byte in the
	 * Header of the active TLS record. This field is set to 0 during
	 * mid-path BD updates, but is set to correct value when a presync BD is
	 * detected. For every record that is processed, the value from the
	 * next_tls_header_tcp_seq_num field is copied.
	 */
	uint32_t	header_tcp_seq_num;
	/*
	 * When a retransmitted packet has a TLS authentication TAG present and
	 * the data spans multiple TCP Packets, HW is required to read the entire
	 * record to recalculate the TAG but only transmit what is required. This
	 * field is the start TCP sequence number of the packet(s) that need to
	 * be re-transmitted. This field is initialized to 0 during Mid-path BD
	 * add command and initialized to value provided by the driver when
	 * Pre-sync BD is detected. This field is never updated unless another
	 * Pre-sync BD signaling a new retransmission is scheduled.
	 */
	uint32_t	start_tcp_seq_num;
	/*
	 * When a retransmitted packet has a TLS authentication TAG present and
	 * the data spans multiple TCP Packets, HW is required to read the
	 * entire record to recalculate the TAG but only transmit what is
	 * required. This field is the end TCP sequence number of the packet(s)
	 * that need to be re-transmitted. This field is initialized to 0 during
	 * Mid-path BD add command and initialized to value provided by the
	 * driver when Pre-sync BD is detected. This field is never updated
	 * unless another Pre-sync BD signaling a new retransmission is
	 * scheduled.
	 */
	uint32_t	end_tcp_seq_num;
	/*
	 * For TLS1.2, an explicit nonce is used as part of the IV (concatenated
	 * with the SALT). For retans packets, this field is extracted from the
	 * TLS record, field right after the TLS Header and stored in the
	 * context. This field needs to be stored in context as TCP segmentation
	 * could have split the field into multiple TCP packets. This value is
	 * initialized to 0 when presync BD is detected by taking the value from
	 * the first TLS header. When subsequent TLS Headers are detected, the
	 * value is extracted from packet.
	 */
	uint64_t	explicit_nonce;
	/*
	 * This is sequence number for the TLS record in a particular session. In
	 * TLS1.2, record sequence number is part of the Associated Data (AD) in
	 * the AEAD algorithm. In TLS1.3, record sequence number is part of the
	 * Initial Vector (IV). The field is initialized to 0 during Mid-path BD
	 * download. Is initialized to correct value when a pre-sync BD is
	 * detected. TCE HW increments the field after that for every record
	 * processed as it parses the TCP packet. Subsequent pre-sync BDs
	 * delivering more retransmission instruction will also update this
	 * field.
	 */
	uint64_t	record_seq_num;
} crypto_presync_bd_cmd_t, *pcrypto_presync_bd_cmd_t;

/* bd_base (size:64b/8B) */

typedef struct bd_base {
	uint8_t	type;
	/* This value identifies the type of buffer descriptor. */
	#define BD_BASE_TYPE_MASK		UINT32_C(0x3f)
	#define BD_BASE_TYPE_SFT		0
	/*
	 * Indicates that this BD is 16B long and is used for
	 * normal L2 packet transmission.
	 */
		#define BD_BASE_TYPE_TX_BD_SHORT	UINT32_C(0x0)
	/*
	 * Indicates that this BD is 1BB long and is an empty
	 * TX BD. Not valid for use by the driver.
	 */
		#define BD_BASE_TYPE_TX_BD_EMPTY	UINT32_C(0x1)
	/*
	 * Indicates that this BD is 16B long and is an RX Producer
	 * (i.e. empty) buffer descriptor.
	 */
		#define BD_BASE_TYPE_RX_PROD_PKT	UINT32_C(0x4)
	/*
	 * Indicates that this BD is 16B long and is an RX
	 * Producer Buffer BD.
	 */
		#define BD_BASE_TYPE_RX_PROD_BFR	UINT32_C(0x5)
	/*
	 * Indicates that this BD is 16B long and is an
	 * RX Producer Assembly Buffer Descriptor.
	 */
		#define BD_BASE_TYPE_RX_PROD_AGG	UINT32_C(0x6)
	/*
	 * Indicates that this BD is used to issue a command to one of
	 * the mid-path destinations.
	 */
		#define BD_BASE_TYPE_TX_BD_MP_CMD	UINT32_C(0x8)
	/*
	 * Indicates that this BD is used to issue a cryptographic pre-
	 * sync command through the fast path and destined for TCE.
	 */
		#define BD_BASE_TYPE_TX_BD_PRESYNC_CMD  UINT32_C(0x9)
	/*
	 * Indicates that this BD is 32B long and is used for
	 * normal L2 packet transmission.
	 */
		#define BD_BASE_TYPE_TX_BD_LONG	UINT32_C(0x10)
	/*
	 * Indicates that this BD is 32B long and is used for
	 * L2 packet transmission for small packets that require
	 * low latency.
	 */
		#define BD_BASE_TYPE_TX_BD_LONG_INLINE  UINT32_C(0x11)
		#define BD_BASE_TYPE_LAST		BD_BASE_TYPE_TX_BD_LONG_INLINE
	uint8_t	unused_1[7];
} bd_base_t, *pbd_base_t;

/* tx_bd_short (size:128b/16B) */

typedef struct tx_bd_short {
	/*
	 * All bits in this field must be valid on the first BD of a packet.
	 * Only the packet_end bit must be valid for the remaining BDs
	 * of a packet.
	 */
	uint16_t	flags_type;
	/* This value identifies the type of buffer descriptor. */
	#define TX_BD_SHORT_TYPE_MASK		UINT32_C(0x3f)
	#define TX_BD_SHORT_TYPE_SFT		0
	/*
	 * Indicates that this BD is 16B long and is used for
	 * normal L2 packet transmission.
	 */
		#define TX_BD_SHORT_TYPE_TX_BD_SHORT	UINT32_C(0x0)
		#define TX_BD_SHORT_TYPE_LAST		TX_BD_SHORT_TYPE_TX_BD_SHORT
	/*
	 * All bits in this field must be valid on the first BD of a packet.
	 * Only the packet_end bit must be valid for the remaining BDs
	 * of a packet.
	 */
	#define TX_BD_SHORT_FLAGS_MASK	UINT32_C(0xffc0)
	#define TX_BD_SHORT_FLAGS_SFT		6
	/*
	 * If set to 1, the packet ends with the data in the buffer
	 * pointed to by this descriptor. This flag must be
	 * valid on every BD.
	 */
	#define TX_BD_SHORT_FLAGS_PACKET_END	UINT32_C(0x40)
	/*
	 * If set to 1, the device will not generate a completion for
	 * this transmit packet unless there is an error in it's
	 * processing.
	 * If this bit
	 * is set to 0, then the packet will be completed normally.
	 *
	 * This bit must be valid only on the first BD of a packet.
	 */
	#define TX_BD_SHORT_FLAGS_NO_CMPL	UINT32_C(0x80)
	/*
	 * This value indicates how many 16B BD locations are consumed
	 * in the ring by this packet.
	 * A value of 1 indicates that this BD is the only BD (and that
	 * it is a short BD). A value
	 * of 3 indicates either 3 short BDs or 1 long BD and one short
	 * BD in the packet. A value of 0 indicates
	 * that there are 32 BD locations in the packet (the maximum).
	 *
	 * This field is valid only on the first BD of a packet.
	 */
	#define TX_BD_SHORT_FLAGS_BD_CNT_MASK	UINT32_C(0x1f00)
	#define TX_BD_SHORT_FLAGS_BD_CNT_SFT	8
	/*
	 * This value is a hint for the length of the entire packet.
	 * It is used by the chip to optimize internal processing.
	 *
	 * The packet will be dropped if the hint is too short.
	 *
	 * This field is valid only on the first BD of a packet.
	 */
	#define TX_BD_SHORT_FLAGS_LHINT_MASK	UINT32_C(0x6000)
	#define TX_BD_SHORT_FLAGS_LHINT_SFT	13
	/* indicates packet length < 512B */
		#define TX_BD_SHORT_FLAGS_LHINT_LT512	(UINT32_C(0x0) << 13)
	/* indicates 512 <= packet length < 1KB */
		#define TX_BD_SHORT_FLAGS_LHINT_LT1K	(UINT32_C(0x1) << 13)
	/* indicates 1KB <= packet length < 2KB */
		#define TX_BD_SHORT_FLAGS_LHINT_LT2K	(UINT32_C(0x2) << 13)
	/* indicates packet length >= 2KB */
		#define TX_BD_SHORT_FLAGS_LHINT_GTE2K	(UINT32_C(0x3) << 13)
		#define TX_BD_SHORT_FLAGS_LHINT_LAST	TX_BD_SHORT_FLAGS_LHINT_GTE2K
	/*
	 * If set to 1, the device immediately updates the Send Consumer
	 * Index after the buffer associated with this descriptor has
	 * been transferred via DMA to NIC memory from host memory. An
	 * interrupt may or may not be generated according to the state
	 * of the interrupt avoidance mechanisms. If this bit
	 * is set to 0, then the Consumer Index is only updated as soon
	 * as one of the host interrupt coalescing conditions has been met.
	 *
	 * This bit must be valid on the first BD of a packet.
	 */
	#define TX_BD_SHORT_FLAGS_COAL_NOW	UINT32_C(0x8000)
	/*
	 * This is the length of the host physical buffer this BD describes
	 * in bytes.
	 *
	 * This field must be valid on all BDs of a packet.
	 */
	uint16_t	len;
	/*
	 * The opaque data field is pass through to the completion and can be
	 * used for any data that the driver wants to associate with the
	 * transmit BD.
	 *
	 * This field must be valid on the first BD of a packet. If completion
	 * coalescing is enabled on the TX ring, it is suggested that the driver
	 * populate the opaque field to indicate the specific TX ring with which
	 * the completion is associated, then utilize the opaque and sq_cons_idx
	 * fields in the coalesced completion record to determine the specific
	 * packets that are to be completed on that ring.
	 */
	uint32_t	opaque;
	/*
	 * This is the host physical address for the portion of the packet
	 * described by this TX BD.
	 *
	 * This value must be valid on all BDs of a packet.
	 */
	uint64_t	addr;
} tx_bd_short_t, *ptx_bd_short_t;

/* tx_bd_long (size:128b/16B) */

typedef struct tx_bd_long {
	/* This value identifies the type of buffer descriptor. */
	uint16_t	flags_type;
	/*
	 * This value indicates the type of buffer descriptor.
	 * packet.
	 */
	#define TX_BD_LONG_TYPE_MASK		UINT32_C(0x3f)
	#define TX_BD_LONG_TYPE_SFT		0
	/*
	 * Indicates that this BD is 32B long and is used for
	 * normal L2 packet transmission.
	 */
		#define TX_BD_LONG_TYPE_TX_BD_LONG	UINT32_C(0x10)
		#define TX_BD_LONG_TYPE_LAST		TX_BD_LONG_TYPE_TX_BD_LONG
	/*
	 * All bits in this field must be valid on the first BD of a packet.
	 * Only the packet_end bit must be valid for the remaining BDs
	 * of a packet.
	 */
	#define TX_BD_LONG_FLAGS_MASK	UINT32_C(0xffc0)
	#define TX_BD_LONG_FLAGS_SFT		6
	/*
	 * If set to 1, the packet ends with the data in the buffer
	 * pointed to by this descriptor. This flag must be
	 * valid on every BD.
	 */
	#define TX_BD_LONG_FLAGS_PACKET_END	UINT32_C(0x40)
	/*
	 * If set to 1, the device will not generate a completion for
	 * this transmit packet unless there is an error in it's
	 * processing.
	 * If this bit
	 * is set to 0, then the packet will be completed normally.
	 *
	 * This bit must be valid only on the first BD of a packet.
	 */
	#define TX_BD_LONG_FLAGS_NO_CMPL	UINT32_C(0x80)
	/*
	 * This value indicates how many 16B BD locations are consumed
	 * in the ring by this packet.
	 * A value of 1 indicates that this BD is the only BD (and that
	 * it is a short BD). A value
	 * of 3 indicates either 3 short BDs or 1 long BD and one short
	 * BD in the packet. A value of 0 indicates
	 * that there are 32 BD locations in the packet (the maximum).
	 *
	 * This field is valid only on the first BD of a packet.
	 */
	#define TX_BD_LONG_FLAGS_BD_CNT_MASK	UINT32_C(0x1f00)
	#define TX_BD_LONG_FLAGS_BD_CNT_SFT	8
	/*
	 * This value is a hint for the length of the entire packet.
	 * It is used by the chip to optimize internal processing.
	 *
	 * The packet will be dropped if the hint is too short.
	 *
	 * This field is valid only on the first BD of a packet.
	 */
	#define TX_BD_LONG_FLAGS_LHINT_MASK	UINT32_C(0x6000)
	#define TX_BD_LONG_FLAGS_LHINT_SFT	13
	/* indicates packet length < 512B */
		#define TX_BD_LONG_FLAGS_LHINT_LT512	(UINT32_C(0x0) << 13)
	/* indicates 512 <= packet length < 1KB */
		#define TX_BD_LONG_FLAGS_LHINT_LT1K	(UINT32_C(0x1) << 13)
	/* indicates 1KB <= packet length < 2KB */
		#define TX_BD_LONG_FLAGS_LHINT_LT2K	(UINT32_C(0x2) << 13)
	/* indicates packet length >= 2KB */
		#define TX_BD_LONG_FLAGS_LHINT_GTE2K	(UINT32_C(0x3) << 13)
		#define TX_BD_LONG_FLAGS_LHINT_LAST	TX_BD_LONG_FLAGS_LHINT_GTE2K
	/*
	 * If set to 1, the device immediately updates the Send Consumer
	 * Index after the buffer associated with this descriptor has
	 * been transferred via DMA to NIC memory from host memory. An
	 * interrupt may or may not be generated according to the state
	 * of the interrupt avoidance mechanisms. If this bit
	 * is set to 0, then the Consumer Index is only updated as soon
	 * as one of the host interrupt coalescing conditions has been met.
	 *
	 * This bit must be valid on the first BD of a packet.
	 */
	#define TX_BD_LONG_FLAGS_COAL_NOW	UINT32_C(0x8000)
	/*
	 * This is the length of the host physical buffer this BD describes
	 * in bytes.
	 *
	 * This field must be valid on all BDs of a packet.
	 */
	uint16_t	len;
	/*
	 * The opaque data field is passed through to the completion and can be
	 * used for any data that the driver wants to associate with the
	 * transmit BD.
	 *
	 * This field must be valid on the first BD of a packet. If completion
	 * coalescing is enabled on the TX ring, it is suggested that the driver
	 * populate the opaque field to indicate the specific TX ring with which
	 * the completion is associated, then utilize the opaque and sq_cons_idx
	 * fields in the coalesced completion record to determine the specific
	 * packets that are to be completed on that ring.
	 */
	uint32_t	opaque;
	/*
	 * This is the host physical address for the portion of the packet
	 * described by this TX BD.
	 *
	 * This value must be valid on all BDs of a packet.
	 */
	uint64_t	addr;
} tx_bd_long_t, *ptx_bd_long_t;

/* Last 16 bytes of tx_bd_long. */
/* tx_bd_long_hi (size:128b/16B) */

typedef struct tx_bd_long_hi {
	/*
	 * All bits in this field must be valid on the first BD of a packet.
	 * Their value on other BDs of the packet will be ignored.
	 */
	uint16_t	lflags;
	/*
	 * If set to 1, the controller replaces the TCP/UPD checksum
	 * fields of normal TCP/UPD checksum, or the inner TCP/UDP
	 * checksum field of the encapsulated TCP/UDP packets with the
	 * hardware calculated TCP/UDP checksum for the packet associated
	 * with this descriptor. The flag is ignored if the LSO flag is set.
	 *
	 * This bit must be valid on the first BD of a packet.
	 */
	#define TX_BD_LONG_LFLAGS_TCP_UDP_CHKSUM	UINT32_C(0x1)
	/*
	 * If set to 1, the controller replaces the IP checksum of the
	 * normal packets, or the inner IP checksum of the encapsulated
	 * packets with the hardware calculated IP checksum for the
	 * packet associated with this descriptor.
	 *
	 * This bit must be valid on the first BD of a packet.
	 */
	#define TX_BD_LONG_LFLAGS_IP_CHKSUM	UINT32_C(0x2)
	/*
	 * If set to 1, the controller will not append an Ethernet CRC
	 * to the end of the frame.
	 *
	 * This bit must be valid on the first BD of a packet.
	 *
	 * Packet must be 64B or longer when this flag is set. It is not
	 * useful to use this bit with any form of TX offload such as
	 * CSO or LSO. The intent is that the packet from the host already
	 * has a valid Ethernet CRC on the packet.
	 */
	#define TX_BD_LONG_LFLAGS_NOCRC		UINT32_C(0x4)
	/*
	 * If set to 1, the device will record the time at which the packet
	 * was actually transmitted at the TX MAC for 2-step time sync.
	 *
	 * This bit must be valid on the first BD of a packet.
	 */
	#define TX_BD_LONG_LFLAGS_STAMP		UINT32_C(0x8)
	/*
	 * If set to 1, The controller replaces the tunnel IP checksum
	 * field with hardware calculated IP checksum for the IP header
	 * of the packet associated with this descriptor.
	 *
	 * For outer UDP checksum, global outer UDP checksum TE_NIC register
	 * needs to be enabled. If the global outer UDP checksum TE_NIC register
	 * bit is set, outer UDP checksum will be calculated for the following
	 * cases:
	 * 1. Packets with tcp_udp_chksum flag set to offload checksum for inner
	 * packet AND the inner packet is TCP/UDP. If the inner packet is ICMP for
	 * example (non-TCP/UDP), even if the tcp_udp_chksum is set, the outer UDP
	 * checksum will not be calculated.
	 * 2. Packets with lso flag set which implies inner TCP checksum calculation
	 * as part of LSO operation.
	 */
	#define TX_BD_LONG_LFLAGS_T_IP_CHKSUM	UINT32_C(0x10)
	/*
	 * If set to 1, the device will treat this packet with LSO(Large
	 * Send Offload) processing for both normal or encapsulated
	 * packets, which is a form of TCP segmentation. When this bit
	 * is 1, the hdr_size and mss fields must be valid. The driver
	 * doesn't need to set ot_ip_chksum, t_ip_chksum, ip_chksum, and
	 * tcp_udp_chksum flags since the controller will replace the
	 * appropriate checksum fields for segmented packets.
	 *
	 * When this bit is 1, the hdr_size and mss fields must be valid.
	 */
	#define TX_BD_LONG_LFLAGS_LSO		UINT32_C(0x20)
	/*
	 * If set to zero when LSO is '1', then the IPID will be treated
	 * as a 16b number and will be wrapped if it exceeds a value of
	 * 0xffff.
	 *
	 * If set to one when LSO is '1', then the IPID will be treated
	 * as a 15b number and will be wrapped if it exceeds a value 0f
	 * 0x7fff.
	 */
	#define TX_BD_LONG_LFLAGS_IPID_FMT	UINT32_C(0x40)
	/*
	 * If set to zero when LSO is '1', then the IPID of the tunnel
	 * IP header will not be modified during LSO operations.
	 *
	 * If set to one when LSO is '1', then the IPID of the tunnel
	 * IP header will be incremented for each subsequent segment of an
	 * LSO operation.
	 *
	 * The flag is ignored if the LSO packet is a normal (non-tunneled)
	 * TCP packet.
	 */
	#define TX_BD_LONG_LFLAGS_T_IPID		UINT32_C(0x80)
	/*
	 * If set to '1', then the RoCE ICRC will be appended to the
	 * packet. Packet must be a valid RoCE format packet.
	 */
	#define TX_BD_LONG_LFLAGS_ROCE_CRC	UINT32_C(0x100)
	/*
	 * If set to '1', then the FCoE CRC will be appended to the
	 * packet. Packet must be a valid FCoE format packet.
	 */
	#define TX_BD_LONG_LFLAGS_FCOE_CRC	UINT32_C(0x200)
	/*
	 * If set to '1', then the timestamp from the BD is used. If cleared
	 * to 0, then TWE provides the timestamp.
	 */
	#define TX_BD_LONG_LFLAGS_BD_TS_EN	UINT32_C(0x400)
	/*
	 * If set to '1', this operation will cause a trace capture in each
	 * block it passes through.
	 */
	#define TX_BD_LONG_LFLAGS_DEBUG_TRACE	UINT32_C(0x800)
	/*
	 * If set to '1', the device will record the time at which the packet
	 * was actually transmitted at the TX MAC for 1-step time sync. This
	 * bit must be valid on the first BD of a packet.
	 */
	#define TX_BD_LONG_LFLAGS_STAMP_1STEP	UINT32_C(0x1000)
	/*
	 * If set to '1', the controller replaces the Outer-tunnel IP checksum
	 * field with hardware calculated IP checksum for the IP header of the
	 * packet associated with this descriptor. For outer UDP checksum, it
	 * will be the following behavior for all cases independent of settings
	 * of inner LSO and checksum offload BD flags. If outer UDP checksum
	 * is 0, then do not update it. If outer UDP checksum is non zero, then
	 * the hardware should compute and update it.
	 */
	#define TX_BD_LONG_LFLAGS_OT_IP_CHKSUM	UINT32_C(0x2000)
	/*
	 * If set to zero when LSO is '1', then the IPID of the Outer-tunnel IP
	 * header will not be modified during LSO operations. If set to one
	 * when LSO is '1', then the IPID of the Outer-tunnel IP header will be
	 * incremented for each subsequent segment of an LSO operation. The
	 * flag is ignored if the LSO packet is a normal (non-tunneled) TCP
	 * packet.
	 */
	#define TX_BD_LONG_LFLAGS_OT_IPID		UINT32_C(0x4000)
	/*
	 * If set to '1', When set to 1, KTLS encryption will be enabled for
	 * the packet.
	 */
	#define TX_BD_LONG_LFLAGS_CRYPTO_EN	UINT32_C(0x8000)
	uint16_t	kid_or_ts_low_hdr_size;
	/*
	 * When LSO is '1', this field must contain the offset of the
	 * TCP payload from the beginning of the packet in as
	 * 16b words. In case of encapsulated/tunneling packet, this field
	 * contains the offset of the inner TCP payload from beginning of the
	 * packet as 16-bit words.
	 *
	 * This value must be valid on the first BD of a packet.
	 */
	#define TX_BD_LONG_HDR_SIZE_MASK	UINT32_C(0x1ff)
	#define TX_BD_LONG_HDR_SIZE_SFT	0
	/*
	 * If lflags.bd_ts_en is 1, this is the lower 7 bits of the 24-bit
	 * timestamp. If lflags.crypto_en is 1, this is the lower 7 bits of the
	 * 20-bit KID.
	 */
	#define TX_BD_LONG_KID_OR_TS_LOW_MASK UINT32_C(0xfe00)
	#define TX_BD_LONG_KID_OR_TS_LOW_SFT 9
	uint32_t	kid_or_ts_high_mss;
	/*
	 * This is the MSS value that will be used to do the LSO processing.
	 * The value is the length in bytes of the TCP payload for each
	 * segment generated by the LSO operation.
	 *
	 * This value must be valid on the first BD of a packet.
	 */
	#define TX_BD_LONG_MSS_MASK	UINT32_C(0x7fff)
	#define TX_BD_LONG_MSS_SFT		0
	/*
	 * If lflags.bd_ts_en is 1, this is the upper 17 bits of the 24-bit
	 * timestamp. If lflags.crypto_en is 1, the least significant 13 bits
	 * of this field contain the upper 13 bits of the 20-bit KID.
	 */
	#define TX_BD_LONG_KID_OR_TS_HIGH_MASK UINT32_C(0xffff8000)
	#define TX_BD_LONG_KID_OR_TS_HIGH_SFT 15
	/*
	 * This value selects bits 25:16 of the CFA action to perform on the
	 * packet. See the cfa_action field for more information.
	 */
	uint16_t	cfa_action_high;
	#define TX_BD_LONG_CFA_ACTION_HIGH_MASK UINT32_C(0x3ff)
	#define TX_BD_LONG_CFA_ACTION_HIGH_SFT 0
	/*
	 * This value selects a CFA action to perform on the packet.
	 * Set this value to zero if no CFA action is desired.
	 *
	 * This value must be valid on the first BD of a packet.
	 */
	uint16_t	cfa_action;
	/*
	 * This value is action meta-data that defines CFA edit operations
	 * that are done in addition to any action editing.
	 */
	uint32_t	cfa_meta;
	/* When key=1, This is the VLAN tag VID value. */
	#define TX_BD_LONG_CFA_META_VLAN_VID_MASK	UINT32_C(0xfff)
	#define TX_BD_LONG_CFA_META_VLAN_VID_SFT	0
	/* When key=1, This is the VLAN tag DE value. */
	#define TX_BD_LONG_CFA_META_VLAN_DE		UINT32_C(0x1000)
	/* When key=1, This is the VLAN tag PRI value. */
	#define TX_BD_LONG_CFA_META_VLAN_PRI_MASK	UINT32_C(0xe000)
	#define TX_BD_LONG_CFA_META_VLAN_PRI_SFT	13
	/* When key=1, This is the VLAN tag TPID select value. */
	#define TX_BD_LONG_CFA_META_VLAN_TPID_MASK	UINT32_C(0x70000)
	#define TX_BD_LONG_CFA_META_VLAN_TPID_SFT	16
	/* 0x88a8 */
		#define TX_BD_LONG_CFA_META_VLAN_TPID_TPID88A8	(UINT32_C(0x0) << 16)
	/* 0x8100 */
		#define TX_BD_LONG_CFA_META_VLAN_TPID_TPID8100	(UINT32_C(0x1) << 16)
	/* 0x9100 */
		#define TX_BD_LONG_CFA_META_VLAN_TPID_TPID9100	(UINT32_C(0x2) << 16)
	/* 0x9200 */
		#define TX_BD_LONG_CFA_META_VLAN_TPID_TPID9200	(UINT32_C(0x3) << 16)
	/* 0x9300 */
		#define TX_BD_LONG_CFA_META_VLAN_TPID_TPID9300	(UINT32_C(0x4) << 16)
	/* Value programmed in CFA VLANTPID register. */
		#define TX_BD_LONG_CFA_META_VLAN_TPID_TPIDCFG	(UINT32_C(0x5) << 16)
		#define TX_BD_LONG_CFA_META_VLAN_TPID_LAST	TX_BD_LONG_CFA_META_VLAN_TPID_TPIDCFG
	/* When key=1, This is the VLAN tag TPID select value. */
	#define TX_BD_LONG_CFA_META_VLAN_RESERVED_MASK   UINT32_C(0xff80000)
	#define TX_BD_LONG_CFA_META_VLAN_RESERVED_SFT	19
	/*
	 * This field identifies the type of edit to be performed
	 * on the packet.
	 *
	 * This value must be valid on the first BD of a packet.
	 */
	#define TX_BD_LONG_CFA_META_KEY_MASK		UINT32_C(0xf0000000)
	#define TX_BD_LONG_CFA_META_KEY_SFT		28
	/* No editing */
		#define TX_BD_LONG_CFA_META_KEY_NONE		(UINT32_C(0x0) << 28)
	/*
	 * - meta[17:16] - TPID select value (0 = 0x8100).
	 * - meta[15:12] - PRI/DE value.
	 * - meta[11:0] - VID value.
	 */
		#define TX_BD_LONG_CFA_META_KEY_VLAN_TAG	(UINT32_C(0x1) << 28)
	/*
	 * Provide metadata
	 * - Wh+/SR - this option is not supported.
	 * - Thor - cfa_meta[15:0] is used for metadata output if en_bd_meta
	 *   is set in the Lookup Table.
	 * - SR2 - {4’d0, cfa_meta[27:0]} is used for metadata output if
	 *   en_bd_meta is set in the Lookup Table.
	 */
		#define TX_BD_LONG_CFA_META_KEY_METADATA_TRANSFER  (UINT32_C(0x2) << 28)
		#define TX_BD_LONG_CFA_META_KEY_LAST		TX_BD_LONG_CFA_META_KEY_METADATA_TRANSFER
} tx_bd_long_hi_t, *ptx_bd_long_hi_t;

/*
 * This structure is used to inform the NIC of packet data that needs to be
 * transmitted with additional processing that requires extra data such as
 * VLAN insertion plus attached inline data. This BD type may be used to
 * improve latency for small packets needing the additional extended features
 * supported by long BDs.
 */
/* tx_bd_long_inline (size:256b/32B) */

typedef struct tx_bd_long_inline {
	uint16_t	flags_type;
	/* This value identifies the type of buffer descriptor. */
	#define TX_BD_LONG_INLINE_TYPE_MASK		UINT32_C(0x3f)
	#define TX_BD_LONG_INLINE_TYPE_SFT		0
	/*
	 * This type of BD is 32B long and is used for inline L2 packet
	 * transmission.
	 */
		#define TX_BD_LONG_INLINE_TYPE_TX_BD_LONG_INLINE  UINT32_C(0x11)
		#define TX_BD_LONG_INLINE_TYPE_LAST		TX_BD_LONG_INLINE_TYPE_TX_BD_LONG_INLINE
	/*
	 * All bits in this field may be set on the first BD of a packet.
	 * Only the packet_end bit may be set in non-first BDs.
	 */
	#define TX_BD_LONG_INLINE_FLAGS_MASK		UINT32_C(0xffc0)
	#define TX_BD_LONG_INLINE_FLAGS_SFT		6
	/*
	 * If set to 1, the packet ends with the data in the buffer
	 * pointed to by this descriptor. This flag must be
	 * valid on every BD.
	 */
	#define TX_BD_LONG_INLINE_FLAGS_PACKET_END	UINT32_C(0x40)
	/*
	 * If set to 1, the device will not generate a completion for
	 * this transmit packet unless there is an error in its processing.
	 * If this bit is set to 0, then the packet will be completed
	 * normally.
	 *
	 * This bit may be set only on the first BD of a packet.
	 */
	#define TX_BD_LONG_INLINE_FLAGS_NO_CMPL	UINT32_C(0x80)
	/*
	 * This value indicates how many 16B BD locations are consumed
	 * in the ring by this packet, including the BD and inline
	 * data.
	 */
	#define TX_BD_LONG_INLINE_FLAGS_BD_CNT_MASK	UINT32_C(0x1f00)
	#define TX_BD_LONG_INLINE_FLAGS_BD_CNT_SFT	8
	/* This field is deprecated. */
	#define TX_BD_LONG_INLINE_FLAGS_LHINT_MASK	UINT32_C(0x6000)
	#define TX_BD_LONG_INLINE_FLAGS_LHINT_SFT	13
	/*
	 * If set to 1, the device immediately updates the Send Consumer
	 * Index after the buffer associated with this descriptor has
	 * been transferred via DMA to NIC memory from host memory. An
	 * interrupt may or may not be generated according to the state
	 * of the interrupt avoidance mechanisms. If this bit
	 * is set to 0, then the Consumer Index is only updated as soon
	 * as one of the host interrupt coalescing conditions has been met.
	 *
	 * This bit must be valid on the first BD of a packet.
	 */
	#define TX_BD_LONG_INLINE_FLAGS_COAL_NOW	UINT32_C(0x8000)
	/*
	 * This is the length of the inline data, not including BD length, in
	 * bytes.
	 * The maximum value is 480.
	 *
	 * This field must be valid on all BDs of a packet.
	 */
	uint16_t	len;
	/*
	 * The opaque data field is passed through to the completion and can be
	 * used for any data that the driver wants to associate with the transmit
	 * BD. This field must be valid on the first BD of a packet. If
	 * completion coalescing is enabled on the TX ring, it is suggested that
	 * the driver populate the opaque field to indicate the specific TX ring
	 * with which the completion is associated, then utilize the opaque and
	 * sq_cons_idx fields in the coalesced completion record to determine
	 * the specific packets that are to be completed on that ring.
	 *
	 * This field must be valid on the first BD of a packet.
	 */
	uint32_t	opaque;
	uint64_t	unused1;
	/*
	 * All bits in this field must be valid on the first BD of a packet.
	 * Their value on other BDs of the packet is ignored.
	 */
	uint16_t	lflags;
	/*
	 * If set to 1, the controller replaces the TCP/UPD checksum
	 * fields of normal TCP/UPD checksum, or the inner TCP/UDP
	 * checksum field of the encapsulated TCP/UDP packets with the
	 * hardware calculated TCP/UDP checksum for the packet associated
	 * with this descriptor. The flag is ignored if the LSO flag is set.
	 */
	#define TX_BD_LONG_INLINE_LFLAGS_TCP_UDP_CHKSUM	UINT32_C(0x1)
	/*
	 * If set to 1, the controller replaces the IP checksum of the
	 * normal packets, or the inner IP checksum of the encapsulated
	 * packets with the hardware calculated IP checksum for the
	 * packet associated with this descriptor.
	 */
	#define TX_BD_LONG_INLINE_LFLAGS_IP_CHKSUM	UINT32_C(0x2)
	/*
	 * If set to 1, the controller will not append an Ethernet CRC
	 * to the end of the frame.
	 *
	 * Packet must be 64B or longer when this flag is set. It is not
	 * useful to use this bit with any form of TX offload such as
	 * CSO or LSO. The intent is that the packet from the host already
	 * has a valid Ethernet CRC on the packet.
	 */
	#define TX_BD_LONG_INLINE_LFLAGS_NOCRC		UINT32_C(0x4)
	/*
	 * If set to 1, the device will record the time at which the packet
	 * was actually transmitted at the TX MAC for 2-step time sync. This
	 * bit must be valid on the first BD of a packet.
	 */
	#define TX_BD_LONG_INLINE_LFLAGS_STAMP		UINT32_C(0x8)
	/*
	 * If set to 1, the controller replaces the tunnel IP checksum
	 * field with hardware calculated IP checksum for the IP header
	 * of the packet associated with this descriptor. The hardware
	 * updates an outer UDP checksum if it is non-zero.
	 */
	#define TX_BD_LONG_INLINE_LFLAGS_T_IP_CHKSUM	UINT32_C(0x10)
	/*
	 * This bit must be 0 for BDs of this type. LSO is not supported with
	 * inline BDs.
	 */
	#define TX_BD_LONG_INLINE_LFLAGS_LSO		UINT32_C(0x20)
	/* Since LSO is not supported with inline BDs, this bit is not used. */
	#define TX_BD_LONG_INLINE_LFLAGS_IPID_FMT	UINT32_C(0x40)
	/* Since LSO is not supported with inline BDs, this bit is not used. */
	#define TX_BD_LONG_INLINE_LFLAGS_T_IPID		UINT32_C(0x80)
	/*
	 * If set to '1', then the RoCE ICRC will be appended to the
	 * packet. Packet must be a valid RoCE format packet.
	 */
	#define TX_BD_LONG_INLINE_LFLAGS_ROCE_CRC	UINT32_C(0x100)
	/*
	 * If set to '1', then the FCoE CRC will be appended to the
	 * packet. Packet must be a valid FCoE format packet.
	 */
	#define TX_BD_LONG_INLINE_LFLAGS_FCOE_CRC	UINT32_C(0x200)
	/*
	 * If set to '1', then the timestamp from the BD is used. If cleared
	 * to 0, then TWE provides the timestamp.
	 */
	#define TX_BD_LONG_INLINE_LFLAGS_BD_TS_EN	UINT32_C(0x400)
	/*
	 * If set to '1', this operation will cause a trace capture in each
	 * block it passes through.
	 */
	#define TX_BD_LONG_INLINE_LFLAGS_DEBUG_TRACE	UINT32_C(0x800)
	/*
	 * If set to '1', the device will record the time at which the packet
	 * was actually transmitted at the TX MAC for 1-step time sync. This
	 * bit must be valid on the first BD of a packet.
	 */
	#define TX_BD_LONG_INLINE_LFLAGS_STAMP_1STEP	UINT32_C(0x1000)
	/*
	 * If set to '1', the controller replaces the Outer-tunnel IP checksum
	 * field with hardware calculated IP checksum for the IP header of the
	 * packet associated with this descriptor. For outer UDP checksum, it
	 * will be the following behavior for all cases independent of settings
	 * of inner LSO and checksum offload BD flags. If outer UDP checksum
	 * is 0, then do not update it. If outer UDP checksum is non zero, then
	 * the hardware should compute and update it.
	 */
	#define TX_BD_LONG_INLINE_LFLAGS_OT_IP_CHKSUM	UINT32_C(0x2000)
	/*
	 * If set to zero when LSO is '1', then the IPID of the Outer-tunnel IP
	 * header will not be modified during LSO operations. If set to one
	 * when LSO is '1', then the IPID of the Outer-tunnel IP header will be
	 * incremented for each subsequent segment of an LSO operation. The
	 * flag is ignored if the LSO packet is a normal (non-tunneled) TCP
	 * packet.
	 */
	#define TX_BD_LONG_INLINE_LFLAGS_OT_IPID		UINT32_C(0x4000)
	/*
	 * If set to '1', When set to 1, KTLS encryption will be enabled for
	 * the packet.
	 */
	#define TX_BD_LONG_INLINE_LFLAGS_CRYPTO_EN	UINT32_C(0x8000)
	uint8_t	unused2;
	uint8_t	kid_or_ts_low;
	#define TX_BD_LONG_INLINE_UNUSED		UINT32_C(0x1)
	/*
	 * If lflags.bd_ts_en is 1, this is the lower 7 bits of the 24-bit
	 * timestamp. If lflags.crypto_en is 1, this is the lower 7 bits of
	 * the 20-bit KID.
	 */
	#define TX_BD_LONG_INLINE_KID_OR_TS_LOW_MASK UINT32_C(0xfe)
	#define TX_BD_LONG_INLINE_KID_OR_TS_LOW_SFT 1
	uint32_t	kid_or_ts_high;
	#define TX_BD_LONG_INLINE_UNUSED_MASK	UINT32_C(0x7fff)
	#define TX_BD_LONG_INLINE_UNUSED_SFT	0
	/*
	 * If lflags.bd_ts_en is 1, this is the upper 17 bits of the 24-bit
	 * timestamp. If lflags.crypto_en is 1, the least significant 13 bits
	 * of this field contain the upper 13 bits of the 20-bit KID.
	 */
	#define TX_BD_LONG_INLINE_KID_OR_TS_HIGH_MASK UINT32_C(0xffff8000)
	#define TX_BD_LONG_INLINE_KID_OR_TS_HIGH_SFT 15
	/*
	 * This value selects bits 25:16 of the CFA action to perform on the
	 * packet. See the cfa_action field for more information.
	 */
	uint16_t	cfa_action_high;
	#define TX_BD_LONG_INLINE_CFA_ACTION_HIGH_MASK UINT32_C(0x3ff)
	#define TX_BD_LONG_INLINE_CFA_ACTION_HIGH_SFT 0
	/*
	 * This value selects a CFA action to perform on the packet.
	 * Set this value to zero if no CFA action is desired.
	 *
	 * This value must be valid on the first BD of a packet.
	 */
	uint16_t	cfa_action;
	/*
	 * This value is action meta-data that defines CFA edit operations
	 * that are done in addition to any action editing.
	 */
	uint32_t	cfa_meta;
	/* When key = 1, this is the VLAN tag VID value. */
	#define TX_BD_LONG_INLINE_CFA_META_VLAN_VID_MASK	UINT32_C(0xfff)
	#define TX_BD_LONG_INLINE_CFA_META_VLAN_VID_SFT	0
	/* When key = 1, this is the VLAN tag DE value. */
	#define TX_BD_LONG_INLINE_CFA_META_VLAN_DE		UINT32_C(0x1000)
	/* When key = 1, this is the VLAN tag PRI value. */
	#define TX_BD_LONG_INLINE_CFA_META_VLAN_PRI_MASK	UINT32_C(0xe000)
	#define TX_BD_LONG_INLINE_CFA_META_VLAN_PRI_SFT	13
	/* When key = 1, this is the VLAN tag TPID select value. */
	#define TX_BD_LONG_INLINE_CFA_META_VLAN_TPID_MASK	UINT32_C(0x70000)
	#define TX_BD_LONG_INLINE_CFA_META_VLAN_TPID_SFT	16
	/* 0x88a8 */
		#define TX_BD_LONG_INLINE_CFA_META_VLAN_TPID_TPID88A8	(UINT32_C(0x0) << 16)
	/* 0x8100 */
		#define TX_BD_LONG_INLINE_CFA_META_VLAN_TPID_TPID8100	(UINT32_C(0x1) << 16)
	/* 0x9100 */
		#define TX_BD_LONG_INLINE_CFA_META_VLAN_TPID_TPID9100	(UINT32_C(0x2) << 16)
	/* 0x9200 */
		#define TX_BD_LONG_INLINE_CFA_META_VLAN_TPID_TPID9200	(UINT32_C(0x3) << 16)
	/* 0x9300 */
		#define TX_BD_LONG_INLINE_CFA_META_VLAN_TPID_TPID9300	(UINT32_C(0x4) << 16)
	/* Value programmed in CFA VLANTPID register. */
		#define TX_BD_LONG_INLINE_CFA_META_VLAN_TPID_TPIDCFG	(UINT32_C(0x5) << 16)
		#define TX_BD_LONG_INLINE_CFA_META_VLAN_TPID_LAST	TX_BD_LONG_INLINE_CFA_META_VLAN_TPID_TPIDCFG
	#define TX_BD_LONG_INLINE_CFA_META_VLAN_RESERVED_MASK   UINT32_C(0xff80000)
	#define TX_BD_LONG_INLINE_CFA_META_VLAN_RESERVED_SFT	19
	/*
	 * This field identifies the type of edit to be performed
	 * on the packet.
	 *
	 * This value must be valid on the first BD of a packet.
	 */
	#define TX_BD_LONG_INLINE_CFA_META_KEY_MASK		UINT32_C(0xf0000000)
	#define TX_BD_LONG_INLINE_CFA_META_KEY_SFT		28
	/* No editing */
		#define TX_BD_LONG_INLINE_CFA_META_KEY_NONE		(UINT32_C(0x0) << 28)
	/*
	 * - meta[17:16] - TPID select value (0 = 0x8100).
	 * - meta[15:12] - PRI/DE value.
	 * - meta[11:0] - VID value.
	 */
		#define TX_BD_LONG_INLINE_CFA_META_KEY_VLAN_TAG	(UINT32_C(0x1) << 28)
	/*
	 * Provide metadata
	 * - Wh+/SR - this option is not supported.
	 * - Thor - cfa_meta[15:0] is used for metadata output if en_bd_meta
	 *   is set in the Lookup Table.
	 * - SR2 - {4’d0, cfa_meta[27:0]} is used for metadata output if
	 *   en_bd_meta is set in the Lookup Table.
	 */
		#define TX_BD_LONG_INLINE_CFA_META_KEY_METADATA_TRANSFER  (UINT32_C(0x2) << 28)
		#define TX_BD_LONG_INLINE_CFA_META_KEY_LAST		TX_BD_LONG_INLINE_CFA_META_KEY_METADATA_TRANSFER
} tx_bd_long_inline_t, *ptx_bd_long_inline_t;

/* tx_bd_empty (size:128b/16B) */

typedef struct tx_bd_empty {
	/* This value identifies the type of buffer descriptor. */
	uint8_t	type;
	#define TX_BD_EMPTY_TYPE_MASK	UINT32_C(0x3f)
	#define TX_BD_EMPTY_TYPE_SFT	0
	/*
	 * Indicates that this BD is 1BB long and is an empty
	 * TX BD. Not valid for use by the driver.
	 */
		#define TX_BD_EMPTY_TYPE_TX_BD_EMPTY  UINT32_C(0x1)
		#define TX_BD_EMPTY_TYPE_LAST	TX_BD_EMPTY_TYPE_TX_BD_EMPTY
	uint8_t	unused_1[3];
	uint8_t	unused_2;
	uint8_t	unused_3[3];
	uint8_t	unused_4[8];
} tx_bd_empty_t, *ptx_bd_empty_t;

/* tx_bd_mp_cmd (size:128b/16B) */

typedef struct tx_bd_mp_cmd {
	/* Unless otherwise stated, sub-fields of this field are always valid. */
	uint16_t	flags_type;
	/* This value identifies the type of buffer descriptor. */
	#define TX_BD_MP_CMD_TYPE_MASK	UINT32_C(0x3f)
	#define TX_BD_MP_CMD_TYPE_SFT	0
	/*
	 * Indicates that this BD is used to issue a command to one of
	 * the mid-path destinations.
	 */
		#define TX_BD_MP_CMD_TYPE_TX_BD_MP_CMD  UINT32_C(0x8)
		#define TX_BD_MP_CMD_TYPE_LAST	TX_BD_MP_CMD_TYPE_TX_BD_MP_CMD
	#define TX_BD_MP_CMD_FLAGS_MASK	UINT32_C(0xffc0)
	#define TX_BD_MP_CMD_FLAGS_SFT	6
	/*  */
	#define TX_BD_MP_CMD_FLAGS_UNUSED_MASK UINT32_C(0xc0)
	#define TX_BD_MP_CMD_FLAGS_UNUSED_SFT  6
	/*
	 * This value indicates the number of 16B BD locations (slots)
	 * consumed in the ring by this mid-path command BD, including the
	 * BD header and the command field.
	 */
	#define TX_BD_MP_CMD_FLAGS_BD_CNT_MASK UINT32_C(0x1f00)
	#define TX_BD_MP_CMD_FLAGS_BD_CNT_SFT  8
	/*
	 * This value defines the length of command field in bytes. The maximum
	 * value shall be 496.
	 */
	uint16_t	len;
	/*
	 * The opaque data field is pass through to the completion and can be
	 * used for any data that the driver wants to associate with this
	 * Tx mid-path command.
	 */
	uint32_t	opaque;
	uint64_t	unused1;
} tx_bd_mp_cmd_t, *ptx_bd_mp_cmd_t;

/* tx_bd_presync_cmd (size:128b/16B) */

typedef struct tx_bd_presync_cmd {
	/* Unless otherwise stated, sub-fields of this field are always valid. */
	uint16_t	flags_type;
	/* This value identifies the type of buffer descriptor. */
	#define TX_BD_PRESYNC_CMD_TYPE_MASK		UINT32_C(0x3f)
	#define TX_BD_PRESYNC_CMD_TYPE_SFT		0
	/*
	 * Indicates that this BD is used to issue a cryptographic pre-
	 * sync command through the fast path and destined for TCE.
	 */
		#define TX_BD_PRESYNC_CMD_TYPE_TX_BD_PRESYNC_CMD  UINT32_C(0x9)
		#define TX_BD_PRESYNC_CMD_TYPE_LAST		TX_BD_PRESYNC_CMD_TYPE_TX_BD_PRESYNC_CMD
	#define TX_BD_PRESYNC_CMD_FLAGS_MASK		UINT32_C(0xffc0)
	#define TX_BD_PRESYNC_CMD_FLAGS_SFT		6
	/*  */
	#define TX_BD_PRESYNC_CMD_FLAGS_UNUSED_MASK	UINT32_C(0xc0)
	#define TX_BD_PRESYNC_CMD_FLAGS_UNUSED_SFT	6
	/*
	 * This value indicates the number of 16B BD locations (slots)
	 * consumed in the ring by this pre-sync command BD, including the
	 * BD header and the command field.
	 */
	#define TX_BD_PRESYNC_CMD_FLAGS_BD_CNT_MASK	UINT32_C(0x1f00)
	#define TX_BD_PRESYNC_CMD_FLAGS_BD_CNT_SFT	8
	/*
	 * This value defines the length of command field in bytes. The maximum
	 * value shall be 496.
	 */
	uint16_t	len;
	/*
	 * The opaque data field is pass through to TCE and can be used for
	 * debug.
	 */
	uint32_t	opaque;
	/*
	 * This field is the Crypto Context ID to which the retransmit packet is
	 * applied. The KID references the context fields used by the
	 * associated kTLS offloaded connection.
	 */
	uint32_t	kid;
	/*
	 * The KID value of all-ones is reserved for non-KTLS packets, which
	 * only implies that this value must not be used when filling this
	 * field for crypto packets.
	 */
	#define TX_BD_PRESYNC_CMD_KID_VAL_MASK UINT32_C(0xfffff)
	#define TX_BD_PRESYNC_CMD_KID_VAL_SFT 0
	uint32_t	unused_1;
} tx_bd_presync_cmd_t, *ptx_bd_presync_cmd_t;

/* rx_prod_pkt_bd (size:128b/16B) */

typedef struct rx_prod_pkt_bd {
	/* This value identifies the type of buffer descriptor. */
	uint16_t	flags_type;
	/* This value identifies the type of buffer descriptor. */
	#define RX_PROD_PKT_BD_TYPE_MASK	UINT32_C(0x3f)
	#define RX_PROD_PKT_BD_TYPE_SFT	0
	/*
	 * Indicates that this BD is 16B long and is an RX Producer
	 * (i.e. empty) buffer descriptor.
	 */
		#define RX_PROD_PKT_BD_TYPE_RX_PROD_PKT	UINT32_C(0x4)
		#define RX_PROD_PKT_BD_TYPE_LAST	RX_PROD_PKT_BD_TYPE_RX_PROD_PKT
	#define RX_PROD_PKT_BD_FLAGS_MASK	UINT32_C(0xffc0)
	#define RX_PROD_PKT_BD_FLAGS_SFT	6
	/*
	 * If set to 1, the packet will be placed at the address plus
	 * 2B. The 2 Bytes of padding will be written as zero.
	 */
	#define RX_PROD_PKT_BD_FLAGS_SOP_PAD	UINT32_C(0x40)
	/*
	 * If set to 1, the packet write will be padded out to the
	 * nearest cache-line with zero value padding.
	 */
	#define RX_PROD_PKT_BD_FLAGS_EOP_PAD	UINT32_C(0x80)
	/*
	 * This field has been deprecated. There can be no additional
	 * BDs for this packet from this ring.
	 *
	 * Old definition:
	 * This value is the number of additional buffers in the ring that
	 * describe the buffer space to be consumed for this packet.
	 * If the value is zero, then the packet must fit within the
	 * space described by this BD. If this value is 1 or more, it
	 * indicates how many additional "buffer" BDs are in the ring
	 * immediately following this BD to be used for the same
	 * network packet. Even if the packet to be placed does not need
	 * all the additional buffers, they will be consumed anyway.
	 */
	#define RX_PROD_PKT_BD_FLAGS_BUFFERS_MASK UINT32_C(0x300)
	#define RX_PROD_PKT_BD_FLAGS_BUFFERS_SFT  8
	/*
	 * This is the length in Bytes of the host physical buffer where
	 * data for the packet may be placed in host memory.
	 */
	uint16_t	len;
	/*
	 * The opaque data field is pass through to the completion and can be
	 * used for any data that the driver wants to associate with this
	 * receive buffer set.
	 */
	uint32_t	opaque;
	/*
	 * This is the host physical address where data for the packet may
	 * be placed in host memory.
	 */
	uint64_t	addr;
} rx_prod_pkt_bd_t, *prx_prod_pkt_bd_t;

/* rx_prod_bfr_bd (size:128b/16B) */

typedef struct rx_prod_bfr_bd {
	/* This value identifies the type of buffer descriptor. */
	uint16_t	flags_type;
	/* This value identifies the type of buffer descriptor. */
	#define RX_PROD_BFR_BD_TYPE_MASK	UINT32_C(0x3f)
	#define RX_PROD_BFR_BD_TYPE_SFT	0
	/*
	 * Indicates that this BD is 16B long and is an RX
	 * Producer Buffer BD.
	 */
		#define RX_PROD_BFR_BD_TYPE_RX_PROD_BFR  UINT32_C(0x5)
		#define RX_PROD_BFR_BD_TYPE_LAST	RX_PROD_BFR_BD_TYPE_RX_PROD_BFR
	#define RX_PROD_BFR_BD_FLAGS_MASK	UINT32_C(0xffc0)
	#define RX_PROD_BFR_BD_FLAGS_SFT	6
	/*
	 * This is the length in Bytes of the host physical buffer where
	 * data for the packet may be placed in host memory.
	 */
	uint16_t	len;
	/* This field is not used. */
	uint32_t	opaque;
	/*
	 * This is the host physical address where data for the packet may
	 * be placed in host memory.
	 */
	uint64_t	addr;
} rx_prod_bfr_bd_t, *prx_prod_bfr_bd_t;

/* rx_prod_agg_bd (size:128b/16B) */

typedef struct rx_prod_agg_bd {
	/* This value identifies the type of buffer descriptor. */
	uint16_t	flags_type;
	/* This value identifies the type of buffer descriptor. */
	#define RX_PROD_AGG_BD_TYPE_MASK	UINT32_C(0x3f)
	#define RX_PROD_AGG_BD_TYPE_SFT	0
	/*
	 * Indicates that this BD is 16B long and is an
	 * RX Producer Assembly Buffer Descriptor.
	 */
		#define RX_PROD_AGG_BD_TYPE_RX_PROD_AGG	UINT32_C(0x6)
		#define RX_PROD_AGG_BD_TYPE_LAST	RX_PROD_AGG_BD_TYPE_RX_PROD_AGG
	#define RX_PROD_AGG_BD_FLAGS_MASK	UINT32_C(0xffc0)
	#define RX_PROD_AGG_BD_FLAGS_SFT	6
	/*
	 * If set to 1, the packet write will be padded out to the
	 * nearest cache-line with zero value padding.
	 */
	#define RX_PROD_AGG_BD_FLAGS_EOP_PAD	UINT32_C(0x40)
	/*
	 * This is the length in Bytes of the host physical buffer where
	 * data for the packet may be placed in host memory.
	 */
	uint16_t	len;
	/*
	 * The opaque data field is pass through to the completion and can be
	 * used for any data that the driver wants to associate with this
	 * receive assembly buffer.
	 */
	uint32_t	opaque;
	/*
	 * This is the host physical address where data for the packet may
	 * be placed in host memory.
	 */
	uint64_t	addr;
} rx_prod_agg_bd_t, *prx_prod_agg_bd_t;

/* cfa_cmpls_cmp_data_msg (size:128b/16B) */

typedef struct cfa_cmpls_cmp_data_msg {
	uint32_t	mp_client_dma_length_opcode_status_type;
	/*
	 * This field represents the Mid-Path client that generated the
	 * completion.
	 */
	#define CFA_CMPLS_CMP_DATA_MSG_TYPE_MASK		UINT32_C(0x3f)
	#define CFA_CMPLS_CMP_DATA_MSG_TYPE_SFT		0
	/* Mid Path Short Completion with length = 16B. */
		#define CFA_CMPLS_CMP_DATA_MSG_TYPE_MID_PATH_SHORT	UINT32_C(0x1e)
		#define CFA_CMPLS_CMP_DATA_MSG_TYPE_LAST		CFA_CMPLS_CMP_DATA_MSG_TYPE_MID_PATH_SHORT
	/* This value indicates the status for the command. */
	#define CFA_CMPLS_CMP_DATA_MSG_STATUS_MASK		UINT32_C(0x3c0)
	#define CFA_CMPLS_CMP_DATA_MSG_STATUS_SFT		6
	/* Completed without error. */
		#define CFA_CMPLS_CMP_DATA_MSG_STATUS_OK		(UINT32_C(0x0) << 6)
	/* Indicates an unsupported CFA opcode in the command. */
		#define CFA_CMPLS_CMP_DATA_MSG_STATUS_UNSPRT_ERR	(UINT32_C(0x1) << 6)
	/*
	 * Indicates a CFA command formatting error. This error can occur on
	 * any of the supported CFA commands.
	 */
		#define CFA_CMPLS_CMP_DATA_MSG_STATUS_FMT_ERR		(UINT32_C(0x2) << 6)
	/*
	 * Indicates an SVIF-Table scope error. This error can occur on any
	 * of the supported CFA commands.
	 */
		#define CFA_CMPLS_CMP_DATA_MSG_STATUS_SCOPE_ERR	(UINT32_C(0x3) << 6)
	/*
	 * Indicates that the table_index is either outside of the
	 * table_scope range set by its EM_SIZE or, for EM Insert, it is in
	 * the static bucket range. This error can occur on EM Insert
	 * commands. It can also occur on Read, Read Clear, Write, and
	 * Invalidate commands if the table_type is EM.
	 */
		#define CFA_CMPLS_CMP_DATA_MSG_STATUS_ADDR_ERR		(UINT32_C(0x4) << 6)
	/*
	 * Cache operation responded with an error. This error can occur on
	 * Read, Read Clear, Write, EM Insert, and EM Delete commands.
	 */
		#define CFA_CMPLS_CMP_DATA_MSG_STATUS_CACHE_ERR	(UINT32_C(0x5) << 6)
	/*
	 * Indicates failure on EM Insert or EM Delete Command. Hash index
	 * and hash msb are returned in table_index and hash_msb fields.
	 * Dma_length is set to 1 if the bucket is also returned (as dma
	 * data).
	 */
		#define CFA_CMPLS_CMP_DATA_MSG_STATUS_EM_FAIL		(UINT32_C(0x6) << 6)
	/*
	 * Indicates no notifications were available on an Event Collection
	 * command.
	 */
		#define CFA_CMPLS_CMP_DATA_MSG_STATUS_EVENT_COLLECT_FAIL  (UINT32_C(0x7) << 6)
		#define CFA_CMPLS_CMP_DATA_MSG_STATUS_LAST		CFA_CMPLS_CMP_DATA_MSG_STATUS_EVENT_COLLECT_FAIL
	#define CFA_CMPLS_CMP_DATA_MSG_UNUSED0_MASK		UINT32_C(0xc00)
	#define CFA_CMPLS_CMP_DATA_MSG_UNUSED0_SFT		10
	/* This is the opcode from the command. */
	#define CFA_CMPLS_CMP_DATA_MSG_OPCODE_MASK		UINT32_C(0xff000)
	#define CFA_CMPLS_CMP_DATA_MSG_OPCODE_SFT		12
	/*
	 * This is read command. From 32 to 128B can be read from a table
	 * using this command.
	 */
		#define CFA_CMPLS_CMP_DATA_MSG_OPCODE_READ		(UINT32_C(0x0) << 12)
	/*
	 * This is write command. From 32 to 128B can be written to a table
	 * using this command.
	 */
		#define CFA_CMPLS_CMP_DATA_MSG_OPCODE_WRITE		(UINT32_C(0x1) << 12)
	/*
	 * This is read-clear command. 32B can be read from a table and a 16b
	 * mask can be used to clear specific 16b units after the read as an
	 * atomic operation.
	 */
		#define CFA_CMPLS_CMP_DATA_MSG_OPCODE_READ_CLR		(UINT32_C(0x2) << 12)
	/*
	 * An exact match table insert will be attempted into the table. If
	 * there is a free location in the bucket, the payload will be
	 * written to the bucket.
	 */
		#define CFA_CMPLS_CMP_DATA_MSG_OPCODE_EM_INSERT	(UINT32_C(0x3) << 12)
	/* An exact match table delete will be attempted. */
		#define CFA_CMPLS_CMP_DATA_MSG_OPCODE_EM_DELETE	(UINT32_C(0x4) << 12)
	/*
	 * The specified table area will be invalidated. If it is needed
	 * again, it will be read from the backing store.
	 */
		#define CFA_CMPLS_CMP_DATA_MSG_OPCODE_INVALIDATE	(UINT32_C(0x5) << 12)
	/* Reads notification messages from the Host Notification Queue. */
		#define CFA_CMPLS_CMP_DATA_MSG_OPCODE_EVENT_COLLECT	(UINT32_C(0x6) << 12)
		#define CFA_CMPLS_CMP_DATA_MSG_OPCODE_LAST		CFA_CMPLS_CMP_DATA_MSG_OPCODE_EVENT_COLLECT
	/*
	 * This field indicates the length of the DMA that accompanies the
	 * completion. Specified in units of DWords (32b). Valid values are
	 * between 0 and 128. A value of zero indicates that there is no DMA
	 * that accompanies the completion.
	 */
	#define CFA_CMPLS_CMP_DATA_MSG_DMA_LENGTH_MASK	UINT32_C(0xff00000)
	#define CFA_CMPLS_CMP_DATA_MSG_DMA_LENGTH_SFT	20
	/*
	 * This field represents the Mid-Path client that generated the
	 * completion.
	 */
	#define CFA_CMPLS_CMP_DATA_MSG_MP_CLIENT_MASK	UINT32_C(0xf0000000)
	#define CFA_CMPLS_CMP_DATA_MSG_MP_CLIENT_SFT		28
	/* TX configrable flow processing block. */
		#define CFA_CMPLS_CMP_DATA_MSG_MP_CLIENT_TE_CFA	(UINT32_C(0x2) << 28)
	/* RX configrable flow processing block. */
		#define CFA_CMPLS_CMP_DATA_MSG_MP_CLIENT_RE_CFA	(UINT32_C(0x3) << 28)
		#define CFA_CMPLS_CMP_DATA_MSG_MP_CLIENT_LAST		CFA_CMPLS_CMP_DATA_MSG_MP_CLIENT_RE_CFA
	/*
	 * This is a copy of the opaque field from the mid path BD of this
	 * command.
	 */
	uint32_t	opaque;
	uint16_t	hash_msb_v;
	/*
	 * This value is written by the NIC such that it will be different for
	 * each pass through the completion queue. The even passes will
	 * write 1. The odd passes will write 0.
	 */
	#define CFA_CMPLS_CMP_DATA_MSG_V		UINT32_C(0x1)
	#define CFA_CMPLS_CMP_DATA_MSG_UNUSED1_MASK UINT32_C(0xe)
	#define CFA_CMPLS_CMP_DATA_MSG_UNUSED1_SFT  1
	/*
	 * This is the upper 12b of the hash, returned on Exact Match
	 * Insertion/Deletion Commands.
	 */
	#define CFA_CMPLS_CMP_DATA_MSG_HASH_MSB_MASK UINT32_C(0xfff0)
	#define CFA_CMPLS_CMP_DATA_MSG_HASH_MSB_SFT 4
	/* This is the table type from the command. */
	uint8_t	table_type;
	#define CFA_CMPLS_CMP_DATA_MSG_UNUSED2_MASK	UINT32_C(0xf)
	#define CFA_CMPLS_CMP_DATA_MSG_UNUSED2_SFT	0
	#define CFA_CMPLS_CMP_DATA_MSG_TABLE_TYPE_MASK  UINT32_C(0xf0)
	#define CFA_CMPLS_CMP_DATA_MSG_TABLE_TYPE_SFT   4
	/* This command acts on the action table of the specified scope. */
		#define CFA_CMPLS_CMP_DATA_MSG_TABLE_TYPE_ACTION  (UINT32_C(0x0) << 4)
	/* This command acts on the exact match table of the specified scope. */
		#define CFA_CMPLS_CMP_DATA_MSG_TABLE_TYPE_EM	(UINT32_C(0x1) << 4)
		#define CFA_CMPLS_CMP_DATA_MSG_TABLE_TYPE_LAST   CFA_CMPLS_CMP_DATA_MSG_TABLE_TYPE_EM
	uint8_t	table_scope;
	/* This is the table scope from the command. */
	#define CFA_CMPLS_CMP_DATA_MSG_TABLE_SCOPE_MASK UINT32_C(0x1f)
	#define CFA_CMPLS_CMP_DATA_MSG_TABLE_SCOPE_SFT 0
	uint32_t	table_index;
	/*
	 * This is the table index from the command (if it exists). However, if
	 * an Exact Match Insertion/Deletion command failed, then this is the
	 * table index of the calculated static hash bucket.
	 */
	#define CFA_CMPLS_CMP_DATA_MSG_TABLE_INDEX_MASK UINT32_C(0x3ffffff)
	#define CFA_CMPLS_CMP_DATA_MSG_TABLE_INDEX_SFT 0
} cfa_cmpls_cmp_data_msg_t, *pcfa_cmpls_cmp_data_msg_t;

/* CFA Mid-Path 32B DMA Message */
/* cfa_dma32b_data_msg (size:256b/32B) */

typedef struct cfa_dma32b_data_msg {
	/* DMA data value. */
	uint32_t	dta[8];
} cfa_dma32b_data_msg_t, *pcfa_dma32b_data_msg_t;

/* CFA Mid-Path 64B DMA Message */
/* cfa_dma64b_data_msg (size:512b/64B) */

typedef struct cfa_dma64b_data_msg {
	/* DMA data value. */
	uint32_t	dta[16];
} cfa_dma64b_data_msg_t, *pcfa_dma64b_data_msg_t;

/* CFA Mid-Path 96B DMA Message */
/* cfa_dma96b_data_msg (size:768b/96B) */

typedef struct cfa_dma96b_data_msg {
	/* DMA data value. */
	uint32_t	dta[24];
} cfa_dma96b_data_msg_t, *pcfa_dma96b_data_msg_t;

/* CFA Mid-Path 128B DMA Message */
/* cfa_dma128b_data_msg (size:1024b/128B) */

typedef struct cfa_dma128b_data_msg {
	/* DMA data value. */
	uint32_t	dta[32];
} cfa_dma128b_data_msg_t, *pcfa_dma128b_data_msg_t;

/* ce_cmpls_cmp_data_msg (size:128b/16B) */

typedef struct ce_cmpls_cmp_data_msg {
	uint16_t	status_subtype_type;
	/*
	 * This field indicates the exact type of the completion. By
	 * convention, the LSB identifies the length of the record in 16B
	 * units. Even values indicate 16B records. Odd values indicate 32B
	 * records.
	 */
	#define CE_CMPLS_CMP_DATA_MSG_TYPE_MASK	UINT32_C(0x3f)
	#define CE_CMPLS_CMP_DATA_MSG_TYPE_SFT	0
	/* Completion of a Mid Path Command. Length = 16B */
		#define CE_CMPLS_CMP_DATA_MSG_TYPE_MID_PATH_SHORT  UINT32_C(0x1e)
		#define CE_CMPLS_CMP_DATA_MSG_TYPE_LAST	CE_CMPLS_CMP_DATA_MSG_TYPE_MID_PATH_SHORT
	/*
	 * This value indicates the CE sub-type operation that is being
	 * completed.
	 */
	#define CE_CMPLS_CMP_DATA_MSG_SUBTYPE_MASK	UINT32_C(0x3c0)
	#define CE_CMPLS_CMP_DATA_MSG_SUBTYPE_SFT	6
	/* Completion Response for a Solicited Command. */
		#define CE_CMPLS_CMP_DATA_MSG_SUBTYPE_SOLICITED	(UINT32_C(0x0) << 6)
	/* Error Completion (Unsolicited). */
		#define CE_CMPLS_CMP_DATA_MSG_SUBTYPE_ERR	(UINT32_C(0x1) << 6)
	/* Re-Sync Completion (Unsolicited) */
		#define CE_CMPLS_CMP_DATA_MSG_SUBTYPE_RESYNC	(UINT32_C(0x2) << 6)
		#define CE_CMPLS_CMP_DATA_MSG_SUBTYPE_LAST	CE_CMPLS_CMP_DATA_MSG_SUBTYPE_RESYNC
	/* This value indicates the status for the command. */
	#define CE_CMPLS_CMP_DATA_MSG_STATUS_MASK	UINT32_C(0x3c00)
	#define CE_CMPLS_CMP_DATA_MSG_STATUS_SFT	10
	/* Completed without error. */
		#define CE_CMPLS_CMP_DATA_MSG_STATUS_OK		(UINT32_C(0x0) << 10)
	/* CFCK load error. */
		#define CE_CMPLS_CMP_DATA_MSG_STATUS_CTX_LD_ERR	(UINT32_C(0x1) << 10)
	/* FID check error. */
		#define CE_CMPLS_CMP_DATA_MSG_STATUS_FID_CHK_ERR   (UINT32_C(0x2) << 10)
		#define CE_CMPLS_CMP_DATA_MSG_STATUS_LAST	CE_CMPLS_CMP_DATA_MSG_STATUS_FID_CHK_ERR
	uint8_t	unused0;
	uint8_t	mp_clients;
	#define CE_CMPLS_CMP_DATA_MSG_UNUSED1_MASK   UINT32_C(0xf)
	#define CE_CMPLS_CMP_DATA_MSG_UNUSED1_SFT	0
	/*
	 * This field represents the Mid-Path client that generated the
	 * completion.
	 */
	#define CE_CMPLS_CMP_DATA_MSG_MP_CLIENTS_MASK UINT32_C(0xf0)
	#define CE_CMPLS_CMP_DATA_MSG_MP_CLIENTS_SFT 4
	/* TX crypto engine block. */
		#define CE_CMPLS_CMP_DATA_MSG_MP_CLIENTS_TCE   (UINT32_C(0x0) << 4)
	/* RX crypto engine block. */
		#define CE_CMPLS_CMP_DATA_MSG_MP_CLIENTS_RCE   (UINT32_C(0x1) << 4)
		#define CE_CMPLS_CMP_DATA_MSG_MP_CLIENTS_LAST CE_CMPLS_CMP_DATA_MSG_MP_CLIENTS_RCE
	/*
	 * This is a copy of the opaque field from the mid path BD of this
	 * command.
	 */
	uint32_t	opaque;
	/*  */
	uint32_t	kid_v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes will
	 * write 1. The odd passes will write 0.
	 */
	#define CE_CMPLS_CMP_DATA_MSG_V	UINT32_C(0x1)
	/*
	 * This field is the Crypto Context ID. The KID is used to store
	 * information used by the associated kTLS offloaded connection.
	 */
	#define CE_CMPLS_CMP_DATA_MSG_KID_MASK UINT32_C(0x1ffffe)
	#define CE_CMPLS_CMP_DATA_MSG_KID_SFT 1
	uint32_t	unused2;
} ce_cmpls_cmp_data_msg_t, *pce_cmpls_cmp_data_msg_t;

/* cmpl_base (size:128b/16B) */

typedef struct cmpl_base {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define CMPL_BASE_TYPE_MASK		UINT32_C(0x3f)
	#define CMPL_BASE_TYPE_SFT		0
	/*
	 * TX L2 completion:
	 * Completion of TX packet. Length = 16B
	 */
		#define CMPL_BASE_TYPE_TX_L2		UINT32_C(0x0)
	/*
	 * NO-OP completion:
	 * Completion of NO-OP. Length = 16B
	 */
		#define CMPL_BASE_TYPE_NO_OP		UINT32_C(0x1)
	/*
	 * TX L2 coalesced completion:
	 * Completion of coalesced TX packet. Length = 16B
	 */
		#define CMPL_BASE_TYPE_TX_L2_COAL	UINT32_C(0x2)
	/*
	 * TX L2 PTP completion:
	 * Completion of PTP TX packet. Length = 32B
	 */
		#define CMPL_BASE_TYPE_TX_L2_PTP	UINT32_C(0x3)
	/*
	 * RX L2 TPA Start V2 Completion:
	 * Completion of and L2 RX packet. Length = 32B
	 * This is the new version of the RX_TPA_START completion used
	 * in SR2 and later chips.
	 */
		#define CMPL_BASE_TYPE_RX_TPA_START_V2   UINT32_C(0xd)
	/*
	 * RX L2 V2 completion:
	 * Completion of and L2 RX packet. Length = 32B
	 * This is the new version of the RX_L2 completion used in SR2
	 * and later chips.
	 */
		#define CMPL_BASE_TYPE_RX_L2_V2	UINT32_C(0xf)
	/*
	 * RX L2 completion:
	 * Completion of and L2 RX packet. Length = 32B
	 */
		#define CMPL_BASE_TYPE_RX_L2		UINT32_C(0x11)
	/*
	 * RX Aggregation Buffer completion :
	 * Completion of an L2 aggregation buffer in support of
	 * TPA, HDS, or Jumbo packet completion. Length = 16B
	 */
		#define CMPL_BASE_TYPE_RX_AGG		UINT32_C(0x12)
	/*
	 * RX L2 TPA Start Completion:
	 * Completion at the beginning of a TPA operation.
	 * Length = 32B
	 */
		#define CMPL_BASE_TYPE_RX_TPA_START	UINT32_C(0x13)
	/*
	 * RX L2 TPA End Completion:
	 * Completion at the end of a TPA operation.
	 * Length = 32B
	 */
		#define CMPL_BASE_TYPE_RX_TPA_END	UINT32_C(0x15)
	/*
	 * Statistics Ejection Completion:
	 * Completion of statistics data ejection buffer.
	 * Length = 16B
	 */
		#define CMPL_BASE_TYPE_STAT_EJECT	UINT32_C(0x1a)
	/*
	 * VEE Flush Completion:
	 * This completion is inserted manually by
	 * the Primate and processed by the VEE hardware to ensure that
	 * all completions on a VEE function have been processed by the
	 * VEE hardware before FLR process is completed.
	 */
		#define CMPL_BASE_TYPE_VEE_FLUSH	UINT32_C(0x1c)
	/*
	 * Mid Path Short Completion :
	 * Completion of a Mid Path Command. Length = 16B
	 */
		#define CMPL_BASE_TYPE_MID_PATH_SHORT	UINT32_C(0x1e)
	/*
	 * Mid Path Long Completion :
	 * Completion of a Mid Path Command. Length = 32B
	 */
		#define CMPL_BASE_TYPE_MID_PATH_LONG	UINT32_C(0x1f)
	/*
	 * HWRM Command Completion:
	 * Completion of an HWRM command.
	 */
		#define CMPL_BASE_TYPE_HWRM_DONE	UINT32_C(0x20)
	/* Forwarded HWRM Request */
		#define CMPL_BASE_TYPE_HWRM_FWD_REQ	UINT32_C(0x22)
	/* Forwarded HWRM Response */
		#define CMPL_BASE_TYPE_HWRM_FWD_RESP	UINT32_C(0x24)
	/* HWRM Asynchronous Event Information */
		#define CMPL_BASE_TYPE_HWRM_ASYNC_EVENT  UINT32_C(0x2e)
	/* CQ Notification */
		#define CMPL_BASE_TYPE_CQ_NOTIFICATION   UINT32_C(0x30)
	/* SRQ Threshold Event */
		#define CMPL_BASE_TYPE_SRQ_EVENT	UINT32_C(0x32)
	/* DBQ Threshold Event */
		#define CMPL_BASE_TYPE_DBQ_EVENT	UINT32_C(0x34)
	/* QP Async Notification */
		#define CMPL_BASE_TYPE_QP_EVENT	UINT32_C(0x38)
	/* Function Async Notification */
		#define CMPL_BASE_TYPE_FUNC_EVENT	UINT32_C(0x3a)
		#define CMPL_BASE_TYPE_LAST		CMPL_BASE_TYPE_FUNC_EVENT
	/* info1 is 16 b */
	uint16_t	info1;
	/* info2 is 32 b */
	uint32_t	info2;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	uint32_t	info3_v;
	#define CMPL_BASE_V	UINT32_C(0x1)
	#define CMPL_BASE_INFO3_MASK UINT32_C(0xfffffffe)
	#define CMPL_BASE_INFO3_SFT 1
	/* info4 is 32 b */
	uint32_t	info4;
} cmpl_base_t, *pcmpl_base_t;

/* tx_cmpl (size:128b/16B) */

typedef struct tx_cmpl {
	uint16_t	flags_type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define TX_CMPL_TYPE_MASK	UINT32_C(0x3f)
	#define TX_CMPL_TYPE_SFT	0
	/*
	 * TX L2 completion:
	 * Completion of TX packet. Length = 16B
	 */
		#define TX_CMPL_TYPE_TX_L2	UINT32_C(0x0)
		#define TX_CMPL_TYPE_LAST	TX_CMPL_TYPE_TX_L2
	#define TX_CMPL_FLAGS_MASK	UINT32_C(0xffc0)
	#define TX_CMPL_FLAGS_SFT	6
	/*
	 * When this bit is '1', it indicates a packet that has an
	 * error of some type. Type of error is indicated in
	 * error_flags.
	 */
	#define TX_CMPL_FLAGS_ERROR	UINT32_C(0x40)
	/*
	 * When this bit is '1', it indicates that the packet completed
	 * was transmitted using the push acceleration data provided
	 * by the driver. When this bit is '0', it indicates that the
	 * packet had not push acceleration data written or was executed
	 * as a normal packet even though push data was provided.
	 */
	#define TX_CMPL_FLAGS_PUSH	UINT32_C(0x80)
	/* unused1 is 16 b */
	uint16_t	unused_0;
	/*
	 * This is a copy of the opaque field from the first TX BD of this
	 * transmitted packet. Note that, if the packet was described by a short
	 * CSO or short CSO inline BD, then the 16-bit opaque field from the
	 * short CSO BD will appear in the bottom 16 bits of this field.
	 */
	uint32_t	opaque;
	uint16_t	errors_v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define TX_CMPL_V				UINT32_C(0x1)
	#define TX_CMPL_ERRORS_MASK			UINT32_C(0xfffe)
	#define TX_CMPL_ERRORS_SFT			1
	/*
	 * This error indicates that there was some sort of problem
	 * with the BDs for the packet.
	 */
	#define TX_CMPL_ERRORS_BUFFER_ERROR_MASK		UINT32_C(0xe)
	#define TX_CMPL_ERRORS_BUFFER_ERROR_SFT		1
	/* No error */
		#define TX_CMPL_ERRORS_BUFFER_ERROR_NO_ERROR	(UINT32_C(0x0) << 1)
	/*
	 * Bad Format:
	 * BDs were not formatted correctly.
	 */
		#define TX_CMPL_ERRORS_BUFFER_ERROR_BAD_FMT	(UINT32_C(0x2) << 1)
		#define TX_CMPL_ERRORS_BUFFER_ERROR_LAST		TX_CMPL_ERRORS_BUFFER_ERROR_BAD_FMT
	/*
	 * When this bit is '1', it indicates that the length of
	 * the packet was zero. No packet was transmitted.
	 */
	#define TX_CMPL_ERRORS_ZERO_LENGTH_PKT		UINT32_C(0x10)
	/*
	 * When this bit is '1', it indicates that the packet
	 * was longer than the programmed limit in TDI. No
	 * packet was transmitted.
	 */
	#define TX_CMPL_ERRORS_EXCESSIVE_BD_LENGTH	UINT32_C(0x20)
	/*
	 * When this bit is '1', it indicates that one or more of the
	 * BDs associated with this packet generated a PCI error.
	 * This probably means the address was not valid.
	 */
	#define TX_CMPL_ERRORS_DMA_ERROR			UINT32_C(0x40)
	/*
	 * When this bit is '1', it indicates that the packet was longer
	 * than indicated by the hint. No packet was transmitted.
	 */
	#define TX_CMPL_ERRORS_HINT_TOO_SHORT		UINT32_C(0x80)
	/*
	 * When this bit is '1', it indicates that the packet was
	 * dropped due to Poison TLP error on one or more of the
	 * TLPs in the PXP completion.
	 */
	#define TX_CMPL_ERRORS_POISON_TLP_ERROR		UINT32_C(0x100)
	/*
	 * When this bit is '1', it indicates that the packet was dropped
	 * due to a transient internal error in TDC. The packet or LSO can
	 * be retried and may transmit successfully on a subsequent attempt.
	 */
	#define TX_CMPL_ERRORS_INTERNAL_ERROR		UINT32_C(0x200)
	/*
	 * When this bit is '1', it was not possible to collect a a timestamp
	 * for a PTP completion, in which case the timestamp_hi and
	 * timestamp_lo fields are invalid. When this bit is '0' for a PTP
	 * completion, the timestamp_hi and timestamp_lo fields are valid.
	 * RJRN will copy the value of this bit into the field of the same
	 * name in all TX completions, regardless of whether such completions
	 * are PTP completions or other TX completions.
	 */
	#define TX_CMPL_ERRORS_TIMESTAMP_INVALID_ERROR	UINT32_C(0x400)
	/* unused2 is 16 b */
	uint16_t	unused_1;
	/* unused3 is 32 b */
	uint32_t	unused_2;
} tx_cmpl_t, *ptx_cmpl_t;

/* tx_cmpl_coal (size:128b/16B) */

typedef struct tx_cmpl_coal {
	uint16_t	flags_type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define TX_CMPL_COAL_TYPE_MASK	UINT32_C(0x3f)
	#define TX_CMPL_COAL_TYPE_SFT	0
	/*
	 * TX L2 coalesced completion:
	 * Completion of TX packet. Length = 16B
	 */
		#define TX_CMPL_COAL_TYPE_TX_L2_COAL   UINT32_C(0x2)
		#define TX_CMPL_COAL_TYPE_LAST	TX_CMPL_COAL_TYPE_TX_L2_COAL
	#define TX_CMPL_COAL_FLAGS_MASK	UINT32_C(0xffc0)
	#define TX_CMPL_COAL_FLAGS_SFT	6
	/*
	 * When this bit is '1', it indicates a packet that has an
	 * error of some type. Type of error is indicated in
	 * error_flags.
	 */
	#define TX_CMPL_COAL_FLAGS_ERROR	UINT32_C(0x40)
	/*
	 * When this bit is '1', it indicates that the packet completed
	 * was transmitted using the push acceleration data provided
	 * by the driver. When this bit is '0', it indicates that the
	 * packet had not push acceleration data written or was executed
	 * as a normal packet even though push data was provided.
	 */
	#define TX_CMPL_COAL_FLAGS_PUSH	UINT32_C(0x80)
	/* unused1 is 16 b */
	uint16_t	unused_0;
	/*
	 * This is a copy of the opaque field from the first TX BD of the packet
	 * which corresponds with the reported sq_cons_idx. Note that, with
	 * coalesced completions, completions are generated for only some of the
	 * packets. The driver will see the opaque field for only those packets.
	 * Note that, if the packet was described by a short CSO or short CSO
	 * inline BD, then the 16-bit opaque field from the short CSO BD will
	 * appear in the bottom 16 bits of this field. For TX rings with
	 * completion coalescing enabled (which would use the coalesced
	 * completion record), it is suggested that the driver populate the
	 * opaque field to indicate the specific TX ring with which the
	 * completion is associated, then utilize the opaque and sq_cons_idx
	 * fields in the coalesced completion record to determine the specific
	 * packets that are to be completed on that ring.
	 */
	uint32_t	opaque;
	uint16_t	errors_v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define TX_CMPL_COAL_V				UINT32_C(0x1)
	#define TX_CMPL_COAL_ERRORS_MASK			UINT32_C(0xfffe)
	#define TX_CMPL_COAL_ERRORS_SFT			1
	/*
	 * This error indicates that there was some sort of problem
	 * with the BDs for the packet.
	 */
	#define TX_CMPL_COAL_ERRORS_BUFFER_ERROR_MASK		UINT32_C(0xe)
	#define TX_CMPL_COAL_ERRORS_BUFFER_ERROR_SFT		1
	/* No error */
		#define TX_CMPL_COAL_ERRORS_BUFFER_ERROR_NO_ERROR	(UINT32_C(0x0) << 1)
	/*
	 * Bad Format:
	 * BDs were not formatted correctly.
	 */
		#define TX_CMPL_COAL_ERRORS_BUFFER_ERROR_BAD_FMT	(UINT32_C(0x2) << 1)
		#define TX_CMPL_COAL_ERRORS_BUFFER_ERROR_LAST		TX_CMPL_COAL_ERRORS_BUFFER_ERROR_BAD_FMT
	/*
	 * When this bit is '1', it indicates that the length of
	 * the packet was zero. No packet was transmitted.
	 */
	#define TX_CMPL_COAL_ERRORS_ZERO_LENGTH_PKT		UINT32_C(0x10)
	/*
	 * When this bit is '1', it indicates that the packet
	 * was longer than the programmed limit in TDI. No
	 * packet was transmitted.
	 */
	#define TX_CMPL_COAL_ERRORS_EXCESSIVE_BD_LENGTH	UINT32_C(0x20)
	/*
	 * When this bit is '1', it indicates that one or more of the
	 * BDs associated with this packet generated a PCI error.
	 * This probably means the address was not valid.
	 */
	#define TX_CMPL_COAL_ERRORS_DMA_ERROR			UINT32_C(0x40)
	/*
	 * When this bit is '1', it indicates that the packet was longer
	 * than indicated by the hint. No packet was transmitted.
	 */
	#define TX_CMPL_COAL_ERRORS_HINT_TOO_SHORT		UINT32_C(0x80)
	/*
	 * When this bit is '1', it indicates that the packet was
	 * dropped due to Poison TLP error on one or more of the
	 * TLPs in the PXP completion.
	 */
	#define TX_CMPL_COAL_ERRORS_POISON_TLP_ERROR		UINT32_C(0x100)
	/*
	 * When this bit is '1', it indicates that the packet was dropped
	 * due to a transient internal error in TDC. The packet or LSO can
	 * be retried and may transmit successfully on a subsequent attempt.
	 */
	#define TX_CMPL_COAL_ERRORS_INTERNAL_ERROR		UINT32_C(0x200)
	/*
	 * When this bit is '1', it was not possible to collect a a timestamp
	 * for a PTP completion, in which case the timestamp_hi and
	 * timestamp_lo fields are invalid. When this bit is '0' for a PTP
	 * completion, the timestamp_hi and timestamp_lo fields are valid.
	 * RJRN will copy the value of this bit into the field of the same
	 * name in all TX completions, regardless of whether such
	 * completions are PTP completions or other TX completions.
	 */
	#define TX_CMPL_COAL_ERRORS_TIMESTAMP_INVALID_ERROR	UINT32_C(0x400)
	/* unused2 is 16 b */
	uint16_t	unused_1;
	uint32_t	sq_cons_idx;
	/*
	 * This value is SQ index for the start of the packet following the
	 * last completed packet.
	 */
	#define TX_CMPL_COAL_SQ_CONS_IDX_MASK UINT32_C(0xffffff)
	#define TX_CMPL_COAL_SQ_CONS_IDX_SFT 0
} tx_cmpl_coal_t, *ptx_cmpl_coal_t;

/* tx_cmpl_ptp (size:128b/16B) */

typedef struct tx_cmpl_ptp {
	uint16_t	flags_type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define TX_CMPL_PTP_TYPE_MASK	UINT32_C(0x3f)
	#define TX_CMPL_PTP_TYPE_SFT	0
	/*
	 * TX L2 PTP completion:
	 * Completion of TX packet. Length = 32B
	 */
		#define TX_CMPL_PTP_TYPE_TX_L2_PTP	UINT32_C(0x2)
		#define TX_CMPL_PTP_TYPE_LAST	TX_CMPL_PTP_TYPE_TX_L2_PTP
	#define TX_CMPL_PTP_FLAGS_MASK	UINT32_C(0xffc0)
	#define TX_CMPL_PTP_FLAGS_SFT	6
	/*
	 * When this bit is '1', it indicates a packet that has an
	 * error of some type. Type of error is indicated in
	 * error_flags.
	 */
	#define TX_CMPL_PTP_FLAGS_ERROR	UINT32_C(0x40)
	/*
	 * When this bit is '1', it indicates that the packet completed
	 * was transmitted using the push acceleration data provided
	 * by the driver. When this bit is '0', it indicates that the
	 * packet had not push acceleration data written or was executed
	 * as a normal packet even though push data was provided.
	 */
	#define TX_CMPL_PTP_FLAGS_PUSH	UINT32_C(0x80)
	/* unused1 is 16 b */
	uint16_t	unused_0;
	/*
	 * This is a copy of the opaque field from the first TX BD of this
	 * transmitted packet. Note that, if the packet was described by a short
	 * CSO or short CSO inline BD, then the 16-bit opaque field from the
	 * short CSO BD will appear in the bottom 16 bits of this field.
	 */
	uint32_t	opaque;
	uint16_t	errors_v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define TX_CMPL_PTP_V				UINT32_C(0x1)
	#define TX_CMPL_PTP_ERRORS_MASK			UINT32_C(0xfffe)
	#define TX_CMPL_PTP_ERRORS_SFT			1
	/*
	 * This error indicates that there was some sort of problem
	 * with the BDs for the packet.
	 */
	#define TX_CMPL_PTP_ERRORS_BUFFER_ERROR_MASK		UINT32_C(0xe)
	#define TX_CMPL_PTP_ERRORS_BUFFER_ERROR_SFT		1
	/* No error */
		#define TX_CMPL_PTP_ERRORS_BUFFER_ERROR_NO_ERROR	(UINT32_C(0x0) << 1)
	/*
	 * Bad Format:
	 * BDs were not formatted correctly.
	 */
		#define TX_CMPL_PTP_ERRORS_BUFFER_ERROR_BAD_FMT	(UINT32_C(0x2) << 1)
		#define TX_CMPL_PTP_ERRORS_BUFFER_ERROR_LAST		TX_CMPL_PTP_ERRORS_BUFFER_ERROR_BAD_FMT
	/*
	 * When this bit is '1', it indicates that the length of
	 * the packet was zero. No packet was transmitted.
	 */
	#define TX_CMPL_PTP_ERRORS_ZERO_LENGTH_PKT		UINT32_C(0x10)
	/*
	 * When this bit is '1', it indicates that the packet
	 * was longer than the programmed limit in TDI. No
	 * packet was transmitted.
	 */
	#define TX_CMPL_PTP_ERRORS_EXCESSIVE_BD_LENGTH	UINT32_C(0x20)
	/*
	 * When this bit is '1', it indicates that one or more of the
	 * BDs associated with this packet generated a PCI error.
	 * This probably means the address was not valid.
	 */
	#define TX_CMPL_PTP_ERRORS_DMA_ERROR			UINT32_C(0x40)
	/*
	 * When this bit is '1', it indicates that the packet was longer
	 * than indicated by the hint. No packet was transmitted.
	 */
	#define TX_CMPL_PTP_ERRORS_HINT_TOO_SHORT		UINT32_C(0x80)
	/*
	 * When this bit is '1', it indicates that the packet was
	 * dropped due to Poison TLP error on one or more of the
	 * TLPs in the PXP completion.
	 */
	#define TX_CMPL_PTP_ERRORS_POISON_TLP_ERROR		UINT32_C(0x100)
	/*
	 * When this bit is '1', it indicates that the packet was dropped due
	 * to a transient internal error in TDC. The packet or LSO can be
	 * retried and may transmit successfully on a subsequent attempt.
	 */
	#define TX_CMPL_PTP_ERRORS_INTERNAL_ERROR		UINT32_C(0x200)
	/*
	 * When this bit is '1', it was not possible to collect a a timestamp
	 * for a PTP completion, in which case the timestamp_hi and
	 * timestamp_lo fields are invalid. When this bit is '0' for a PTP
	 * completion, the timestamp_hi and timestamp_lo fields are valid.
	 * RJRN will copy the value of this bit into the field of the same
	 * name in all TX completions, regardless of whether such
	 * completions are PTP completions or other TX completions.
	 */
	#define TX_CMPL_PTP_ERRORS_TIMESTAMP_INVALID_ERROR	UINT32_C(0x400)
	/* unused2 is 16 b */
	uint16_t	unused_1;
	/*
	 * This is timestamp value (lower 32bits) read from PM for the PTP
	 * timestamp enabled packet.
	 */
	uint32_t	timestamp_lo;
} tx_cmpl_ptp_t, *ptx_cmpl_ptp_t;

/* tx_cmpl_ptp_hi (size:128b/16B) */

typedef struct tx_cmpl_ptp_hi {
	/*
	 * This is timestamp value (lower 32bits) read from PM for the PTP
	 * timestamp enabled packet.
	 */
	uint16_t	timestamp_hi[3];
	uint16_t	reserved16;
	uint64_t	v2;
	/*
	 * This value is written by the NIC such that it will be different for
	 * each pass through the completion queue.The even passes will write 1.
	 * The odd passes will write 0
	 */
	#define TX_CMPL_PTP_HI_V2	UINT32_C(0x1)
} tx_cmpl_ptp_hi_t, *ptx_cmpl_ptp_hi_t;

/* rx_pkt_cmpl (size:128b/16B) */

typedef struct rx_pkt_cmpl {
	uint16_t	flags_type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define RX_PKT_CMPL_TYPE_MASK		UINT32_C(0x3f)
	#define RX_PKT_CMPL_TYPE_SFT			0
	/*
	 * RX L2 completion:
	 * Completion of and L2 RX packet. Length = 32B
	 */
		#define RX_PKT_CMPL_TYPE_RX_L2			UINT32_C(0x11)
		#define RX_PKT_CMPL_TYPE_LAST			RX_PKT_CMPL_TYPE_RX_L2
	#define RX_PKT_CMPL_FLAGS_MASK		UINT32_C(0xffc0)
	#define RX_PKT_CMPL_FLAGS_SFT		6
	/*
	 * When this bit is '1', it indicates a packet that has an
	 * error of some type. Type of error is indicated in
	 * error_flags.
	 */
	#define RX_PKT_CMPL_FLAGS_ERROR		UINT32_C(0x40)
	/* This field indicates how the packet was placed in the buffer. */
	#define RX_PKT_CMPL_FLAGS_PLACEMENT_MASK	UINT32_C(0x380)
	#define RX_PKT_CMPL_FLAGS_PLACEMENT_SFT	7
	/*
	 * Normal:
	 * Packet was placed using normal algorithm.
	 */
		#define RX_PKT_CMPL_FLAGS_PLACEMENT_NORMAL	(UINT32_C(0x0) << 7)
	/*
	 * Jumbo:
	 * Packet was placed using jumbo algorithm.
	 */
		#define RX_PKT_CMPL_FLAGS_PLACEMENT_JUMBO	(UINT32_C(0x1) << 7)
	/*
	 * Header/Data Separation:
	 * Packet was placed using Header/Data separation algorithm.
	 * The separation location is indicated by the itype field.
	 */
		#define RX_PKT_CMPL_FLAGS_PLACEMENT_HDS		(UINT32_C(0x2) << 7)
		#define RX_PKT_CMPL_FLAGS_PLACEMENT_LAST	RX_PKT_CMPL_FLAGS_PLACEMENT_HDS
	/* This bit is '1' if the RSS field in this completion is valid. */
	#define RX_PKT_CMPL_FLAGS_RSS_VALID		UINT32_C(0x400)
	/* unused is 1 b */
	#define RX_PKT_CMPL_FLAGS_UNUSED		UINT32_C(0x800)
	/*
	 * This value indicates what the inner packet determined for the
	 * packet was.
	 */
	#define RX_PKT_CMPL_FLAGS_ITYPE_MASK		UINT32_C(0xf000)
	#define RX_PKT_CMPL_FLAGS_ITYPE_SFT		12
	/*
	 * Not Known:
	 * Indicates that the packet type was not known.
	 */
		#define RX_PKT_CMPL_FLAGS_ITYPE_NOT_KNOWN	(UINT32_C(0x0) << 12)
	/*
	 * IP Packet:
	 * Indicates that the packet was an IP packet, but further
	 * classification was not possible.
	 */
		#define RX_PKT_CMPL_FLAGS_ITYPE_IP		(UINT32_C(0x1) << 12)
	/*
	 * TCP Packet:
	 * Indicates that the packet was IP and TCP.
	 * This indicates that the payload_offset field is valid.
	 */
		#define RX_PKT_CMPL_FLAGS_ITYPE_TCP		(UINT32_C(0x2) << 12)
	/*
	 * UDP Packet:
	 * Indicates that the packet was IP and UDP.
	 * This indicates that the payload_offset field is valid.
	 */
		#define RX_PKT_CMPL_FLAGS_ITYPE_UDP		(UINT32_C(0x3) << 12)
	/*
	 * FCoE Packet:
	 * Indicates that the packet was recognized as a FCoE.
	 * This also indicates that the payload_offset field is valid.
	 */
		#define RX_PKT_CMPL_FLAGS_ITYPE_FCOE		(UINT32_C(0x4) << 12)
	/*
	 * RoCE Packet:
	 * Indicates that the packet was recognized as a RoCE.
	 * This also indicates that the payload_offset field is valid.
	 */
		#define RX_PKT_CMPL_FLAGS_ITYPE_ROCE		(UINT32_C(0x5) << 12)
	/*
	 * ICMP Packet:
	 * Indicates that the packet was recognized as ICMP.
	 * This indicates that the payload_offset field is valid.
	 */
		#define RX_PKT_CMPL_FLAGS_ITYPE_ICMP		(UINT32_C(0x7) << 12)
	/*
	 * PtP packet wo/timestamp:
	 * Indicates that the packet was recognized as a PtP
	 * packet.
	 */
		#define RX_PKT_CMPL_FLAGS_ITYPE_PTP_WO_TIMESTAMP   (UINT32_C(0x8) << 12)
	/*
	 * PtP packet w/timestamp:
	 * Indicates that the packet was recognized as a PtP
	 * packet and that a timestamp was taken for the packet.
	 */
		#define RX_PKT_CMPL_FLAGS_ITYPE_PTP_W_TIMESTAMP	(UINT32_C(0x9) << 12)
		#define RX_PKT_CMPL_FLAGS_ITYPE_LAST		RX_PKT_CMPL_FLAGS_ITYPE_PTP_W_TIMESTAMP
	/*
	 * This is the length of the data for the packet stored in the
	 * buffer(s) identified by the opaque value. This includes
	 * the packet BD and any associated buffer BDs. This does not include
	 * the length of any data places in aggregation BDs.
	 */
	uint16_t	len;
	/*
	 * This is a copy of the opaque field from the RX BD this completion
	 * corresponds to.
	 */
	uint32_t	opaque;
	uint8_t	agg_bufs_v1;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define RX_PKT_CMPL_V1	UINT32_C(0x1)
	/*
	 * This value is the number of aggregation buffers that follow this
	 * entry in the completion ring that are a part of this packet.
	 * If the value is zero, then the packet is completely contained
	 * in the buffer space provided for the packet in the RX ring.
	 */
	#define RX_PKT_CMPL_AGG_BUFS_MASK UINT32_C(0x3e)
	#define RX_PKT_CMPL_AGG_BUFS_SFT 1
	/* unused1 is 2 b */
	#define RX_PKT_CMPL_UNUSED1_MASK UINT32_C(0xc0)
	#define RX_PKT_CMPL_UNUSED1_SFT  6
	/*
	 * This is the RSS hash type for the packet. The value is packed
	 * {tuple_extrac_op[1:0],rss_profile_id[4:0],tuple_extrac_op[2]}.
	 *
	 * The value of tuple_extrac_op provides the information about
	 * what fields the hash was computed on.
	 * * 0: The RSS hash was computed over source IP address,
	 * destination IP address, source port, and destination port of inner
	 * IP and TCP or UDP headers. Note: For non-tunneled packets,
	 * the packet headers are considered inner packet headers for the RSS
	 * hash computation purpose.
	 * * 1: The RSS hash was computed over source IP address and destination
	 * IP address of inner IP header. Note: For non-tunneled packets,
	 * the packet headers are considered inner packet headers for the RSS
	 * hash computation purpose.
	 * * 2: The RSS hash was computed over source IP address,
	 * destination IP address, source port, and destination port of
	 * IP and TCP or UDP headers of outer tunnel headers.
	 * Note: For non-tunneled packets, this value is not applicable.
	 * * 3: The RSS hash was computed over source IP address and
	 * destination IP address of IP header of outer tunnel headers.
	 * Note: For non-tunneled packets, this value is not applicable.
	 *
	 * Note that 4-tuples values listed above are applicable
	 * for layer 4 protocols supported and enabled for RSS in the hardware,
	 * HWRM firmware, and drivers. For example, if RSS hash is supported and
	 * enabled for TCP traffic only, then the values of tuple_extract_op
	 * corresponding to 4-tuples are only valid for TCP traffic.
	 */
	uint8_t	rss_hash_type;
	/*
	 * This value indicates the offset in bytes from the beginning of the packet
	 * where the inner payload starts. This value is valid for TCP, UDP,
	 * FCoE, and RoCE packets.
	 *
	 * A value of zero indicates that header is 256B into the packet.
	 */
	uint8_t	payload_offset;
	/* unused2 is 8 b */
	uint8_t	unused1;
	/*
	 * This value is the RSS hash value calculated for the packet
	 * based on the mode bits and key value in the VNIC.
	 */
	uint32_t	rss_hash;
} rx_pkt_cmpl_t, *prx_pkt_cmpl_t;

/* Last 16 bytes of rx_pkt_cmpl. */
/* rx_pkt_cmpl_hi (size:128b/16B) */

typedef struct rx_pkt_cmpl_hi {
	uint32_t	flags2;
	/*
	 * This indicates that the ip checksum was calculated for the
	 * inner packet and that the ip_cs_error field indicates if there
	 * was an error.
	 */
	#define RX_PKT_CMPL_FLAGS2_IP_CS_CALC		UINT32_C(0x1)
	/*
	 * This indicates that the TCP, UDP or ICMP checksum was
	 * calculated for the inner packet and that the l4_cs_error field
	 * indicates if there was an error.
	 */
	#define RX_PKT_CMPL_FLAGS2_L4_CS_CALC		UINT32_C(0x2)
	/*
	 * This indicates that the ip checksum was calculated for the
	 * tunnel header and that the t_ip_cs_error field indicates if there
	 * was an error.
	 */
	#define RX_PKT_CMPL_FLAGS2_T_IP_CS_CALC		UINT32_C(0x4)
	/*
	 * This indicates that the UDP checksum was
	 * calculated for the tunnel packet and that the t_l4_cs_error field
	 * indicates if there was an error.
	 */
	#define RX_PKT_CMPL_FLAGS2_T_L4_CS_CALC		UINT32_C(0x8)
	/* This value indicates what format the metadata field is. */
	#define RX_PKT_CMPL_FLAGS2_META_FORMAT_MASK	UINT32_C(0xf0)
	#define RX_PKT_CMPL_FLAGS2_META_FORMAT_SFT		4
	/* No metadata information. Value is zero. */
		#define RX_PKT_CMPL_FLAGS2_META_FORMAT_NONE		(UINT32_C(0x0) << 4)
	/*
	 * The metadata field contains the VLAN tag and TPID value.
	 * - metadata[11:0] contains the vlan VID value.
	 * - metadata[12] contains the vlan DE value.
	 * - metadata[15:13] contains the vlan PRI value.
	 * - metadata[31:16] contains the vlan TPID value.
	 */
		#define RX_PKT_CMPL_FLAGS2_META_FORMAT_VLAN		(UINT32_C(0x1) << 4)
	/*
	 * If ext_meta_format is equal to 1, the metadata field
	 * contains the lower 16b of the tunnel ID value, justified
	 * to LSB
	 * - VXLAN = VNI[23:0] -> VXLAN Network ID
	 * - Geneve (NGE) = VNI[23:0] a-> Virtual Network Identifier.
	 * - NVGRE = TNI[23:0] -> Tenant Network ID
	 * - GRE = KEY[31:0] -> key field with bit mask. zero if K = 0
	 * - IPV4 = 0 (not populated)
	 * - IPV6 = Flow Label[19:0]
	 * - PPPoE = sessionID[15:0]
	 * - MPLs = Outer label[19:0]
	 * - UPAR = Selected[31:0] with bit mask
	 */
		#define RX_PKT_CMPL_FLAGS2_META_FORMAT_TUNNEL_ID	(UINT32_C(0x2) << 4)
	/*
	 * if ext_meta_format is equal to 1, metadata field contains
	 * 16b metadata from the prepended header (chdr_data).
	 */
		#define RX_PKT_CMPL_FLAGS2_META_FORMAT_CHDR_DATA	(UINT32_C(0x3) << 4)
	/*
	 * If ext_meta_format is equal to 1, the metadata field contains
	 * the outer_l3_offset, inner_l2_offset, inner_l3_offset and
	 * inner_l4_size.
	 * - metadata[8:0] contains the outer_l3_offset.
	 * - metadata[17:9] contains the inner_l2_offset.
	 * - metadata[26:18] contains the inner_l3_offset.
	 * - metadata[31:27] contains the inner_l4_size.
	 */
		#define RX_PKT_CMPL_FLAGS2_META_FORMAT_HDR_OFFSET	(UINT32_C(0x4) << 4)
		#define RX_PKT_CMPL_FLAGS2_META_FORMAT_LAST		RX_PKT_CMPL_FLAGS2_META_FORMAT_HDR_OFFSET
	/*
	 * This field indicates the IP type for the inner-most IP header.
	 * A value of '0' indicates IPv4. A value of '1' indicates IPv6.
	 * This value is only valid if itype indicates a packet
	 * with an IP header.
	 */
	#define RX_PKT_CMPL_FLAGS2_IP_TYPE			UINT32_C(0x100)
	/*
	 * This indicates that the complete 1's complement checksum was
	 * calculated for the packet.
	 */
	#define RX_PKT_CMPL_FLAGS2_COMPLETE_CHECKSUM_CALC	UINT32_C(0x200)
	/*
	 * The combination of this value and meta_format indicated what
	 * format the metadata field is.
	 */
	#define RX_PKT_CMPL_FLAGS2_EXT_META_FORMAT_MASK	UINT32_C(0xc00)
	#define RX_PKT_CMPL_FLAGS2_EXT_META_FORMAT_SFT	10
	/*
	 * This value is the complete 1's complement checksum calculated from
	 * the start of the outer L3 header to the end of the packet (not
	 * including the ethernet crc). It is valid when the
	 * 'complete_checksum_calc' flag is set.
	 */
	#define RX_PKT_CMPL_FLAGS2_COMPLETE_CHECKSUM_MASK	UINT32_C(0xffff0000)
	#define RX_PKT_CMPL_FLAGS2_COMPLETE_CHECKSUM_SFT	16
	/*
	 * This is data from the CFA block as indicated by the meta_format
	 * field.
	 */
	uint32_t	metadata;
	/* When meta_format=1, this value is the VLAN VID. */
	#define RX_PKT_CMPL_METADATA_VID_MASK UINT32_C(0xfff)
	#define RX_PKT_CMPL_METADATA_VID_SFT  0
	/* When meta_format=1, this value is the VLAN DE. */
	#define RX_PKT_CMPL_METADATA_DE	UINT32_C(0x1000)
	/* When meta_format=1, this value is the VLAN PRI. */
	#define RX_PKT_CMPL_METADATA_PRI_MASK UINT32_C(0xe000)
	#define RX_PKT_CMPL_METADATA_PRI_SFT  13
	/* When meta_format=1, this value is the VLAN TPID. */
	#define RX_PKT_CMPL_METADATA_TPID_MASK UINT32_C(0xffff0000)
	#define RX_PKT_CMPL_METADATA_TPID_SFT 16
	uint16_t	errors_v2;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define RX_PKT_CMPL_V2					UINT32_C(0x1)
	#define RX_PKT_CMPL_ERRORS_MASK				UINT32_C(0xfffe)
	#define RX_PKT_CMPL_ERRORS_SFT				1
	/*
	 * This error indicates that there was some sort of problem with
	 * the BDs for the packet that was found after part of the
	 * packet was already placed. The packet should be treated as
	 * invalid.
	 */
	#define RX_PKT_CMPL_ERRORS_BUFFER_ERROR_MASK		UINT32_C(0xe)
	#define RX_PKT_CMPL_ERRORS_BUFFER_ERROR_SFT		1
	/* No buffer error */
		#define RX_PKT_CMPL_ERRORS_BUFFER_ERROR_NO_BUFFER		(UINT32_C(0x0) << 1)
	/*
	 * Did Not Fit:
	 * Packet did not fit into packet buffer provided.
	 * For regular placement, this means the packet did not fit
	 * in the buffer provided. For HDS and jumbo placement, this
	 * means that the packet could not be placed into 7 physical
	 * buffers or less.
	 */
		#define RX_PKT_CMPL_ERRORS_BUFFER_ERROR_DID_NOT_FIT		(UINT32_C(0x1) << 1)
	/*
	 * Not On Chip:
	 * All BDs needed for the packet were not on-chip when
	 * the packet arrived.
	 */
		#define RX_PKT_CMPL_ERRORS_BUFFER_ERROR_NOT_ON_CHIP		(UINT32_C(0x2) << 1)
	/*
	 * Bad Format:
	 * BDs were not formatted correctly.
	 */
		#define RX_PKT_CMPL_ERRORS_BUFFER_ERROR_BAD_FORMAT		(UINT32_C(0x3) << 1)
	/*
	 * Flush:
	 * There was a bad_format error on the previous operation
	 */
		#define RX_PKT_CMPL_ERRORS_BUFFER_ERROR_FLUSH		(UINT32_C(0x5) << 1)
		#define RX_PKT_CMPL_ERRORS_BUFFER_ERROR_LAST		RX_PKT_CMPL_ERRORS_BUFFER_ERROR_FLUSH
	/*
	 * This indicates that there was an error in the IP header
	 * checksum.
	 */
	#define RX_PKT_CMPL_ERRORS_IP_CS_ERROR			UINT32_C(0x10)
	/*
	 * This indicates that there was an error in the TCP, UDP
	 * or ICMP checksum.
	 */
	#define RX_PKT_CMPL_ERRORS_L4_CS_ERROR			UINT32_C(0x20)
	/*
	 * This indicates that there was an error in the tunnel
	 * IP header checksum.
	 */
	#define RX_PKT_CMPL_ERRORS_T_IP_CS_ERROR			UINT32_C(0x40)
	/*
	 * This indicates that there was an error in the tunnel
	 * UDP checksum.
	 */
	#define RX_PKT_CMPL_ERRORS_T_L4_CS_ERROR			UINT32_C(0x80)
	/*
	 * This indicates that there was a CRC error on either an FCoE
	 * or RoCE packet. The itype indicates the packet type.
	 */
	#define RX_PKT_CMPL_ERRORS_CRC_ERROR			UINT32_C(0x100)
	/*
	 * This indicates that there was an error in the tunnel
	 * portion of the packet when this
	 * field is non-zero.
	 */
	#define RX_PKT_CMPL_ERRORS_T_PKT_ERROR_MASK		UINT32_C(0xe00)
	#define RX_PKT_CMPL_ERRORS_T_PKT_ERROR_SFT			9
	/*
	 * No additional error occurred on the tunnel portion
	 * or the packet of the packet does not have a tunnel.
	 */
		#define RX_PKT_CMPL_ERRORS_T_PKT_ERROR_NO_ERROR		(UINT32_C(0x0) << 9)
	/*
	 * Indicates that IP header version does not match
	 * expectation from L2 Ethertype for IPv4 and IPv6
	 * in the tunnel header.
	 */
		#define RX_PKT_CMPL_ERRORS_T_PKT_ERROR_T_L3_BAD_VERSION	(UINT32_C(0x1) << 9)
	/*
	 * Indicates that header length is out of range in the
	 * tunnel header. Valid for
	 * IPv4.
	 */
		#define RX_PKT_CMPL_ERRORS_T_PKT_ERROR_T_L3_BAD_HDR_LEN	(UINT32_C(0x2) << 9)
	/*
	 * Indicates that the physical packet is shorter than that
	 * claimed by the PPPoE header length for a tunnel PPPoE
	 * packet.
	 */
		#define RX_PKT_CMPL_ERRORS_T_PKT_ERROR_TUNNEL_TOTAL_ERROR	(UINT32_C(0x3) << 9)
	/*
	 * Indicates that physical packet is shorter than that claimed
	 * by the tunnel l3 header length. Valid for IPv4, or IPv6
	 * tunnel packet packets.
	 */
		#define RX_PKT_CMPL_ERRORS_T_PKT_ERROR_T_IP_TOTAL_ERROR	(UINT32_C(0x4) << 9)
	/*
	 * Indicates that the physical packet is shorter than that
	 * claimed by the tunnel UDP header length for a tunnel
	 * UDP packet that is not fragmented.
	 */
		#define RX_PKT_CMPL_ERRORS_T_PKT_ERROR_T_UDP_TOTAL_ERROR	(UINT32_C(0x5) << 9)
	/*
	 * indicates that the IPv4 TTL or IPv6 hop limit check
	 * have failed (e.g. TTL = 0) in the tunnel header. Valid
	 * for IPv4, and IPv6.
	 */
		#define RX_PKT_CMPL_ERRORS_T_PKT_ERROR_T_L3_BAD_TTL		(UINT32_C(0x6) << 9)
		#define RX_PKT_CMPL_ERRORS_T_PKT_ERROR_LAST			RX_PKT_CMPL_ERRORS_T_PKT_ERROR_T_L3_BAD_TTL
	/*
	 * This indicates that there was an error in the inner
	 * portion of the packet when this
	 * field is non-zero.
	 */
	#define RX_PKT_CMPL_ERRORS_PKT_ERROR_MASK			UINT32_C(0xf000)
	#define RX_PKT_CMPL_ERRORS_PKT_ERROR_SFT			12
	/*
	 * No additional error occurred on the tunnel portion
	 * or the packet of the packet does not have a tunnel.
	 */
		#define RX_PKT_CMPL_ERRORS_PKT_ERROR_NO_ERROR		(UINT32_C(0x0) << 12)
	/*
	 * Indicates that IP header version does not match
	 * expectation from L2 Ethertype for IPv4 and IPv6 or that
	 * option other than VFT was parsed on
	 * FCoE packet.
	 */
		#define RX_PKT_CMPL_ERRORS_PKT_ERROR_L3_BAD_VERSION		(UINT32_C(0x1) << 12)
	/*
	 * indicates that header length is out of range. Valid for
	 * IPv4 and RoCE
	 */
		#define RX_PKT_CMPL_ERRORS_PKT_ERROR_L3_BAD_HDR_LEN		(UINT32_C(0x2) << 12)
	/*
	 * indicates that the IPv4 TTL or IPv6 hop limit check
	 * have failed (e.g. TTL = 0). Valid for IPv4, and IPv6
	 */
		#define RX_PKT_CMPL_ERRORS_PKT_ERROR_L3_BAD_TTL		(UINT32_C(0x3) << 12)
	/*
	 * Indicates that physical packet is shorter than that
	 * claimed by the l3 header length. Valid for IPv4,
	 * IPv6 packet or RoCE packets.
	 */
		#define RX_PKT_CMPL_ERRORS_PKT_ERROR_IP_TOTAL_ERROR		(UINT32_C(0x4) << 12)
	/*
	 * Indicates that the physical packet is shorter than that
	 * claimed by the UDP header length for a UDP packet that is
	 * not fragmented.
	 */
		#define RX_PKT_CMPL_ERRORS_PKT_ERROR_UDP_TOTAL_ERROR		(UINT32_C(0x5) << 12)
	/*
	 * Indicates that TCP header length > IP payload. Valid for
	 * TCP packets only.
	 */
		#define RX_PKT_CMPL_ERRORS_PKT_ERROR_L4_BAD_HDR_LEN		(UINT32_C(0x6) << 12)
	/* Indicates that TCP header length < 5. Valid for TCP. */
		#define RX_PKT_CMPL_ERRORS_PKT_ERROR_L4_BAD_HDR_LEN_TOO_SMALL   (UINT32_C(0x7) << 12)
	/*
	 * Indicates that TCP option headers result in a TCP header
	 * size that does not match data offset in TCP header. Valid
	 * for TCP.
	 */
		#define RX_PKT_CMPL_ERRORS_PKT_ERROR_L4_BAD_OPT_LEN		(UINT32_C(0x8) << 12)
		#define RX_PKT_CMPL_ERRORS_PKT_ERROR_LAST			RX_PKT_CMPL_ERRORS_PKT_ERROR_L4_BAD_OPT_LEN
	/*
	 * This field identifies the CFA action rule that was used for this
	 * packet.
	 */
	uint16_t	cfa_code;
	uint32_t	reorder;
	/*
	 * This value holds the reordering sequence number for the packet.
	 * If the reordering sequence is not valid, then this value is zero.
	 * The reordering domain for the packet is in the bottom 8 to 10b of
	 * the rss_hash value. The bottom 20b of this value contain the
	 * ordering domain value for the packet.
	 */
	#define RX_PKT_CMPL_REORDER_MASK UINT32_C(0xffffff)
	#define RX_PKT_CMPL_REORDER_SFT 0
} rx_pkt_cmpl_hi_t, *prx_pkt_cmpl_hi_t;

/* rx_pkt_v2_cmpl (size:128b/16B) */

typedef struct rx_pkt_v2_cmpl {
	uint16_t	flags_type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define RX_PKT_V2_CMPL_TYPE_MASK			UINT32_C(0x3f)
	#define RX_PKT_V2_CMPL_TYPE_SFT			0
	/*
	 * RX L2 V2 completion:
	 * Completion of and L2 RX packet. Length = 32B
	 * This is the new version of the RX_L2 completion used in SR2
	 * and later chips.
	 */
		#define RX_PKT_V2_CMPL_TYPE_RX_L2_V2			UINT32_C(0xf)
		#define RX_PKT_V2_CMPL_TYPE_LAST			RX_PKT_V2_CMPL_TYPE_RX_L2_V2
	#define RX_PKT_V2_CMPL_FLAGS_MASK			UINT32_C(0xffc0)
	#define RX_PKT_V2_CMPL_FLAGS_SFT			6
	/*
	 * When this bit is '1', it indicates a packet that has an
	 * error of some type. Type of error is indicated in
	 * error_flags.
	 */
	#define RX_PKT_V2_CMPL_FLAGS_ERROR			UINT32_C(0x40)
	/* This field indicates how the packet was placed in the buffer. */
	#define RX_PKT_V2_CMPL_FLAGS_PLACEMENT_MASK		UINT32_C(0x380)
	#define RX_PKT_V2_CMPL_FLAGS_PLACEMENT_SFT		7
	/*
	 * Normal:
	 * Packet was placed using normal algorithm.
	 */
		#define RX_PKT_V2_CMPL_FLAGS_PLACEMENT_NORMAL		(UINT32_C(0x0) << 7)
	/*
	 * Jumbo:
	 * Packet was placed using jumbo algorithm.
	 */
		#define RX_PKT_V2_CMPL_FLAGS_PLACEMENT_JUMBO		(UINT32_C(0x1) << 7)
	/*
	 * Header/Data Separation:
	 * Packet was placed using Header/Data separation algorithm.
	 * The separation location is indicated by the itype field.
	 */
		#define RX_PKT_V2_CMPL_FLAGS_PLACEMENT_HDS		(UINT32_C(0x2) << 7)
	/*
	 * Truncation:
	 * Packet was placed using truncation algorithm. The
	 * placed (truncated) length is indicated in the payload_offset
	 * field. The original length is indicated in the len field.
	 */
		#define RX_PKT_V2_CMPL_FLAGS_PLACEMENT_TRUNCATION	(UINT32_C(0x3) << 7)
		#define RX_PKT_V2_CMPL_FLAGS_PLACEMENT_LAST		RX_PKT_V2_CMPL_FLAGS_PLACEMENT_TRUNCATION
	/* This bit is '1' if the RSS field in this completion is valid. */
	#define RX_PKT_V2_CMPL_FLAGS_RSS_VALID		UINT32_C(0x400)
	/*
	 * This bit is '1' if metadata has been added to the end of the
	 * packet in host memory. Metadata starts at the first 32B boundary
	 * after the end of the packet for regular and jumbo placement.
	 * It starts at the first 32B boundary after the end of the header
	 * for HDS placement. The length of the metadata is indicated in the
	 * metadata itself.
	 */
	#define RX_PKT_V2_CMPL_FLAGS_PKT_METADATA_PRESENT	UINT32_C(0x800)
	/*
	 * This value indicates what the inner packet determined for the
	 * packet was.
	 */
	#define RX_PKT_V2_CMPL_FLAGS_ITYPE_MASK		UINT32_C(0xf000)
	#define RX_PKT_V2_CMPL_FLAGS_ITYPE_SFT		12
	/*
	 * Not Known:
	 * Indicates that the packet type was not known.
	 */
		#define RX_PKT_V2_CMPL_FLAGS_ITYPE_NOT_KNOWN		(UINT32_C(0x0) << 12)
	/*
	 * IP Packet:
	 * Indicates that the packet was an IP packet, but further
	 * classification was not possible.
	 */
		#define RX_PKT_V2_CMPL_FLAGS_ITYPE_IP			(UINT32_C(0x1) << 12)
	/*
	 * TCP Packet:
	 * Indicates that the packet was IP and TCP.
	 * This indicates that the payload_offset field is valid.
	 */
		#define RX_PKT_V2_CMPL_FLAGS_ITYPE_TCP		(UINT32_C(0x2) << 12)
	/*
	 * UDP Packet:
	 * Indicates that the packet was IP and UDP.
	 * This indicates that the payload_offset field is valid.
	 */
		#define RX_PKT_V2_CMPL_FLAGS_ITYPE_UDP		(UINT32_C(0x3) << 12)
	/*
	 * FCoE Packet:
	 * Indicates that the packet was recognized as a FCoE.
	 * This also indicates that the payload_offset field is valid.
	 */
		#define RX_PKT_V2_CMPL_FLAGS_ITYPE_FCOE		(UINT32_C(0x4) << 12)
	/*
	 * RoCE Packet:
	 * Indicates that the packet was recognized as a RoCE.
	 * This also indicates that the payload_offset field is valid.
	 */
		#define RX_PKT_V2_CMPL_FLAGS_ITYPE_ROCE		(UINT32_C(0x5) << 12)
	/*
	 * ICMP Packet:
	 * Indicates that the packet was recognized as ICMP.
	 * This indicates that the payload_offset field is valid.
	 */
		#define RX_PKT_V2_CMPL_FLAGS_ITYPE_ICMP		(UINT32_C(0x7) << 12)
	/*
	 * PtP packet wo/timestamp:
	 * Indicates that the packet was recognized as a PtP
	 * packet.
	 */
		#define RX_PKT_V2_CMPL_FLAGS_ITYPE_PTP_WO_TIMESTAMP	(UINT32_C(0x8) << 12)
	/*
	 * PtP packet w/timestamp:
	 * Indicates that the packet was recognized as a PtP
	 * packet and that a timestamp was taken for the packet.
	 */
		#define RX_PKT_V2_CMPL_FLAGS_ITYPE_PTP_W_TIMESTAMP	(UINT32_C(0x9) << 12)
		#define RX_PKT_V2_CMPL_FLAGS_ITYPE_LAST		RX_PKT_V2_CMPL_FLAGS_ITYPE_PTP_W_TIMESTAMP
	/*
	 * This is the length of the data for the packet stored in the
	 * buffer(s) identified by the opaque value. This includes
	 * the packet BD and any associated buffer BDs. This does not include
	 * the length of any data places in aggregation BDs.
	 */
	uint16_t	len;
	/*
	 * This is a copy of the opaque field from the RX BD this completion
	 * corresponds to.
	 */
	uint32_t	opaque;
	uint8_t	agg_bufs_v1;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define RX_PKT_V2_CMPL_V1	UINT32_C(0x1)
	/*
	 * This value is the number of aggregation buffers that follow this
	 * entry in the completion ring that are a part of this packet.
	 * If the value is zero, then the packet is completely contained
	 * in the buffer space provided for the packet in the RX ring.
	 */
	#define RX_PKT_V2_CMPL_AGG_BUFS_MASK UINT32_C(0x3e)
	#define RX_PKT_V2_CMPL_AGG_BUFS_SFT 1
	/* unused1 is 2 b */
	#define RX_PKT_V2_CMPL_UNUSED1_MASK UINT32_C(0xc0)
	#define RX_PKT_V2_CMPL_UNUSED1_SFT  6
	/*
	 * This is the RSS hash type for the packet. The value is packed
	 * {tuple_extrac_op[1:0],rss_profile_id[4:0],tuple_extrac_op[2]}.
	 *
	 * The value of tuple_extrac_op provides the information about
	 * what fields the hash was computed on.
	 * * 0: The RSS hash was computed over source IP address,
	 * destination IP address, source port, and destination port of inner
	 * IP and TCP or UDP headers. Note: For non-tunneled packets,
	 * the packet headers are considered inner packet headers for the RSS
	 * hash computation purpose.
	 * * 1: The RSS hash was computed over source IP address and destination
	 * IP address of inner IP header. Note: For non-tunneled packets,
	 * the packet headers are considered inner packet headers for the RSS
	 * hash computation purpose.
	 * * 2: The RSS hash was computed over source IP address,
	 * destination IP address, source port, and destination port of
	 * IP and TCP or UDP headers of outer tunnel headers.
	 * Note: For non-tunneled packets, this value is not applicable.
	 * * 3: The RSS hash was computed over source IP address and
	 * destination IP address of IP header of outer tunnel headers.
	 * Note: For non-tunneled packets, this value is not applicable.
	 *
	 * Note that 4-tuples values listed above are applicable
	 * for layer 4 protocols supported and enabled for RSS in the hardware,
	 * HWRM firmware, and drivers. For example, if RSS hash is supported and
	 * enabled for TCP traffic only, then the values of tuple_extract_op
	 * corresponding to 4-tuples are only valid for TCP traffic.
	 */
	uint8_t	rss_hash_type;
	uint16_t	metadata1_payload_offset;
	/*
	 * This is data from the CFA as indicated by the meta_format field.
	 * If truncation placement is not used, this value indicates the offset
	 * in bytes from the beginning of the packet where the inner payload
	 * starts. This value is valid for TCP, UDP, FCoE, and RoCE packets. If
	 * truncation placement is used, this value represents the placed
	 * (truncated) length of the packet.
	 */
	#define RX_PKT_V2_CMPL_PAYLOAD_OFFSET_MASK	UINT32_C(0x1ff)
	#define RX_PKT_V2_CMPL_PAYLOAD_OFFSET_SFT	0
	/* This is data from the CFA as indicated by the meta_format field. */
	#define RX_PKT_V2_CMPL_METADATA1_MASK		UINT32_C(0xf000)
	#define RX_PKT_V2_CMPL_METADATA1_SFT		12
	/* When meta_format != 0, this value is the VLAN TPID_SEL. */
	#define RX_PKT_V2_CMPL_METADATA1_TPID_SEL_MASK	UINT32_C(0x7000)
	#define RX_PKT_V2_CMPL_METADATA1_TPID_SEL_SFT	12
	/* 0x88a8 */
		#define RX_PKT_V2_CMPL_METADATA1_TPID_SEL_TPID88A8   (UINT32_C(0x0) << 12)
	/* 0x8100 */
		#define RX_PKT_V2_CMPL_METADATA1_TPID_SEL_TPID8100   (UINT32_C(0x1) << 12)
	/* 0x9100 */
		#define RX_PKT_V2_CMPL_METADATA1_TPID_SEL_TPID9100   (UINT32_C(0x2) << 12)
	/* 0x9200 */
		#define RX_PKT_V2_CMPL_METADATA1_TPID_SEL_TPID9200   (UINT32_C(0x3) << 12)
	/* 0x9300 */
		#define RX_PKT_V2_CMPL_METADATA1_TPID_SEL_TPID9300   (UINT32_C(0x4) << 12)
	/* Value programmed in CFA VLANTPID register. */
		#define RX_PKT_V2_CMPL_METADATA1_TPID_SEL_TPIDCFG	(UINT32_C(0x5) << 12)
		#define RX_PKT_V2_CMPL_METADATA1_TPID_SEL_LAST	RX_PKT_V2_CMPL_METADATA1_TPID_SEL_TPIDCFG
	/* When meta_format != 0, this value is the VLAN valid. */
	#define RX_PKT_V2_CMPL_METADATA1_VALID		UINT32_C(0x8000)
	/*
	 * This value is the RSS hash value calculated for the packet
	 * based on the mode bits and key value in the VNIC. When vee_cmpl_mode
	 * is set in VNIC context, this is the lower 32b of the host address
	 * from the first BD used to place the packet.
	 */
	uint32_t	rss_hash;
} rx_pkt_v2_cmpl_t, *prx_pkt_v2_cmpl_t;

/* Last 16 bytes of RX Packet V2 Completion Record */
/* rx_pkt_v2_cmpl_hi (size:128b/16B) */

typedef struct rx_pkt_v2_cmpl_hi {
	uint32_t	flags2;
	/*
	 * When this bit is '0', the cs_ok field has the following definition:-
	 * ip_cs_ok[2:0] = The number of header groups with a valid IP checksum
	 * in the delivered packet, counted from the outer-most header group to
	 * the inner-most header group, stopping at the first error. -
	 * l4_cs_ok[5:3] = The number of header groups with a valid L4 checksum
	 * in the delivered packet, counted from the outer-most header group to
	 * the inner-most header group, stopping at the first error. When this
	 * bit is '1', the cs_ok field has the following definition: -
	 * hdr_cnt[2:0] = The number of header groups that were parsed by the
	 * chip and passed in the delivered packet. - ip_cs_all_ok[3] =This bit
	 * will be '1' if all the parsed header groups with an IP checksum are
	 * valid. - l4_cs_all_ok[4] = This bit will be '1' if all the parsed
	 * header groups with an L4 checksum are valid.
	 */
	#define RX_PKT_V2_CMPL_HI_FLAGS2_CS_ALL_OK_MODE		UINT32_C(0x8)
	/* This value indicates what format the metadata field is. */
	#define RX_PKT_V2_CMPL_HI_FLAGS2_META_FORMAT_MASK	UINT32_C(0xf0)
	#define RX_PKT_V2_CMPL_HI_FLAGS2_META_FORMAT_SFT		4
	/* There is no metadata information. Values are zero. */
		#define RX_PKT_V2_CMPL_HI_FLAGS2_META_FORMAT_NONE		(UINT32_C(0x0) << 4)
	/*
	 * The {metadata1, metadata0} fields contain the vtag
	 * information: - vtag[19:0] = {valid, tpid_sel[2:0], pri[2:0],
	 * de, vid[11:0]} The metadata2 field contains the table scope
	 * and action record pointer. - metadata2[25:0] contains the
	 * action record pointer. - metadata2[31:26] contains the table
	 * scope.
	 */
		#define RX_PKT_V2_CMPL_HI_FLAGS2_META_FORMAT_ACT_REC_PTR	(UINT32_C(0x1) << 4)
	/*
	 * The {metadata1, metadata0} fields contain the vtag
	 * information:
	 * - vtag[19:0] = {valid, tpid_sel[2:0], pri[2:0], de, vid[11:0]}
	 * The metadata2 field contains the Tunnel ID
	 * value, justified to LSB. i
	 * - VXLAN = VNI[23:0] -> VXLAN Network ID
	 * - Geneve (NGE) = VNI[23:0] a-> Virtual Network Identifier
	 * - NVGRE = TNI[23:0] -> Tenant Network ID
	 * - GRE = KEY[31:0] -> key field with bit mask. zero if K=0
	 * - IPv4 = 0 (not populated)
	 * - IPv6 = Flow Label[19:0]
	 * - PPPoE = sessionID[15:0]
	 * - MPLs = Outer label[19:0]
	 * - UPAR = Selected[31:0] with bit mask
	 */
		#define RX_PKT_V2_CMPL_HI_FLAGS2_META_FORMAT_TUNNEL_ID	(UINT32_C(0x2) << 4)
	/*
	 * The {metadata1, metadata0} fields contain the vtag
	 * information:
	 * - vtag[19:0] = {valid, tpid_sel[2:0], pri[2:0],de, vid[11:0]}
	 * The metadata2 field contains the 32b metadata from the prepended
	 * header (chdr_data).
	 */
		#define RX_PKT_V2_CMPL_HI_FLAGS2_META_FORMAT_CHDR_DATA	(UINT32_C(0x3) << 4)
	/*
	 * The {metadata1, metadata0} fields contain the vtag
	 * information:
	 * - vtag[19:0] = {valid, tpid_sel[2:0], pri[2:0], de, vid[11:0]}
	 * The metadata2 field contains the outer_l3_offset,
	 * inner_l2_offset, inner_l3_offset, and inner_l4_size.
	 * - metadata2[8:0] contains the outer_l3_offset.
	 * - metadata2[17:9] contains the inner_l2_offset.
	 * - metadata2[26:18] contains the inner_l3_offset.
	 * - metadata2[31:27] contains the inner_l4_size.
	 */
		#define RX_PKT_V2_CMPL_HI_FLAGS2_META_FORMAT_HDR_OFFSET	(UINT32_C(0x4) << 4)
		#define RX_PKT_V2_CMPL_HI_FLAGS2_META_FORMAT_LAST		RX_PKT_V2_CMPL_HI_FLAGS2_META_FORMAT_HDR_OFFSET
	/*
	 * This field indicates the IP type for the inner-most IP header.
	 * A value of '0' indicates IPv4. A value of '1' indicates IPv6.
	 * This value is only valid if itype indicates a packet
	 * with an IP header.
	 */
	#define RX_PKT_V2_CMPL_HI_FLAGS2_IP_TYPE			UINT32_C(0x100)
	/*
	 * This indicates that the complete 1's complement checksum was
	 * calculated for the packet.
	 */
	#define RX_PKT_V2_CMPL_HI_FLAGS2_COMPLETE_CHECKSUM_CALC	UINT32_C(0x200)
	/*
	 * This field indicates the status of IP and L4 CS calculations done
	 * by the chip. The format of this field is indicated by the
	 * cs_all_ok_mode bit.
	 */
	#define RX_PKT_V2_CMPL_HI_FLAGS2_CS_OK_MASK		UINT32_C(0xfc00)
	#define RX_PKT_V2_CMPL_HI_FLAGS2_CS_OK_SFT		10
	/*
	 * This value is the complete 1's complement checksum calculated from
	 * the start of the outer L3 header to the end of the packet (not
	 * including the ethernet crc). It is valid when the
	 * 'complete_checksum_calc' flag is set.
	 */
	#define RX_PKT_V2_CMPL_HI_FLAGS2_COMPLETE_CHECKSUM_MASK	UINT32_C(0xffff0000)
	#define RX_PKT_V2_CMPL_HI_FLAGS2_COMPLETE_CHECKSUM_SFT	16
	/*
	 * This is data from the CFA block as indicated by the meta_format
	 * field.
	 * - meta_format 0 - none - metadata2 = 0 - not valid/not stripped
	 * - meta_format 1 - act_rec_ptr - metadata2 = {table_scope[5:0],
	 *   act_rec_ptr[25:0]}
	 * - meta_format 2 - tunnel_id - metadata2 = tunnel_id[31:0]
	 * - meta_format 3 - chdr_data - metadata2 = updated_chdr_data[31:0]
	 * - meta_format 4 - hdr_offsets - metadata2 = hdr_offsets[31:0]
	 * When vee_cmpl_mode is set in VNIC context, this is the upper 32b
	 * of the host address from the first BD used to place the packet.
	 */
	uint32_t	metadata2;
	uint16_t	errors_v2;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define RX_PKT_V2_CMPL_HI_V2					UINT32_C(0x1)
	#define RX_PKT_V2_CMPL_HI_ERRORS_MASK				UINT32_C(0xfffe)
	#define RX_PKT_V2_CMPL_HI_ERRORS_SFT				1
	/*
	 * This error indicates that there was some sort of problem with
	 * the BDs for the packet that was found after part of the
	 * packet was already placed. The packet should be treated as
	 * invalid.
	 */
	#define RX_PKT_V2_CMPL_HI_ERRORS_BUFFER_ERROR_MASK		UINT32_C(0xe)
	#define RX_PKT_V2_CMPL_HI_ERRORS_BUFFER_ERROR_SFT		1
	/* No buffer error */
		#define RX_PKT_V2_CMPL_HI_ERRORS_BUFFER_ERROR_NO_BUFFER		(UINT32_C(0x0) << 1)
	/*
	 * Did Not Fit: Packet did not fit into packet buffer provided.
	 * For regular placement, this means the packet did not fit in
	 * the buffer provided. For HDS and jumbo placement, this means
	 * that the packet could not be placed into 8 physical buffers
	 * (if fixed-size buffers are used), or that the packet could
	 * not be placed in the number of physical buffers configured
	 * for the VNIC (if variable-size buffers are used)
	 */
		#define RX_PKT_V2_CMPL_HI_ERRORS_BUFFER_ERROR_DID_NOT_FIT		(UINT32_C(0x1) << 1)
	/*
	 * Not On Chip: All BDs needed for the packet were not on-chip
	 * when the packet arrived. For regular placement, this error is
	 * not valid. For HDS and jumbo placement, this means that not
	 * enough agg BDs were posted to place the packet.
	 */
		#define RX_PKT_V2_CMPL_HI_ERRORS_BUFFER_ERROR_NOT_ON_CHIP		(UINT32_C(0x2) << 1)
	/*
	 * Bad Format:
	 * BDs were not formatted correctly.
	 */
		#define RX_PKT_V2_CMPL_HI_ERRORS_BUFFER_ERROR_BAD_FORMAT		(UINT32_C(0x3) << 1)
	/*
	 * Flush:
	 * There was a bad_format error on the previous operation
	 */
		#define RX_PKT_V2_CMPL_HI_ERRORS_BUFFER_ERROR_FLUSH		(UINT32_C(0x5) << 1)
		#define RX_PKT_V2_CMPL_HI_ERRORS_BUFFER_ERROR_LAST		RX_PKT_V2_CMPL_HI_ERRORS_BUFFER_ERROR_FLUSH
	/*
	 * This indicates that there was an error in the outer tunnel
	 * portion of the packet when this field is non-zero.
	 */
	#define RX_PKT_V2_CMPL_HI_ERRORS_OT_PKT_ERROR_MASK		UINT32_C(0x70)
	#define RX_PKT_V2_CMPL_HI_ERRORS_OT_PKT_ERROR_SFT		4
	/*
	 * No additional error occurred on the outer tunnel portion
	 * of the packet or the packet does not have a outer tunnel.
	 */
		#define RX_PKT_V2_CMPL_HI_ERRORS_OT_PKT_ERROR_NO_ERROR		(UINT32_C(0x0) << 4)
	/*
	 * Indicates that IP header version does not match expectation
	 * from L2 Ethertype for IPv4 and IPv6 in the outer tunnel header.
	 */
		#define RX_PKT_V2_CMPL_HI_ERRORS_OT_PKT_ERROR_OT_L3_BAD_VERSION	(UINT32_C(0x1) << 4)
	/*
	 * Indicates that header length is out of range in the outer
	 * tunnel header. Valid for IPv4.
	 */
		#define RX_PKT_V2_CMPL_HI_ERRORS_OT_PKT_ERROR_OT_L3_BAD_HDR_LEN	(UINT32_C(0x2) << 4)
	/*
	 * Indicates that physical packet is shorter than that claimed
	 * by the outer tunnel l3 header length. Valid for IPv4, or
	 * IPv6 outer tunnel packets.
	 */
		#define RX_PKT_V2_CMPL_HI_ERRORS_OT_PKT_ERROR_OT_IP_TOTAL_ERROR	(UINT32_C(0x3) << 4)
	/*
	 * Indicates that the physical packet is shorter than that
	 * claimed by the outer tunnel UDP header length for a outer
	 * tunnel UDP packet that is not fragmented.
	 */
		#define RX_PKT_V2_CMPL_HI_ERRORS_OT_PKT_ERROR_OT_UDP_TOTAL_ERROR	(UINT32_C(0x4) << 4)
	/*
	 * Indicates that the IPv4 TTL or IPv6 hop limit check have
	 * failed (e.g. TTL = 0) in the outer tunnel header. Valid for
	 * IPv4, and IPv6.
	 */
		#define RX_PKT_V2_CMPL_HI_ERRORS_OT_PKT_ERROR_OT_L3_BAD_TTL	(UINT32_C(0x5) << 4)
	/*
	 * Indicates that the IP checksum failed its check in the outer
	 * tunnel header.
	 */
		#define RX_PKT_V2_CMPL_HI_ERRORS_OT_PKT_ERROR_OT_IP_CS_ERROR	(UINT32_C(0x6) << 4)
	/*
	 * Indicates that the L4 checksum failed its check in the outer
	 * tunnel header.
	 */
		#define RX_PKT_V2_CMPL_HI_ERRORS_OT_PKT_ERROR_OT_L4_CS_ERROR	(UINT32_C(0x7) << 4)
		#define RX_PKT_V2_CMPL_HI_ERRORS_OT_PKT_ERROR_LAST		RX_PKT_V2_CMPL_HI_ERRORS_OT_PKT_ERROR_OT_L4_CS_ERROR
	/*
	 * This indicates that there was a CRC error on either an FCoE
	 * or RoCE packet. The itype indicates the packet type.
	 */
	#define RX_PKT_V2_CMPL_HI_ERRORS_CRC_ERROR			UINT32_C(0x100)
	/*
	 * This indicates that there was an error in the tunnel portion
	 * of the packet when this field is non-zero.
	 */
	#define RX_PKT_V2_CMPL_HI_ERRORS_T_PKT_ERROR_MASK		UINT32_C(0xe00)
	#define RX_PKT_V2_CMPL_HI_ERRORS_T_PKT_ERROR_SFT			9
	/*
	 * No additional error occurred on the tunnel portion
	 * of the packet or the packet does not have a tunnel.
	 */
		#define RX_PKT_V2_CMPL_HI_ERRORS_T_PKT_ERROR_NO_ERROR		(UINT32_C(0x0) << 9)
	/*
	 * Indicates that IP header version does not match expectation
	 * from L2 Ethertype for IPv4 and IPv6 in the tunnel header.
	 */
		#define RX_PKT_V2_CMPL_HI_ERRORS_T_PKT_ERROR_T_L3_BAD_VERSION	(UINT32_C(0x1) << 9)
	/*
	 * Indicates that header length is out of range in the tunnel
	 * header. Valid for IPv4.
	 */
		#define RX_PKT_V2_CMPL_HI_ERRORS_T_PKT_ERROR_T_L3_BAD_HDR_LEN	(UINT32_C(0x2) << 9)
	/*
	 * Indicates that physical packet is shorter than that claimed
	 * by the tunnel l3 header length. Valid for IPv4, or IPv6 tunnel
	 * packet packets.
	 */
		#define RX_PKT_V2_CMPL_HI_ERRORS_T_PKT_ERROR_T_IP_TOTAL_ERROR	(UINT32_C(0x3) << 9)
	/*
	 * Indicates that the physical packet is shorter than that claimed
	 * by the tunnel UDP header length for a tunnel UDP packet that is
	 * not fragmented.
	 */
		#define RX_PKT_V2_CMPL_HI_ERRORS_T_PKT_ERROR_T_UDP_TOTAL_ERROR	(UINT32_C(0x4) << 9)
	/*
	 * Indicates that the IPv4 TTL or IPv6 hop limit check have failed
	 * (e.g. TTL = 0) in the tunnel header. Valid for IPv4, and IPv6.
	 */
		#define RX_PKT_V2_CMPL_HI_ERRORS_T_PKT_ERROR_T_L3_BAD_TTL		(UINT32_C(0x5) << 9)
	/*
	 * Indicates that the IP checksum failed its check in the tunnel
	 * header.
	 */
		#define RX_PKT_V2_CMPL_HI_ERRORS_T_PKT_ERROR_T_IP_CS_ERROR		(UINT32_C(0x6) << 9)
	/*
	 * Indicates that the L4 checksum failed its check in the tunnel
	 * header.
	 */
		#define RX_PKT_V2_CMPL_HI_ERRORS_T_PKT_ERROR_T_L4_CS_ERROR		(UINT32_C(0x7) << 9)
		#define RX_PKT_V2_CMPL_HI_ERRORS_T_PKT_ERROR_LAST			RX_PKT_V2_CMPL_HI_ERRORS_T_PKT_ERROR_T_L4_CS_ERROR
	/*
	 * This indicates that there was an error in the inner
	 * portion of the packet when this
	 * field is non-zero.
	 */
	#define RX_PKT_V2_CMPL_HI_ERRORS_PKT_ERROR_MASK			UINT32_C(0xf000)
	#define RX_PKT_V2_CMPL_HI_ERRORS_PKT_ERROR_SFT			12
	/*
	 * No additional error occurred on the tunnel portion
	 * or the packet of the packet does not have a tunnel.
	 */
		#define RX_PKT_V2_CMPL_HI_ERRORS_PKT_ERROR_NO_ERROR		(UINT32_C(0x0) << 12)
	/*
	 * Indicates that IP header version does not match
	 * expectation from L2 Ethertype for IPv4 and IPv6 or that
	 * option other than VFT was parsed on
	 * FCoE packet.
	 */
		#define RX_PKT_V2_CMPL_HI_ERRORS_PKT_ERROR_L3_BAD_VERSION		(UINT32_C(0x1) << 12)
	/*
	 * indicates that header length is out of range. Valid for
	 * IPv4 and RoCE
	 */
		#define RX_PKT_V2_CMPL_HI_ERRORS_PKT_ERROR_L3_BAD_HDR_LEN		(UINT32_C(0x2) << 12)
	/*
	 * indicates that the IPv4 TTL or IPv6 hop limit check
	 * have failed (e.g. TTL = 0). Valid for IPv4, and IPv6
	 */
		#define RX_PKT_V2_CMPL_HI_ERRORS_PKT_ERROR_L3_BAD_TTL		(UINT32_C(0x3) << 12)
	/*
	 * Indicates that physical packet is shorter than that
	 * claimed by the l3 header length. Valid for IPv4,
	 * IPv6 packet or RoCE packets.
	 */
		#define RX_PKT_V2_CMPL_HI_ERRORS_PKT_ERROR_IP_TOTAL_ERROR		(UINT32_C(0x4) << 12)
	/*
	 * Indicates that the physical packet is shorter than that
	 * claimed by the UDP header length for a UDP packet that is
	 * not fragmented.
	 */
		#define RX_PKT_V2_CMPL_HI_ERRORS_PKT_ERROR_UDP_TOTAL_ERROR		(UINT32_C(0x5) << 12)
	/*
	 * Indicates that TCP header length > IP payload. Valid for
	 * TCP packets only.
	 */
		#define RX_PKT_V2_CMPL_HI_ERRORS_PKT_ERROR_L4_BAD_HDR_LEN		(UINT32_C(0x6) << 12)
	/* Indicates that TCP header length < 5. Valid for TCP. */
		#define RX_PKT_V2_CMPL_HI_ERRORS_PKT_ERROR_L4_BAD_HDR_LEN_TOO_SMALL   (UINT32_C(0x7) << 12)
	/*
	 * Indicates that TCP option headers result in a TCP header
	 * size that does not match data offset in TCP header. Valid
	 * for TCP.
	 */
		#define RX_PKT_V2_CMPL_HI_ERRORS_PKT_ERROR_L4_BAD_OPT_LEN		(UINT32_C(0x8) << 12)
	/*
	 * Indicates that the IP checksum failed its check in the
	 * inner header.
	 */
		#define RX_PKT_V2_CMPL_HI_ERRORS_PKT_ERROR_IP_CS_ERROR		(UINT32_C(0x9) << 12)
	/*
	 * Indicates that the L4 checksum failed its check in the
	 * inner header.
	 */
		#define RX_PKT_V2_CMPL_HI_ERRORS_PKT_ERROR_L4_CS_ERROR		(UINT32_C(0xa) << 12)
		#define RX_PKT_V2_CMPL_HI_ERRORS_PKT_ERROR_LAST			RX_PKT_V2_CMPL_HI_ERRORS_PKT_ERROR_L4_CS_ERROR
	/*
	 * This is data from the CFA block as indicated by the meta_format
	 * field.
	 */
	uint16_t	metadata0;
	/* When meta_format=1, this value is the VLAN VID. */
	#define RX_PKT_V2_CMPL_HI_METADATA0_VID_MASK UINT32_C(0xfff)
	#define RX_PKT_V2_CMPL_HI_METADATA0_VID_SFT 0
	/* When meta_format=1, this value is the VLAN DE. */
	#define RX_PKT_V2_CMPL_HI_METADATA0_DE	UINT32_C(0x1000)
	/* When meta_format=1, this value is the VLAN PRI. */
	#define RX_PKT_V2_CMPL_HI_METADATA0_PRI_MASK UINT32_C(0xe000)
	#define RX_PKT_V2_CMPL_HI_METADATA0_PRI_SFT 13
	/*
	 * The timestamp field contains the 32b timestamp for the packet from
	 * the MAC.
	 */
	uint32_t	timestamp;
} rx_pkt_v2_cmpl_hi_t, *prx_pkt_v2_cmpl_hi_t;

/*
 * This TPA completion structure is used on devices where the
 * `hwrm_vnic_qcaps.max_aggs_supported` value is 0.
 */
/* rx_tpa_start_cmpl (size:128b/16B) */

typedef struct rx_tpa_start_cmpl {
	uint16_t	flags_type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define RX_TPA_START_CMPL_TYPE_MASK		UINT32_C(0x3f)
	#define RX_TPA_START_CMPL_TYPE_SFT		0
	/*
	 * RX L2 TPA Start Completion:
	 * Completion at the beginning of a TPA operation.
	 * Length = 32B
	 */
		#define RX_TPA_START_CMPL_TYPE_RX_TPA_START	UINT32_C(0x13)
		#define RX_TPA_START_CMPL_TYPE_LAST		RX_TPA_START_CMPL_TYPE_RX_TPA_START
	#define RX_TPA_START_CMPL_FLAGS_MASK		UINT32_C(0xffc0)
	#define RX_TPA_START_CMPL_FLAGS_SFT		6
	/* This bit will always be '0' for TPA start completions. */
	#define RX_TPA_START_CMPL_FLAGS_ERROR		UINT32_C(0x40)
	/* This field indicates how the packet was placed in the buffer. */
	#define RX_TPA_START_CMPL_FLAGS_PLACEMENT_MASK	UINT32_C(0x380)
	#define RX_TPA_START_CMPL_FLAGS_PLACEMENT_SFT	7
	/*
	 * Jumbo:
	 * TPA Packet was placed using jumbo algorithm. This means
	 * that the first buffer will be filled with data before
	 * moving to aggregation buffers. Each aggregation buffer
	 * will be filled before moving to the next aggregation
	 * buffer.
	 */
		#define RX_TPA_START_CMPL_FLAGS_PLACEMENT_JUMBO	(UINT32_C(0x1) << 7)
	/*
	 * Header/Data Separation:
	 * Packet was placed using Header/Data separation algorithm.
	 * The separation location is indicated by the itype field.
	 */
		#define RX_TPA_START_CMPL_FLAGS_PLACEMENT_HDS	(UINT32_C(0x2) << 7)
	/*
	 * GRO/Jumbo:
	 * Packet will be placed using GRO/Jumbo where the first
	 * packet is filled with data. Subsequent packets will be
	 * placed such that any one packet does not span two
	 * aggregation buffers unless it starts at the beginning of
	 * an aggregation buffer.
	 */
		#define RX_TPA_START_CMPL_FLAGS_PLACEMENT_GRO_JUMBO   (UINT32_C(0x5) << 7)
	/*
	 * GRO/Header-Data Separation:
	 * Packet will be placed using GRO/HDS where the header
	 * is in the first packet.
	 * Payload of each packet will be
	 * placed such that any one packet does not span two
	 * aggregation buffers unless it starts at the beginning of
	 * an aggregation buffer.
	 */
		#define RX_TPA_START_CMPL_FLAGS_PLACEMENT_GRO_HDS	(UINT32_C(0x6) << 7)
		#define RX_TPA_START_CMPL_FLAGS_PLACEMENT_LAST	RX_TPA_START_CMPL_FLAGS_PLACEMENT_GRO_HDS
	/* This bit is '1' if the RSS field in this completion is valid. */
	#define RX_TPA_START_CMPL_FLAGS_RSS_VALID	UINT32_C(0x400)
	/* unused is 1 b */
	#define RX_TPA_START_CMPL_FLAGS_UNUSED		UINT32_C(0x800)
	/*
	 * This value indicates what the inner packet determined for the
	 * packet was.
	 */
	#define RX_TPA_START_CMPL_FLAGS_ITYPE_MASK	UINT32_C(0xf000)
	#define RX_TPA_START_CMPL_FLAGS_ITYPE_SFT	12
	/*
	 * TCP Packet:
	 * Indicates that the packet was IP and TCP.
	 */
		#define RX_TPA_START_CMPL_FLAGS_ITYPE_TCP		(UINT32_C(0x2) << 12)
		#define RX_TPA_START_CMPL_FLAGS_ITYPE_LAST	RX_TPA_START_CMPL_FLAGS_ITYPE_TCP
	/*
	 * This value indicates the amount of packet data written to the
	 * buffer the opaque field in this completion corresponds to.
	 */
	uint16_t	len;
	/*
	 * This is a copy of the opaque field from the RX BD this completion
	 * corresponds to.
	 */
	uint32_t	opaque;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	uint8_t	v1;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define RX_TPA_START_CMPL_V1 UINT32_C(0x1)
	#define RX_TPA_START_CMPL_LAST RX_TPA_START_CMPL_V1
	/*
	 * This is the RSS hash type for the packet. The value is packed
	 * {tuple_extrac_op[1:0],rss_profile_id[4:0],tuple_extrac_op[2]}.
	 *
	 * The value of tuple_extrac_op provides the information about
	 * what fields the hash was computed on.
	 * * 0: The RSS hash was computed over source IP address,
	 * destination IP address, source port, and destination port of inner
	 * IP and TCP or UDP headers. Note: For non-tunneled packets,
	 * the packet headers are considered inner packet headers for the RSS
	 * hash computation purpose.
	 * * 1: The RSS hash was computed over source IP address and destination
	 * IP address of inner IP header. Note: For non-tunneled packets,
	 * the packet headers are considered inner packet headers for the RSS
	 * hash computation purpose.
	 * * 2: The RSS hash was computed over source IP address,
	 * destination IP address, source port, and destination port of
	 * IP and TCP or UDP headers of outer tunnel headers.
	 * Note: For non-tunneled packets, this value is not applicable.
	 * * 3: The RSS hash was computed over source IP address and
	 * destination IP address of IP header of outer tunnel headers.
	 * Note: For non-tunneled packets, this value is not applicable.
	 *
	 * Note that 4-tuples values listed above are applicable
	 * for layer 4 protocols supported and enabled for RSS in the hardware,
	 * HWRM firmware, and drivers. For example, if RSS hash is supported and
	 * enabled for TCP traffic only, then the values of tuple_extract_op
	 * corresponding to 4-tuples are only valid for TCP traffic.
	 */
	uint8_t	rss_hash_type;
	/*
	 * This is the aggregation ID that the completion is associated
	 * with. Use this number to correlate the TPA start completion
	 * with the TPA end completion.
	 */
	uint16_t	agg_id;
	/* unused2 is 9 b */
	#define RX_TPA_START_CMPL_UNUSED2_MASK UINT32_C(0x1ff)
	#define RX_TPA_START_CMPL_UNUSED2_SFT 0
	/*
	 * This is the aggregation ID that the completion is associated
	 * with. Use this number to correlate the TPA start completion
	 * with the TPA end completion.
	 */
	#define RX_TPA_START_CMPL_AGG_ID_MASK UINT32_C(0xfe00)
	#define RX_TPA_START_CMPL_AGG_ID_SFT  9
	/*
	 * This value is the RSS hash value calculated for the packet
	 * based on the mode bits and key value in the VNIC.
	 */
	uint32_t	rss_hash;
} rx_tpa_start_cmpl_t, *prx_tpa_start_cmpl_t;

/*
 * Last 16 bytes of rx_tpa_start_cmpl.
 *
 * This TPA completion structure is used on devices where the
 * `hwrm_vnic_qcaps.max_aggs_supported` value is 0.
 */
/* rx_tpa_start_cmpl_hi (size:128b/16B) */

typedef struct rx_tpa_start_cmpl_hi {
	uint32_t	flags2;
	/*
	 * This indicates that the ip checksum was calculated for the
	 * inner packet and that the sum passed for all segments
	 * included in the aggregation.
	 */
	#define RX_TPA_START_CMPL_FLAGS2_IP_CS_CALC	UINT32_C(0x1)
	/*
	 * This indicates that the TCP, UDP or ICMP checksum was
	 * calculated for the inner packet and that the sum passed
	 * for all segments included in the aggregation.
	 */
	#define RX_TPA_START_CMPL_FLAGS2_L4_CS_CALC	UINT32_C(0x2)
	/*
	 * This indicates that the ip checksum was calculated for the
	 * tunnel header and that the sum passed for all segments
	 * included in the aggregation.
	 */
	#define RX_TPA_START_CMPL_FLAGS2_T_IP_CS_CALC	UINT32_C(0x4)
	/*
	 * This indicates that the UDP checksum was
	 * calculated for the tunnel packet and that the sum passed for
	 * all segments included in the aggregation.
	 */
	#define RX_TPA_START_CMPL_FLAGS2_T_L4_CS_CALC	UINT32_C(0x8)
	/* This value indicates what format the metadata field is. */
	#define RX_TPA_START_CMPL_FLAGS2_META_FORMAT_MASK UINT32_C(0xf0)
	#define RX_TPA_START_CMPL_FLAGS2_META_FORMAT_SFT  4
	/* No metadata information. Value is zero. */
		#define RX_TPA_START_CMPL_FLAGS2_META_FORMAT_NONE   (UINT32_C(0x0) << 4)
	/*
	 * The metadata field contains the VLAN tag and TPID value.
	 * - metadata[11:0] contains the vlan VID value.
	 * - metadata[12] contains the vlan DE value.
	 * - metadata[15:13] contains the vlan PRI value.
	 * - metadata[31:16] contains the vlan TPID value.
	 */
		#define RX_TPA_START_CMPL_FLAGS2_META_FORMAT_VLAN   (UINT32_C(0x1) << 4)
		#define RX_TPA_START_CMPL_FLAGS2_META_FORMAT_LAST  RX_TPA_START_CMPL_FLAGS2_META_FORMAT_VLAN
	/*
	 * This field indicates the IP type for the inner-most IP header.
	 * A value of '0' indicates IPv4. A value of '1' indicates IPv6.
	 */
	#define RX_TPA_START_CMPL_FLAGS2_IP_TYPE	UINT32_C(0x100)
	/*
	 * This is data from the CFA block as indicated by the meta_format
	 * field.
	 */
	uint32_t	metadata;
	/* When meta_format=1, this value is the VLAN VID. */
	#define RX_TPA_START_CMPL_METADATA_VID_MASK UINT32_C(0xfff)
	#define RX_TPA_START_CMPL_METADATA_VID_SFT  0
	/* When meta_format=1, this value is the VLAN DE. */
	#define RX_TPA_START_CMPL_METADATA_DE	UINT32_C(0x1000)
	/* When meta_format=1, this value is the VLAN PRI. */
	#define RX_TPA_START_CMPL_METADATA_PRI_MASK UINT32_C(0xe000)
	#define RX_TPA_START_CMPL_METADATA_PRI_SFT  13
	/* When meta_format=1, this value is the VLAN TPID. */
	#define RX_TPA_START_CMPL_METADATA_TPID_MASK UINT32_C(0xffff0000)
	#define RX_TPA_START_CMPL_METADATA_TPID_SFT 16
	uint16_t	v2;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define RX_TPA_START_CMPL_V2	UINT32_C(0x1)
	/*
	 * This field identifies the CFA action rule that was used for this
	 * packet.
	 */
	uint16_t	cfa_code;
	/*
	 * This is the size in bytes of the inner most L4 header.
	 * This can be subtracted from the payload_offset to determine
	 * the start of the inner most L4 header.
	 */
	uint32_t	inner_l4_size_inner_l3_offset_inner_l2_offset_outer_l3_offset;
	/*
	 * This is the offset from the beginning of the packet in bytes for
	 * the outer L3 header. If there is no outer L3 header, then this
	 * value is zero.
	 */
	#define RX_TPA_START_CMPL_OUTER_L3_OFFSET_MASK UINT32_C(0x1ff)
	#define RX_TPA_START_CMPL_OUTER_L3_OFFSET_SFT 0
	/*
	 * This is the offset from the beginning of the packet in bytes for
	 * the inner most L2 header.
	 */
	#define RX_TPA_START_CMPL_INNER_L2_OFFSET_MASK UINT32_C(0x3fe00)
	#define RX_TPA_START_CMPL_INNER_L2_OFFSET_SFT 9
	/*
	 * This is the offset from the beginning of the packet in bytes for
	 * the inner most L3 header.
	 */
	#define RX_TPA_START_CMPL_INNER_L3_OFFSET_MASK UINT32_C(0x7fc0000)
	#define RX_TPA_START_CMPL_INNER_L3_OFFSET_SFT 18
	/*
	 * This is the size in bytes of the inner most L4 header.
	 * This can be subtracted from the payload_offset to determine
	 * the start of the inner most L4 header.
	 */
	#define RX_TPA_START_CMPL_INNER_L4_SIZE_MASK  UINT32_C(0xf8000000)
	#define RX_TPA_START_CMPL_INNER_L4_SIZE_SFT   27
} rx_tpa_start_cmpl_hi_t, *prx_tpa_start_cmpl_hi_t;

/*
 * This TPA completion structure is used on devices where the
 * `hwrm_vnic_qcaps.max_aggs_supported` value is 0.
 * RX L2 TPA Start V2 Completion Record (32 bytes split to 2 16-byte
 * struct)
 */
/* rx_tpa_start_v2_cmpl (size:128b/16B) */

typedef struct rx_tpa_start_v2_cmpl {
	uint16_t	flags_type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define RX_TPA_START_V2_CMPL_TYPE_MASK			UINT32_C(0x3f)
	#define RX_TPA_START_V2_CMPL_TYPE_SFT			0
	/*
	 * RX L2 TPA Start V2 Completion:
	 * Completion at the beginning of a TPA operation.
	 * Length = 32B
	 * This is the new version of the RX_TPA_START completion used
	 * in SR2 and later chips.
	 */
		#define RX_TPA_START_V2_CMPL_TYPE_RX_TPA_START_V2		UINT32_C(0xd)
		#define RX_TPA_START_V2_CMPL_TYPE_LAST			RX_TPA_START_V2_CMPL_TYPE_RX_TPA_START_V2
	#define RX_TPA_START_V2_CMPL_FLAGS_MASK			UINT32_C(0xffc0)
	#define RX_TPA_START_V2_CMPL_FLAGS_SFT			6
	/*
	 * When this bit is '1', it indicates a packet that has an error
	 * of some type. Type of error is indicated in error_flags.
	 */
	#define RX_TPA_START_V2_CMPL_FLAGS_ERROR			UINT32_C(0x40)
	/* This field indicates how the packet was placed in the buffer. */
	#define RX_TPA_START_V2_CMPL_FLAGS_PLACEMENT_MASK		UINT32_C(0x380)
	#define RX_TPA_START_V2_CMPL_FLAGS_PLACEMENT_SFT		7
	/*
	 * Jumbo:
	 * TPA Packet was placed using jumbo algorithm. This means
	 * that the first buffer will be filled with data before
	 * moving to aggregation buffers. Each aggregation buffer
	 * will be filled before moving to the next aggregation
	 * buffer.
	 */
		#define RX_TPA_START_V2_CMPL_FLAGS_PLACEMENT_JUMBO		(UINT32_C(0x1) << 7)
	/*
	 * Header/Data Separation:
	 * Packet was placed using Header/Data separation algorithm.
	 * The separation location is indicated by the itype field.
	 */
		#define RX_TPA_START_V2_CMPL_FLAGS_PLACEMENT_HDS		(UINT32_C(0x2) << 7)
	/*
	 * IOC/Jumbo:
	 * Packet will be placed using In-Order Completion/Jumbo where
	 * the first packet of the aggregation is placed using Jumbo
	 * Placement. Subsequent packets will be placed such that each
	 * packet starts at the beginning of an aggregation buffer.
	 */
		#define RX_TPA_START_V2_CMPL_FLAGS_PLACEMENT_IOC_JUMBO	(UINT32_C(0x4) << 7)
	/*
	 * GRO/Jumbo:
	 * Packet will be placed using GRO/Jumbo where the first
	 * packet is filled with data. Subsequent packets will be
	 * placed such that any one packet does not span two
	 * aggregation buffers unless it starts at the beginning of
	 * an aggregation buffer.
	 */
		#define RX_TPA_START_V2_CMPL_FLAGS_PLACEMENT_GRO_JUMBO	(UINT32_C(0x5) << 7)
	/*
	 * GRO/Header-Data Separation:
	 * Packet will be placed using GRO/HDS where the header
	 * is in the first packet.
	 * Payload of each packet will be
	 * placed such that any one packet does not span two
	 * aggregation buffers unless it starts at the beginning of
	 * an aggregation buffer.
	 */
		#define RX_TPA_START_V2_CMPL_FLAGS_PLACEMENT_GRO_HDS	(UINT32_C(0x6) << 7)
	/*
	 * IOC/Header-Data Separation:
	 * Packet will be placed using In-Order Completion/HDS where
	 * the header is in the first packet buffer. Payload of each
	 * packet will be placed such that each packet starts at the
	 * beginning of an aggregation buffer.
	 */
		#define RX_TPA_START_V2_CMPL_FLAGS_PLACEMENT_IOC_HDS	(UINT32_C(0x7) << 7)
		#define RX_TPA_START_V2_CMPL_FLAGS_PLACEMENT_LAST		RX_TPA_START_V2_CMPL_FLAGS_PLACEMENT_IOC_HDS
	/* This bit is '1' if the RSS field in this completion is valid. */
	#define RX_TPA_START_V2_CMPL_FLAGS_RSS_VALID		UINT32_C(0x400)
	/*
	 * This bit is '1' if metadata has been added to the end of the
	 * packet in host memory. Metadata starts at the first 32B boundary
	 * after the end of the packet for regular and jumbo placement. It
	 * starts at the first 32B boundary after the end of the header for
	 * HDS placement. The length of the metadata is indicated in the
	 * metadata itself.
	 */
	#define RX_TPA_START_V2_CMPL_FLAGS_PKT_METADATA_PRESENT	UINT32_C(0x800)
	/*
	 * This value indicates what the inner packet determined for the
	 * packet was.
	 */
	#define RX_TPA_START_V2_CMPL_FLAGS_ITYPE_MASK		UINT32_C(0xf000)
	#define RX_TPA_START_V2_CMPL_FLAGS_ITYPE_SFT		12
	/*
	 * TCP Packet:
	 * Indicates that the packet was IP and TCP.
	 */
		#define RX_TPA_START_V2_CMPL_FLAGS_ITYPE_TCP		(UINT32_C(0x2) << 12)
		#define RX_TPA_START_V2_CMPL_FLAGS_ITYPE_LAST		RX_TPA_START_V2_CMPL_FLAGS_ITYPE_TCP
	/*
	 * This value indicates the amount of packet data written to the
	 * buffer the opaque field in this completion corresponds to.
	 */
	uint16_t	len;
	/*
	 * This is a copy of the opaque field from the RX BD this completion
	 * corresponds to. If the VNIC is configured to not use an Rx BD for
	 * the TPA Start completion, then this is a copy of the opaque field
	 * from the first BD used to place the TPA Start packet.
	 */
	uint32_t	opaque;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	uint8_t	v1;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define RX_TPA_START_V2_CMPL_V1 UINT32_C(0x1)
	#define RX_TPA_START_V2_CMPL_LAST RX_TPA_START_V2_CMPL_V1
	/*
	 * This is the RSS hash type for the packet. The value is packed
	 * {tuple_extrac_op[1:0],rss_profile_id[4:0],tuple_extrac_op[2]}.
	 *
	 * The value of tuple_extrac_op provides the information about
	 * what fields the hash was computed on.
	 * * 0: The RSS hash was computed over source IP address,
	 * destination IP address, source port, and destination port of inner
	 * IP and TCP or UDP headers. Note: For non-tunneled packets,
	 * the packet headers are considered inner packet headers for the RSS
	 * hash computation purpose.
	 * * 1: The RSS hash was computed over source IP address and destination
	 * IP address of inner IP header. Note: For non-tunneled packets,
	 * the packet headers are considered inner packet headers for the RSS
	 * hash computation purpose.
	 * * 2: The RSS hash was computed over source IP address,
	 * destination IP address, source port, and destination port of
	 * IP and TCP or UDP headers of outer tunnel headers.
	 * Note: For non-tunneled packets, this value is not applicable.
	 * * 3: The RSS hash was computed over source IP address and
	 * destination IP address of IP header of outer tunnel headers.
	 * Note: For non-tunneled packets, this value is not applicable.
	 *
	 * Note that 4-tuples values listed above are applicable
	 * for layer 4 protocols supported and enabled for RSS in the hardware,
	 * HWRM firmware, and drivers. For example, if RSS hash is supported and
	 * enabled for TCP traffic only, then the values of tuple_extract_op
	 * corresponding to 4-tuples are only valid for TCP traffic.
	 */
	uint8_t	rss_hash_type;
	/*
	 * This is the aggregation ID that the completion is associated
	 * with. Use this number to correlate the TPA start completion
	 * with the TPA end completion.
	 */
	uint16_t	agg_id;
	/*
	 * This is the aggregation ID that the completion is associated
	 * with. Use this number to correlate the TPA start completion
	 * with the TPA end completion.
	 */
	#define RX_TPA_START_V2_CMPL_AGG_ID_MASK		UINT32_C(0xfff)
	#define RX_TPA_START_V2_CMPL_AGG_ID_SFT		0
	#define RX_TPA_START_V2_CMPL_METADATA1_MASK		UINT32_C(0xf000)
	#define RX_TPA_START_V2_CMPL_METADATA1_SFT		12
	/* When meta_format != 0, this value is the VLAN TPID_SEL. */
	#define RX_TPA_START_V2_CMPL_METADATA1_TPID_SEL_MASK	UINT32_C(0x7000)
	#define RX_TPA_START_V2_CMPL_METADATA1_TPID_SEL_SFT	12
	/* 0x88a8 */
		#define RX_TPA_START_V2_CMPL_METADATA1_TPID_SEL_TPID88A8   (UINT32_C(0x0) << 12)
	/* 0x8100 */
		#define RX_TPA_START_V2_CMPL_METADATA1_TPID_SEL_TPID8100   (UINT32_C(0x1) << 12)
	/* 0x9100 */
		#define RX_TPA_START_V2_CMPL_METADATA1_TPID_SEL_TPID9100   (UINT32_C(0x2) << 12)
	/* 0x9200 */
		#define RX_TPA_START_V2_CMPL_METADATA1_TPID_SEL_TPID9200   (UINT32_C(0x3) << 12)
	/* 0x9300 */
		#define RX_TPA_START_V2_CMPL_METADATA1_TPID_SEL_TPID9300   (UINT32_C(0x4) << 12)
	/* Value programmed in CFA VLANTPID register. */
		#define RX_TPA_START_V2_CMPL_METADATA1_TPID_SEL_TPIDCFG	(UINT32_C(0x5) << 12)
		#define RX_TPA_START_V2_CMPL_METADATA1_TPID_SEL_LAST	RX_TPA_START_V2_CMPL_METADATA1_TPID_SEL_TPIDCFG
	/* When meta_format != 0, this value is the VLAN valid. */
	#define RX_TPA_START_V2_CMPL_METADATA1_VALID		UINT32_C(0x8000)
	/*
	 * This value is the RSS hash value calculated for the packet
	 * based on the mode bits and key value in the VNIC.
	 * When vee_cmpl_mode is set in VNIC context, this is the lower
	 * 32b of the host address from the first BD used to place the packet.
	 */
	uint32_t	rss_hash;
} rx_tpa_start_v2_cmpl_t, *prx_tpa_start_v2_cmpl_t;

/*
 * Last 16 bytes of RX L2 TPA Start V2 Completion Record
 *
 * This TPA completion structure is used on devices where the
 * `hwrm_vnic_qcaps.max_aggs_supported` value is 0.
 */
/* rx_tpa_start_v2_cmpl_hi (size:128b/16B) */

typedef struct rx_tpa_start_v2_cmpl_hi {
	uint32_t	flags2;
	/* This indicates that the aggregation was done using GRO rules. */
	#define RX_TPA_START_V2_CMPL_FLAGS2_AGG_GRO			UINT32_C(0x4)
	/*
	 * When this bit is '0', the cs_ok field has the following definition:-
	 * ip_cs_ok[2:0] = The number of header groups with a valid IP checksum
	 * in the delivered packet, counted from the outer-most header group to
	 * the inner-most header group, stopping at the first error. -
	 * l4_cs_ok[5:3] = The number of header groups with a valid L4 checksum
	 * in the delivered packet, counted from the outer-most header group to
	 * the inner-most header group, stopping at the first error. When this
	 * bit is '1', the cs_ok field has the following definition: -
	 * hdr_cnt[2:0] = The number of header groups that were parsed by the
	 * chip and passed in the delivered packet. - ip_cs_all_ok[3] =This bit
	 * will be '1' if all the parsed header groups with an IP checksum are
	 * valid. - l4_cs_all_ok[4] = This bit will be '1' if all the parsed
	 * header groups with an L4 checksum are valid.
	 */
	#define RX_TPA_START_V2_CMPL_FLAGS2_CS_ALL_OK_MODE		UINT32_C(0x8)
	/* This value indicates what format the metadata field is. */
	#define RX_TPA_START_V2_CMPL_FLAGS2_META_FORMAT_MASK	UINT32_C(0xf0)
	#define RX_TPA_START_V2_CMPL_FLAGS2_META_FORMAT_SFT		4
	/* There is no metadata information. Values are zero. */
		#define RX_TPA_START_V2_CMPL_FLAGS2_META_FORMAT_NONE		(UINT32_C(0x0) << 4)
	/*
	 * The {metadata1, metadata0} fields contain the vtag
	 * information: - vtag[19:0] = {valid, tpid_sel[2:0], pri[2:0],
	 * de, vid[11:0]} The metadata2 field contains the table scope
	 * and action record pointer. - metadata2[25:0] contains the
	 * action record pointer. - metadata2[31:26] contains the table
	 * scope.
	 */
		#define RX_TPA_START_V2_CMPL_FLAGS2_META_FORMAT_ACT_REC_PTR	(UINT32_C(0x1) << 4)
	/*
	 * The {metadata1, metadata0} fields contain the vtag
	 * information:
	 * - vtag[19:0] = {valid, tpid_sel[2:0], pri[2:0], de, vid[11:0]}
	 * The metadata2 field contains the Tunnel ID
	 * value, justified to LSB. i
	 * - VXLAN = VNI[23:0] -> VXLAN Network ID
	 * - Geneve (NGE) = VNI[23:0] a-> Virtual Network Identifier
	 * - NVGRE = TNI[23:0] -> Tenant Network ID
	 * - GRE = KEY[31:0] -> key field with bit mask. zero if K=0
	 * - IPv4 = 0 (not populated)
	 * - IPv6 = Flow Label[19:0]
	 * - PPPoE = sessionID[15:0]
	 * - MPLs = Outer label[19:0]
	 * - UPAR = Selected[31:0] with bit mask
	 */
		#define RX_TPA_START_V2_CMPL_FLAGS2_META_FORMAT_TUNNEL_ID	(UINT32_C(0x2) << 4)
	/*
	 * The {metadata1, metadata0} fields contain the vtag
	 * information:
	 * - vtag[19:0] = {valid, tpid_sel[2:0], pri[2:0],de, vid[11:0]}
	 * The metadata2 field contains the 32b metadata from the prepended
	 * header (chdr_data).
	 */
		#define RX_TPA_START_V2_CMPL_FLAGS2_META_FORMAT_CHDR_DATA	(UINT32_C(0x3) << 4)
	/*
	 * The {metadata1, metadata0} fields contain the vtag
	 * information:
	 * - vtag[19:0] = {valid, tpid_sel[2:0], pri[2:0], de, vid[11:0]}
	 * The metadata2 field contains the outer_l3_offset,
	 * inner_l2_offset, inner_l3_offset, and inner_l4_size.
	 * - metadata2[8:0] contains the outer_l3_offset.
	 * - metadata2[17:9] contains the inner_l2_offset.
	 * - metadata2[26:18] contains the inner_l3_offset.
	 * - metadata2[31:27] contains the inner_l4_size.
	 */
		#define RX_TPA_START_V2_CMPL_FLAGS2_META_FORMAT_HDR_OFFSET	(UINT32_C(0x4) << 4)
		#define RX_TPA_START_V2_CMPL_FLAGS2_META_FORMAT_LAST		RX_TPA_START_V2_CMPL_FLAGS2_META_FORMAT_HDR_OFFSET
	/*
	 * This field indicates the IP type for the inner-most IP header.
	 * A value of '0' indicates IPv4. A value of '1' indicates IPv6.
	 * This value is only valid if itype indicates a packet
	 * with an IP header.
	 */
	#define RX_TPA_START_V2_CMPL_FLAGS2_IP_TYPE			UINT32_C(0x100)
	/*
	 * This indicates that the complete 1's complement checksum was
	 * calculated for the packet in the affregation.
	 */
	#define RX_TPA_START_V2_CMPL_FLAGS2_COMPLETE_CHECKSUM_CALC	UINT32_C(0x200)
	/*
	 * This field indicates the status of IP and L4 CS calculations done
	 * by the chip. The format of this field is indicated by the
	 * cs_all_ok_mode bit.
	 * CS status for TPA packets is always valid. This means that "all_ok"
	 * status will always be set. The ok count status will be set
	 * appropriately for the packet header, such that all existing CS
	 * values are ok.
	 */
	#define RX_TPA_START_V2_CMPL_FLAGS2_CS_OK_MASK		UINT32_C(0xfc00)
	#define RX_TPA_START_V2_CMPL_FLAGS2_CS_OK_SFT		10
	/*
	 * This value is the complete 1's complement checksum calculated from
	 * the start of the outer L3 header to the end of the packet (not
	 * including the ethernet crc). It is valid when the
	 * 'complete_checksum_calc' flag is set. For TPA Start completions,
	 * the complete checksum is calculated for the first packet in the
	 * aggregation only.
	 */
	#define RX_TPA_START_V2_CMPL_FLAGS2_COMPLETE_CHECKSUM_MASK	UINT32_C(0xffff0000)
	#define RX_TPA_START_V2_CMPL_FLAGS2_COMPLETE_CHECKSUM_SFT	16
	/*
	 * This is data from the CFA block as indicated by the meta_format
	 * field.
	 * - meta_format 0 - none - metadata2 = 0 - not valid/not stripped
	 * - meta_format 1 - act_rec_ptr - metadata2 = {table_scope[5:0],
	 *   act_rec_ptr[25:0]}
	 * - meta_format 2 - tunnel_id - metadata2 = tunnel_id[31:0]
	 * - meta_format 3 - chdr_data - metadata2 = updated_chdr_data[31:0]
	 * - meta_format 4 - hdr_offsets - metadata2 = hdr_offsets[31:0]
	 * When vee_cmpl_mode is set in VNIC context, this is the upper 32b
	 * of the host address from the first BD used to place the packet.
	 */
	uint32_t	metadata2;
	uint16_t	errors_v2;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define RX_TPA_START_V2_CMPL_V2				UINT32_C(0x1)
	#define RX_TPA_START_V2_CMPL_ERRORS_MASK			UINT32_C(0xfffe)
	#define RX_TPA_START_V2_CMPL_ERRORS_SFT			1
	/*
	 * This error indicates that there was some sort of problem with
	 * the BDs for the packetThe packet should be treated as
	 * invalid.
	 */
	#define RX_TPA_START_V2_CMPL_ERRORS_BUFFER_ERROR_MASK	UINT32_C(0xe)
	#define RX_TPA_START_V2_CMPL_ERRORS_BUFFER_ERROR_SFT	1
	/* No buffer error */
		#define RX_TPA_START_V2_CMPL_ERRORS_BUFFER_ERROR_NO_BUFFER	(UINT32_C(0x0) << 1)
	/*
	 * Did Not Fit:
	 * Packet did not fit into packet buffer provided. This means
	 * that the TPA Start packet was too big to be placed into the
	 * per-packet maximum number of physical buffers configured for
	 * the VNIC, or that it was too big to be placed into the
	 * per-aggregation maximum number of physical buffers configured
	 * for the VNIC. This error only occurs when the VNIC is
	 * configured for variable size receive buffers.
	 */
		#define RX_TPA_START_V2_CMPL_ERRORS_BUFFER_ERROR_DID_NOT_FIT   (UINT32_C(0x1) << 1)
	/*
	 * Bad Format:
	 * BDs were not formatted correctly.
	 */
		#define RX_TPA_START_V2_CMPL_ERRORS_BUFFER_ERROR_BAD_FORMAT	(UINT32_C(0x3) << 1)
	/*
	 * Flush:
	 * There was a bad_format error on the previous operation
	 */
		#define RX_TPA_START_V2_CMPL_ERRORS_BUFFER_ERROR_FLUSH	(UINT32_C(0x5) << 1)
		#define RX_TPA_START_V2_CMPL_ERRORS_BUFFER_ERROR_LAST	RX_TPA_START_V2_CMPL_ERRORS_BUFFER_ERROR_FLUSH
	/*
	 * This is data from the CFA block as indicated by the meta_format
	 * field.
	 */
	uint16_t	metadata0;
	/* When meta_format != 0, this value is the VLAN VID. */
	#define RX_TPA_START_V2_CMPL_METADATA0_VID_MASK UINT32_C(0xfff)
	#define RX_TPA_START_V2_CMPL_METADATA0_VID_SFT 0
	/* When meta_format != 0, this value is the VLAN DE. */
	#define RX_TPA_START_V2_CMPL_METADATA0_DE	UINT32_C(0x1000)
	/* When meta_format != 0, this value is the VLAN PRI. */
	#define RX_TPA_START_V2_CMPL_METADATA0_PRI_MASK UINT32_C(0xe000)
	#define RX_TPA_START_V2_CMPL_METADATA0_PRI_SFT 13
	/*
	 * This field contains the outer_l3_offset, inner_l2_offset,
	 * inner_l3_offset, and inner_l4_size.
	 *
	 * hdr_offsets[8:0] contains the outer_l3_offset.
	 * hdr_offsets[17:9] contains the inner_l2_offset.
	 * hdr_offsets[26:18] contains the inner_l3_offset.
	 * hdr_offsets[31:27] contains the inner_l4_size.
	 */
	uint32_t	hdr_offsets;
} rx_tpa_start_v2_cmpl_hi_t, *prx_tpa_start_v2_cmpl_hi_t;

/*
 * This TPA completion structure is used on devices where the
 * `hwrm_vnic_qcaps.max_aggs_supported` value is 0.
 */
/* rx_tpa_end_cmpl (size:128b/16B) */

typedef struct rx_tpa_end_cmpl {
	uint16_t	flags_type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define RX_TPA_END_CMPL_TYPE_MASK			UINT32_C(0x3f)
	#define RX_TPA_END_CMPL_TYPE_SFT			0
	/*
	 * RX L2 TPA End Completion:
	 * Completion at the end of a TPA operation.
	 * Length = 32B
	 */
		#define RX_TPA_END_CMPL_TYPE_RX_TPA_END		UINT32_C(0x15)
		#define RX_TPA_END_CMPL_TYPE_LAST			RX_TPA_END_CMPL_TYPE_RX_TPA_END
	#define RX_TPA_END_CMPL_FLAGS_MASK			UINT32_C(0xffc0)
	#define RX_TPA_END_CMPL_FLAGS_SFT			6
	/*
	 * When this bit is '1', it indicates a packet that has an
	 * error of some type. Type of error is indicated in
	 * error_flags.
	 */
	#define RX_TPA_END_CMPL_FLAGS_ERROR			UINT32_C(0x40)
	/* This field indicates how the packet was placed in the buffer. */
	#define RX_TPA_END_CMPL_FLAGS_PLACEMENT_MASK		UINT32_C(0x380)
	#define RX_TPA_END_CMPL_FLAGS_PLACEMENT_SFT		7
	/*
	 * Jumbo:
	 * TPA Packet was placed using jumbo algorithm. This means
	 * that the first buffer will be filled with data before
	 * moving to aggregation buffers. Each aggregation buffer
	 * will be filled before moving to the next aggregation
	 * buffer.
	 */
		#define RX_TPA_END_CMPL_FLAGS_PLACEMENT_JUMBO		(UINT32_C(0x1) << 7)
	/*
	 * Header/Data Separation:
	 * Packet was placed using Header/Data separation algorithm.
	 * The separation location is indicated by the itype field.
	 */
		#define RX_TPA_END_CMPL_FLAGS_PLACEMENT_HDS		(UINT32_C(0x2) << 7)
	/*
	 * IOC/Jumbo:
	 * Packet will be placed using In-Order Completion/Jumbo where
	 * the first packet of the aggregation is placed using Jumbo
	 * Placement. Subsequent packets will be placed such that each
	 * packet starts at the beginning of an aggregation buffer.
	 */
		#define RX_TPA_END_CMPL_FLAGS_PLACEMENT_IOC_JUMBO	(UINT32_C(0x4) << 7)
	/*
	 * GRO/Jumbo:
	 * Packet will be placed using GRO/Jumbo where the first
	 * packet is filled with data. Subsequent packets will be
	 * placed such that any one packet does not span two
	 * aggregation buffers unless it starts at the beginning of
	 * an aggregation buffer.
	 */
		#define RX_TPA_END_CMPL_FLAGS_PLACEMENT_GRO_JUMBO	(UINT32_C(0x5) << 7)
	/*
	 * GRO/Header-Data Separation:
	 * Packet will be placed using GRO/HDS where the header
	 * is in the first packet.
	 * Payload of each packet will be
	 * placed such that any one packet does not span two
	 * aggregation buffers unless it starts at the beginning of
	 * an aggregation buffer.
	 */
		#define RX_TPA_END_CMPL_FLAGS_PLACEMENT_GRO_HDS	(UINT32_C(0x6) << 7)
	/*
	 * IOC/Header-Data Separation:
	 * Packet will be placed using In-Order Completion/HDS where
	 * the header is in the first packet buffer. Payload of each
	 * packet will be placed such that each packet starts at the
	 * beginning of an aggregation buffer.
	 */
		#define RX_TPA_END_CMPL_FLAGS_PLACEMENT_IOC_HDS	(UINT32_C(0x7) << 7)
		#define RX_TPA_END_CMPL_FLAGS_PLACEMENT_LAST		RX_TPA_END_CMPL_FLAGS_PLACEMENT_IOC_HDS
	/* unused is 1 b */
	#define RX_TPA_END_CMPL_FLAGS_UNUSED			UINT32_C(0x400)
	/*
	 * This bit is '1' if metadata has been added to the end of the
	 * packet in host memory. Metadata starts at the first 32B boundary
	 * after the end of the packet for regular and jumbo placement.
	 * It starts at the first 32B boundary after the end of the header
	 * for HDS placement. The length of the metadata is indicated in the
	 * metadata itself.
	 */
	#define RX_TPA_END_CMPL_FLAGS_PKT_METADATA_PRESENT	UINT32_C(0x800)
	/*
	 * This value indicates what the inner packet determined for the
	 * packet was.
	 * - 2 TCP Packet
	 *	Indicates that the packet was IP and TCP. This indicates
	 *	that the ip_cs field is valid and that the tcp_udp_cs
	 *	field is valid and contains the TCP checksum.
	 *	This also indicates that the payload_offset field is valid.
	 */
	#define RX_TPA_END_CMPL_FLAGS_ITYPE_MASK		UINT32_C(0xf000)
	#define RX_TPA_END_CMPL_FLAGS_ITYPE_SFT		12
	/*
	 * This value is zero for TPA End completions.
	 * There is no data in the buffer that corresponds to the opaque
	 * value in this completion.
	 */
	uint16_t	len;
	/*
	 * This is a copy of the opaque field from the RX BD this completion
	 * corresponds to.
	 */
	uint32_t	opaque;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	uint8_t	agg_bufs_v1;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define RX_TPA_END_CMPL_V1	UINT32_C(0x1)
	/*
	 * This value is the number of aggregation buffers that follow this
	 * entry in the completion ring that are a part of this aggregation
	 * packet.
	 * If the value is zero, then the packet is completely contained
	 * in the buffer space provided in the aggregation start completion.
	 */
	#define RX_TPA_END_CMPL_AGG_BUFS_MASK UINT32_C(0x7e)
	#define RX_TPA_END_CMPL_AGG_BUFS_SFT 1
	/* This value is the number of segments in the TPA operation. */
	uint8_t	tpa_segs;
	/*
	 * This value indicates the offset in bytes from the beginning of the packet
	 * where the inner payload starts. This value is valid for TCP, UDP,
	 * FCoE, and RoCE packets.
	 *
	 * A value of zero indicates an offset of 256 bytes.
	 */
	uint8_t	payload_offset;
	uint8_t	agg_id;
	/* unused2 is 1 b */
	#define RX_TPA_END_CMPL_UNUSED2	UINT32_C(0x1)
	/*
	 * This is the aggregation ID that the completion is associated
	 * with. Use this number to correlate the TPA start completion
	 * with the TPA end completion.
	 */
	#define RX_TPA_END_CMPL_AGG_ID_MASK UINT32_C(0xfe)
	#define RX_TPA_END_CMPL_AGG_ID_SFT  1
	/*
	 * For non-GRO packets, this value is the
	 * timestamp delta between earliest and latest timestamp values for
	 * TPA packet. If packets were not time stamped, then delta will be
	 * zero.
	 *
	 * For GRO packets, this field is zero except for the following
	 * sub-fields.
	 * - tsdelta[31]
	 *	Timestamp present indication. When '0', no Timestamp
	 *	option is in the packet. When '1', then a Timestamp
	 *	option is present in the packet.
	 */
	uint32_t	tsdelta;
} rx_tpa_end_cmpl_t, *prx_tpa_end_cmpl_t;

/*
 * Last 16 bytes of rx_tpa_end_cmpl.
 *
 * This TPA completion structure is used on devices where the
 * `hwrm_vnic_qcaps.max_aggs_supported` value is 0.
 */
/* rx_tpa_end_cmpl_hi (size:128b/16B) */

typedef struct rx_tpa_end_cmpl_hi {
	uint32_t	tpa_dup_acks;
	/*
	 * This value is the number of duplicate ACKs that have been
	 * received as part of the TPA operation.
	 */
	#define RX_TPA_END_CMPL_TPA_DUP_ACKS_MASK UINT32_C(0xf)
	#define RX_TPA_END_CMPL_TPA_DUP_ACKS_SFT 0
	/*
	 * This value is the valid when TPA completion is active. It
	 * indicates the length of the longest segment of the TPA operation
	 * for LRO mode and the length of the first segment in GRO mode.
	 *
	 * This value may be used by GRO software to re-construct the original
	 * packet stream from the TPA packet. This is the length of all
	 * but the last segment for GRO. In LRO mode this value may be used
	 * to indicate MSS size to the stack.
	 */
	uint16_t	tpa_seg_len;
	/* unused4 is 16 b */
	uint16_t	unused3;
	uint16_t	errors_v2;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define RX_TPA_END_CMPL_V2				UINT32_C(0x1)
	#define RX_TPA_END_CMPL_ERRORS_MASK			UINT32_C(0xfffe)
	#define RX_TPA_END_CMPL_ERRORS_SFT			1
	/*
	 * This error indicates that there was some sort of problem with
	 * the BDs for the packet that was found after part of the
	 * packet was already placed. The packet should be treated as
	 * invalid.
	 */
	#define RX_TPA_END_CMPL_ERRORS_BUFFER_ERROR_MASK	UINT32_C(0xe)
	#define RX_TPA_END_CMPL_ERRORS_BUFFER_ERROR_SFT	1
	/*
	 * This error occurs when there is a fatal HW problem in
	 * the chip only. It indicates that there were not
	 * BDs on chip but that there was adequate reservation.
	 * provided by the TPA block.
	 */
		#define RX_TPA_END_CMPL_ERRORS_BUFFER_ERROR_NOT_ON_CHIP   (UINT32_C(0x2) << 1)
	/*
	 * This error occurs when TPA block was not configured to
	 * reserve adequate BDs for TPA operations on this RX
	 * ring. All data for the TPA operation was not placed.
	 *
	 * This error can also be generated when the number of
	 * segments is not programmed correctly in TPA and the
	 * 33 total aggregation buffers allowed for the TPA
	 * operation has been exceeded.
	 */
		#define RX_TPA_END_CMPL_ERRORS_BUFFER_ERROR_RSV_ERROR	(UINT32_C(0x4) << 1)
		#define RX_TPA_END_CMPL_ERRORS_BUFFER_ERROR_LAST	RX_TPA_END_CMPL_ERRORS_BUFFER_ERROR_RSV_ERROR
	/* unused5 is 16 b */
	uint16_t	unused_4;
	/*
	 * This is the opaque value that was completed for the TPA start
	 * completion that corresponds to this TPA end completion.
	 */
	uint32_t	start_opaque;
} rx_tpa_end_cmpl_hi_t, *prx_tpa_end_cmpl_hi_t;

/*
 * This TPA completion structure is used on devices where the
 * `hwrm_vnic_qcaps.max_aggs_supported` value is greater than 0.
 */
/* rx_tpa_v2_start_cmpl (size:128b/16B) */

typedef struct rx_tpa_v2_start_cmpl {
	uint16_t	flags_type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define RX_TPA_V2_START_CMPL_TYPE_MASK			UINT32_C(0x3f)
	#define RX_TPA_V2_START_CMPL_TYPE_SFT			0
	/*
	 * RX L2 TPA Start Completion:
	 * Completion at the beginning of a TPA operation.
	 * Length = 32B
	 */
		#define RX_TPA_V2_START_CMPL_TYPE_RX_TPA_START		UINT32_C(0x13)
		#define RX_TPA_V2_START_CMPL_TYPE_LAST			RX_TPA_V2_START_CMPL_TYPE_RX_TPA_START
	#define RX_TPA_V2_START_CMPL_FLAGS_MASK			UINT32_C(0xffc0)
	#define RX_TPA_V2_START_CMPL_FLAGS_SFT			6
	/* This bit will always be '0' for TPA start completions. */
	#define RX_TPA_V2_START_CMPL_FLAGS_ERROR			UINT32_C(0x40)
	/* This field indicates how the packet was placed in the buffer. */
	#define RX_TPA_V2_START_CMPL_FLAGS_PLACEMENT_MASK		UINT32_C(0x380)
	#define RX_TPA_V2_START_CMPL_FLAGS_PLACEMENT_SFT		7
	/*
	 * Jumbo:
	 * TPA Packet was placed using jumbo algorithm. This means
	 * that the first buffer will be filled with data before
	 * moving to aggregation buffers. Each aggregation buffer
	 * will be filled before moving to the next aggregation
	 * buffer.
	 */
		#define RX_TPA_V2_START_CMPL_FLAGS_PLACEMENT_JUMBO		(UINT32_C(0x1) << 7)
	/*
	 * Header/Data Separation:
	 * Packet was placed using Header/Data separation algorithm.
	 * The separation location is indicated by the itype field.
	 */
		#define RX_TPA_V2_START_CMPL_FLAGS_PLACEMENT_HDS		(UINT32_C(0x2) << 7)
	/*
	 * GRO/Jumbo:
	 * Packet will be placed using GRO/Jumbo where the first
	 * packet is filled with data. Subsequent packets will be
	 * placed such that any one packet does not span two
	 * aggregation buffers unless it starts at the beginning of
	 * an aggregation buffer.
	 */
		#define RX_TPA_V2_START_CMPL_FLAGS_PLACEMENT_GRO_JUMBO	(UINT32_C(0x5) << 7)
	/*
	 * GRO/Header-Data Separation:
	 * Packet will be placed using GRO/HDS where the header
	 * is in the first packet.
	 * Payload of each packet will be
	 * placed such that any one packet does not span two
	 * aggregation buffers unless it starts at the beginning of
	 * an aggregation buffer.
	 */
		#define RX_TPA_V2_START_CMPL_FLAGS_PLACEMENT_GRO_HDS	(UINT32_C(0x6) << 7)
		#define RX_TPA_V2_START_CMPL_FLAGS_PLACEMENT_LAST		RX_TPA_V2_START_CMPL_FLAGS_PLACEMENT_GRO_HDS
	/* This bit is '1' if the RSS field in this completion is valid. */
	#define RX_TPA_V2_START_CMPL_FLAGS_RSS_VALID		UINT32_C(0x400)
	/*
	 * For devices that support timestamps, when this bit is cleared the
	 * `inner_l4_size_inner_l3_offset_inner_l2_offset_outer_l3_offset`
	 * field contains the 32b timestamp for
	 * the packet from the MAC. When this bit is set, the
	 * `inner_l4_size_inner_l3_offset_inner_l2_offset_outer_l3_offset`
	 * field contains the outer_l3_offset, inner_l2_offset,
	 * inner_l3_offset, and inner_l4_size.
	 */
	#define RX_TPA_V2_START_CMPL_FLAGS_TIMESTAMP_FLD_FORMAT	UINT32_C(0x800)
	/*
	 * This value indicates what the inner packet determined for the
	 * packet was.
	 */
	#define RX_TPA_V2_START_CMPL_FLAGS_ITYPE_MASK		UINT32_C(0xf000)
	#define RX_TPA_V2_START_CMPL_FLAGS_ITYPE_SFT		12
	/*
	 * TCP Packet:
	 * Indicates that the packet was IP and TCP.
	 */
		#define RX_TPA_V2_START_CMPL_FLAGS_ITYPE_TCP		(UINT32_C(0x2) << 12)
		#define RX_TPA_V2_START_CMPL_FLAGS_ITYPE_LAST		RX_TPA_V2_START_CMPL_FLAGS_ITYPE_TCP
	/*
	 * This value indicates the amount of packet data written to the
	 * buffer the opaque field in this completion corresponds to.
	 */
	uint16_t	len;
	/*
	 * This is a copy of the opaque field from the RX BD this completion
	 * corresponds to.
	 */
	uint32_t	opaque;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	uint8_t	v1;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define RX_TPA_V2_START_CMPL_V1 UINT32_C(0x1)
	#define RX_TPA_V2_START_CMPL_LAST RX_TPA_V2_START_CMPL_V1
	/*
	 * This is the RSS hash type for the packet. The value is packed
	 * {tuple_extrac_op[1:0],rss_profile_id[4:0],tuple_extrac_op[2]}.
	 *
	 * The value of tuple_extrac_op provides the information about
	 * what fields the hash was computed on.
	 * * 0: The RSS hash was computed over source IP address,
	 * destination IP address, source port, and destination port of inner
	 * IP and TCP or UDP headers. Note: For non-tunneled packets,
	 * the packet headers are considered inner packet headers for the RSS
	 * hash computation purpose.
	 * * 1: The RSS hash was computed over source IP address and destination
	 * IP address of inner IP header. Note: For non-tunneled packets,
	 * the packet headers are considered inner packet headers for the RSS
	 * hash computation purpose.
	 * * 2: The RSS hash was computed over source IP address,
	 * destination IP address, source port, and destination port of
	 * IP and TCP or UDP headers of outer tunnel headers.
	 * Note: For non-tunneled packets, this value is not applicable.
	 * * 3: The RSS hash was computed over source IP address and
	 * destination IP address of IP header of outer tunnel headers.
	 * Note: For non-tunneled packets, this value is not applicable.
	 *
	 * Note that 4-tuples values listed above are applicable
	 * for layer 4 protocols supported and enabled for RSS in the hardware,
	 * HWRM firmware, and drivers. For example, if RSS hash is supported and
	 * enabled for TCP traffic only, then the values of tuple_extract_op
	 * corresponding to 4-tuples are only valid for TCP traffic.
	 */
	uint8_t	rss_hash_type;
	/*
	 * This is the aggregation ID that the completion is associated
	 * with. Use this number to correlate the TPA start completion
	 * with the TPA end completion.
	 */
	uint16_t	agg_id;
	/*
	 * This value is the RSS hash value calculated for the packet
	 * based on the mode bits and key value in the VNIC.
	 */
	uint32_t	rss_hash;
} rx_tpa_v2_start_cmpl_t, *prx_tpa_v2_start_cmpl_t;

/*
 * Last 16 bytes of rx_tpa_v2_start_cmpl.
 *
 * This TPA completion structure is used on devices where the
 * `hwrm_vnic_qcaps.max_aggs_supported` value is greater than 0.
 */
/* rx_tpa_v2_start_cmpl_hi (size:128b/16B) */

typedef struct rx_tpa_v2_start_cmpl_hi {
	uint32_t	flags2;
	/*
	 * This indicates that the ip checksum was calculated for the
	 * inner packet and that the sum passed for all segments
	 * included in the aggregation.
	 */
	#define RX_TPA_V2_START_CMPL_FLAGS2_IP_CS_CALC		UINT32_C(0x1)
	/*
	 * This indicates that the TCP, UDP or ICMP checksum was
	 * calculated for the inner packet and that the sum passed
	 * for all segments included in the aggregation.
	 */
	#define RX_TPA_V2_START_CMPL_FLAGS2_L4_CS_CALC		UINT32_C(0x2)
	/*
	 * This indicates that the ip checksum was calculated for the
	 * tunnel header and that the sum passed for all segments
	 * included in the aggregation.
	 */
	#define RX_TPA_V2_START_CMPL_FLAGS2_T_IP_CS_CALC		UINT32_C(0x4)
	/*
	 * This indicates that the UDP checksum was
	 * calculated for the tunnel packet and that the sum passed for
	 * all segments included in the aggregation.
	 */
	#define RX_TPA_V2_START_CMPL_FLAGS2_T_L4_CS_CALC		UINT32_C(0x8)
	/* This value indicates what format the metadata field is. */
	#define RX_TPA_V2_START_CMPL_FLAGS2_META_FORMAT_MASK	UINT32_C(0xf0)
	#define RX_TPA_V2_START_CMPL_FLAGS2_META_FORMAT_SFT		4
	/* No metadata informtaion. Value is zero. */
		#define RX_TPA_V2_START_CMPL_FLAGS2_META_FORMAT_NONE		(UINT32_C(0x0) << 4)
	/*
	 * The metadata field contains the VLAN tag and TPID value.
	 * - metadata[11:0] contains the vlan VID value.
	 * - metadata[12] contains the vlan DE value.
	 * - metadata[15:13] contains the vlan PRI value.
	 * - metadata[31:16] contains the vlan TPID value.
	 */
		#define RX_TPA_V2_START_CMPL_FLAGS2_META_FORMAT_VLAN		(UINT32_C(0x1) << 4)
	/*
	 * If ext_meta_format is equal to 1, the metadata field
	 * contains the lower 16b of the tunnel ID value, justified
	 * to LSB
	 * - VXLAN = VNI[23:0] -> VXLAN Network ID
	 * - Geneve (NGE) = VNI[23:0] a-> Virtual Network Identifier.
	 * - NVGRE = TNI[23:0] -> Tenant Network ID
	 * - GRE = KEY[31:0 -> key fieled with bit mask. zero if K = 0
	 * - IPV4 = 0 (not populated)
	 * - IPV6 = Flow Label[19:0]
	 * - PPPoE = sessionID[15:0]
	 * - MPLs = Outer label[19:0]
	 * - UPAR = Selected[31:0] with bit mask
	 */
		#define RX_TPA_V2_START_CMPL_FLAGS2_META_FORMAT_TUNNEL_ID	(UINT32_C(0x2) << 4)
	/*
	 * if ext_meta_format is equal to 1, metadata field contains
	 * 16b metadata from the prepended header (chdr_data).
	 */
		#define RX_TPA_V2_START_CMPL_FLAGS2_META_FORMAT_CHDR_DATA	(UINT32_C(0x3) << 4)
	/*
	 * If ext_meta_format is equal to 1, the metadata field contains
	 * the outer_l3_offset, inner_l2_offset, inner_l3_offset and
	 * inner_l4_size.
	 * - metadata[8:0] contains the outer_l3_offset.
	 * - metadata[17:9] contains the inner_l2_offset.
	 * - metadata[26:18] contains the inner_l3_offset.
	 * - metadata[31:27] contains the inner_l4_size.
	 */
		#define RX_TPA_V2_START_CMPL_FLAGS2_META_FORMAT_HDR_OFFSET	(UINT32_C(0x4) << 4)
		#define RX_TPA_V2_START_CMPL_FLAGS2_META_FORMAT_LAST		RX_TPA_V2_START_CMPL_FLAGS2_META_FORMAT_HDR_OFFSET
	/*
	 * This field indicates the IP type for the inner-most IP header.
	 * A value of '0' indicates IPv4. A value of '1' indicates IPv6.
	 */
	#define RX_TPA_V2_START_CMPL_FLAGS2_IP_TYPE			UINT32_C(0x100)
	/*
	 * This indicates that the complete 1's complement checksum was
	 * calculated for the packet.
	 */
	#define RX_TPA_V2_START_CMPL_FLAGS2_COMPLETE_CHECKSUM_CALC	UINT32_C(0x200)
	/*
	 * The combination of this value and meta_format indicated what
	 * format the metadata field is.
	 */
	#define RX_TPA_V2_START_CMPL_FLAGS2_EXT_META_FORMAT_MASK	UINT32_C(0xc00)
	#define RX_TPA_V2_START_CMPL_FLAGS2_EXT_META_FORMAT_SFT	10
	/*
	 * This value is the complete 1's complement checksum calculated from
	 * the start of the outer L3 header to the end of the packet (not
	 * including the ethernet crc). It is valid when the
	 * 'complete_checksum_calc' flag is set. For TPA Start completions,
	 * the complete checksum is calculated for the first packet in the
	 * aggregation only.
	 */
	#define RX_TPA_V2_START_CMPL_FLAGS2_COMPLETE_CHECKSUM_MASK	UINT32_C(0xffff0000)
	#define RX_TPA_V2_START_CMPL_FLAGS2_COMPLETE_CHECKSUM_SFT	16
	/*
	 * This is data from the CFA block as indicated by the meta_format
	 * field.
	 */
	uint32_t	metadata;
	/* When {ext_meta_format,meta_format}=1, this value is the VLAN VID. */
	#define RX_TPA_V2_START_CMPL_METADATA_VID_MASK UINT32_C(0xfff)
	#define RX_TPA_V2_START_CMPL_METADATA_VID_SFT  0
	/* When {ext_meta_format,meta_format}=1, this value is the VLAN DE. */
	#define RX_TPA_V2_START_CMPL_METADATA_DE	UINT32_C(0x1000)
	/* When {ext_meta_format,meta_format}=1, this value is the VLAN PRI. */
	#define RX_TPA_V2_START_CMPL_METADATA_PRI_MASK UINT32_C(0xe000)
	#define RX_TPA_V2_START_CMPL_METADATA_PRI_SFT  13
	/* When {ext_meta_format,meta_format}=1, this value is the VLAN TPID. */
	#define RX_TPA_V2_START_CMPL_METADATA_TPID_MASK UINT32_C(0xffff0000)
	#define RX_TPA_V2_START_CMPL_METADATA_TPID_SFT 16
	uint16_t	errors_v2;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define RX_TPA_V2_START_CMPL_V2				UINT32_C(0x1)
	#define RX_TPA_V2_START_CMPL_ERRORS_MASK		UINT32_C(0xfffe)
	#define RX_TPA_V2_START_CMPL_ERRORS_SFT			1
	/*
	 * This error indicates that there was some sort of problem with
	 * the BDs for the packet that was found after part of the
	 * packet was already placed. The packet should be treated as
	 * invalid.
	 */
	#define RX_TPA_V2_START_CMPL_ERRORS_BUFFER_ERROR_MASK	UINT32_C(0xe)
	#define RX_TPA_V2_START_CMPL_ERRORS_BUFFER_ERROR_SFT	1
	/* No buffer error */
		#define RX_TPA_V2_START_CMPL_ERRORS_BUFFER_ERROR_NO_BUFFER	(UINT32_C(0x0) << 1)
	/*
	 * Bad Format:
	 * BDs were not formatted correctly.
	 */
		#define RX_TPA_V2_START_CMPL_ERRORS_BUFFER_ERROR_BAD_FORMAT   (UINT32_C(0x3) << 1)
	/*
	 * Flush:
	 * There was a bad_format error on the previous operation
	 */
		#define RX_TPA_V2_START_CMPL_ERRORS_BUFFER_ERROR_FLUSH	(UINT32_C(0x5) << 1)
		#define RX_TPA_V2_START_CMPL_ERRORS_BUFFER_ERROR_LAST	RX_TPA_V2_START_CMPL_ERRORS_BUFFER_ERROR_FLUSH
	/*
	 * This field identifies the CFA action rule that was used for this
	 * packet.
	 */
	uint16_t	cfa_code;
	/*
	 * For devices that support timestamps this field is overridden
	 * with the timestamp value. When `flags.timestamp_fld_format` is
	 * cleared, this field contains the 32b timestamp for the packet from the
	 * MAC.
	 *
	 * When `flags.timestamp_fld_format` is set, this field contains the
	 * outer_l3_offset, inner_l2_offset, inner_l3_offset, and inner_l4_size
	 * as defined below.
	 */
	uint32_t	inner_l4_size_inner_l3_offset_inner_l2_offset_outer_l3_offset;
	/*
	 * This is the offset from the beginning of the packet in bytes for
	 * the outer L3 header. If there is no outer L3 header, then this
	 * value is zero.
	 */
	#define RX_TPA_V2_START_CMPL_OUTER_L3_OFFSET_MASK UINT32_C(0x1ff)
	#define RX_TPA_V2_START_CMPL_OUTER_L3_OFFSET_SFT 0
	/*
	 * This is the offset from the beginning of the packet in bytes for
	 * the inner most L2 header.
	 */
	#define RX_TPA_V2_START_CMPL_INNER_L2_OFFSET_MASK UINT32_C(0x3fe00)
	#define RX_TPA_V2_START_CMPL_INNER_L2_OFFSET_SFT 9
	/*
	 * This is the offset from the beginning of the packet in bytes for
	 * the inner most L3 header.
	 */
	#define RX_TPA_V2_START_CMPL_INNER_L3_OFFSET_MASK UINT32_C(0x7fc0000)
	#define RX_TPA_V2_START_CMPL_INNER_L3_OFFSET_SFT 18
	/*
	 * This is the size in bytes of the inner most L4 header.
	 * This can be subtracted from the payload_offset to determine
	 * the start of the inner most L4 header.
	 */
	#define RX_TPA_V2_START_CMPL_INNER_L4_SIZE_MASK  UINT32_C(0xf8000000)
	#define RX_TPA_V2_START_CMPL_INNER_L4_SIZE_SFT   27
} rx_tpa_v2_start_cmpl_hi_t, *prx_tpa_v2_start_cmpl_hi_t;

/*
 * This TPA completion structure is used on devices where the
 * `hwrm_vnic_qcaps.max_aggs_supported` value is greater than 0.
 */
/* rx_tpa_v2_end_cmpl (size:128b/16B) */

typedef struct rx_tpa_v2_end_cmpl {
	uint16_t	flags_type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define RX_TPA_V2_END_CMPL_TYPE_MASK			UINT32_C(0x3f)
	#define RX_TPA_V2_END_CMPL_TYPE_SFT			0
	/*
	 * RX L2 TPA End Completion:
	 * Completion at the end of a TPA operation.
	 * Length = 32B
	 */
		#define RX_TPA_V2_END_CMPL_TYPE_RX_TPA_END		UINT32_C(0x15)
		#define RX_TPA_V2_END_CMPL_TYPE_LAST			RX_TPA_V2_END_CMPL_TYPE_RX_TPA_END
	#define RX_TPA_V2_END_CMPL_FLAGS_MASK			UINT32_C(0xffc0)
	#define RX_TPA_V2_END_CMPL_FLAGS_SFT			6
	/*
	 * When this bit is '1', it indicates a packet that has an
	 * error of some type. Type of error is indicated in
	 * error_flags.
	 */
	#define RX_TPA_V2_END_CMPL_FLAGS_ERROR			UINT32_C(0x40)
	/* This field indicates how the packet was placed in the buffer. */
	#define RX_TPA_V2_END_CMPL_FLAGS_PLACEMENT_MASK		UINT32_C(0x380)
	#define RX_TPA_V2_END_CMPL_FLAGS_PLACEMENT_SFT		7
	/*
	 * Jumbo:
	 * TPA Packet was placed using jumbo algorithm. This means
	 * that the first buffer will be filled with data before
	 * moving to aggregation buffers. Each aggregation buffer
	 * will be filled before moving to the next aggregation
	 * buffer.
	 */
		#define RX_TPA_V2_END_CMPL_FLAGS_PLACEMENT_JUMBO		(UINT32_C(0x1) << 7)
	/*
	 * Header/Data Separation:
	 * Packet was placed using Header/Data separation algorithm.
	 * The separation location is indicated by the itype field.
	 */
		#define RX_TPA_V2_END_CMPL_FLAGS_PLACEMENT_HDS		(UINT32_C(0x2) << 7)
	/*
	 * GRO/Jumbo:
	 * Packet will be placed using GRO/Jumbo where the first
	 * packet is filled with data. Subsequent packets will be
	 * placed such that any one packet does not span two
	 * aggregation buffers unless it starts at the beginning of
	 * an aggregation buffer.
	 */
		#define RX_TPA_V2_END_CMPL_FLAGS_PLACEMENT_GRO_JUMBO	(UINT32_C(0x5) << 7)
	/*
	 * GRO/Header-Data Separation:
	 * Packet will be placed using GRO/HDS where the header
	 * is in the first packet.
	 * Payload of each packet will be
	 * placed such that any one packet does not span two
	 * aggregation buffers unless it starts at the beginning of
	 * an aggregation buffer.
	 */
		#define RX_TPA_V2_END_CMPL_FLAGS_PLACEMENT_GRO_HDS	(UINT32_C(0x6) << 7)
	/*
	 * IOC/Header-Data Separation:
	 * Packet will be placed using In-Order Completion/HDS where
	 * the header is in the first packet buffer. Payload of each
	 * packet will be placed such that each packet starts at the
	 * beginning of an aggregation buffer.
	 */
		#define RX_TPA_V2_END_CMPL_FLAGS_PLACEMENT_IOC_HDS	(UINT32_C(0x7) << 7)
		#define RX_TPA_V2_END_CMPL_FLAGS_PLACEMENT_LAST		RX_TPA_V2_END_CMPL_FLAGS_PLACEMENT_IOC_HDS
	/* unused is 1 b */
	#define RX_TPA_V2_END_CMPL_FLAGS_UNUSED			UINT32_C(0x400)
	/*
	 * This bit is '1' if metadata has been added to the end of the
	 * packet in host memory. Metadata starts at the first 32B boundary
	 * after the end of the packet for regular and jumbo placement.
	 * It starts at the first 32B boundary after the end of the header
	 * for HDS placement. The length of the metadata is indicated in the
	 * metadata itself.
	 */
	#define RX_TPA_V2_END_CMPL_FLAGS_PKT_METADATA_PRESENT	UINT32_C(0x800)
	/*
	 * This value indicates what the inner packet determined for the
	 * packet was.
	 * - 2 TCP Packet
	 *	Indicates that the packet was IP and TCP. This indicates
	 *	that the ip_cs field is valid and that the tcp_udp_cs
	 *	field is valid and contains the TCP checksum.
	 *	This also indicates that the payload_offset field is valid.
	 */
	#define RX_TPA_V2_END_CMPL_FLAGS_ITYPE_MASK		UINT32_C(0xf000)
	#define RX_TPA_V2_END_CMPL_FLAGS_ITYPE_SFT		12
	/*
	 * This value is zero for TPA End completions.
	 * There is no data in the buffer that corresponds to the opaque
	 * value in this completion.
	 */
	uint16_t	len;
	/*
	 * This is a copy of the opaque field from the RX BD this completion
	 * corresponds to.
	 */
	uint32_t	opaque;
	uint8_t	v1;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define RX_TPA_V2_END_CMPL_V1	UINT32_C(0x1)
	/* This value is the number of segments in the TPA operation. */
	uint8_t	tpa_segs;
	/*
	 * This is the aggregation ID that the completion is associated
	 * with. Use this number to correlate the TPA start completion
	 * with the TPA end completion.
	 */
	uint16_t	agg_id;
	/*
	 * For non-GRO packets, this value is the
	 * timestamp delta between earliest and latest timestamp values for
	 * TPA packet. If packets were not time stamped, then delta will be
	 * zero.
	 *
	 * For GRO packets, this field is zero except for the following
	 * sub-fields.
	 * - tsdelta[31]
	 *	Timestamp present indication. When '0', no Timestamp
	 *	option is in the packet. When '1', then a Timestamp
	 *	option is present in the packet.
	 */
	uint32_t	tsdelta;
} rx_tpa_v2_end_cmpl_t, *prx_tpa_v2_end_cmpl_t;

/*
 * Last 16 bytes of rx_tpa_v2_end_cmpl.
 *
 * This TPA completion structure is used on devices where the
 * `hwrm_vnic_qcaps.max_aggs_supported` value is greater than 0.
 */
/* rx_tpa_v2_end_cmpl_hi (size:128b/16B) */

typedef struct rx_tpa_v2_end_cmpl_hi {
	/*
	 * This value is the number of duplicate ACKs that have been
	 * received as part of the TPA operation.
	 */
	uint16_t	tpa_dup_acks;
	/*
	 * This value is the number of duplicate ACKs that have been
	 * received as part of the TPA operation.
	 */
	#define RX_TPA_V2_END_CMPL_TPA_DUP_ACKS_MASK UINT32_C(0xf)
	#define RX_TPA_V2_END_CMPL_TPA_DUP_ACKS_SFT 0
	/*
	 * This value indicated the offset in bytes from the beginning of
	 * the packet where the inner payload starts. This value is valid
	 * for TCP, UDP, FCoE and RoCE packets
	 */
	uint8_t	payload_offset;
	/*
	 * The value is the total number of aggregation buffers that were
	 * used in the TPA operation. All TPA aggregation buffer completions
	 * precede the TPA End completion. If the value is zero, then the
	 * aggregation is completely contained in the buffer space provided
	 * in the aggregation start completion.
	 * Note that the field is simply provided as a cross check.
	 */
	uint8_t	tpa_agg_bufs;
	/*
	 * This value is the valid when TPA completion is active. It
	 * indicates the length of the longest segment of the TPA operation
	 * for LRO mode and the length of the first segment in GRO mode.
	 *
	 * This value may be used by GRO software to re-construct the original
	 * packet stream from the TPA packet. This is the length of all
	 * but the last segment for GRO. In LRO mode this value may be used
	 * to indicate MSS size to the stack.
	 */
	uint16_t	tpa_seg_len;
	uint16_t	unused_1;
	uint16_t	errors_v2;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define RX_TPA_V2_END_CMPL_V2				UINT32_C(0x1)
	#define RX_TPA_V2_END_CMPL_ERRORS_MASK			UINT32_C(0xfffe)
	#define RX_TPA_V2_END_CMPL_ERRORS_SFT			1
	/*
	 * This error indicates that there was some sort of problem with
	 * the BDs for the packet that was found after part of the
	 * packet was already placed. The packet should be treated as
	 * invalid.
	 */
	#define RX_TPA_V2_END_CMPL_ERRORS_BUFFER_ERROR_MASK	UINT32_C(0xe)
	#define RX_TPA_V2_END_CMPL_ERRORS_BUFFER_ERROR_SFT	1
	/* No buffer error */
		#define RX_TPA_V2_END_CMPL_ERRORS_BUFFER_ERROR_NO_BUFFER	(UINT32_C(0x0) << 1)
	/*
	 * This error occurs when there is a fatal HW problem in
	 * the chip only. It indicates that there were not
	 * BDs on chip but that there was adequate reservation.
	 * provided by the TPA block.
	 */
		#define RX_TPA_V2_END_CMPL_ERRORS_BUFFER_ERROR_NOT_ON_CHIP   (UINT32_C(0x2) << 1)
	/*
	 * Bad Format:
	 * BDs were not formatted correctly.
	 */
		#define RX_TPA_V2_END_CMPL_ERRORS_BUFFER_ERROR_BAD_FORMAT	(UINT32_C(0x3) << 1)
	/*
	 * This error occurs when TPA block was not configured to
	 * reserve adequate BDs for TPA operations on this RX
	 * ring. All data for the TPA operation was not placed.
	 *
	 * This error can also be generated when the number of
	 * segments is not programmed correctly in TPA and the
	 * 33 total aggregation buffers allowed for the TPA
	 * operation has been exceeded.
	 */
		#define RX_TPA_V2_END_CMPL_ERRORS_BUFFER_ERROR_RSV_ERROR	(UINT32_C(0x4) << 1)
	/*
	 * Flush:
	 * There was a bad_format error on the previous operation
	 */
		#define RX_TPA_V2_END_CMPL_ERRORS_BUFFER_ERROR_FLUSH	(UINT32_C(0x5) << 1)
		#define RX_TPA_V2_END_CMPL_ERRORS_BUFFER_ERROR_LAST	RX_TPA_V2_END_CMPL_ERRORS_BUFFER_ERROR_FLUSH
	uint16_t	unused_2;
	/*
	 * This is the opaque value that was completed for the TPA start
	 * completion that corresponds to this TPA end completion.
	 */
	uint32_t	start_opaque;
} rx_tpa_v2_end_cmpl_hi_t, *prx_tpa_v2_end_cmpl_hi_t;

/*
 * This TPA completion structure is used on devices where the
 * `hwrm_vnic_qcaps.max_aggs_supported` value is greater than 0.
 */
/* rx_tpa_v2_abuf_cmpl (size:128b/16B) */

typedef struct rx_tpa_v2_abuf_cmpl {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define RX_TPA_V2_ABUF_CMPL_TYPE_MASK	UINT32_C(0x3f)
	#define RX_TPA_V2_ABUF_CMPL_TYPE_SFT	0
	/*
	 * RX TPA Aggregation Buffer completion :
	 * Completion of an L2 aggregation buffer in support of
	 * TPA packet completion. Length = 16B
	 */
		#define RX_TPA_V2_ABUF_CMPL_TYPE_RX_TPA_AGG  UINT32_C(0x16)
		#define RX_TPA_V2_ABUF_CMPL_TYPE_LAST	RX_TPA_V2_ABUF_CMPL_TYPE_RX_TPA_AGG
	/*
	 * This is the length of the data for the packet stored in this
	 * aggregation buffer identified by the opaque value. This does not
	 * include the length of any
	 * data placed in other aggregation BDs or in the packet or buffer
	 * BDs. This length does not include any space added due to
	 * hdr_offset register during HDS placement mode.
	 */
	uint16_t	len;
	/*
	 * This is a copy of the opaque field from the RX BD this aggregation
	 * buffer corresponds to.
	 */
	uint32_t	opaque;
	uint16_t	v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define RX_TPA_V2_ABUF_CMPL_V	UINT32_C(0x1)
	/*
	 * This is the aggregation ID that the completion is associated with. Use
	 * this number to correlate the TPA agg completion with the TPA start
	 * completion and the TPA end completion.
	 */
	uint16_t	agg_id;
	uint32_t	unused_1;
} rx_tpa_v2_abuf_cmpl_t, *prx_tpa_v2_abuf_cmpl_t;

/* rx_abuf_cmpl (size:128b/16B) */

typedef struct rx_abuf_cmpl {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define RX_ABUF_CMPL_TYPE_MASK  UINT32_C(0x3f)
	#define RX_ABUF_CMPL_TYPE_SFT   0
	/*
	 * RX Aggregation Buffer completion :
	 * Completion of an L2 aggregation buffer in support of
	 * TPA, HDS, or Jumbo packet completion. Length = 16B
	 */
		#define RX_ABUF_CMPL_TYPE_RX_AGG  UINT32_C(0x12)
		#define RX_ABUF_CMPL_TYPE_LAST   RX_ABUF_CMPL_TYPE_RX_AGG
	/*
	 * This is the length of the data for the packet stored in this
	 * aggregation buffer identified by the opaque value. This does not
	 * include the length of any
	 * data placed in other aggregation BDs or in the packet or buffer
	 * BDs. This length does not include any space added due to
	 * hdr_offset register during HDS placement mode.
	 */
	uint16_t	len;
	/*
	 * This is a copy of the opaque field from the RX BD this aggregation
	 * buffer corresponds to.
	 */
	uint32_t	opaque;
	uint32_t	v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define RX_ABUF_CMPL_V	UINT32_C(0x1)
	/* unused3 is 32 b */
	uint32_t	unused_2;
} rx_abuf_cmpl_t, *prx_abuf_cmpl_t;

/* VEE FLUSH Completion Record (16 bytes) */
/* vee_flush (size:128b/16B) */

typedef struct vee_flush {
	uint32_t	downstream_path_type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define VEE_FLUSH_TYPE_MASK	UINT32_C(0x3f)
	#define VEE_FLUSH_TYPE_SFT		0
	/*
	 * VEE Flush Completion:
	 * This completion is inserted manually by the Primate and processed
	 * by the VEE hardware to ensure that all completions on a VEE
	 * function have been processed by the VEE hardware before FLR
	 * process is completed.
	 */
		#define VEE_FLUSH_TYPE_VEE_FLUSH	UINT32_C(0x1c)
		#define VEE_FLUSH_TYPE_LAST		VEE_FLUSH_TYPE_VEE_FLUSH
	/* downstream_path is 1 b */
	#define VEE_FLUSH_DOWNSTREAM_PATH	UINT32_C(0x40)
	/* This completion is associated with VEE Transmit */
		#define VEE_FLUSH_DOWNSTREAM_PATH_TX	(UINT32_C(0x0) << 6)
	/* This completion is associated with VEE Receive */
		#define VEE_FLUSH_DOWNSTREAM_PATH_RX	(UINT32_C(0x1) << 6)
		#define VEE_FLUSH_DOWNSTREAM_PATH_LAST VEE_FLUSH_DOWNSTREAM_PATH_RX
	/*
	 * This is an opaque value that is passed through the completion
	 * to the VEE handler SW and is used to indicate what VEE VQ or
	 * function has completed FLR processing.
	 */
	uint32_t	opaque;
	uint32_t	v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes will
	 * write 1. The odd passes will write 0.
	 */
	#define VEE_FLUSH_V	UINT32_C(0x1)
	/* unused3 is 32 b */
	uint32_t	unused_3;
} vee_flush_t, *pvee_flush_t;

/* eject_cmpl (size:128b/16B) */

typedef struct eject_cmpl {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define EJECT_CMPL_TYPE_MASK	UINT32_C(0x3f)
	#define EJECT_CMPL_TYPE_SFT	0
	/*
	 * Statistics Ejection Completion:
	 * Completion of statistics data ejection buffer.
	 * Length = 16B
	 */
		#define EJECT_CMPL_TYPE_STAT_EJECT   UINT32_C(0x1a)
		#define EJECT_CMPL_TYPE_LAST	EJECT_CMPL_TYPE_STAT_EJECT
	#define EJECT_CMPL_FLAGS_MASK	UINT32_C(0xffc0)
	#define EJECT_CMPL_FLAGS_SFT	6
	/*
	 * When this bit is '1', it indicates a packet that has an
	 * error of some type. Type of error is indicated in
	 * error_flags.
	 */
	#define EJECT_CMPL_FLAGS_ERROR	UINT32_C(0x40)
	/*
	 * This is the length of the statistics data stored in this
	 * buffer.
	 */
	uint16_t	len;
	/*
	 * This is a copy of the opaque field from the RX BD this ejection
	 * buffer corresponds to.
	 */
	uint32_t	opaque;
	uint16_t	v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define EJECT_CMPL_V				UINT32_C(0x1)
	#define EJECT_CMPL_ERRORS_MASK			UINT32_C(0xfffe)
	#define EJECT_CMPL_ERRORS_SFT			1
	/*
	 * This error indicates that there was some sort of problem with
	 * the BDs for statistics ejection. The statistics ejection should
	 * be treated as invalid
	 */
	#define EJECT_CMPL_ERRORS_BUFFER_ERROR_MASK	UINT32_C(0xe)
	#define EJECT_CMPL_ERRORS_BUFFER_ERROR_SFT	1
	/* No buffer error */
		#define EJECT_CMPL_ERRORS_BUFFER_ERROR_NO_BUFFER	(UINT32_C(0x0) << 1)
	/*
	 * Did Not Fit:
	 * Statistics did not fit into aggregation buffer provided.
	 */
		#define EJECT_CMPL_ERRORS_BUFFER_ERROR_DID_NOT_FIT   (UINT32_C(0x1) << 1)
	/*
	 * Bad Format:
	 * BDs were not formatted correctly.
	 */
		#define EJECT_CMPL_ERRORS_BUFFER_ERROR_BAD_FORMAT	(UINT32_C(0x3) << 1)
	/*
	 * Flush:
	 * There was a bad_format error on the previous operation
	 */
		#define EJECT_CMPL_ERRORS_BUFFER_ERROR_FLUSH	(UINT32_C(0x5) << 1)
		#define EJECT_CMPL_ERRORS_BUFFER_ERROR_LAST	EJECT_CMPL_ERRORS_BUFFER_ERROR_FLUSH
	/* reserved16 is 16 b */
	uint16_t	reserved16;
	/* unused3 is 32 b */
	uint32_t	unused_2;
} eject_cmpl_t, *peject_cmpl_t;

/* hwrm_cmpl (size:128b/16B) */

typedef struct hwrm_cmpl {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define HWRM_CMPL_TYPE_MASK	UINT32_C(0x3f)
	#define HWRM_CMPL_TYPE_SFT	0
	/*
	 * HWRM Command Completion:
	 * Completion of an HWRM command.
	 */
		#define HWRM_CMPL_TYPE_HWRM_DONE  UINT32_C(0x20)
		#define HWRM_CMPL_TYPE_LAST	HWRM_CMPL_TYPE_HWRM_DONE
	/* This is the sequence_id of the HWRM command that has completed. */
	uint16_t	sequence_id;
	/* unused2 is 32 b */
	uint32_t	unused_1;
	uint32_t	v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define HWRM_CMPL_V	UINT32_C(0x1)
	/* unused4 is 32 b */
	uint32_t	unused_3;
} hwrm_cmpl_t, *phwrm_cmpl_t;

/* hwrm_fwd_req_cmpl (size:128b/16B) */

typedef struct hwrm_fwd_req_cmpl {
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	uint16_t	req_len_type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define HWRM_FWD_REQ_CMPL_TYPE_MASK	UINT32_C(0x3f)
	#define HWRM_FWD_REQ_CMPL_TYPE_SFT	0
	/* Forwarded HWRM Request */
		#define HWRM_FWD_REQ_CMPL_TYPE_HWRM_FWD_REQ  UINT32_C(0x22)
		#define HWRM_FWD_REQ_CMPL_TYPE_LAST	HWRM_FWD_REQ_CMPL_TYPE_HWRM_FWD_REQ
	/* Length of forwarded request in bytes. */
	#define HWRM_FWD_REQ_CMPL_REQ_LEN_MASK	UINT32_C(0xffc0)
	#define HWRM_FWD_REQ_CMPL_REQ_LEN_SFT	6
	/*
	 * Source ID of this request.
	 * Typically used in forwarding requests and responses.
	 * 0x0 - 0xFFF8 - Used for function ids
	 * 0xFFF8 - 0xFFFE - Reserved for internal processors
	 * 0xFFFF - HWRM
	 */
	uint16_t	source_id;
	/* unused1 is 32 b */
	uint32_t	unused0;
	/* Address of forwarded request. */
	uint64_t	req_buf_addr_v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define HWRM_FWD_REQ_CMPL_V		UINT32_C(0x1)
	/* Address of forwarded request. */
	#define HWRM_FWD_REQ_CMPL_REQ_BUF_ADDR_MASK UINT32_C(0xfffffffe)
	#define HWRM_FWD_REQ_CMPL_REQ_BUF_ADDR_SFT 1
} hwrm_fwd_req_cmpl_t, *phwrm_fwd_req_cmpl_t;

/* hwrm_fwd_resp_cmpl (size:128b/16B) */

typedef struct hwrm_fwd_resp_cmpl {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define HWRM_FWD_RESP_CMPL_TYPE_MASK	UINT32_C(0x3f)
	#define HWRM_FWD_RESP_CMPL_TYPE_SFT	0
	/* Forwarded HWRM Response */
		#define HWRM_FWD_RESP_CMPL_TYPE_HWRM_FWD_RESP  UINT32_C(0x24)
		#define HWRM_FWD_RESP_CMPL_TYPE_LAST	HWRM_FWD_RESP_CMPL_TYPE_HWRM_FWD_RESP
	/*
	 * Source ID of this response.
	 * Typically used in forwarding requests and responses.
	 * 0x0 - 0xFFF8 - Used for function ids
	 * 0xFFF8 - 0xFFFE - Reserved for internal processors
	 * 0xFFFF - HWRM
	 */
	uint16_t	source_id;
	/* Length of forwarded response in bytes. */
	uint16_t	resp_len;
	/* unused2 is 16 b */
	uint16_t	unused_1;
	/* Address of forwarded request. */
	uint64_t	resp_buf_addr_v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define HWRM_FWD_RESP_CMPL_V		UINT32_C(0x1)
	/* Address of forwarded request. */
	#define HWRM_FWD_RESP_CMPL_RESP_BUF_ADDR_MASK UINT32_C(0xfffffffe)
	#define HWRM_FWD_RESP_CMPL_RESP_BUF_ADDR_SFT 1
} hwrm_fwd_resp_cmpl_t, *phwrm_fwd_resp_cmpl_t;

/* hwrm_async_event_cmpl (size:128b/16B) */

typedef struct hwrm_async_event_cmpl {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_TYPE_MASK		UINT32_C(0x3f)
	#define HWRM_ASYNC_EVENT_CMPL_TYPE_SFT		0
	/* HWRM Asynchronous Event Information */
		#define HWRM_ASYNC_EVENT_CMPL_TYPE_HWRM_ASYNC_EVENT  UINT32_C(0x2e)
		#define HWRM_ASYNC_EVENT_CMPL_TYPE_LAST		HWRM_ASYNC_EVENT_CMPL_TYPE_HWRM_ASYNC_EVENT
	/* Identifiers of events. */
	uint16_t	event_id;
	/* Link status changed */
	#define HWRM_ASYNC_EVENT_CMPL_EVENT_ID_LINK_STATUS_CHANGE	UINT32_C(0x0)
	/* Link MTU changed */
	#define HWRM_ASYNC_EVENT_CMPL_EVENT_ID_LINK_MTU_CHANGE		UINT32_C(0x1)
	/* Link speed changed */
	#define HWRM_ASYNC_EVENT_CMPL_EVENT_ID_LINK_SPEED_CHANGE	UINT32_C(0x2)
	/* DCB Configuration changed */
	#define HWRM_ASYNC_EVENT_CMPL_EVENT_ID_DCB_CONFIG_CHANGE	UINT32_C(0x3)
	/* Port connection not allowed */
	#define HWRM_ASYNC_EVENT_CMPL_EVENT_ID_PORT_CONN_NOT_ALLOWED	UINT32_C(0x4)
	/* Link speed configuration was not allowed */
	#define HWRM_ASYNC_EVENT_CMPL_EVENT_ID_LINK_SPEED_CFG_NOT_ALLOWED UINT32_C(0x5)
	/* Link speed configuration change */
	#define HWRM_ASYNC_EVENT_CMPL_EVENT_ID_LINK_SPEED_CFG_CHANGE	UINT32_C(0x6)
	/* Port PHY configuration change */
	#define HWRM_ASYNC_EVENT_CMPL_EVENT_ID_PORT_PHY_CFG_CHANGE	UINT32_C(0x7)
	/* Reset notification to clients */
	#define HWRM_ASYNC_EVENT_CMPL_EVENT_ID_RESET_NOTIFY		UINT32_C(0x8)
	/* Master function selection event */
	#define HWRM_ASYNC_EVENT_CMPL_EVENT_ID_ERROR_RECOVERY		UINT32_C(0x9)
	/*
	 * An event signifying that a ring has been disabled by
	 * hw due to error.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_EVENT_ID_RING_MONITOR_MSG	UINT32_C(0xa)
	/* Function driver unloaded */
	#define HWRM_ASYNC_EVENT_CMPL_EVENT_ID_FUNC_DRVR_UNLOAD	UINT32_C(0x10)
	/* Function driver loaded */
	#define HWRM_ASYNC_EVENT_CMPL_EVENT_ID_FUNC_DRVR_LOAD		UINT32_C(0x11)
	/* Function FLR related processing has completed */
	#define HWRM_ASYNC_EVENT_CMPL_EVENT_ID_FUNC_FLR_PROC_CMPLT	UINT32_C(0x12)
	/* PF driver unloaded */
	#define HWRM_ASYNC_EVENT_CMPL_EVENT_ID_PF_DRVR_UNLOAD		UINT32_C(0x20)
	/* PF driver loaded */
	#define HWRM_ASYNC_EVENT_CMPL_EVENT_ID_PF_DRVR_LOAD		UINT32_C(0x21)
	/* VF Function Level Reset (FLR) */
	#define HWRM_ASYNC_EVENT_CMPL_EVENT_ID_VF_FLR			UINT32_C(0x30)
	/* VF MAC Address Change */
	#define HWRM_ASYNC_EVENT_CMPL_EVENT_ID_VF_MAC_ADDR_CHANGE	UINT32_C(0x31)
	/* PF-VF communication channel status change. */
	#define HWRM_ASYNC_EVENT_CMPL_EVENT_ID_PF_VF_COMM_STATUS_CHANGE   UINT32_C(0x32)
	/* VF Configuration Change */
	#define HWRM_ASYNC_EVENT_CMPL_EVENT_ID_VF_CFG_CHANGE		UINT32_C(0x33)
	/* LLFC/PFC Configuration Change */
	#define HWRM_ASYNC_EVENT_CMPL_EVENT_ID_LLFC_PFC_CHANGE		UINT32_C(0x34)
	/* Default VNIC Configuration Change */
	#define HWRM_ASYNC_EVENT_CMPL_EVENT_ID_DEFAULT_VNIC_CHANGE	UINT32_C(0x35)
	/* HW flow aged */
	#define HWRM_ASYNC_EVENT_CMPL_EVENT_ID_HW_FLOW_AGED		UINT32_C(0x36)
	/*
	 * A debug notification being posted to the driver. These
	 * notifications are purely for diagnostic purpose and should not be
	 * used for functional purpose. The driver is not supposed to act
	 * on these messages except to log/record it.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_EVENT_ID_DEBUG_NOTIFICATION	UINT32_C(0x37)
	/*
	 * An EEM flow cached memory flush for all flows request event being
	 * posted to the PF driver.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_EVENT_ID_EEM_CACHE_FLUSH_REQ	UINT32_C(0x38)
	/*
	 * An EEM flow cache memory flush completion event being posted to the
	 * firmware by the PF driver. This is indication that host EEM flush
	 * has completed by the PF.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_EVENT_ID_EEM_CACHE_FLUSH_DONE	UINT32_C(0x39)
	/*
	 * A tcp flag action change event being posted to the PF or trusted VF
	 * driver by the firmware. The PF or trusted VF driver should query
	 * the firmware for the new TCP flag action update after receiving
	 * this async event.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_EVENT_ID_TCP_FLAG_ACTION_CHANGE	UINT32_C(0x3a)
	/*
	 * An EEM flow active event being posted to the PF or trusted VF driver
	 * by the firmware. The PF or trusted VF driver should update the
	 * flow's aging timer after receiving this async event.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_EVENT_ID_EEM_FLOW_ACTIVE		UINT32_C(0x3b)
	/*
	 * A eem cfg change event being posted to the trusted VF driver by the
	 * firmware if the parent PF EEM configuration changed.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_EVENT_ID_EEM_CFG_CHANGE		UINT32_C(0x3c)
	/*
	 * Deprecated.
	 * TFLIB unique default VNIC Configuration Change
	 */
	#define HWRM_ASYNC_EVENT_CMPL_EVENT_ID_TFLIB_DEFAULT_VNIC_CHANGE  UINT32_C(0x3d)
	/*
	 * Deprecated.
	 * TFLIB unique link status changed
	 */
	#define HWRM_ASYNC_EVENT_CMPL_EVENT_ID_TFLIB_LINK_STATUS_CHANGE   UINT32_C(0x3e)
	/*
	 * An event signifying completion for HWRM_FW_STATE_QUIESCE
	 * (completion, timeout, or error)
	 */
	#define HWRM_ASYNC_EVENT_CMPL_EVENT_ID_QUIESCE_DONE		UINT32_C(0x3f)
	/*
	 * An event signifying a HWRM command is in progress and its
	 * response will be deferred. This event is used on crypto controllers
	 * only.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_EVENT_ID_DEFERRED_RESPONSE	UINT32_C(0x40)
	/*
	 * An event signifying that a PFC WatchDog configuration
	 * has changed on any port / cos.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_EVENT_ID_PFC_WATCHDOG_CFG_CHANGE	UINT32_C(0x41)
	/*
	 * An echo request from the firmware. An echo response is expected by
	 * the firmware.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_EVENT_ID_ECHO_REQUEST		UINT32_C(0x42)
	/*
	 * An event from firmware indicating who has been selected as the
	 * PHC Master. Only the function who is the Master can discipline
	 * PHC.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_EVENT_ID_PHC_MASTER		UINT32_C(0x43)
	/*
	 * An event from firmware showing the last PPS timestamp that has been
	 * latched.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_EVENT_ID_PPS_TIMESTAMP		UINT32_C(0x44)
	/* Maximum Registrable event id. */
	#define HWRM_ASYNC_EVENT_CMPL_EVENT_ID_MAX_RGTR_EVENT_ID	UINT32_C(0x45)
	/*
	 * A trace log message. This contains firmware trace logs string
	 * embedded in the asynchronous message. This is an experimental
	 * event, not meant for production use at this time.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_EVENT_ID_FW_TRACE_MSG		UINT32_C(0xfe)
	/* HWRM Error */
	#define HWRM_ASYNC_EVENT_CMPL_EVENT_ID_HWRM_ERROR		UINT32_C(0xff)
	#define HWRM_ASYNC_EVENT_CMPL_EVENT_ID_LAST			HWRM_ASYNC_EVENT_CMPL_EVENT_ID_HWRM_ERROR
	/* Event specific data */
	uint32_t	event_data2;
	uint8_t	opaque_v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_V	UINT32_C(0x1)
	/* opaque is 7 b */
	#define HWRM_ASYNC_EVENT_CMPL_OPAQUE_MASK UINT32_C(0xfe)
	#define HWRM_ASYNC_EVENT_CMPL_OPAQUE_SFT 1
	/* 8-lsb timestamp from POR (100-msec resolution) */
	uint8_t	timestamp_lo;
	/* 16-lsb timestamp from POR (100-msec resolution) */
	uint16_t	timestamp_hi;
	/* Event specific data */
	uint32_t	event_data1;
} hwrm_async_event_cmpl_t, *phwrm_async_event_cmpl_t;

#define GET_EVENT_ID(x) \
	(((x) < 0x80) ? \
	((x) == 0x0 ? "LINK_STATUS_CHANGE": \
	((x) == 0x1 ? "LINK_MTU_CHANGE": \
	((x) == 0x2 ? "LINK_SPEED_CHANGE": \
	((x) == 0x3 ? "DCB_CONFIG_CHANGE": \
	((x) == 0x4 ? "PORT_CONN_NOT_ALLOWED": \
	((x) == 0x5 ? "LINK_SPEED_CFG_NOT_ALLOWED": \
	((x) == 0x6 ? "LINK_SPEED_CFG_CHANGE": \
	((x) == 0x7 ? "PORT_PHY_CFG_CHANGE": \
	((x) == 0x8 ? "RESET_NOTIFY": \
	((x) == 0x9 ? "ERROR_RECOVERY": \
	((x) == 0xa ? "RING_MONITOR_MSG": \
	((x) == 0x10 ? "FUNC_DRVR_UNLOAD": \
	((x) == 0x11 ? "FUNC_DRVR_LOAD": \
	((x) == 0x12 ? "FUNC_FLR_PROC_CMPLT": \
	((x) == 0x20 ? "PF_DRVR_UNLOAD": \
	((x) == 0x21 ? "PF_DRVR_LOAD": \
	((x) == 0x30 ? "VF_FLR": \
	((x) == 0x31 ? "VF_MAC_ADDR_CHANGE": \
	((x) == 0x32 ? "PF_VF_COMM_STATUS_CHANGE": \
	((x) == 0x33 ? "VF_CFG_CHANGE": \
	((x) == 0x34 ? "LLFC_PFC_CHANGE": \
	((x) == 0x35 ? "DEFAULT_VNIC_CHANGE": \
	((x) == 0x36 ? "HW_FLOW_AGED": \
	((x) == 0x37 ? "DEBUG_NOTIFICATION": \
	((x) == 0x38 ? "EEM_CACHE_FLUSH_REQ": \
	((x) == 0x39 ? "EEM_CACHE_FLUSH_DONE": \
	((x) == 0x3a ? "TCP_FLAG_ACTION_CHANGE": \
	((x) == 0x3b ? "EEM_FLOW_ACTIVE": \
	((x) == 0x3c ? "EEM_CFG_CHANGE": \
	((x) == 0x3d ? "TFLIB_DEFAULT_VNIC_CHANGE": \
	((x) == 0x3e ? "TFLIB_LINK_STATUS_CHANGE": \
	((x) == 0x3f ? "QUIESCE_DONE": \
	((x) == 0x40 ? "DEFERRED_RESPONSE": \
	((x) == 0x41 ? "PFC_WATCHDOG_CFG_CHANGE": \
	((x) == 0x42 ? "ECHO_REQUEST": \
	((x) == 0x43 ? "PHC_MASTER": \
	((x) == 0x44 ? "PPS_TIMESTAMP": \
	((x) == 0x45 ? "MAX_RGTR_EVENT_ID": \
	"Unknown decode" )))))))))))))))))))))))))))))))))))))) : \
	(((x) < 0x100) ? \
	((x) == 0xfe ? "FW_TRACE_MSG": \
	((x) == 0xff ? "HWRM_ERROR": \
	"Unknown decode" )) : \
	"Unknown decode" ))


/* hwrm_async_event_cmpl_link_status_change (size:128b/16B) */

typedef struct hwrm_async_event_cmpl_link_status_change {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_LINK_STATUS_CHANGE_TYPE_MASK		UINT32_C(0x3f)
	#define HWRM_ASYNC_EVENT_CMPL_LINK_STATUS_CHANGE_TYPE_SFT		0
	/* HWRM Asynchronous Event Information */
		#define HWRM_ASYNC_EVENT_CMPL_LINK_STATUS_CHANGE_TYPE_HWRM_ASYNC_EVENT  UINT32_C(0x2e)
		#define HWRM_ASYNC_EVENT_CMPL_LINK_STATUS_CHANGE_TYPE_LAST		HWRM_ASYNC_EVENT_CMPL_LINK_STATUS_CHANGE_TYPE_HWRM_ASYNC_EVENT
	/* Identifiers of events. */
	uint16_t	event_id;
	/* Link status changed */
	#define HWRM_ASYNC_EVENT_CMPL_LINK_STATUS_CHANGE_EVENT_ID_LINK_STATUS_CHANGE UINT32_C(0x0)
	#define HWRM_ASYNC_EVENT_CMPL_LINK_STATUS_CHANGE_EVENT_ID_LAST		HWRM_ASYNC_EVENT_CMPL_LINK_STATUS_CHANGE_EVENT_ID_LINK_STATUS_CHANGE
	/* Event specific data */
	uint32_t	event_data2;
	uint8_t	opaque_v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_LINK_STATUS_CHANGE_V	UINT32_C(0x1)
	/* opaque is 7 b */
	#define HWRM_ASYNC_EVENT_CMPL_LINK_STATUS_CHANGE_OPAQUE_MASK UINT32_C(0xfe)
	#define HWRM_ASYNC_EVENT_CMPL_LINK_STATUS_CHANGE_OPAQUE_SFT 1
	/* 8-lsb timestamp from POR (100-msec resolution) */
	uint8_t	timestamp_lo;
	/* 16-lsb timestamp from POR (100-msec resolution) */
	uint16_t	timestamp_hi;
	/* Event specific data */
	uint32_t	event_data1;
	/* Indicates link status change */
	#define HWRM_ASYNC_EVENT_CMPL_LINK_STATUS_CHANGE_EVENT_DATA1_LINK_CHANGE	UINT32_C(0x1)
	/*
	 * If this bit set to 0, then it indicates that the link
	 * was up and it went down.
	 */
		#define HWRM_ASYNC_EVENT_CMPL_LINK_STATUS_CHANGE_EVENT_DATA1_LINK_CHANGE_DOWN  UINT32_C(0x0)
	/*
	 * If this bit is set to 1, then it indicates that the link
	 * was down and it went up.
	 */
		#define HWRM_ASYNC_EVENT_CMPL_LINK_STATUS_CHANGE_EVENT_DATA1_LINK_CHANGE_UP	UINT32_C(0x1)
		#define HWRM_ASYNC_EVENT_CMPL_LINK_STATUS_CHANGE_EVENT_DATA1_LINK_CHANGE_LAST HWRM_ASYNC_EVENT_CMPL_LINK_STATUS_CHANGE_EVENT_DATA1_LINK_CHANGE_UP
	/* Indicates the physical port this link status change occur */
	#define HWRM_ASYNC_EVENT_CMPL_LINK_STATUS_CHANGE_EVENT_DATA1_PORT_MASK	UINT32_C(0xe)
	#define HWRM_ASYNC_EVENT_CMPL_LINK_STATUS_CHANGE_EVENT_DATA1_PORT_SFT	1
	/* PORT ID */
	#define HWRM_ASYNC_EVENT_CMPL_LINK_STATUS_CHANGE_EVENT_DATA1_PORT_ID_MASK	UINT32_C(0xffff0)
	#define HWRM_ASYNC_EVENT_CMPL_LINK_STATUS_CHANGE_EVENT_DATA1_PORT_ID_SFT	4
	/* Indicates the physical function this event occurred on. */
	#define HWRM_ASYNC_EVENT_CMPL_LINK_STATUS_CHANGE_EVENT_DATA1_PF_ID_MASK	UINT32_C(0xff00000)
	#define HWRM_ASYNC_EVENT_CMPL_LINK_STATUS_CHANGE_EVENT_DATA1_PF_ID_SFT	20
} hwrm_async_event_cmpl_link_status_change_t, *phwrm_async_event_cmpl_link_status_change_t;

/* hwrm_async_event_cmpl_link_mtu_change (size:128b/16B) */

typedef struct hwrm_async_event_cmpl_link_mtu_change {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_LINK_MTU_CHANGE_TYPE_MASK		UINT32_C(0x3f)
	#define HWRM_ASYNC_EVENT_CMPL_LINK_MTU_CHANGE_TYPE_SFT		0
	/* HWRM Asynchronous Event Information */
		#define HWRM_ASYNC_EVENT_CMPL_LINK_MTU_CHANGE_TYPE_HWRM_ASYNC_EVENT  UINT32_C(0x2e)
		#define HWRM_ASYNC_EVENT_CMPL_LINK_MTU_CHANGE_TYPE_LAST		HWRM_ASYNC_EVENT_CMPL_LINK_MTU_CHANGE_TYPE_HWRM_ASYNC_EVENT
	/* Identifiers of events. */
	uint16_t	event_id;
	/* Link MTU changed */
	#define HWRM_ASYNC_EVENT_CMPL_LINK_MTU_CHANGE_EVENT_ID_LINK_MTU_CHANGE UINT32_C(0x1)
	#define HWRM_ASYNC_EVENT_CMPL_LINK_MTU_CHANGE_EVENT_ID_LAST	HWRM_ASYNC_EVENT_CMPL_LINK_MTU_CHANGE_EVENT_ID_LINK_MTU_CHANGE
	/* Event specific data */
	uint32_t	event_data2;
	uint8_t	opaque_v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_LINK_MTU_CHANGE_V	UINT32_C(0x1)
	/* opaque is 7 b */
	#define HWRM_ASYNC_EVENT_CMPL_LINK_MTU_CHANGE_OPAQUE_MASK UINT32_C(0xfe)
	#define HWRM_ASYNC_EVENT_CMPL_LINK_MTU_CHANGE_OPAQUE_SFT 1
	/* 8-lsb timestamp from POR (100-msec resolution) */
	uint8_t	timestamp_lo;
	/* 16-lsb timestamp from POR (100-msec resolution) */
	uint16_t	timestamp_hi;
	/* Event specific data */
	uint32_t	event_data1;
	/* The new MTU of the link in bytes. */
	#define HWRM_ASYNC_EVENT_CMPL_LINK_MTU_CHANGE_EVENT_DATA1_NEW_MTU_MASK UINT32_C(0xffff)
	#define HWRM_ASYNC_EVENT_CMPL_LINK_MTU_CHANGE_EVENT_DATA1_NEW_MTU_SFT 0
} hwrm_async_event_cmpl_link_mtu_change_t, *phwrm_async_event_cmpl_link_mtu_change_t;

/* hwrm_async_event_cmpl_link_speed_change (size:128b/16B) */

typedef struct hwrm_async_event_cmpl_link_speed_change {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CHANGE_TYPE_MASK		UINT32_C(0x3f)
	#define HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CHANGE_TYPE_SFT		0
	/* HWRM Asynchronous Event Information */
		#define HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CHANGE_TYPE_HWRM_ASYNC_EVENT  UINT32_C(0x2e)
		#define HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CHANGE_TYPE_LAST		HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CHANGE_TYPE_HWRM_ASYNC_EVENT
	/* Identifiers of events. */
	uint16_t	event_id;
	/* Link speed changed */
	#define HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CHANGE_EVENT_ID_LINK_SPEED_CHANGE UINT32_C(0x2)
	#define HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CHANGE_EVENT_ID_LAST		HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CHANGE_EVENT_ID_LINK_SPEED_CHANGE
	/* Event specific data */
	uint32_t	event_data2;
	uint8_t	opaque_v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CHANGE_V	UINT32_C(0x1)
	/* opaque is 7 b */
	#define HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CHANGE_OPAQUE_MASK UINT32_C(0xfe)
	#define HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CHANGE_OPAQUE_SFT 1
	/* 8-lsb timestamp from POR (100-msec resolution) */
	uint8_t	timestamp_lo;
	/* 16-lsb timestamp from POR (100-msec resolution) */
	uint16_t	timestamp_hi;
	/* Event specific data */
	uint32_t	event_data1;
	/*
	 * When this bit is '1', the link was forced to the
	 * force_link_speed value.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CHANGE_EVENT_DATA1_FORCE			UINT32_C(0x1)
	/* The new link speed in 100 Mbps units. */
	#define HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CHANGE_EVENT_DATA1_NEW_LINK_SPEED_100MBPS_MASK UINT32_C(0xfffe)
	#define HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CHANGE_EVENT_DATA1_NEW_LINK_SPEED_100MBPS_SFT  1
	/* 100Mb link speed */
		#define HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CHANGE_EVENT_DATA1_NEW_LINK_SPEED_100MBPS_100MB  (UINT32_C(0x1) << 1)
	/* 1Gb link speed */
		#define HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CHANGE_EVENT_DATA1_NEW_LINK_SPEED_100MBPS_1GB	(UINT32_C(0xa) << 1)
	/* 2Gb link speed */
		#define HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CHANGE_EVENT_DATA1_NEW_LINK_SPEED_100MBPS_2GB	(UINT32_C(0x14) << 1)
	/* 25Gb link speed */
		#define HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CHANGE_EVENT_DATA1_NEW_LINK_SPEED_100MBPS_2_5GB  (UINT32_C(0x19) << 1)
	/* 10Gb link speed */
		#define HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CHANGE_EVENT_DATA1_NEW_LINK_SPEED_100MBPS_10GB   (UINT32_C(0x64) << 1)
	/* 20Mb link speed */
		#define HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CHANGE_EVENT_DATA1_NEW_LINK_SPEED_100MBPS_20GB   (UINT32_C(0xc8) << 1)
	/* 25Gb link speed */
		#define HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CHANGE_EVENT_DATA1_NEW_LINK_SPEED_100MBPS_25GB   (UINT32_C(0xfa) << 1)
	/* 40Gb link speed */
		#define HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CHANGE_EVENT_DATA1_NEW_LINK_SPEED_100MBPS_40GB   (UINT32_C(0x190) << 1)
	/* 50Gb link speed */
		#define HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CHANGE_EVENT_DATA1_NEW_LINK_SPEED_100MBPS_50GB   (UINT32_C(0x1f4) << 1)
	/* 100Gb link speed */
		#define HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CHANGE_EVENT_DATA1_NEW_LINK_SPEED_100MBPS_100GB  (UINT32_C(0x3e8) << 1)
		#define HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CHANGE_EVENT_DATA1_NEW_LINK_SPEED_100MBPS_LAST  HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CHANGE_EVENT_DATA1_NEW_LINK_SPEED_100MBPS_100GB
	/* PORT ID */
	#define HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CHANGE_EVENT_DATA1_PORT_ID_MASK		UINT32_C(0xffff0000)
	#define HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CHANGE_EVENT_DATA1_PORT_ID_SFT		16
} hwrm_async_event_cmpl_link_speed_change_t, *phwrm_async_event_cmpl_link_speed_change_t;

/* hwrm_async_event_cmpl_dcb_config_change (size:128b/16B) */

typedef struct hwrm_async_event_cmpl_dcb_config_change {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_DCB_CONFIG_CHANGE_TYPE_MASK		UINT32_C(0x3f)
	#define HWRM_ASYNC_EVENT_CMPL_DCB_CONFIG_CHANGE_TYPE_SFT		0
	/* HWRM Asynchronous Event Information */
		#define HWRM_ASYNC_EVENT_CMPL_DCB_CONFIG_CHANGE_TYPE_HWRM_ASYNC_EVENT  UINT32_C(0x2e)
		#define HWRM_ASYNC_EVENT_CMPL_DCB_CONFIG_CHANGE_TYPE_LAST		HWRM_ASYNC_EVENT_CMPL_DCB_CONFIG_CHANGE_TYPE_HWRM_ASYNC_EVENT
	/* Identifiers of events. */
	uint16_t	event_id;
	/* DCB Configuration changed */
	#define HWRM_ASYNC_EVENT_CMPL_DCB_CONFIG_CHANGE_EVENT_ID_DCB_CONFIG_CHANGE UINT32_C(0x3)
	#define HWRM_ASYNC_EVENT_CMPL_DCB_CONFIG_CHANGE_EVENT_ID_LAST		HWRM_ASYNC_EVENT_CMPL_DCB_CONFIG_CHANGE_EVENT_ID_DCB_CONFIG_CHANGE
	/* Event specific data */
	uint32_t	event_data2;
	/* ETS configuration change */
	#define HWRM_ASYNC_EVENT_CMPL_DCB_CONFIG_CHANGE_EVENT_DATA2_ETS	UINT32_C(0x1)
	/* PFC configuration change */
	#define HWRM_ASYNC_EVENT_CMPL_DCB_CONFIG_CHANGE_EVENT_DATA2_PFC	UINT32_C(0x2)
	/* APP configuration change */
	#define HWRM_ASYNC_EVENT_CMPL_DCB_CONFIG_CHANGE_EVENT_DATA2_APP	UINT32_C(0x4)
	/* DSCP configuration change */
	#define HWRM_ASYNC_EVENT_CMPL_DCB_CONFIG_CHANGE_EVENT_DATA2_DSCP	UINT32_C(0x8)
	uint8_t	opaque_v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_DCB_CONFIG_CHANGE_V	UINT32_C(0x1)
	/* opaque is 7 b */
	#define HWRM_ASYNC_EVENT_CMPL_DCB_CONFIG_CHANGE_OPAQUE_MASK UINT32_C(0xfe)
	#define HWRM_ASYNC_EVENT_CMPL_DCB_CONFIG_CHANGE_OPAQUE_SFT 1
	/* 8-lsb timestamp from POR (100-msec resolution) */
	uint8_t	timestamp_lo;
	/* 16-lsb timestamp from POR (100-msec resolution) */
	uint16_t	timestamp_hi;
	/* Event specific data */
	uint32_t	event_data1;
	/* PORT ID */
	#define HWRM_ASYNC_EVENT_CMPL_DCB_CONFIG_CHANGE_EVENT_DATA1_PORT_ID_MASK		UINT32_C(0xffff)
	#define HWRM_ASYNC_EVENT_CMPL_DCB_CONFIG_CHANGE_EVENT_DATA1_PORT_ID_SFT		0
	/* Priority recommended for RoCE traffic */
	#define HWRM_ASYNC_EVENT_CMPL_DCB_CONFIG_CHANGE_EVENT_DATA1_RECOMMEND_ROCE_PRIORITY_MASK UINT32_C(0xff0000)
	#define HWRM_ASYNC_EVENT_CMPL_DCB_CONFIG_CHANGE_EVENT_DATA1_RECOMMEND_ROCE_PRIORITY_SFT 16
	/* none is 255 */
		#define HWRM_ASYNC_EVENT_CMPL_DCB_CONFIG_CHANGE_EVENT_DATA1_RECOMMEND_ROCE_PRIORITY_NONE  (UINT32_C(0xff) << 16)
		#define HWRM_ASYNC_EVENT_CMPL_DCB_CONFIG_CHANGE_EVENT_DATA1_RECOMMEND_ROCE_PRIORITY_LAST HWRM_ASYNC_EVENT_CMPL_DCB_CONFIG_CHANGE_EVENT_DATA1_RECOMMEND_ROCE_PRIORITY_NONE
	/* Priority recommended for L2 traffic */
	#define HWRM_ASYNC_EVENT_CMPL_DCB_CONFIG_CHANGE_EVENT_DATA1_RECOMMEND_L2_PRIORITY_MASK  UINT32_C(0xff000000)
	#define HWRM_ASYNC_EVENT_CMPL_DCB_CONFIG_CHANGE_EVENT_DATA1_RECOMMEND_L2_PRIORITY_SFT   24
	/* none is 255 */
		#define HWRM_ASYNC_EVENT_CMPL_DCB_CONFIG_CHANGE_EVENT_DATA1_RECOMMEND_L2_PRIORITY_NONE	(UINT32_C(0xff) << 24)
		#define HWRM_ASYNC_EVENT_CMPL_DCB_CONFIG_CHANGE_EVENT_DATA1_RECOMMEND_L2_PRIORITY_LAST   HWRM_ASYNC_EVENT_CMPL_DCB_CONFIG_CHANGE_EVENT_DATA1_RECOMMEND_L2_PRIORITY_NONE
} hwrm_async_event_cmpl_dcb_config_change_t, *phwrm_async_event_cmpl_dcb_config_change_t;

/* hwrm_async_event_cmpl_port_conn_not_allowed (size:128b/16B) */

typedef struct hwrm_async_event_cmpl_port_conn_not_allowed {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_PORT_CONN_NOT_ALLOWED_TYPE_MASK		UINT32_C(0x3f)
	#define HWRM_ASYNC_EVENT_CMPL_PORT_CONN_NOT_ALLOWED_TYPE_SFT		0
	/* HWRM Asynchronous Event Information */
		#define HWRM_ASYNC_EVENT_CMPL_PORT_CONN_NOT_ALLOWED_TYPE_HWRM_ASYNC_EVENT  UINT32_C(0x2e)
		#define HWRM_ASYNC_EVENT_CMPL_PORT_CONN_NOT_ALLOWED_TYPE_LAST		HWRM_ASYNC_EVENT_CMPL_PORT_CONN_NOT_ALLOWED_TYPE_HWRM_ASYNC_EVENT
	/* Identifiers of events. */
	uint16_t	event_id;
	/* Port connection not allowed */
	#define HWRM_ASYNC_EVENT_CMPL_PORT_CONN_NOT_ALLOWED_EVENT_ID_PORT_CONN_NOT_ALLOWED UINT32_C(0x4)
	#define HWRM_ASYNC_EVENT_CMPL_PORT_CONN_NOT_ALLOWED_EVENT_ID_LAST		HWRM_ASYNC_EVENT_CMPL_PORT_CONN_NOT_ALLOWED_EVENT_ID_PORT_CONN_NOT_ALLOWED
	/* Event specific data */
	uint32_t	event_data2;
	uint8_t	opaque_v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_PORT_CONN_NOT_ALLOWED_V	UINT32_C(0x1)
	/* opaque is 7 b */
	#define HWRM_ASYNC_EVENT_CMPL_PORT_CONN_NOT_ALLOWED_OPAQUE_MASK UINT32_C(0xfe)
	#define HWRM_ASYNC_EVENT_CMPL_PORT_CONN_NOT_ALLOWED_OPAQUE_SFT 1
	/* 8-lsb timestamp from POR (100-msec resolution) */
	uint8_t	timestamp_lo;
	/* 16-lsb timestamp from POR (100-msec resolution) */
	uint16_t	timestamp_hi;
	/* Event specific data */
	uint32_t	event_data1;
	/* PORT ID */
	#define HWRM_ASYNC_EVENT_CMPL_PORT_CONN_NOT_ALLOWED_EVENT_DATA1_PORT_ID_MASK		UINT32_C(0xffff)
	#define HWRM_ASYNC_EVENT_CMPL_PORT_CONN_NOT_ALLOWED_EVENT_DATA1_PORT_ID_SFT		0
	/*
	 * This value indicates the current port level enforcement policy
	 * for the optics module when there is an optical module mismatch
	 * and port is not connected.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_PORT_CONN_NOT_ALLOWED_EVENT_DATA1_ENFORCEMENT_POLICY_MASK	UINT32_C(0xff0000)
	#define HWRM_ASYNC_EVENT_CMPL_PORT_CONN_NOT_ALLOWED_EVENT_DATA1_ENFORCEMENT_POLICY_SFT	16
	/* No enforcement */
		#define HWRM_ASYNC_EVENT_CMPL_PORT_CONN_NOT_ALLOWED_EVENT_DATA1_ENFORCEMENT_POLICY_NONE	(UINT32_C(0x0) << 16)
	/* Disable Transmit side Laser. */
		#define HWRM_ASYNC_EVENT_CMPL_PORT_CONN_NOT_ALLOWED_EVENT_DATA1_ENFORCEMENT_POLICY_DISABLETX   (UINT32_C(0x1) << 16)
	/* Raise a warning message. */
		#define HWRM_ASYNC_EVENT_CMPL_PORT_CONN_NOT_ALLOWED_EVENT_DATA1_ENFORCEMENT_POLICY_WARNINGMSG  (UINT32_C(0x2) << 16)
	/* Power down the module. */
		#define HWRM_ASYNC_EVENT_CMPL_PORT_CONN_NOT_ALLOWED_EVENT_DATA1_ENFORCEMENT_POLICY_PWRDOWN	(UINT32_C(0x3) << 16)
		#define HWRM_ASYNC_EVENT_CMPL_PORT_CONN_NOT_ALLOWED_EVENT_DATA1_ENFORCEMENT_POLICY_LAST	HWRM_ASYNC_EVENT_CMPL_PORT_CONN_NOT_ALLOWED_EVENT_DATA1_ENFORCEMENT_POLICY_PWRDOWN
} hwrm_async_event_cmpl_port_conn_not_allowed_t, *phwrm_async_event_cmpl_port_conn_not_allowed_t;

/* hwrm_async_event_cmpl_link_speed_cfg_not_allowed (size:128b/16B) */

typedef struct hwrm_async_event_cmpl_link_speed_cfg_not_allowed {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CFG_NOT_ALLOWED_TYPE_MASK		UINT32_C(0x3f)
	#define HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CFG_NOT_ALLOWED_TYPE_SFT		0
	/* HWRM Asynchronous Event Information */
		#define HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CFG_NOT_ALLOWED_TYPE_HWRM_ASYNC_EVENT  UINT32_C(0x2e)
		#define HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CFG_NOT_ALLOWED_TYPE_LAST		HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CFG_NOT_ALLOWED_TYPE_HWRM_ASYNC_EVENT
	/* Identifiers of events. */
	uint16_t	event_id;
	/* Link speed configuration was not allowed */
	#define HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CFG_NOT_ALLOWED_EVENT_ID_LINK_SPEED_CFG_NOT_ALLOWED UINT32_C(0x5)
	#define HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CFG_NOT_ALLOWED_EVENT_ID_LAST			HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CFG_NOT_ALLOWED_EVENT_ID_LINK_SPEED_CFG_NOT_ALLOWED
	/* Event specific data */
	uint32_t	event_data2;
	uint8_t	opaque_v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CFG_NOT_ALLOWED_V	UINT32_C(0x1)
	/* opaque is 7 b */
	#define HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CFG_NOT_ALLOWED_OPAQUE_MASK UINT32_C(0xfe)
	#define HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CFG_NOT_ALLOWED_OPAQUE_SFT 1
	/* 8-lsb timestamp from POR (100-msec resolution) */
	uint8_t	timestamp_lo;
	/* 16-lsb timestamp from POR (100-msec resolution) */
	uint16_t	timestamp_hi;
	/* Event specific data */
	uint32_t	event_data1;
	/* PORT ID */
	#define HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CFG_NOT_ALLOWED_EVENT_DATA1_PORT_ID_MASK UINT32_C(0xffff)
	#define HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CFG_NOT_ALLOWED_EVENT_DATA1_PORT_ID_SFT 0
} hwrm_async_event_cmpl_link_speed_cfg_not_allowed_t, *phwrm_async_event_cmpl_link_speed_cfg_not_allowed_t;

/* hwrm_async_event_cmpl_link_speed_cfg_change (size:128b/16B) */

typedef struct hwrm_async_event_cmpl_link_speed_cfg_change {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CFG_CHANGE_TYPE_MASK		UINT32_C(0x3f)
	#define HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CFG_CHANGE_TYPE_SFT		0
	/* HWRM Asynchronous Event Information */
		#define HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CFG_CHANGE_TYPE_HWRM_ASYNC_EVENT  UINT32_C(0x2e)
		#define HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CFG_CHANGE_TYPE_LAST		HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CFG_CHANGE_TYPE_HWRM_ASYNC_EVENT
	/* Identifiers of events. */
	uint16_t	event_id;
	/* Link speed configuration change */
	#define HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CFG_CHANGE_EVENT_ID_LINK_SPEED_CFG_CHANGE UINT32_C(0x6)
	#define HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CFG_CHANGE_EVENT_ID_LAST		HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CFG_CHANGE_EVENT_ID_LINK_SPEED_CFG_CHANGE
	/* Event specific data */
	uint32_t	event_data2;
	uint8_t	opaque_v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CFG_CHANGE_V	UINT32_C(0x1)
	/* opaque is 7 b */
	#define HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CFG_CHANGE_OPAQUE_MASK UINT32_C(0xfe)
	#define HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CFG_CHANGE_OPAQUE_SFT 1
	/* 8-lsb timestamp from POR (100-msec resolution) */
	uint8_t	timestamp_lo;
	/* 16-lsb timestamp from POR (100-msec resolution) */
	uint16_t	timestamp_hi;
	/* Event specific data */
	uint32_t	event_data1;
	/* PORT ID */
	#define HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CFG_CHANGE_EVENT_DATA1_PORT_ID_MASK			UINT32_C(0xffff)
	#define HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CFG_CHANGE_EVENT_DATA1_PORT_ID_SFT			0
	/*
	 * If set to 1, it indicates that the supported link speeds
	 * configuration on the port has changed.
	 * If set to 0, then there is no change in supported link speeds
	 * configuration.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CFG_CHANGE_EVENT_DATA1_SUPPORTED_LINK_SPEEDS_CHANGE	UINT32_C(0x10000)
	/*
	 * If set to 1, it indicates that the link speed configuration
	 * on the port has become illegal or invalid.
	 * If set to 0, then the link speed configuration on the port is
	 * legal or valid.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_LINK_SPEED_CFG_CHANGE_EVENT_DATA1_ILLEGAL_LINK_SPEED_CFG	UINT32_C(0x20000)
} hwrm_async_event_cmpl_link_speed_cfg_change_t, *phwrm_async_event_cmpl_link_speed_cfg_change_t;

/* hwrm_async_event_cmpl_port_phy_cfg_change (size:128b/16B) */

typedef struct hwrm_async_event_cmpl_port_phy_cfg_change {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_PORT_PHY_CFG_CHANGE_TYPE_MASK		UINT32_C(0x3f)
	#define HWRM_ASYNC_EVENT_CMPL_PORT_PHY_CFG_CHANGE_TYPE_SFT		0
	/* HWRM Asynchronous Event Information */
		#define HWRM_ASYNC_EVENT_CMPL_PORT_PHY_CFG_CHANGE_TYPE_HWRM_ASYNC_EVENT  UINT32_C(0x2e)
		#define HWRM_ASYNC_EVENT_CMPL_PORT_PHY_CFG_CHANGE_TYPE_LAST		HWRM_ASYNC_EVENT_CMPL_PORT_PHY_CFG_CHANGE_TYPE_HWRM_ASYNC_EVENT
	/* Identifiers of events. */
	uint16_t	event_id;
	/* Port PHY configuration change */
	#define HWRM_ASYNC_EVENT_CMPL_PORT_PHY_CFG_CHANGE_EVENT_ID_PORT_PHY_CFG_CHANGE UINT32_C(0x7)
	#define HWRM_ASYNC_EVENT_CMPL_PORT_PHY_CFG_CHANGE_EVENT_ID_LAST		HWRM_ASYNC_EVENT_CMPL_PORT_PHY_CFG_CHANGE_EVENT_ID_PORT_PHY_CFG_CHANGE
	/* Event specific data */
	uint32_t	event_data2;
	uint8_t	opaque_v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_PORT_PHY_CFG_CHANGE_V	UINT32_C(0x1)
	/* opaque is 7 b */
	#define HWRM_ASYNC_EVENT_CMPL_PORT_PHY_CFG_CHANGE_OPAQUE_MASK UINT32_C(0xfe)
	#define HWRM_ASYNC_EVENT_CMPL_PORT_PHY_CFG_CHANGE_OPAQUE_SFT 1
	/* 8-lsb timestamp from POR (100-msec resolution) */
	uint8_t	timestamp_lo;
	/* 16-lsb timestamp from POR (100-msec resolution) */
	uint16_t	timestamp_hi;
	/* Event specific data */
	uint32_t	event_data1;
	/* PORT ID */
	#define HWRM_ASYNC_EVENT_CMPL_PORT_PHY_CFG_CHANGE_EVENT_DATA1_PORT_ID_MASK	UINT32_C(0xffff)
	#define HWRM_ASYNC_EVENT_CMPL_PORT_PHY_CFG_CHANGE_EVENT_DATA1_PORT_ID_SFT	0
	/*
	 * If set to 1, it indicates that the FEC
	 * configuration on the port has changed.
	 * If set to 0, then there is no change in FEC configuration.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_PORT_PHY_CFG_CHANGE_EVENT_DATA1_FEC_CFG_CHANGE	UINT32_C(0x10000)
	/*
	 * If set to 1, it indicates that the EEE configuration
	 * on the port has changed.
	 * If set to 0, then there is no change in EEE configuration
	 * on the port.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_PORT_PHY_CFG_CHANGE_EVENT_DATA1_EEE_CFG_CHANGE	UINT32_C(0x20000)
	/*
	 * If set to 1, it indicates that the pause configuration
	 * on the PHY has changed.
	 * If set to 0, then there is no change in the pause
	 * configuration on the PHY.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_PORT_PHY_CFG_CHANGE_EVENT_DATA1_PAUSE_CFG_CHANGE	UINT32_C(0x40000)
} hwrm_async_event_cmpl_port_phy_cfg_change_t, *phwrm_async_event_cmpl_port_phy_cfg_change_t;

/* hwrm_async_event_cmpl_reset_notify (size:128b/16B) */

typedef struct hwrm_async_event_cmpl_reset_notify {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_RESET_NOTIFY_TYPE_MASK		UINT32_C(0x3f)
	#define HWRM_ASYNC_EVENT_CMPL_RESET_NOTIFY_TYPE_SFT		0
	/* HWRM Asynchronous Event Information */
		#define HWRM_ASYNC_EVENT_CMPL_RESET_NOTIFY_TYPE_HWRM_ASYNC_EVENT  UINT32_C(0x2e)
		#define HWRM_ASYNC_EVENT_CMPL_RESET_NOTIFY_TYPE_LAST		HWRM_ASYNC_EVENT_CMPL_RESET_NOTIFY_TYPE_HWRM_ASYNC_EVENT
	/* Identifiers of events. */
	uint16_t	event_id;
	/* Notify clients of imminent reset. */
	#define HWRM_ASYNC_EVENT_CMPL_RESET_NOTIFY_EVENT_ID_RESET_NOTIFY UINT32_C(0x8)
	#define HWRM_ASYNC_EVENT_CMPL_RESET_NOTIFY_EVENT_ID_LAST	HWRM_ASYNC_EVENT_CMPL_RESET_NOTIFY_EVENT_ID_RESET_NOTIFY
	/* Event specific data. The data is for internal debug use only. */
	uint32_t	event_data2;
	/*
	 * These bits indicate the status as being reported by the firmware.
	 * This value is exactly the same as status code in fw_status register.
	 * If the status code is equal to 0x8000, then the reset is initiated
	 * by the Host using the FW_RESET command when the FW is in a healthy
	 * state. If the status code is not equal to 0x8000, then the reset is
	 * initiated by the FW to recover from the error or FATAL state.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_RESET_NOTIFY_EVENT_DATA2_FW_STATUS_CODE_MASK UINT32_C(0xffff)
	#define HWRM_ASYNC_EVENT_CMPL_RESET_NOTIFY_EVENT_DATA2_FW_STATUS_CODE_SFT 0
	uint8_t	opaque_v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_RESET_NOTIFY_V	UINT32_C(0x1)
	/* opaque is 7 b */
	#define HWRM_ASYNC_EVENT_CMPL_RESET_NOTIFY_OPAQUE_MASK UINT32_C(0xfe)
	#define HWRM_ASYNC_EVENT_CMPL_RESET_NOTIFY_OPAQUE_SFT 1
	/*
	 * 8-lsb timestamp (100-msec resolution)
	 * The Minimum time required for the Firmware readiness after sending this
	 * notification to the driver instances.
	 */
	uint8_t	timestamp_lo;
	/*
	 * 16-lsb timestamp (100-msec resolution)
	 * The Maximum Firmware Reset bail out value in the order of 100
	 * milli seconds. The driver instances will use this value to re-initiate the
	 * registration process again if the core firmware didn’t set the ready
	 * state bit.
	 */
	uint16_t	timestamp_hi;
	/* Event specific data */
	uint32_t	event_data1;
	/* Indicates driver action requested */
	#define HWRM_ASYNC_EVENT_CMPL_RESET_NOTIFY_EVENT_DATA1_DRIVER_ACTION_MASK		UINT32_C(0xff)
	#define HWRM_ASYNC_EVENT_CMPL_RESET_NOTIFY_EVENT_DATA1_DRIVER_ACTION_SFT		0
	/*
	 * If set to 1, it indicates that the l2 client should
	 * stop sending in band traffic to Nitro.
	 * if set to 0, there is no change in L2 client behavior.
	 */
		#define HWRM_ASYNC_EVENT_CMPL_RESET_NOTIFY_EVENT_DATA1_DRIVER_ACTION_DRIVER_STOP_TX_QUEUE	UINT32_C(0x1)
	/*
	 * If set to 1, it indicates that the L2 client should
	 * bring down the interface.
	 * If set to 0, then there is no change in L2 client behavior.
	 */
		#define HWRM_ASYNC_EVENT_CMPL_RESET_NOTIFY_EVENT_DATA1_DRIVER_ACTION_DRIVER_IFDOWN	UINT32_C(0x2)
		#define HWRM_ASYNC_EVENT_CMPL_RESET_NOTIFY_EVENT_DATA1_DRIVER_ACTION_LAST		HWRM_ASYNC_EVENT_CMPL_RESET_NOTIFY_EVENT_DATA1_DRIVER_ACTION_DRIVER_IFDOWN
	/* Indicates reason for reset. */
	#define HWRM_ASYNC_EVENT_CMPL_RESET_NOTIFY_EVENT_DATA1_REASON_CODE_MASK			UINT32_C(0xff00)
	#define HWRM_ASYNC_EVENT_CMPL_RESET_NOTIFY_EVENT_DATA1_REASON_CODE_SFT			8
	/* A management client has requested reset. */
		#define HWRM_ASYNC_EVENT_CMPL_RESET_NOTIFY_EVENT_DATA1_REASON_CODE_MANAGEMENT_RESET_REQUEST  (UINT32_C(0x1) << 8)
	/* A fatal firmware exception has occurred. */
		#define HWRM_ASYNC_EVENT_CMPL_RESET_NOTIFY_EVENT_DATA1_REASON_CODE_FW_EXCEPTION_FATAL	(UINT32_C(0x2) << 8)
	/* A non-fatal firmware exception has occurred. */
		#define HWRM_ASYNC_EVENT_CMPL_RESET_NOTIFY_EVENT_DATA1_REASON_CODE_FW_EXCEPTION_NON_FATAL	(UINT32_C(0x3) << 8)
	/* Fast reset */
		#define HWRM_ASYNC_EVENT_CMPL_RESET_NOTIFY_EVENT_DATA1_REASON_CODE_FAST_RESET		(UINT32_C(0x4) << 8)
		#define HWRM_ASYNC_EVENT_CMPL_RESET_NOTIFY_EVENT_DATA1_REASON_CODE_LAST			HWRM_ASYNC_EVENT_CMPL_RESET_NOTIFY_EVENT_DATA1_REASON_CODE_FAST_RESET
	/*
	 * Minimum time before driver should attempt access - units 100ms ticks.
	 * Range 0-65535
	 */
	#define HWRM_ASYNC_EVENT_CMPL_RESET_NOTIFY_EVENT_DATA1_DELAY_IN_100MS_TICKS_MASK	UINT32_C(0xffff0000)
	#define HWRM_ASYNC_EVENT_CMPL_RESET_NOTIFY_EVENT_DATA1_DELAY_IN_100MS_TICKS_SFT		16
} hwrm_async_event_cmpl_reset_notify_t, *phwrm_async_event_cmpl_reset_notify_t;

/* hwrm_async_event_cmpl_error_recovery (size:128b/16B) */

typedef struct hwrm_async_event_cmpl_error_recovery {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_RECOVERY_TYPE_MASK		UINT32_C(0x3f)
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_RECOVERY_TYPE_SFT		0
	/* HWRM Asynchronous Event Information */
		#define HWRM_ASYNC_EVENT_CMPL_ERROR_RECOVERY_TYPE_HWRM_ASYNC_EVENT  UINT32_C(0x2e)
		#define HWRM_ASYNC_EVENT_CMPL_ERROR_RECOVERY_TYPE_LAST		HWRM_ASYNC_EVENT_CMPL_ERROR_RECOVERY_TYPE_HWRM_ASYNC_EVENT
	/* Identifiers of events. */
	uint16_t	event_id;
	/*
	 * This async notification message can be used for selecting or
	 * deselecting master function for error recovery,
	 * and to communicate to all the functions whether error recovery
	 * was enabled/disabled.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_RECOVERY_EVENT_ID_ERROR_RECOVERY UINT32_C(0x9)
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_RECOVERY_EVENT_ID_LAST	HWRM_ASYNC_EVENT_CMPL_ERROR_RECOVERY_EVENT_ID_ERROR_RECOVERY
	/* Event specific data */
	uint32_t	event_data2;
	uint8_t	opaque_v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_RECOVERY_V	UINT32_C(0x1)
	/* opaque is 7 b */
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_RECOVERY_OPAQUE_MASK UINT32_C(0xfe)
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_RECOVERY_OPAQUE_SFT 1
	/* 8-lsb timestamp (100-msec resolution) */
	uint8_t	timestamp_lo;
	/* 16-lsb timestamp (100-msec resolution) */
	uint16_t	timestamp_hi;
	/* Event specific data */
	uint32_t	event_data1;
	/* Indicates driver action requested */
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_RECOVERY_EVENT_DATA1_FLAGS_MASK		UINT32_C(0xff)
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_RECOVERY_EVENT_DATA1_FLAGS_SFT		0
	/*
	 * If set to 1, this function is selected as Master function.
	 * This function has responsibility to do 'chip reset' when it
	 * detects a fatal error. If set to 0, master function functionality
	 * is disabled on this function.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_RECOVERY_EVENT_DATA1_FLAGS_MASTER_FUNC	UINT32_C(0x1)
	/*
	 * If set to 1, error recovery is enabled.
	 * If set to 0, error recovery is disabled.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_ERROR_RECOVERY_EVENT_DATA1_FLAGS_RECOVERY_ENABLED	UINT32_C(0x2)
} hwrm_async_event_cmpl_error_recovery_t, *phwrm_async_event_cmpl_error_recovery_t;

/* hwrm_async_event_cmpl_ring_monitor_msg (size:128b/16B) */

typedef struct hwrm_async_event_cmpl_ring_monitor_msg {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_RING_MONITOR_MSG_TYPE_MASK		UINT32_C(0x3f)
	#define HWRM_ASYNC_EVENT_CMPL_RING_MONITOR_MSG_TYPE_SFT		0
	/* HWRM Asynchronous Event Information */
		#define HWRM_ASYNC_EVENT_CMPL_RING_MONITOR_MSG_TYPE_HWRM_ASYNC_EVENT  UINT32_C(0x2e)
		#define HWRM_ASYNC_EVENT_CMPL_RING_MONITOR_MSG_TYPE_LAST		HWRM_ASYNC_EVENT_CMPL_RING_MONITOR_MSG_TYPE_HWRM_ASYNC_EVENT
	/* Identifiers of events. */
	uint16_t	event_id;
	/* Ring Monitor Message. */
	#define HWRM_ASYNC_EVENT_CMPL_RING_MONITOR_MSG_EVENT_ID_RING_MONITOR_MSG UINT32_C(0xa)
	#define HWRM_ASYNC_EVENT_CMPL_RING_MONITOR_MSG_EVENT_ID_LAST		HWRM_ASYNC_EVENT_CMPL_RING_MONITOR_MSG_EVENT_ID_RING_MONITOR_MSG
	/* Event specific data */
	uint32_t	event_data2;
	/* Type of Ring disabled. */
	#define HWRM_ASYNC_EVENT_CMPL_RING_MONITOR_MSG_EVENT_DATA2_DISABLE_RING_TYPE_MASK UINT32_C(0xff)
	#define HWRM_ASYNC_EVENT_CMPL_RING_MONITOR_MSG_EVENT_DATA2_DISABLE_RING_TYPE_SFT 0
	/* tx ring disabled. */
		#define HWRM_ASYNC_EVENT_CMPL_RING_MONITOR_MSG_EVENT_DATA2_DISABLE_RING_TYPE_TX	UINT32_C(0x0)
	/* rx ring disabled. */
		#define HWRM_ASYNC_EVENT_CMPL_RING_MONITOR_MSG_EVENT_DATA2_DISABLE_RING_TYPE_RX	UINT32_C(0x1)
	/* cmpl ring disabled. */
		#define HWRM_ASYNC_EVENT_CMPL_RING_MONITOR_MSG_EVENT_DATA2_DISABLE_RING_TYPE_CMPL  UINT32_C(0x2)
		#define HWRM_ASYNC_EVENT_CMPL_RING_MONITOR_MSG_EVENT_DATA2_DISABLE_RING_TYPE_LAST HWRM_ASYNC_EVENT_CMPL_RING_MONITOR_MSG_EVENT_DATA2_DISABLE_RING_TYPE_CMPL
	uint8_t	opaque_v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_RING_MONITOR_MSG_V	UINT32_C(0x1)
	/* opaque is 7 b */
	#define HWRM_ASYNC_EVENT_CMPL_RING_MONITOR_MSG_OPAQUE_MASK UINT32_C(0xfe)
	#define HWRM_ASYNC_EVENT_CMPL_RING_MONITOR_MSG_OPAQUE_SFT 1
	/* 8-lsb timestamp from POR (100-msec resolution) */
	uint8_t	timestamp_lo;
	/* 16-lsb timestamp from POR (100-msec resolution) */
	uint16_t	timestamp_hi;
	/*
	 * Event specific data. If ring_type_disabled indicates a tx,rx or cmpl
	 * then this field will indicate the ring id.
	 */
	uint32_t	event_data1;
} hwrm_async_event_cmpl_ring_monitor_msg_t, *phwrm_async_event_cmpl_ring_monitor_msg_t;

/* hwrm_async_event_cmpl_func_drvr_unload (size:128b/16B) */

typedef struct hwrm_async_event_cmpl_func_drvr_unload {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_FUNC_DRVR_UNLOAD_TYPE_MASK		UINT32_C(0x3f)
	#define HWRM_ASYNC_EVENT_CMPL_FUNC_DRVR_UNLOAD_TYPE_SFT		0
	/* HWRM Asynchronous Event Information */
		#define HWRM_ASYNC_EVENT_CMPL_FUNC_DRVR_UNLOAD_TYPE_HWRM_ASYNC_EVENT  UINT32_C(0x2e)
		#define HWRM_ASYNC_EVENT_CMPL_FUNC_DRVR_UNLOAD_TYPE_LAST		HWRM_ASYNC_EVENT_CMPL_FUNC_DRVR_UNLOAD_TYPE_HWRM_ASYNC_EVENT
	/* Identifiers of events. */
	uint16_t	event_id;
	/* Function driver unloaded */
	#define HWRM_ASYNC_EVENT_CMPL_FUNC_DRVR_UNLOAD_EVENT_ID_FUNC_DRVR_UNLOAD UINT32_C(0x10)
	#define HWRM_ASYNC_EVENT_CMPL_FUNC_DRVR_UNLOAD_EVENT_ID_LAST		HWRM_ASYNC_EVENT_CMPL_FUNC_DRVR_UNLOAD_EVENT_ID_FUNC_DRVR_UNLOAD
	/* Event specific data */
	uint32_t	event_data2;
	uint8_t	opaque_v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_FUNC_DRVR_UNLOAD_V	UINT32_C(0x1)
	/* opaque is 7 b */
	#define HWRM_ASYNC_EVENT_CMPL_FUNC_DRVR_UNLOAD_OPAQUE_MASK UINT32_C(0xfe)
	#define HWRM_ASYNC_EVENT_CMPL_FUNC_DRVR_UNLOAD_OPAQUE_SFT 1
	/* 8-lsb timestamp from POR (100-msec resolution) */
	uint8_t	timestamp_lo;
	/* 16-lsb timestamp from POR (100-msec resolution) */
	uint16_t	timestamp_hi;
	/* Event specific data */
	uint32_t	event_data1;
	/* Function ID */
	#define HWRM_ASYNC_EVENT_CMPL_FUNC_DRVR_UNLOAD_EVENT_DATA1_FUNC_ID_MASK UINT32_C(0xffff)
	#define HWRM_ASYNC_EVENT_CMPL_FUNC_DRVR_UNLOAD_EVENT_DATA1_FUNC_ID_SFT 0
} hwrm_async_event_cmpl_func_drvr_unload_t, *phwrm_async_event_cmpl_func_drvr_unload_t;

/* hwrm_async_event_cmpl_func_drvr_load (size:128b/16B) */

typedef struct hwrm_async_event_cmpl_func_drvr_load {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_FUNC_DRVR_LOAD_TYPE_MASK		UINT32_C(0x3f)
	#define HWRM_ASYNC_EVENT_CMPL_FUNC_DRVR_LOAD_TYPE_SFT		0
	/* HWRM Asynchronous Event Information */
		#define HWRM_ASYNC_EVENT_CMPL_FUNC_DRVR_LOAD_TYPE_HWRM_ASYNC_EVENT  UINT32_C(0x2e)
		#define HWRM_ASYNC_EVENT_CMPL_FUNC_DRVR_LOAD_TYPE_LAST		HWRM_ASYNC_EVENT_CMPL_FUNC_DRVR_LOAD_TYPE_HWRM_ASYNC_EVENT
	/* Identifiers of events. */
	uint16_t	event_id;
	/* Function driver loaded */
	#define HWRM_ASYNC_EVENT_CMPL_FUNC_DRVR_LOAD_EVENT_ID_FUNC_DRVR_LOAD UINT32_C(0x11)
	#define HWRM_ASYNC_EVENT_CMPL_FUNC_DRVR_LOAD_EVENT_ID_LAST	HWRM_ASYNC_EVENT_CMPL_FUNC_DRVR_LOAD_EVENT_ID_FUNC_DRVR_LOAD
	/* Event specific data */
	uint32_t	event_data2;
	uint8_t	opaque_v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_FUNC_DRVR_LOAD_V	UINT32_C(0x1)
	/* opaque is 7 b */
	#define HWRM_ASYNC_EVENT_CMPL_FUNC_DRVR_LOAD_OPAQUE_MASK UINT32_C(0xfe)
	#define HWRM_ASYNC_EVENT_CMPL_FUNC_DRVR_LOAD_OPAQUE_SFT 1
	/* 8-lsb timestamp from POR (100-msec resolution) */
	uint8_t	timestamp_lo;
	/* 16-lsb timestamp from POR (100-msec resolution) */
	uint16_t	timestamp_hi;
	/* Event specific data */
	uint32_t	event_data1;
	/* Function ID */
	#define HWRM_ASYNC_EVENT_CMPL_FUNC_DRVR_LOAD_EVENT_DATA1_FUNC_ID_MASK UINT32_C(0xffff)
	#define HWRM_ASYNC_EVENT_CMPL_FUNC_DRVR_LOAD_EVENT_DATA1_FUNC_ID_SFT 0
} hwrm_async_event_cmpl_func_drvr_load_t, *phwrm_async_event_cmpl_func_drvr_load_t;

/* hwrm_async_event_cmpl_func_flr_proc_cmplt (size:128b/16B) */

typedef struct hwrm_async_event_cmpl_func_flr_proc_cmplt {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_FUNC_FLR_PROC_CMPLT_TYPE_MASK		UINT32_C(0x3f)
	#define HWRM_ASYNC_EVENT_CMPL_FUNC_FLR_PROC_CMPLT_TYPE_SFT		0
	/* HWRM Asynchronous Event Information */
		#define HWRM_ASYNC_EVENT_CMPL_FUNC_FLR_PROC_CMPLT_TYPE_HWRM_ASYNC_EVENT  UINT32_C(0x2e)
		#define HWRM_ASYNC_EVENT_CMPL_FUNC_FLR_PROC_CMPLT_TYPE_LAST		HWRM_ASYNC_EVENT_CMPL_FUNC_FLR_PROC_CMPLT_TYPE_HWRM_ASYNC_EVENT
	/* Identifiers of events. */
	uint16_t	event_id;
	/* Function FLR related processing has completed */
	#define HWRM_ASYNC_EVENT_CMPL_FUNC_FLR_PROC_CMPLT_EVENT_ID_FUNC_FLR_PROC_CMPLT UINT32_C(0x12)
	#define HWRM_ASYNC_EVENT_CMPL_FUNC_FLR_PROC_CMPLT_EVENT_ID_LAST		HWRM_ASYNC_EVENT_CMPL_FUNC_FLR_PROC_CMPLT_EVENT_ID_FUNC_FLR_PROC_CMPLT
	/* Event specific data */
	uint32_t	event_data2;
	uint8_t	opaque_v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_FUNC_FLR_PROC_CMPLT_V	UINT32_C(0x1)
	/* opaque is 7 b */
	#define HWRM_ASYNC_EVENT_CMPL_FUNC_FLR_PROC_CMPLT_OPAQUE_MASK UINT32_C(0xfe)
	#define HWRM_ASYNC_EVENT_CMPL_FUNC_FLR_PROC_CMPLT_OPAQUE_SFT 1
	/* 8-lsb timestamp from POR (100-msec resolution) */
	uint8_t	timestamp_lo;
	/* 16-lsb timestamp from POR (100-msec resolution) */
	uint16_t	timestamp_hi;
	/* Event specific data */
	uint32_t	event_data1;
	/* Function ID */
	#define HWRM_ASYNC_EVENT_CMPL_FUNC_FLR_PROC_CMPLT_EVENT_DATA1_FUNC_ID_MASK UINT32_C(0xffff)
	#define HWRM_ASYNC_EVENT_CMPL_FUNC_FLR_PROC_CMPLT_EVENT_DATA1_FUNC_ID_SFT 0
} hwrm_async_event_cmpl_func_flr_proc_cmplt_t, *phwrm_async_event_cmpl_func_flr_proc_cmplt_t;

/* hwrm_async_event_cmpl_pf_drvr_unload (size:128b/16B) */

typedef struct hwrm_async_event_cmpl_pf_drvr_unload {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_PF_DRVR_UNLOAD_TYPE_MASK		UINT32_C(0x3f)
	#define HWRM_ASYNC_EVENT_CMPL_PF_DRVR_UNLOAD_TYPE_SFT		0
	/* HWRM Asynchronous Event Information */
		#define HWRM_ASYNC_EVENT_CMPL_PF_DRVR_UNLOAD_TYPE_HWRM_ASYNC_EVENT  UINT32_C(0x2e)
		#define HWRM_ASYNC_EVENT_CMPL_PF_DRVR_UNLOAD_TYPE_LAST		HWRM_ASYNC_EVENT_CMPL_PF_DRVR_UNLOAD_TYPE_HWRM_ASYNC_EVENT
	/* Identifiers of events. */
	uint16_t	event_id;
	/* PF driver unloaded */
	#define HWRM_ASYNC_EVENT_CMPL_PF_DRVR_UNLOAD_EVENT_ID_PF_DRVR_UNLOAD UINT32_C(0x20)
	#define HWRM_ASYNC_EVENT_CMPL_PF_DRVR_UNLOAD_EVENT_ID_LAST	HWRM_ASYNC_EVENT_CMPL_PF_DRVR_UNLOAD_EVENT_ID_PF_DRVR_UNLOAD
	/* Event specific data */
	uint32_t	event_data2;
	uint8_t	opaque_v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_PF_DRVR_UNLOAD_V	UINT32_C(0x1)
	/* opaque is 7 b */
	#define HWRM_ASYNC_EVENT_CMPL_PF_DRVR_UNLOAD_OPAQUE_MASK UINT32_C(0xfe)
	#define HWRM_ASYNC_EVENT_CMPL_PF_DRVR_UNLOAD_OPAQUE_SFT 1
	/* 8-lsb timestamp from POR (100-msec resolution) */
	uint8_t	timestamp_lo;
	/* 16-lsb timestamp from POR (100-msec resolution) */
	uint16_t	timestamp_hi;
	/* Event specific data */
	uint32_t	event_data1;
	/* PF ID */
	#define HWRM_ASYNC_EVENT_CMPL_PF_DRVR_UNLOAD_EVENT_DATA1_FUNC_ID_MASK UINT32_C(0xffff)
	#define HWRM_ASYNC_EVENT_CMPL_PF_DRVR_UNLOAD_EVENT_DATA1_FUNC_ID_SFT 0
	/* Indicates the physical port this pf belongs to */
	#define HWRM_ASYNC_EVENT_CMPL_PF_DRVR_UNLOAD_EVENT_DATA1_PORT_MASK   UINT32_C(0x70000)
	#define HWRM_ASYNC_EVENT_CMPL_PF_DRVR_UNLOAD_EVENT_DATA1_PORT_SFT	16
} hwrm_async_event_cmpl_pf_drvr_unload_t, *phwrm_async_event_cmpl_pf_drvr_unload_t;

/* hwrm_async_event_cmpl_pf_drvr_load (size:128b/16B) */

typedef struct hwrm_async_event_cmpl_pf_drvr_load {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_PF_DRVR_LOAD_TYPE_MASK		UINT32_C(0x3f)
	#define HWRM_ASYNC_EVENT_CMPL_PF_DRVR_LOAD_TYPE_SFT		0
	/* HWRM Asynchronous Event Information */
		#define HWRM_ASYNC_EVENT_CMPL_PF_DRVR_LOAD_TYPE_HWRM_ASYNC_EVENT  UINT32_C(0x2e)
		#define HWRM_ASYNC_EVENT_CMPL_PF_DRVR_LOAD_TYPE_LAST		HWRM_ASYNC_EVENT_CMPL_PF_DRVR_LOAD_TYPE_HWRM_ASYNC_EVENT
	/* Identifiers of events. */
	uint16_t	event_id;
	/* PF driver loaded */
	#define HWRM_ASYNC_EVENT_CMPL_PF_DRVR_LOAD_EVENT_ID_PF_DRVR_LOAD UINT32_C(0x21)
	#define HWRM_ASYNC_EVENT_CMPL_PF_DRVR_LOAD_EVENT_ID_LAST	HWRM_ASYNC_EVENT_CMPL_PF_DRVR_LOAD_EVENT_ID_PF_DRVR_LOAD
	/* Event specific data */
	uint32_t	event_data2;
	uint8_t	opaque_v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_PF_DRVR_LOAD_V	UINT32_C(0x1)
	/* opaque is 7 b */
	#define HWRM_ASYNC_EVENT_CMPL_PF_DRVR_LOAD_OPAQUE_MASK UINT32_C(0xfe)
	#define HWRM_ASYNC_EVENT_CMPL_PF_DRVR_LOAD_OPAQUE_SFT 1
	/* 8-lsb timestamp from POR (100-msec resolution) */
	uint8_t	timestamp_lo;
	/* 16-lsb timestamp from POR (100-msec resolution) */
	uint16_t	timestamp_hi;
	/* Event specific data */
	uint32_t	event_data1;
	/* PF ID */
	#define HWRM_ASYNC_EVENT_CMPL_PF_DRVR_LOAD_EVENT_DATA1_FUNC_ID_MASK UINT32_C(0xffff)
	#define HWRM_ASYNC_EVENT_CMPL_PF_DRVR_LOAD_EVENT_DATA1_FUNC_ID_SFT 0
	/* Indicates the physical port this pf belongs to */
	#define HWRM_ASYNC_EVENT_CMPL_PF_DRVR_LOAD_EVENT_DATA1_PORT_MASK   UINT32_C(0x70000)
	#define HWRM_ASYNC_EVENT_CMPL_PF_DRVR_LOAD_EVENT_DATA1_PORT_SFT	16
} hwrm_async_event_cmpl_pf_drvr_load_t, *phwrm_async_event_cmpl_pf_drvr_load_t;

/* hwrm_async_event_cmpl_vf_flr (size:128b/16B) */

typedef struct hwrm_async_event_cmpl_vf_flr {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_VF_FLR_TYPE_MASK		UINT32_C(0x3f)
	#define HWRM_ASYNC_EVENT_CMPL_VF_FLR_TYPE_SFT		0
	/* HWRM Asynchronous Event Information */
		#define HWRM_ASYNC_EVENT_CMPL_VF_FLR_TYPE_HWRM_ASYNC_EVENT  UINT32_C(0x2e)
		#define HWRM_ASYNC_EVENT_CMPL_VF_FLR_TYPE_LAST		HWRM_ASYNC_EVENT_CMPL_VF_FLR_TYPE_HWRM_ASYNC_EVENT
	/* Identifiers of events. */
	uint16_t	event_id;
	/* VF Function Level Reset (FLR) */
	#define HWRM_ASYNC_EVENT_CMPL_VF_FLR_EVENT_ID_VF_FLR UINT32_C(0x30)
	#define HWRM_ASYNC_EVENT_CMPL_VF_FLR_EVENT_ID_LAST  HWRM_ASYNC_EVENT_CMPL_VF_FLR_EVENT_ID_VF_FLR
	/* Event specific data */
	uint32_t	event_data2;
	uint8_t	opaque_v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_VF_FLR_V	UINT32_C(0x1)
	/* opaque is 7 b */
	#define HWRM_ASYNC_EVENT_CMPL_VF_FLR_OPAQUE_MASK UINT32_C(0xfe)
	#define HWRM_ASYNC_EVENT_CMPL_VF_FLR_OPAQUE_SFT 1
	/* 8-lsb timestamp from POR (100-msec resolution) */
	uint8_t	timestamp_lo;
	/* 16-lsb timestamp from POR (100-msec resolution) */
	uint16_t	timestamp_hi;
	/* Event specific data */
	uint32_t	event_data1;
	/* VF ID */
	#define HWRM_ASYNC_EVENT_CMPL_VF_FLR_EVENT_DATA1_VF_ID_MASK UINT32_C(0xffff)
	#define HWRM_ASYNC_EVENT_CMPL_VF_FLR_EVENT_DATA1_VF_ID_SFT 0
	/* Indicates the physical function this event occurred on. */
	#define HWRM_ASYNC_EVENT_CMPL_VF_FLR_EVENT_DATA1_PF_ID_MASK UINT32_C(0xff0000)
	#define HWRM_ASYNC_EVENT_CMPL_VF_FLR_EVENT_DATA1_PF_ID_SFT 16
} hwrm_async_event_cmpl_vf_flr_t, *phwrm_async_event_cmpl_vf_flr_t;

/* hwrm_async_event_cmpl_vf_mac_addr_change (size:128b/16B) */

typedef struct hwrm_async_event_cmpl_vf_mac_addr_change {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_VF_MAC_ADDR_CHANGE_TYPE_MASK		UINT32_C(0x3f)
	#define HWRM_ASYNC_EVENT_CMPL_VF_MAC_ADDR_CHANGE_TYPE_SFT		0
	/* HWRM Asynchronous Event Information */
		#define HWRM_ASYNC_EVENT_CMPL_VF_MAC_ADDR_CHANGE_TYPE_HWRM_ASYNC_EVENT  UINT32_C(0x2e)
		#define HWRM_ASYNC_EVENT_CMPL_VF_MAC_ADDR_CHANGE_TYPE_LAST		HWRM_ASYNC_EVENT_CMPL_VF_MAC_ADDR_CHANGE_TYPE_HWRM_ASYNC_EVENT
	/* Identifiers of events. */
	uint16_t	event_id;
	/* VF MAC Address Change */
	#define HWRM_ASYNC_EVENT_CMPL_VF_MAC_ADDR_CHANGE_EVENT_ID_VF_MAC_ADDR_CHANGE UINT32_C(0x31)
	#define HWRM_ASYNC_EVENT_CMPL_VF_MAC_ADDR_CHANGE_EVENT_ID_LAST		HWRM_ASYNC_EVENT_CMPL_VF_MAC_ADDR_CHANGE_EVENT_ID_VF_MAC_ADDR_CHANGE
	/* Event specific data */
	uint32_t	event_data2;
	uint8_t	opaque_v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_VF_MAC_ADDR_CHANGE_V	UINT32_C(0x1)
	/* opaque is 7 b */
	#define HWRM_ASYNC_EVENT_CMPL_VF_MAC_ADDR_CHANGE_OPAQUE_MASK UINT32_C(0xfe)
	#define HWRM_ASYNC_EVENT_CMPL_VF_MAC_ADDR_CHANGE_OPAQUE_SFT 1
	/* 8-lsb timestamp from POR (100-msec resolution) */
	uint8_t	timestamp_lo;
	/* 16-lsb timestamp from POR (100-msec resolution) */
	uint16_t	timestamp_hi;
	/* Event specific data */
	uint32_t	event_data1;
	/* VF ID */
	#define HWRM_ASYNC_EVENT_CMPL_VF_MAC_ADDR_CHANGE_EVENT_DATA1_VF_ID_MASK UINT32_C(0xffff)
	#define HWRM_ASYNC_EVENT_CMPL_VF_MAC_ADDR_CHANGE_EVENT_DATA1_VF_ID_SFT 0
} hwrm_async_event_cmpl_vf_mac_addr_change_t, *phwrm_async_event_cmpl_vf_mac_addr_change_t;

/* hwrm_async_event_cmpl_pf_vf_comm_status_change (size:128b/16B) */

typedef struct hwrm_async_event_cmpl_pf_vf_comm_status_change {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_PF_VF_COMM_STATUS_CHANGE_TYPE_MASK		UINT32_C(0x3f)
	#define HWRM_ASYNC_EVENT_CMPL_PF_VF_COMM_STATUS_CHANGE_TYPE_SFT		0
	/* HWRM Asynchronous Event Information */
		#define HWRM_ASYNC_EVENT_CMPL_PF_VF_COMM_STATUS_CHANGE_TYPE_HWRM_ASYNC_EVENT  UINT32_C(0x2e)
		#define HWRM_ASYNC_EVENT_CMPL_PF_VF_COMM_STATUS_CHANGE_TYPE_LAST		HWRM_ASYNC_EVENT_CMPL_PF_VF_COMM_STATUS_CHANGE_TYPE_HWRM_ASYNC_EVENT
	/* Identifiers of events. */
	uint16_t	event_id;
	/* PF-VF communication channel status change. */
	#define HWRM_ASYNC_EVENT_CMPL_PF_VF_COMM_STATUS_CHANGE_EVENT_ID_PF_VF_COMM_STATUS_CHANGE UINT32_C(0x32)
	#define HWRM_ASYNC_EVENT_CMPL_PF_VF_COMM_STATUS_CHANGE_EVENT_ID_LAST			HWRM_ASYNC_EVENT_CMPL_PF_VF_COMM_STATUS_CHANGE_EVENT_ID_PF_VF_COMM_STATUS_CHANGE
	/* Event specific data */
	uint32_t	event_data2;
	uint8_t	opaque_v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_PF_VF_COMM_STATUS_CHANGE_V	UINT32_C(0x1)
	/* opaque is 7 b */
	#define HWRM_ASYNC_EVENT_CMPL_PF_VF_COMM_STATUS_CHANGE_OPAQUE_MASK UINT32_C(0xfe)
	#define HWRM_ASYNC_EVENT_CMPL_PF_VF_COMM_STATUS_CHANGE_OPAQUE_SFT 1
	/* 8-lsb timestamp from POR (100-msec resolution) */
	uint8_t	timestamp_lo;
	/* 16-lsb timestamp from POR (100-msec resolution) */
	uint16_t	timestamp_hi;
	/* Event specific data */
	uint32_t	event_data1;
	/*
	 * If this bit is set to 1, then it indicates that the PF-VF
	 * communication was lost and it is established.
	 * If this bit set to 0, then it indicates that the PF-VF
	 * communication was established and it is lost.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_PF_VF_COMM_STATUS_CHANGE_EVENT_DATA1_COMM_ESTABLISHED	UINT32_C(0x1)
} hwrm_async_event_cmpl_pf_vf_comm_status_change_t, *phwrm_async_event_cmpl_pf_vf_comm_status_change_t;

/* hwrm_async_event_cmpl_vf_cfg_change (size:128b/16B) */

typedef struct hwrm_async_event_cmpl_vf_cfg_change {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_VF_CFG_CHANGE_TYPE_MASK		UINT32_C(0x3f)
	#define HWRM_ASYNC_EVENT_CMPL_VF_CFG_CHANGE_TYPE_SFT		0
	/* HWRM Asynchronous Event Information */
		#define HWRM_ASYNC_EVENT_CMPL_VF_CFG_CHANGE_TYPE_HWRM_ASYNC_EVENT  UINT32_C(0x2e)
		#define HWRM_ASYNC_EVENT_CMPL_VF_CFG_CHANGE_TYPE_LAST		HWRM_ASYNC_EVENT_CMPL_VF_CFG_CHANGE_TYPE_HWRM_ASYNC_EVENT
	/* Identifiers of events. */
	uint16_t	event_id;
	/* VF Configuration Change */
	#define HWRM_ASYNC_EVENT_CMPL_VF_CFG_CHANGE_EVENT_ID_VF_CFG_CHANGE UINT32_C(0x33)
	#define HWRM_ASYNC_EVENT_CMPL_VF_CFG_CHANGE_EVENT_ID_LAST	HWRM_ASYNC_EVENT_CMPL_VF_CFG_CHANGE_EVENT_ID_VF_CFG_CHANGE
	/* Event specific data */
	uint32_t	event_data2;
	/*
	 * This value indicates the VF ID of the VF whose configuration
	 * is changing if this async. event is sent to the parent PF.
	 * The firmware supports sending this to the parent PF if the
	 * `hwrm_func_qcaps.vf_cfg_async_for_pf_supported` value is 1.
	 * This value is undefined when the async. event is sent to the
	 * VF.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_VF_CFG_CHANGE_EVENT_DATA2_VF_ID_MASK UINT32_C(0xffff)
	#define HWRM_ASYNC_EVENT_CMPL_VF_CFG_CHANGE_EVENT_DATA2_VF_ID_SFT 0
	uint8_t	opaque_v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_VF_CFG_CHANGE_V	UINT32_C(0x1)
	/* opaque is 7 b */
	#define HWRM_ASYNC_EVENT_CMPL_VF_CFG_CHANGE_OPAQUE_MASK UINT32_C(0xfe)
	#define HWRM_ASYNC_EVENT_CMPL_VF_CFG_CHANGE_OPAQUE_SFT 1
	/* 8-lsb timestamp from POR (100-msec resolution) */
	uint8_t	timestamp_lo;
	/* 16-lsb timestamp from POR (100-msec resolution) */
	uint16_t	timestamp_hi;
	/*
	 * Each flag provided in this field indicates a specific VF
	 * configuration change. At least one of these flags shall be set to 1
	 * when an asynchronous event completion of this type is provided
	 * by the HWRM.
	 */
	uint32_t	event_data1;
	/*
	 * If this bit is set to 1, then the value of MTU
	 * was changed on this VF.
	 * If set to 0, then this bit should be ignored.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_VF_CFG_CHANGE_EVENT_DATA1_MTU_CHANGE		UINT32_C(0x1)
	/*
	 * If this bit is set to 1, then the value of MRU
	 * was changed on this VF.
	 * If set to 0, then this bit should be ignored.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_VF_CFG_CHANGE_EVENT_DATA1_MRU_CHANGE		UINT32_C(0x2)
	/*
	 * If this bit is set to 1, then the value of default MAC
	 * address was changed on this VF.
	 * If set to 0, then this bit should be ignored.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_VF_CFG_CHANGE_EVENT_DATA1_DFLT_MAC_ADDR_CHANGE	UINT32_C(0x4)
	/*
	 * If this bit is set to 1, then the value of default VLAN
	 * was changed on this VF.
	 * If set to 0, then this bit should be ignored.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_VF_CFG_CHANGE_EVENT_DATA1_DFLT_VLAN_CHANGE	UINT32_C(0x8)
	/*
	 * If this bit is set to 1, then the value of trusted VF enable
	 * was changed on this VF.
	 * If set to 0, then this bit should be ignored.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_VF_CFG_CHANGE_EVENT_DATA1_TRUSTED_VF_CFG_CHANGE	UINT32_C(0x10)
} hwrm_async_event_cmpl_vf_cfg_change_t, *phwrm_async_event_cmpl_vf_cfg_change_t;

/* hwrm_async_event_cmpl_llfc_pfc_change (size:128b/16B) */

typedef struct hwrm_async_event_cmpl_llfc_pfc_change {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_LLFC_PFC_CHANGE_TYPE_MASK		UINT32_C(0x3f)
	#define HWRM_ASYNC_EVENT_CMPL_LLFC_PFC_CHANGE_TYPE_SFT		0
	/* HWRM Asynchronous Event Information */
		#define HWRM_ASYNC_EVENT_CMPL_LLFC_PFC_CHANGE_TYPE_HWRM_ASYNC_EVENT  UINT32_C(0x2e)
		#define HWRM_ASYNC_EVENT_CMPL_LLFC_PFC_CHANGE_TYPE_LAST		HWRM_ASYNC_EVENT_CMPL_LLFC_PFC_CHANGE_TYPE_HWRM_ASYNC_EVENT
	/* unused1 is 10 b */
	#define HWRM_ASYNC_EVENT_CMPL_LLFC_PFC_CHANGE_UNUSED1_MASK	UINT32_C(0xffc0)
	#define HWRM_ASYNC_EVENT_CMPL_LLFC_PFC_CHANGE_UNUSED1_SFT	6
	/* Identifiers of events. */
	uint16_t	event_id;
	/* LLFC/PFC Configuration Change */
	#define HWRM_ASYNC_EVENT_CMPL_LLFC_PFC_CHANGE_EVENT_ID_LLFC_PFC_CHANGE UINT32_C(0x34)
	#define HWRM_ASYNC_EVENT_CMPL_LLFC_PFC_CHANGE_EVENT_ID_LAST	HWRM_ASYNC_EVENT_CMPL_LLFC_PFC_CHANGE_EVENT_ID_LLFC_PFC_CHANGE
	/* Event specific data */
	uint32_t	event_data2;
	uint8_t	opaque_v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_LLFC_PFC_CHANGE_V	UINT32_C(0x1)
	/* opaque is 7 b */
	#define HWRM_ASYNC_EVENT_CMPL_LLFC_PFC_CHANGE_OPAQUE_MASK UINT32_C(0xfe)
	#define HWRM_ASYNC_EVENT_CMPL_LLFC_PFC_CHANGE_OPAQUE_SFT 1
	/* 8-lsb timestamp from POR (100-msec resolution) */
	uint8_t	timestamp_lo;
	/* 16-lsb timestamp from POR (100-msec resolution) */
	uint16_t	timestamp_hi;
	/* Event specific data */
	uint32_t	event_data1;
	/* Indicates llfc pfc status change */
	#define HWRM_ASYNC_EVENT_CMPL_LLFC_PFC_CHANGE_EVENT_DATA1_LLFC_PFC_MASK UINT32_C(0x3)
	#define HWRM_ASYNC_EVENT_CMPL_LLFC_PFC_CHANGE_EVENT_DATA1_LLFC_PFC_SFT 0
	/*
	 * If this field set to 1, then it indicates that llfc is
	 * enabled.
	 */
		#define HWRM_ASYNC_EVENT_CMPL_LLFC_PFC_CHANGE_EVENT_DATA1_LLFC_PFC_LLFC  UINT32_C(0x1)
	/*
	 * If this field is set to 2, then it indicates that pfc
	 * is enabled.
	 */
		#define HWRM_ASYNC_EVENT_CMPL_LLFC_PFC_CHANGE_EVENT_DATA1_LLFC_PFC_PFC   UINT32_C(0x2)
		#define HWRM_ASYNC_EVENT_CMPL_LLFC_PFC_CHANGE_EVENT_DATA1_LLFC_PFC_LAST HWRM_ASYNC_EVENT_CMPL_LLFC_PFC_CHANGE_EVENT_DATA1_LLFC_PFC_PFC
	/* Indicates the physical port this llfc pfc change occur */
	#define HWRM_ASYNC_EVENT_CMPL_LLFC_PFC_CHANGE_EVENT_DATA1_PORT_MASK	UINT32_C(0x1c)
	#define HWRM_ASYNC_EVENT_CMPL_LLFC_PFC_CHANGE_EVENT_DATA1_PORT_SFT	2
	/* PORT ID */
	#define HWRM_ASYNC_EVENT_CMPL_LLFC_PFC_CHANGE_EVENT_DATA1_PORT_ID_MASK UINT32_C(0x1fffe0)
	#define HWRM_ASYNC_EVENT_CMPL_LLFC_PFC_CHANGE_EVENT_DATA1_PORT_ID_SFT  5
} hwrm_async_event_cmpl_llfc_pfc_change_t, *phwrm_async_event_cmpl_llfc_pfc_change_t;

/* hwrm_async_event_cmpl_default_vnic_change (size:128b/16B) */

typedef struct hwrm_async_event_cmpl_default_vnic_change {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_DEFAULT_VNIC_CHANGE_TYPE_MASK		UINT32_C(0x3f)
	#define HWRM_ASYNC_EVENT_CMPL_DEFAULT_VNIC_CHANGE_TYPE_SFT		0
	/* HWRM Asynchronous Event Information */
		#define HWRM_ASYNC_EVENT_CMPL_DEFAULT_VNIC_CHANGE_TYPE_HWRM_ASYNC_EVENT  UINT32_C(0x2e)
		#define HWRM_ASYNC_EVENT_CMPL_DEFAULT_VNIC_CHANGE_TYPE_LAST		HWRM_ASYNC_EVENT_CMPL_DEFAULT_VNIC_CHANGE_TYPE_HWRM_ASYNC_EVENT
	/* unused1 is 10 b */
	#define HWRM_ASYNC_EVENT_CMPL_DEFAULT_VNIC_CHANGE_UNUSED1_MASK	UINT32_C(0xffc0)
	#define HWRM_ASYNC_EVENT_CMPL_DEFAULT_VNIC_CHANGE_UNUSED1_SFT	6
	/* Identifiers of events. */
	uint16_t	event_id;
	/* Notification of a default vnic allocation or free */
	#define HWRM_ASYNC_EVENT_CMPL_DEFAULT_VNIC_CHANGE_EVENT_ID_ALLOC_FREE_NOTIFICATION UINT32_C(0x35)
	#define HWRM_ASYNC_EVENT_CMPL_DEFAULT_VNIC_CHANGE_EVENT_ID_LAST		HWRM_ASYNC_EVENT_CMPL_DEFAULT_VNIC_CHANGE_EVENT_ID_ALLOC_FREE_NOTIFICATION
	/* Event specific data */
	uint32_t	event_data2;
	uint8_t	opaque_v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_DEFAULT_VNIC_CHANGE_V	UINT32_C(0x1)
	/* opaque is 7 b */
	#define HWRM_ASYNC_EVENT_CMPL_DEFAULT_VNIC_CHANGE_OPAQUE_MASK UINT32_C(0xfe)
	#define HWRM_ASYNC_EVENT_CMPL_DEFAULT_VNIC_CHANGE_OPAQUE_SFT 1
	/* 8-lsb timestamp from POR (100-msec resolution) */
	uint8_t	timestamp_lo;
	/* 16-lsb timestamp from POR (100-msec resolution) */
	uint16_t	timestamp_hi;
	/* Event specific data */
	uint32_t	event_data1;
	/* Indicates default vnic configuration change */
	#define HWRM_ASYNC_EVENT_CMPL_DEFAULT_VNIC_CHANGE_EVENT_DATA1_DEF_VNIC_STATE_MASK	UINT32_C(0x3)
	#define HWRM_ASYNC_EVENT_CMPL_DEFAULT_VNIC_CHANGE_EVENT_DATA1_DEF_VNIC_STATE_SFT	0
	/*
	 * If this field is set to 1, then it indicates that
	 * a default VNIC has been allocate.
	 */
		#define HWRM_ASYNC_EVENT_CMPL_DEFAULT_VNIC_CHANGE_EVENT_DATA1_DEF_VNIC_STATE_DEF_VNIC_ALLOC  UINT32_C(0x1)
	/*
	 * If this field is set to 2, then it indicates that
	 * a default VNIC has been freed.
	 */
		#define HWRM_ASYNC_EVENT_CMPL_DEFAULT_VNIC_CHANGE_EVENT_DATA1_DEF_VNIC_STATE_DEF_VNIC_FREE   UINT32_C(0x2)
		#define HWRM_ASYNC_EVENT_CMPL_DEFAULT_VNIC_CHANGE_EVENT_DATA1_DEF_VNIC_STATE_LAST	HWRM_ASYNC_EVENT_CMPL_DEFAULT_VNIC_CHANGE_EVENT_DATA1_DEF_VNIC_STATE_DEF_VNIC_FREE
	/* Indicates the physical function this event occurred on. */
	#define HWRM_ASYNC_EVENT_CMPL_DEFAULT_VNIC_CHANGE_EVENT_DATA1_PF_ID_MASK		UINT32_C(0x3fc)
	#define HWRM_ASYNC_EVENT_CMPL_DEFAULT_VNIC_CHANGE_EVENT_DATA1_PF_ID_SFT			2
	/* Indicates the virtual function this event occurred on */
	#define HWRM_ASYNC_EVENT_CMPL_DEFAULT_VNIC_CHANGE_EVENT_DATA1_VF_ID_MASK		UINT32_C(0x3fffc00)
	#define HWRM_ASYNC_EVENT_CMPL_DEFAULT_VNIC_CHANGE_EVENT_DATA1_VF_ID_SFT			10
} hwrm_async_event_cmpl_default_vnic_change_t, *phwrm_async_event_cmpl_default_vnic_change_t;

/* hwrm_async_event_cmpl_hw_flow_aged (size:128b/16B) */

typedef struct hwrm_async_event_cmpl_hw_flow_aged {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_HW_FLOW_AGED_TYPE_MASK		UINT32_C(0x3f)
	#define HWRM_ASYNC_EVENT_CMPL_HW_FLOW_AGED_TYPE_SFT		0
	/* HWRM Asynchronous Event Information */
		#define HWRM_ASYNC_EVENT_CMPL_HW_FLOW_AGED_TYPE_HWRM_ASYNC_EVENT  UINT32_C(0x2e)
		#define HWRM_ASYNC_EVENT_CMPL_HW_FLOW_AGED_TYPE_LAST		HWRM_ASYNC_EVENT_CMPL_HW_FLOW_AGED_TYPE_HWRM_ASYNC_EVENT
	/* Identifiers of events. */
	uint16_t	event_id;
	/* Notification of a hw flow aged */
	#define HWRM_ASYNC_EVENT_CMPL_HW_FLOW_AGED_EVENT_ID_HW_FLOW_AGED UINT32_C(0x36)
	#define HWRM_ASYNC_EVENT_CMPL_HW_FLOW_AGED_EVENT_ID_LAST	HWRM_ASYNC_EVENT_CMPL_HW_FLOW_AGED_EVENT_ID_HW_FLOW_AGED
	/* Event specific data */
	uint32_t	event_data2;
	uint8_t	opaque_v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_HW_FLOW_AGED_V	UINT32_C(0x1)
	/* opaque is 7 b */
	#define HWRM_ASYNC_EVENT_CMPL_HW_FLOW_AGED_OPAQUE_MASK UINT32_C(0xfe)
	#define HWRM_ASYNC_EVENT_CMPL_HW_FLOW_AGED_OPAQUE_SFT 1
	/* 8-lsb timestamp from POR (100-msec resolution) */
	uint8_t	timestamp_lo;
	/* 16-lsb timestamp from POR (100-msec resolution) */
	uint16_t	timestamp_hi;
	/* Event specific data */
	uint32_t	event_data1;
	/* Indicates flow ID this event occurred on. */
	#define HWRM_ASYNC_EVENT_CMPL_HW_FLOW_AGED_EVENT_DATA1_FLOW_ID_MASK	UINT32_C(0x7fffffff)
	#define HWRM_ASYNC_EVENT_CMPL_HW_FLOW_AGED_EVENT_DATA1_FLOW_ID_SFT	0
	/* Indicates flow direction this event occurred on. */
	#define HWRM_ASYNC_EVENT_CMPL_HW_FLOW_AGED_EVENT_DATA1_FLOW_DIRECTION	UINT32_C(0x80000000)
	/*
	 * If this bit set to 0, then it indicates that the aged
	 * event was rx flow.
	 */
		#define HWRM_ASYNC_EVENT_CMPL_HW_FLOW_AGED_EVENT_DATA1_FLOW_DIRECTION_RX	(UINT32_C(0x0) << 31)
	/*
	 * If this bit is set to 1, then it indicates that the aged
	 * event was tx flow.
	 */
		#define HWRM_ASYNC_EVENT_CMPL_HW_FLOW_AGED_EVENT_DATA1_FLOW_DIRECTION_TX	(UINT32_C(0x1) << 31)
		#define HWRM_ASYNC_EVENT_CMPL_HW_FLOW_AGED_EVENT_DATA1_FLOW_DIRECTION_LAST HWRM_ASYNC_EVENT_CMPL_HW_FLOW_AGED_EVENT_DATA1_FLOW_DIRECTION_TX
} hwrm_async_event_cmpl_hw_flow_aged_t, *phwrm_async_event_cmpl_hw_flow_aged_t;

/* hwrm_async_event_cmpl_eem_cache_flush_req (size:128b/16B) */

typedef struct hwrm_async_event_cmpl_eem_cache_flush_req {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_EEM_CACHE_FLUSH_REQ_TYPE_MASK		UINT32_C(0x3f)
	#define HWRM_ASYNC_EVENT_CMPL_EEM_CACHE_FLUSH_REQ_TYPE_SFT		0
	/* HWRM Asynchronous Event Information */
		#define HWRM_ASYNC_EVENT_CMPL_EEM_CACHE_FLUSH_REQ_TYPE_HWRM_ASYNC_EVENT  UINT32_C(0x2e)
		#define HWRM_ASYNC_EVENT_CMPL_EEM_CACHE_FLUSH_REQ_TYPE_LAST		HWRM_ASYNC_EVENT_CMPL_EEM_CACHE_FLUSH_REQ_TYPE_HWRM_ASYNC_EVENT
	/* Identifiers of events. */
	uint16_t	event_id;
	/* Notification of a eem_cache_flush request */
	#define HWRM_ASYNC_EVENT_CMPL_EEM_CACHE_FLUSH_REQ_EVENT_ID_EEM_CACHE_FLUSH_REQ UINT32_C(0x38)
	#define HWRM_ASYNC_EVENT_CMPL_EEM_CACHE_FLUSH_REQ_EVENT_ID_LAST		HWRM_ASYNC_EVENT_CMPL_EEM_CACHE_FLUSH_REQ_EVENT_ID_EEM_CACHE_FLUSH_REQ
	/* Event specific data */
	uint32_t	event_data2;
	uint8_t	opaque_v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_EEM_CACHE_FLUSH_REQ_V	UINT32_C(0x1)
	/* opaque is 7 b */
	#define HWRM_ASYNC_EVENT_CMPL_EEM_CACHE_FLUSH_REQ_OPAQUE_MASK UINT32_C(0xfe)
	#define HWRM_ASYNC_EVENT_CMPL_EEM_CACHE_FLUSH_REQ_OPAQUE_SFT 1
	/* 8-lsb timestamp from POR (100-msec resolution) */
	uint8_t	timestamp_lo;
	/* 16-lsb timestamp from POR (100-msec resolution) */
	uint16_t	timestamp_hi;
	/* Event specific data */
	uint32_t	event_data1;
} hwrm_async_event_cmpl_eem_cache_flush_req_t, *phwrm_async_event_cmpl_eem_cache_flush_req_t;

/* hwrm_async_event_cmpl_eem_cache_flush_done (size:128b/16B) */

typedef struct hwrm_async_event_cmpl_eem_cache_flush_done {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_EEM_CACHE_FLUSH_DONE_TYPE_MASK		UINT32_C(0x3f)
	#define HWRM_ASYNC_EVENT_CMPL_EEM_CACHE_FLUSH_DONE_TYPE_SFT		0
	/* HWRM Asynchronous Event Information */
		#define HWRM_ASYNC_EVENT_CMPL_EEM_CACHE_FLUSH_DONE_TYPE_HWRM_ASYNC_EVENT  UINT32_C(0x2e)
		#define HWRM_ASYNC_EVENT_CMPL_EEM_CACHE_FLUSH_DONE_TYPE_LAST		HWRM_ASYNC_EVENT_CMPL_EEM_CACHE_FLUSH_DONE_TYPE_HWRM_ASYNC_EVENT
	/* Identifiers of events. */
	uint16_t	event_id;
	/*
	 * Notification of a host eem_cache_flush has completed. This event
	 * is generated by the host driver.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_EEM_CACHE_FLUSH_DONE_EVENT_ID_EEM_CACHE_FLUSH_DONE UINT32_C(0x39)
	#define HWRM_ASYNC_EVENT_CMPL_EEM_CACHE_FLUSH_DONE_EVENT_ID_LAST		HWRM_ASYNC_EVENT_CMPL_EEM_CACHE_FLUSH_DONE_EVENT_ID_EEM_CACHE_FLUSH_DONE
	/* Event specific data */
	uint32_t	event_data2;
	uint8_t	opaque_v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_EEM_CACHE_FLUSH_DONE_V	UINT32_C(0x1)
	/* opaque is 7 b */
	#define HWRM_ASYNC_EVENT_CMPL_EEM_CACHE_FLUSH_DONE_OPAQUE_MASK UINT32_C(0xfe)
	#define HWRM_ASYNC_EVENT_CMPL_EEM_CACHE_FLUSH_DONE_OPAQUE_SFT 1
	/* 8-lsb timestamp from POR (100-msec resolution) */
	uint8_t	timestamp_lo;
	/* 16-lsb timestamp from POR (100-msec resolution) */
	uint16_t	timestamp_hi;
	/* Event specific data */
	uint32_t	event_data1;
	/* Indicates function ID that this event occurred on. */
	#define HWRM_ASYNC_EVENT_CMPL_EEM_CACHE_FLUSH_DONE_EVENT_DATA1_FID_MASK UINT32_C(0xffff)
	#define HWRM_ASYNC_EVENT_CMPL_EEM_CACHE_FLUSH_DONE_EVENT_DATA1_FID_SFT 0
} hwrm_async_event_cmpl_eem_cache_flush_done_t, *phwrm_async_event_cmpl_eem_cache_flush_done_t;

/* hwrm_async_event_cmpl_tcp_flag_action_change (size:128b/16B) */

typedef struct hwrm_async_event_cmpl_tcp_flag_action_change {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_TCP_FLAG_ACTION_CHANGE_TYPE_MASK		UINT32_C(0x3f)
	#define HWRM_ASYNC_EVENT_CMPL_TCP_FLAG_ACTION_CHANGE_TYPE_SFT		0
	/* HWRM Asynchronous Event Information */
		#define HWRM_ASYNC_EVENT_CMPL_TCP_FLAG_ACTION_CHANGE_TYPE_HWRM_ASYNC_EVENT  UINT32_C(0x2e)
		#define HWRM_ASYNC_EVENT_CMPL_TCP_FLAG_ACTION_CHANGE_TYPE_LAST		HWRM_ASYNC_EVENT_CMPL_TCP_FLAG_ACTION_CHANGE_TYPE_HWRM_ASYNC_EVENT
	/* Identifiers of events. */
	uint16_t	event_id;
	/* Notification of tcp flag action change */
	#define HWRM_ASYNC_EVENT_CMPL_TCP_FLAG_ACTION_CHANGE_EVENT_ID_TCP_FLAG_ACTION_CHANGE UINT32_C(0x3a)
	#define HWRM_ASYNC_EVENT_CMPL_TCP_FLAG_ACTION_CHANGE_EVENT_ID_LAST		HWRM_ASYNC_EVENT_CMPL_TCP_FLAG_ACTION_CHANGE_EVENT_ID_TCP_FLAG_ACTION_CHANGE
	/* Event specific data */
	uint32_t	event_data2;
	uint8_t	opaque_v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_TCP_FLAG_ACTION_CHANGE_V	UINT32_C(0x1)
	/* opaque is 7 b */
	#define HWRM_ASYNC_EVENT_CMPL_TCP_FLAG_ACTION_CHANGE_OPAQUE_MASK UINT32_C(0xfe)
	#define HWRM_ASYNC_EVENT_CMPL_TCP_FLAG_ACTION_CHANGE_OPAQUE_SFT 1
	/* 8-lsb timestamp from POR (100-msec resolution) */
	uint8_t	timestamp_lo;
	/* 16-lsb timestamp from POR (100-msec resolution) */
	uint16_t	timestamp_hi;
	/* Event specific data */
	uint32_t	event_data1;
} hwrm_async_event_cmpl_tcp_flag_action_change_t, *phwrm_async_event_cmpl_tcp_flag_action_change_t;

/* hwrm_async_event_cmpl_eem_flow_active (size:128b/16B) */

typedef struct hwrm_async_event_cmpl_eem_flow_active {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_EEM_FLOW_ACTIVE_TYPE_MASK		UINT32_C(0x3f)
	#define HWRM_ASYNC_EVENT_CMPL_EEM_FLOW_ACTIVE_TYPE_SFT		0
	/* HWRM Asynchronous Event Information */
		#define HWRM_ASYNC_EVENT_CMPL_EEM_FLOW_ACTIVE_TYPE_HWRM_ASYNC_EVENT  UINT32_C(0x2e)
		#define HWRM_ASYNC_EVENT_CMPL_EEM_FLOW_ACTIVE_TYPE_LAST		HWRM_ASYNC_EVENT_CMPL_EEM_FLOW_ACTIVE_TYPE_HWRM_ASYNC_EVENT
	/* Identifiers of events. */
	uint16_t	event_id;
	/* Notification of an active eem flow */
	#define HWRM_ASYNC_EVENT_CMPL_EEM_FLOW_ACTIVE_EVENT_ID_EEM_FLOW_ACTIVE UINT32_C(0x3b)
	#define HWRM_ASYNC_EVENT_CMPL_EEM_FLOW_ACTIVE_EVENT_ID_LAST	HWRM_ASYNC_EVENT_CMPL_EEM_FLOW_ACTIVE_EVENT_ID_EEM_FLOW_ACTIVE
	/* Event specific data */
	uint32_t	event_data2;
	/* Indicates the 2nd global id this event occurred on. */
	#define HWRM_ASYNC_EVENT_CMPL_EEM_FLOW_ACTIVE_EVENT_DATA2_GLOBAL_ID_2_MASK   UINT32_C(0x3fffffff)
	#define HWRM_ASYNC_EVENT_CMPL_EEM_FLOW_ACTIVE_EVENT_DATA2_GLOBAL_ID_2_SFT	0
	/*
	 * Indicates flow direction of the flow identified by
	 * the global_id_2.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_EEM_FLOW_ACTIVE_EVENT_DATA2_FLOW_DIRECTION	UINT32_C(0x40000000)
	/* If this bit is set to 0, then it indicates that this rx flow. */
		#define HWRM_ASYNC_EVENT_CMPL_EEM_FLOW_ACTIVE_EVENT_DATA2_FLOW_DIRECTION_RX	(UINT32_C(0x0) << 30)
	/* If this bit is set to 1, then it indicates that this tx flow. */
		#define HWRM_ASYNC_EVENT_CMPL_EEM_FLOW_ACTIVE_EVENT_DATA2_FLOW_DIRECTION_TX	(UINT32_C(0x1) << 30)
		#define HWRM_ASYNC_EVENT_CMPL_EEM_FLOW_ACTIVE_EVENT_DATA2_FLOW_DIRECTION_LAST HWRM_ASYNC_EVENT_CMPL_EEM_FLOW_ACTIVE_EVENT_DATA2_FLOW_DIRECTION_TX
	uint8_t	opaque_v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_EEM_FLOW_ACTIVE_V	UINT32_C(0x1)
	/* opaque is 7 b */
	#define HWRM_ASYNC_EVENT_CMPL_EEM_FLOW_ACTIVE_OPAQUE_MASK UINT32_C(0xfe)
	#define HWRM_ASYNC_EVENT_CMPL_EEM_FLOW_ACTIVE_OPAQUE_SFT 1
	/* 8-lsb timestamp from POR (100-msec resolution) */
	uint8_t	timestamp_lo;
	/* 16-lsb timestamp from POR (100-msec resolution) */
	uint16_t	timestamp_hi;
	/* Event specific data */
	uint32_t	event_data1;
	/* Indicates the 1st global id this event occurred on. */
	#define HWRM_ASYNC_EVENT_CMPL_EEM_FLOW_ACTIVE_EVENT_DATA1_GLOBAL_ID_1_MASK   UINT32_C(0x3fffffff)
	#define HWRM_ASYNC_EVENT_CMPL_EEM_FLOW_ACTIVE_EVENT_DATA1_GLOBAL_ID_1_SFT	0
	/*
	 * Indicates flow direction of the flow identified by the
	 * global_id_1.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_EEM_FLOW_ACTIVE_EVENT_DATA1_FLOW_DIRECTION	UINT32_C(0x40000000)
	/* If this bit is set to 0, then it indicates that this is rx flow. */
		#define HWRM_ASYNC_EVENT_CMPL_EEM_FLOW_ACTIVE_EVENT_DATA1_FLOW_DIRECTION_RX	(UINT32_C(0x0) << 30)
	/* If this bit is set to 1, then it indicates that this is tx flow. */
		#define HWRM_ASYNC_EVENT_CMPL_EEM_FLOW_ACTIVE_EVENT_DATA1_FLOW_DIRECTION_TX	(UINT32_C(0x1) << 30)
		#define HWRM_ASYNC_EVENT_CMPL_EEM_FLOW_ACTIVE_EVENT_DATA1_FLOW_DIRECTION_LAST HWRM_ASYNC_EVENT_CMPL_EEM_FLOW_ACTIVE_EVENT_DATA1_FLOW_DIRECTION_TX
	/*
	 * Indicates EEM flow aging mode this event occurred on. If
	 * this bit is set to 0, the event_data1 is the EEM global
	 * ID. If this bit is set to 1, the event_data1 is the number
	 * of global ID in the context memory.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_EEM_FLOW_ACTIVE_EVENT_DATA1_MODE		UINT32_C(0x80000000)
	/* EEM flow aging mode 0. */
		#define HWRM_ASYNC_EVENT_CMPL_EEM_FLOW_ACTIVE_EVENT_DATA1_MODE_0		(UINT32_C(0x0) << 31)
	/* EEM flow aging mode 1. */
		#define HWRM_ASYNC_EVENT_CMPL_EEM_FLOW_ACTIVE_EVENT_DATA1_MODE_1		(UINT32_C(0x1) << 31)
		#define HWRM_ASYNC_EVENT_CMPL_EEM_FLOW_ACTIVE_EVENT_DATA1_MODE_LAST	HWRM_ASYNC_EVENT_CMPL_EEM_FLOW_ACTIVE_EVENT_DATA1_MODE_1
} hwrm_async_event_cmpl_eem_flow_active_t, *phwrm_async_event_cmpl_eem_flow_active_t;

/* hwrm_async_event_cmpl_eem_cfg_change (size:128b/16B) */

typedef struct hwrm_async_event_cmpl_eem_cfg_change {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_EEM_CFG_CHANGE_TYPE_MASK		UINT32_C(0x3f)
	#define HWRM_ASYNC_EVENT_CMPL_EEM_CFG_CHANGE_TYPE_SFT		0
	/* HWRM Asynchronous Event Information */
		#define HWRM_ASYNC_EVENT_CMPL_EEM_CFG_CHANGE_TYPE_HWRM_ASYNC_EVENT  UINT32_C(0x2e)
		#define HWRM_ASYNC_EVENT_CMPL_EEM_CFG_CHANGE_TYPE_LAST		HWRM_ASYNC_EVENT_CMPL_EEM_CFG_CHANGE_TYPE_HWRM_ASYNC_EVENT
	/* Identifiers of events. */
	uint16_t	event_id;
	/* Notification of EEM configuration change */
	#define HWRM_ASYNC_EVENT_CMPL_EEM_CFG_CHANGE_EVENT_ID_EEM_CFG_CHANGE UINT32_C(0x3c)
	#define HWRM_ASYNC_EVENT_CMPL_EEM_CFG_CHANGE_EVENT_ID_LAST	HWRM_ASYNC_EVENT_CMPL_EEM_CFG_CHANGE_EVENT_ID_EEM_CFG_CHANGE
	/* Event specific data */
	uint32_t	event_data2;
	uint8_t	opaque_v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_EEM_CFG_CHANGE_V	UINT32_C(0x1)
	/* opaque is 7 b */
	#define HWRM_ASYNC_EVENT_CMPL_EEM_CFG_CHANGE_OPAQUE_MASK UINT32_C(0xfe)
	#define HWRM_ASYNC_EVENT_CMPL_EEM_CFG_CHANGE_OPAQUE_SFT 1
	/* 8-lsb timestamp from POR (100-msec resolution) */
	uint8_t	timestamp_lo;
	/* 16-lsb timestamp from POR (100-msec resolution) */
	uint16_t	timestamp_hi;
	/* Event specific data */
	uint32_t	event_data1;
	/*
	 * Value of 1 to indicate EEM TX configuration is enabled. Value of
	 * 0 to indicate the EEM TX configuration is disabled.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_EEM_CFG_CHANGE_EVENT_DATA1_EEM_TX_ENABLE	UINT32_C(0x1)
	/*
	 * Value of 1 to indicate EEM RX configuration is enabled. Value of 0
	 * to indicate the EEM RX configuration is disabled.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_EEM_CFG_CHANGE_EVENT_DATA1_EEM_RX_ENABLE	UINT32_C(0x2)
} hwrm_async_event_cmpl_eem_cfg_change_t, *phwrm_async_event_cmpl_eem_cfg_change_t;

/* hwrm_async_event_cmpl_quiesce_done (size:128b/16B) */

typedef struct hwrm_async_event_cmpl_quiesce_done {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_QUIESCE_DONE_TYPE_MASK		UINT32_C(0x3f)
	#define HWRM_ASYNC_EVENT_CMPL_QUIESCE_DONE_TYPE_SFT		0
	/* HWRM Asynchronous Event Information */
		#define HWRM_ASYNC_EVENT_CMPL_QUIESCE_DONE_TYPE_HWRM_ASYNC_EVENT  UINT32_C(0x2e)
		#define HWRM_ASYNC_EVENT_CMPL_QUIESCE_DONE_TYPE_LAST		HWRM_ASYNC_EVENT_CMPL_QUIESCE_DONE_TYPE_HWRM_ASYNC_EVENT
	/* Identifiers of events. */
	uint16_t	event_id;
	/* An event signifying completion of HWRM_FW_STATE_QUIESCE */
	#define HWRM_ASYNC_EVENT_CMPL_QUIESCE_DONE_EVENT_ID_QUIESCE_DONE UINT32_C(0x3f)
	#define HWRM_ASYNC_EVENT_CMPL_QUIESCE_DONE_EVENT_ID_LAST	HWRM_ASYNC_EVENT_CMPL_QUIESCE_DONE_EVENT_ID_QUIESCE_DONE
	/* Event specific data */
	uint32_t	event_data2;
	/* Status of HWRM_FW_STATE_QUIESCE completion */
	#define HWRM_ASYNC_EVENT_CMPL_QUIESCE_DONE_EVENT_DATA2_QUIESCE_STATUS_MASK		UINT32_C(0xff)
	#define HWRM_ASYNC_EVENT_CMPL_QUIESCE_DONE_EVENT_DATA2_QUIESCE_STATUS_SFT		0
	/*
	 * The quiesce operation started by HWRM_FW_STATE_QUIESCE
	 * completed successfully.
	 */
		#define HWRM_ASYNC_EVENT_CMPL_QUIESCE_DONE_EVENT_DATA2_QUIESCE_STATUS_SUCCESS		UINT32_C(0x0)
	/*
	 * The quiesce operation started by HWRM_FW_STATE_QUIESCE timed
	 * out.
	 */
		#define HWRM_ASYNC_EVENT_CMPL_QUIESCE_DONE_EVENT_DATA2_QUIESCE_STATUS_TIMEOUT		UINT32_C(0x1)
	/*
	 * The quiesce operation started by HWRM_FW_STATE_QUIESCE
	 * encountered an error.
	 */
		#define HWRM_ASYNC_EVENT_CMPL_QUIESCE_DONE_EVENT_DATA2_QUIESCE_STATUS_ERROR		UINT32_C(0x2)
		#define HWRM_ASYNC_EVENT_CMPL_QUIESCE_DONE_EVENT_DATA2_QUIESCE_STATUS_LAST		HWRM_ASYNC_EVENT_CMPL_QUIESCE_DONE_EVENT_DATA2_QUIESCE_STATUS_ERROR
	/* opaque is 8 b */
	#define HWRM_ASYNC_EVENT_CMPL_QUIESCE_DONE_EVENT_DATA2_OPAQUE_MASK			UINT32_C(0xff00)
	#define HWRM_ASYNC_EVENT_CMPL_QUIESCE_DONE_EVENT_DATA2_OPAQUE_SFT			8
	/*
	 * Additional information about internal hardware state related to
	 * idle/quiesce state.  QUIESCE may succeed per quiesce_status
	 * regardless of idle_state_flags.  If QUIESCE fails, the host may
	 * inspect idle_state_flags to determine whether a retry is warranted.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_QUIESCE_DONE_EVENT_DATA2_IDLE_STATE_FLAGS_MASK		UINT32_C(0xff0000)
	#define HWRM_ASYNC_EVENT_CMPL_QUIESCE_DONE_EVENT_DATA2_IDLE_STATE_FLAGS_SFT		16
	/*
	 * Failure to quiesce is caused by host not updating the NQ consumer
	 * index.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_QUIESCE_DONE_EVENT_DATA2_IDLE_STATE_FLAGS_INCOMPLETE_NQ	UINT32_C(0x10000)
	/* Flag 1 indicating partial non-idle state. */
	#define HWRM_ASYNC_EVENT_CMPL_QUIESCE_DONE_EVENT_DATA2_IDLE_STATE_FLAGS_IDLE_STATUS_1	UINT32_C(0x20000)
	/* Flag 2 indicating partial non-idle state. */
	#define HWRM_ASYNC_EVENT_CMPL_QUIESCE_DONE_EVENT_DATA2_IDLE_STATE_FLAGS_IDLE_STATUS_2	UINT32_C(0x40000)
	/* Flag 3 indicating partial non-idle state. */
	#define HWRM_ASYNC_EVENT_CMPL_QUIESCE_DONE_EVENT_DATA2_IDLE_STATE_FLAGS_IDLE_STATUS_3	UINT32_C(0x80000)
	uint8_t	opaque_v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_QUIESCE_DONE_V	UINT32_C(0x1)
	/* opaque is 7 b */
	#define HWRM_ASYNC_EVENT_CMPL_QUIESCE_DONE_OPAQUE_MASK UINT32_C(0xfe)
	#define HWRM_ASYNC_EVENT_CMPL_QUIESCE_DONE_OPAQUE_SFT 1
	/* 8-lsb timestamp from POR (100-msec resolution) */
	uint8_t	timestamp_lo;
	/* 16-lsb timestamp from POR (100-msec resolution) */
	uint16_t	timestamp_hi;
	/* Event specific data */
	uint32_t	event_data1;
	/* Time stamp for error event */
	#define HWRM_ASYNC_EVENT_CMPL_QUIESCE_DONE_EVENT_DATA1_TIMESTAMP	UINT32_C(0x1)
} hwrm_async_event_cmpl_quiesce_done_t, *phwrm_async_event_cmpl_quiesce_done_t;

/* hwrm_async_event_cmpl_deferred_response (size:128b/16B) */

typedef struct hwrm_async_event_cmpl_deferred_response {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_DEFERRED_RESPONSE_TYPE_MASK		UINT32_C(0x3f)
	#define HWRM_ASYNC_EVENT_CMPL_DEFERRED_RESPONSE_TYPE_SFT		0
	/* HWRM Asynchronous Event Information */
		#define HWRM_ASYNC_EVENT_CMPL_DEFERRED_RESPONSE_TYPE_HWRM_ASYNC_EVENT  UINT32_C(0x2e)
		#define HWRM_ASYNC_EVENT_CMPL_DEFERRED_RESPONSE_TYPE_LAST		HWRM_ASYNC_EVENT_CMPL_DEFERRED_RESPONSE_TYPE_HWRM_ASYNC_EVENT
	/* Identifiers of events. */
	uint16_t	event_id;
	/*
	 * An event signifying a HWRM command is in progress and its
	 * response will be deferred
	 */
	#define HWRM_ASYNC_EVENT_CMPL_DEFERRED_RESPONSE_EVENT_ID_DEFERRED_RESPONSE UINT32_C(0x40)
	#define HWRM_ASYNC_EVENT_CMPL_DEFERRED_RESPONSE_EVENT_ID_LAST		HWRM_ASYNC_EVENT_CMPL_DEFERRED_RESPONSE_EVENT_ID_DEFERRED_RESPONSE
	/* Event specific data */
	uint32_t	event_data2;
	/*
	 * The PF's mailbox is clear to issue another command.
	 * A command with this seq_id is still in progress
	 * and will return a regular HWRM completion when done.
	 * 'event_data1' field, if non-zero, contains the estimated
	 * execution time for the command.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_DEFERRED_RESPONSE_EVENT_DATA2_SEQ_ID_MASK UINT32_C(0xffff)
	#define HWRM_ASYNC_EVENT_CMPL_DEFERRED_RESPONSE_EVENT_DATA2_SEQ_ID_SFT 0
	uint8_t	opaque_v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_DEFERRED_RESPONSE_V	UINT32_C(0x1)
	/* opaque is 7 b */
	#define HWRM_ASYNC_EVENT_CMPL_DEFERRED_RESPONSE_OPAQUE_MASK UINT32_C(0xfe)
	#define HWRM_ASYNC_EVENT_CMPL_DEFERRED_RESPONSE_OPAQUE_SFT 1
	/* 8-lsb timestamp from POR (100-msec resolution) */
	uint8_t	timestamp_lo;
	/* 16-lsb timestamp from POR (100-msec resolution) */
	uint16_t	timestamp_hi;
	/* Estimated remaining time of command execution in ms (if not zero) */
	uint32_t	event_data1;
} hwrm_async_event_cmpl_deferred_response_t, *phwrm_async_event_cmpl_deferred_response_t;

/* hwrm_async_event_cmpl_pfc_watchdog_cfg_change (size:128b/16B) */

typedef struct hwrm_async_event_cmpl_pfc_watchdog_cfg_change {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_PFC_WATCHDOG_CFG_CHANGE_TYPE_MASK		UINT32_C(0x3f)
	#define HWRM_ASYNC_EVENT_CMPL_PFC_WATCHDOG_CFG_CHANGE_TYPE_SFT		0
	/* HWRM Asynchronous Event Information */
		#define HWRM_ASYNC_EVENT_CMPL_PFC_WATCHDOG_CFG_CHANGE_TYPE_HWRM_ASYNC_EVENT  UINT32_C(0x2e)
		#define HWRM_ASYNC_EVENT_CMPL_PFC_WATCHDOG_CFG_CHANGE_TYPE_LAST		HWRM_ASYNC_EVENT_CMPL_PFC_WATCHDOG_CFG_CHANGE_TYPE_HWRM_ASYNC_EVENT
	/* Identifiers of events. */
	uint16_t	event_id;
	/* PFC watchdog configuration change for given port/cos */
	#define HWRM_ASYNC_EVENT_CMPL_PFC_WATCHDOG_CFG_CHANGE_EVENT_ID_PFC_WATCHDOG_CFG_CHANGE UINT32_C(0x41)
	#define HWRM_ASYNC_EVENT_CMPL_PFC_WATCHDOG_CFG_CHANGE_EVENT_ID_LAST		HWRM_ASYNC_EVENT_CMPL_PFC_WATCHDOG_CFG_CHANGE_EVENT_ID_PFC_WATCHDOG_CFG_CHANGE
	/* Event specific data */
	uint32_t	event_data2;
	uint8_t	opaque_v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_PFC_WATCHDOG_CFG_CHANGE_V	UINT32_C(0x1)
	/* opaque is 7 b */
	#define HWRM_ASYNC_EVENT_CMPL_PFC_WATCHDOG_CFG_CHANGE_OPAQUE_MASK UINT32_C(0xfe)
	#define HWRM_ASYNC_EVENT_CMPL_PFC_WATCHDOG_CFG_CHANGE_OPAQUE_SFT 1
	/* 8-lsb timestamp from POR (100-msec resolution) */
	uint8_t	timestamp_lo;
	/* 16-lsb timestamp from POR (100-msec resolution) */
	uint16_t	timestamp_hi;
	/* Event specific data */
	uint32_t	event_data1;
	/*
	 * 1 in bit position X indicates PFC watchdog should
	 * be on for COSX
	 */
	#define HWRM_ASYNC_EVENT_CMPL_PFC_WATCHDOG_CFG_CHANGE_EVENT_DATA1_PFC_WD_COS_MASK		UINT32_C(0xff)
	#define HWRM_ASYNC_EVENT_CMPL_PFC_WATCHDOG_CFG_CHANGE_EVENT_DATA1_PFC_WD_COS_SFT		0
	/* 1 means PFC WD for COS0 is on, 0 - off. */
	#define HWRM_ASYNC_EVENT_CMPL_PFC_WATCHDOG_CFG_CHANGE_EVENT_DATA1_PFC_WD_COS_PFC_WD_COS0	UINT32_C(0x1)
	/* 1 means PFC WD for COS1 is on, 0 - off. */
	#define HWRM_ASYNC_EVENT_CMPL_PFC_WATCHDOG_CFG_CHANGE_EVENT_DATA1_PFC_WD_COS_PFC_WD_COS1	UINT32_C(0x2)
	/* 1 means PFC WD for COS2 is on, 0 - off. */
	#define HWRM_ASYNC_EVENT_CMPL_PFC_WATCHDOG_CFG_CHANGE_EVENT_DATA1_PFC_WD_COS_PFC_WD_COS2	UINT32_C(0x4)
	/* 1 means PFC WD for COS3 is on, 0 - off. */
	#define HWRM_ASYNC_EVENT_CMPL_PFC_WATCHDOG_CFG_CHANGE_EVENT_DATA1_PFC_WD_COS_PFC_WD_COS3	UINT32_C(0x8)
	/* 1 means PFC WD for COS4 is on, 0 - off. */
	#define HWRM_ASYNC_EVENT_CMPL_PFC_WATCHDOG_CFG_CHANGE_EVENT_DATA1_PFC_WD_COS_PFC_WD_COS4	UINT32_C(0x10)
	/* 1 means PFC WD for COS5 is on, 0 - off. */
	#define HWRM_ASYNC_EVENT_CMPL_PFC_WATCHDOG_CFG_CHANGE_EVENT_DATA1_PFC_WD_COS_PFC_WD_COS5	UINT32_C(0x20)
	/* 1 means PFC WD for COS6 is on, 0 - off. */
	#define HWRM_ASYNC_EVENT_CMPL_PFC_WATCHDOG_CFG_CHANGE_EVENT_DATA1_PFC_WD_COS_PFC_WD_COS6	UINT32_C(0x40)
	/* 1 means PFC WD for COS7 is on, 0 - off. */
	#define HWRM_ASYNC_EVENT_CMPL_PFC_WATCHDOG_CFG_CHANGE_EVENT_DATA1_PFC_WD_COS_PFC_WD_COS7	UINT32_C(0x80)
	/* PORT ID */
	#define HWRM_ASYNC_EVENT_CMPL_PFC_WATCHDOG_CFG_CHANGE_EVENT_DATA1_PORT_ID_MASK		UINT32_C(0xffff00)
	#define HWRM_ASYNC_EVENT_CMPL_PFC_WATCHDOG_CFG_CHANGE_EVENT_DATA1_PORT_ID_SFT		8
} hwrm_async_event_cmpl_pfc_watchdog_cfg_change_t, *phwrm_async_event_cmpl_pfc_watchdog_cfg_change_t;

/* hwrm_async_event_cmpl_echo_request (size:128b/16B) */

typedef struct hwrm_async_event_cmpl_echo_request {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_ECHO_REQUEST_TYPE_MASK		UINT32_C(0x3f)
	#define HWRM_ASYNC_EVENT_CMPL_ECHO_REQUEST_TYPE_SFT		0
	/* HWRM Asynchronous Event Information */
		#define HWRM_ASYNC_EVENT_CMPL_ECHO_REQUEST_TYPE_HWRM_ASYNC_EVENT  UINT32_C(0x2e)
		#define HWRM_ASYNC_EVENT_CMPL_ECHO_REQUEST_TYPE_LAST		HWRM_ASYNC_EVENT_CMPL_ECHO_REQUEST_TYPE_HWRM_ASYNC_EVENT
	/* Identifiers of events. */
	uint16_t	event_id;
	/*
	 * An echo request from the firmware. An echo response is expected by
	 * the firmware.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_ECHO_REQUEST_EVENT_ID_ECHO_REQUEST UINT32_C(0x42)
	#define HWRM_ASYNC_EVENT_CMPL_ECHO_REQUEST_EVENT_ID_LAST	HWRM_ASYNC_EVENT_CMPL_ECHO_REQUEST_EVENT_ID_ECHO_REQUEST
	/* Event specific data that should be provided in the echo response */
	uint32_t	event_data2;
	uint8_t	opaque_v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_ECHO_REQUEST_V	UINT32_C(0x1)
	/* opaque is 7 b */
	#define HWRM_ASYNC_EVENT_CMPL_ECHO_REQUEST_OPAQUE_MASK UINT32_C(0xfe)
	#define HWRM_ASYNC_EVENT_CMPL_ECHO_REQUEST_OPAQUE_SFT 1
	/* 8-lsb timestamp from POR (100-msec resolution) */
	uint8_t	timestamp_lo;
	/* 16-lsb timestamp from POR (100-msec resolution) */
	uint16_t	timestamp_hi;
	/* Event specific data that should be provided in the echo response */
	uint32_t	event_data1;
} hwrm_async_event_cmpl_echo_request_t, *phwrm_async_event_cmpl_echo_request_t;

/* hwrm_async_event_cmpl_phc_master (size:128b/16B) */

typedef struct hwrm_async_event_cmpl_phc_master {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_PHC_MASTER_TYPE_MASK		UINT32_C(0x3f)
	#define HWRM_ASYNC_EVENT_CMPL_PHC_MASTER_TYPE_SFT		0
	/* HWRM Asynchronous Event Information */
		#define HWRM_ASYNC_EVENT_CMPL_PHC_MASTER_TYPE_HWRM_ASYNC_EVENT  UINT32_C(0x2e)
		#define HWRM_ASYNC_EVENT_CMPL_PHC_MASTER_TYPE_LAST		HWRM_ASYNC_EVENT_CMPL_PHC_MASTER_TYPE_HWRM_ASYNC_EVENT
	/* Identifiers of events. */
	uint16_t	event_id;
	/*
	 * This async event is used to notify driver of changes
	 * in PHC master. Only one master function can configure
	 * PHC.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_PHC_MASTER_EVENT_ID_PHC_MASTER UINT32_C(0x43)
	#define HWRM_ASYNC_EVENT_CMPL_PHC_MASTER_EVENT_ID_LAST	HWRM_ASYNC_EVENT_CMPL_PHC_MASTER_EVENT_ID_PHC_MASTER
	/* Event specific data */
	uint32_t	event_data2;
	uint8_t	opaque_v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_PHC_MASTER_V	UINT32_C(0x1)
	/* opaque is 7 b */
	#define HWRM_ASYNC_EVENT_CMPL_PHC_MASTER_OPAQUE_MASK UINT32_C(0xfe)
	#define HWRM_ASYNC_EVENT_CMPL_PHC_MASTER_OPAQUE_SFT 1
	/* 8-lsb timestamp (100-msec resolution) */
	uint8_t	timestamp_lo;
	/* 16-lsb timestamp (100-msec resolution) */
	uint16_t	timestamp_hi;
	/* Event specific data */
	uint32_t	event_data1;
	/* Indicates driver action requested */
	#define HWRM_ASYNC_EVENT_CMPL_PHC_MASTER_EVENT_DATA1_FLAGS_MASK		UINT32_C(0xff)
	#define HWRM_ASYNC_EVENT_CMPL_PHC_MASTER_EVENT_DATA1_FLAGS_SFT		0
	/*
	 * If set to 1, this function is selected as Master function.
	 * A function is selected as PHC master if it's the first one
	 * that tries to configure PHC.
	 * If set to 0, this function is not the Master.
	 * If master_selected is set to 1, driver should prevent PHC
	 * configuration requests from being sent down. Firmware will
	 * reject requests from this non-master.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_PHC_MASTER_EVENT_DATA1_FLAGS_MASTER_FUNC	UINT32_C(0x1)
	/*
	 * If set to 1, indicates that PHC Master has been selected.
	 * If set to 0, indicates that PHC Master has not been selected
	 * yet.
	 * Since no PHC Master is selected, it indicates to driver that
	 * any function can send down PHC configuration requests and
	 * consequently become the PHC Master.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_PHC_MASTER_EVENT_DATA1_FLAGS_MASTER_SELECTED	UINT32_C(0x2)
} hwrm_async_event_cmpl_phc_master_t, *phwrm_async_event_cmpl_phc_master_t;

/* hwrm_async_event_cmpl_pps_timestamp (size:128b/16B) */

typedef struct hwrm_async_event_cmpl_pps_timestamp {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_PPS_TIMESTAMP_TYPE_MASK		UINT32_C(0x3f)
	#define HWRM_ASYNC_EVENT_CMPL_PPS_TIMESTAMP_TYPE_SFT		0
	/* HWRM Asynchronous Event Information */
		#define HWRM_ASYNC_EVENT_CMPL_PPS_TIMESTAMP_TYPE_HWRM_ASYNC_EVENT  UINT32_C(0x2e)
		#define HWRM_ASYNC_EVENT_CMPL_PPS_TIMESTAMP_TYPE_LAST		HWRM_ASYNC_EVENT_CMPL_PPS_TIMESTAMP_TYPE_HWRM_ASYNC_EVENT
	/* Identifiers of events. */
	uint16_t	event_id;
	/*
	 * This async notification message can be used to inform
	 * driver of the latest PPS timestamp that has been latched.
	 * When driver enables PPS event, Firmware will generate
	 * PPS timestamps every second, Firmware informs driver
	 * of this timestamp through the async event.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_PPS_TIMESTAMP_EVENT_ID_PPS_TIMESTAMP UINT32_C(0x44)
	#define HWRM_ASYNC_EVENT_CMPL_PPS_TIMESTAMP_EVENT_ID_LAST	HWRM_ASYNC_EVENT_CMPL_PPS_TIMESTAMP_EVENT_ID_PPS_TIMESTAMP
	/* Event specific data */
	uint32_t	event_data2;
	/* Indicates the PPS event type */
	#define HWRM_ASYNC_EVENT_CMPL_PPS_TIMESTAMP_EVENT_DATA2_EVENT_TYPE		UINT32_C(0x1)
	/* This is an internal event. */
		#define HWRM_ASYNC_EVENT_CMPL_PPS_TIMESTAMP_EVENT_DATA2_EVENT_TYPE_INTERNAL	UINT32_C(0x0)
	/* This is an external event. */
		#define HWRM_ASYNC_EVENT_CMPL_PPS_TIMESTAMP_EVENT_DATA2_EVENT_TYPE_EXTERNAL	UINT32_C(0x1)
		#define HWRM_ASYNC_EVENT_CMPL_PPS_TIMESTAMP_EVENT_DATA2_EVENT_TYPE_LAST	HWRM_ASYNC_EVENT_CMPL_PPS_TIMESTAMP_EVENT_DATA2_EVENT_TYPE_EXTERNAL
	/*
	 * Indicates the pin number on which the event is
	 * received.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_PPS_TIMESTAMP_EVENT_DATA2_PIN_NUMBER_MASK	UINT32_C(0xe)
	#define HWRM_ASYNC_EVENT_CMPL_PPS_TIMESTAMP_EVENT_DATA2_PIN_NUMBER_SFT	1
	/*
	 * Contains bits[47:32] of the upper PPS timestamp.
	 * Lower 32 bits are in event_data1. Together they
	 * provide the 48 bit PPS timestamp.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_PPS_TIMESTAMP_EVENT_DATA2_PPS_TIMESTAMP_UPPER_MASK UINT32_C(0xffff0)
	#define HWRM_ASYNC_EVENT_CMPL_PPS_TIMESTAMP_EVENT_DATA2_PPS_TIMESTAMP_UPPER_SFT 4
	uint8_t	opaque_v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_PPS_TIMESTAMP_V	UINT32_C(0x1)
	/* opaque is 7 b */
	#define HWRM_ASYNC_EVENT_CMPL_PPS_TIMESTAMP_OPAQUE_MASK UINT32_C(0xfe)
	#define HWRM_ASYNC_EVENT_CMPL_PPS_TIMESTAMP_OPAQUE_SFT 1
	/* 8-lsb timestamp (100-msec resolution) */
	uint8_t	timestamp_lo;
	/* 16-lsb timestamp (100-msec resolution) */
	uint16_t	timestamp_hi;
	/* Contains the lower 32 bits of the PPS timestamp. */
	uint32_t	event_data1;
	/* Contains the lower 32 bit PPS timestamp */
	#define HWRM_ASYNC_EVENT_CMPL_PPS_TIMESTAMP_EVENT_DATA1_PPS_TIMESTAMP_LOWER_MASK UINT32_C(0xffffffff)
	#define HWRM_ASYNC_EVENT_CMPL_PPS_TIMESTAMP_EVENT_DATA1_PPS_TIMESTAMP_LOWER_SFT 0
} hwrm_async_event_cmpl_pps_timestamp_t, *phwrm_async_event_cmpl_pps_timestamp_t;

/* hwrm_async_event_cmpl_fw_trace_msg (size:128b/16B) */

typedef struct hwrm_async_event_cmpl_fw_trace_msg {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_FW_TRACE_MSG_TYPE_MASK		UINT32_C(0x3f)
	#define HWRM_ASYNC_EVENT_CMPL_FW_TRACE_MSG_TYPE_SFT		0
	/* HWRM Asynchronous Event Information */
		#define HWRM_ASYNC_EVENT_CMPL_FW_TRACE_MSG_TYPE_HWRM_ASYNC_EVENT  UINT32_C(0x2e)
		#define HWRM_ASYNC_EVENT_CMPL_FW_TRACE_MSG_TYPE_LAST		HWRM_ASYNC_EVENT_CMPL_FW_TRACE_MSG_TYPE_HWRM_ASYNC_EVENT
	/* Identifiers of events. */
	uint16_t	event_id;
	/* Firmware trace log message */
	#define HWRM_ASYNC_EVENT_CMPL_FW_TRACE_MSG_EVENT_ID_FW_TRACE_MSG UINT32_C(0xfe)
	#define HWRM_ASYNC_EVENT_CMPL_FW_TRACE_MSG_EVENT_ID_LAST	HWRM_ASYNC_EVENT_CMPL_FW_TRACE_MSG_EVENT_ID_FW_TRACE_MSG
	/* Trace byte 0 to 3 */
	uint32_t	event_data2;
	/* Trace byte0 */
	#define HWRM_ASYNC_EVENT_CMPL_FW_TRACE_MSG_EVENT_DATA2_BYTE0_MASK UINT32_C(0xff)
	#define HWRM_ASYNC_EVENT_CMPL_FW_TRACE_MSG_EVENT_DATA2_BYTE0_SFT 0
	/* Trace byte1 */
	#define HWRM_ASYNC_EVENT_CMPL_FW_TRACE_MSG_EVENT_DATA2_BYTE1_MASK UINT32_C(0xff00)
	#define HWRM_ASYNC_EVENT_CMPL_FW_TRACE_MSG_EVENT_DATA2_BYTE1_SFT 8
	/* Trace byte2 */
	#define HWRM_ASYNC_EVENT_CMPL_FW_TRACE_MSG_EVENT_DATA2_BYTE2_MASK UINT32_C(0xff0000)
	#define HWRM_ASYNC_EVENT_CMPL_FW_TRACE_MSG_EVENT_DATA2_BYTE2_SFT 16
	/* Trace byte3 */
	#define HWRM_ASYNC_EVENT_CMPL_FW_TRACE_MSG_EVENT_DATA2_BYTE3_MASK UINT32_C(0xff000000)
	#define HWRM_ASYNC_EVENT_CMPL_FW_TRACE_MSG_EVENT_DATA2_BYTE3_SFT 24
	uint8_t	opaque_v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_FW_TRACE_MSG_V	UINT32_C(0x1)
	/* opaque is 7 b */
	#define HWRM_ASYNC_EVENT_CMPL_FW_TRACE_MSG_OPAQUE_MASK UINT32_C(0xfe)
	#define HWRM_ASYNC_EVENT_CMPL_FW_TRACE_MSG_OPAQUE_SFT 1
	/* Trace flags */
	uint8_t	timestamp_lo;
	/* Indicates if the string is partial or complete. */
	#define HWRM_ASYNC_EVENT_CMPL_FW_TRACE_MSG_TIMESTAMP_LO_STRING		UINT32_C(0x1)
	/* Complete string */
		#define HWRM_ASYNC_EVENT_CMPL_FW_TRACE_MSG_TIMESTAMP_LO_STRING_COMPLETE	UINT32_C(0x0)
	/* Partial string */
		#define HWRM_ASYNC_EVENT_CMPL_FW_TRACE_MSG_TIMESTAMP_LO_STRING_PARTIAL	UINT32_C(0x1)
		#define HWRM_ASYNC_EVENT_CMPL_FW_TRACE_MSG_TIMESTAMP_LO_STRING_LAST	HWRM_ASYNC_EVENT_CMPL_FW_TRACE_MSG_TIMESTAMP_LO_STRING_PARTIAL
	/* Indicates the firmware that sent the trace message. */
	#define HWRM_ASYNC_EVENT_CMPL_FW_TRACE_MSG_TIMESTAMP_LO_FIRMWARE	UINT32_C(0x2)
	/* Primary firmware */
		#define HWRM_ASYNC_EVENT_CMPL_FW_TRACE_MSG_TIMESTAMP_LO_FIRMWARE_PRIMARY	(UINT32_C(0x0) << 1)
	/* Secondary firmware */
		#define HWRM_ASYNC_EVENT_CMPL_FW_TRACE_MSG_TIMESTAMP_LO_FIRMWARE_SECONDARY  (UINT32_C(0x1) << 1)
		#define HWRM_ASYNC_EVENT_CMPL_FW_TRACE_MSG_TIMESTAMP_LO_FIRMWARE_LAST	HWRM_ASYNC_EVENT_CMPL_FW_TRACE_MSG_TIMESTAMP_LO_FIRMWARE_SECONDARY
	/* Trace byte 4 to 5 */
	uint16_t	timestamp_hi;
	/* Trace byte4 */
	#define HWRM_ASYNC_EVENT_CMPL_FW_TRACE_MSG_TIMESTAMP_HI_BYTE4_MASK UINT32_C(0xff)
	#define HWRM_ASYNC_EVENT_CMPL_FW_TRACE_MSG_TIMESTAMP_HI_BYTE4_SFT 0
	/* Trace byte5 */
	#define HWRM_ASYNC_EVENT_CMPL_FW_TRACE_MSG_TIMESTAMP_HI_BYTE5_MASK UINT32_C(0xff00)
	#define HWRM_ASYNC_EVENT_CMPL_FW_TRACE_MSG_TIMESTAMP_HI_BYTE5_SFT 8
	/* Trace byte 6 to 9 */
	uint32_t	event_data1;
	/* Trace byte6 */
	#define HWRM_ASYNC_EVENT_CMPL_FW_TRACE_MSG_EVENT_DATA1_BYTE6_MASK UINT32_C(0xff)
	#define HWRM_ASYNC_EVENT_CMPL_FW_TRACE_MSG_EVENT_DATA1_BYTE6_SFT 0
	/* Trace byte7 */
	#define HWRM_ASYNC_EVENT_CMPL_FW_TRACE_MSG_EVENT_DATA1_BYTE7_MASK UINT32_C(0xff00)
	#define HWRM_ASYNC_EVENT_CMPL_FW_TRACE_MSG_EVENT_DATA1_BYTE7_SFT 8
	/* Trace byte8 */
	#define HWRM_ASYNC_EVENT_CMPL_FW_TRACE_MSG_EVENT_DATA1_BYTE8_MASK UINT32_C(0xff0000)
	#define HWRM_ASYNC_EVENT_CMPL_FW_TRACE_MSG_EVENT_DATA1_BYTE8_SFT 16
	/* Trace byte9 */
	#define HWRM_ASYNC_EVENT_CMPL_FW_TRACE_MSG_EVENT_DATA1_BYTE9_MASK UINT32_C(0xff000000)
	#define HWRM_ASYNC_EVENT_CMPL_FW_TRACE_MSG_EVENT_DATA1_BYTE9_SFT 24
} hwrm_async_event_cmpl_fw_trace_msg_t, *phwrm_async_event_cmpl_fw_trace_msg_t;

/* hwrm_async_event_cmpl_hwrm_error (size:128b/16B) */

typedef struct hwrm_async_event_cmpl_hwrm_error {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_HWRM_ERROR_TYPE_MASK		UINT32_C(0x3f)
	#define HWRM_ASYNC_EVENT_CMPL_HWRM_ERROR_TYPE_SFT		0
	/* HWRM Asynchronous Event Information */
		#define HWRM_ASYNC_EVENT_CMPL_HWRM_ERROR_TYPE_HWRM_ASYNC_EVENT  UINT32_C(0x2e)
		#define HWRM_ASYNC_EVENT_CMPL_HWRM_ERROR_TYPE_LAST		HWRM_ASYNC_EVENT_CMPL_HWRM_ERROR_TYPE_HWRM_ASYNC_EVENT
	/* Identifiers of events. */
	uint16_t	event_id;
	/* HWRM Error */
	#define HWRM_ASYNC_EVENT_CMPL_HWRM_ERROR_EVENT_ID_HWRM_ERROR UINT32_C(0xff)
	#define HWRM_ASYNC_EVENT_CMPL_HWRM_ERROR_EVENT_ID_LAST	HWRM_ASYNC_EVENT_CMPL_HWRM_ERROR_EVENT_ID_HWRM_ERROR
	/* Event specific data */
	uint32_t	event_data2;
	/* Severity of HWRM Error */
	#define HWRM_ASYNC_EVENT_CMPL_HWRM_ERROR_EVENT_DATA2_SEVERITY_MASK	UINT32_C(0xff)
	#define HWRM_ASYNC_EVENT_CMPL_HWRM_ERROR_EVENT_DATA2_SEVERITY_SFT	0
	/* Warning */
		#define HWRM_ASYNC_EVENT_CMPL_HWRM_ERROR_EVENT_DATA2_SEVERITY_WARNING   UINT32_C(0x0)
	/* Non-fatal Error */
		#define HWRM_ASYNC_EVENT_CMPL_HWRM_ERROR_EVENT_DATA2_SEVERITY_NONFATAL  UINT32_C(0x1)
	/* Fatal Error */
		#define HWRM_ASYNC_EVENT_CMPL_HWRM_ERROR_EVENT_DATA2_SEVERITY_FATAL	UINT32_C(0x2)
		#define HWRM_ASYNC_EVENT_CMPL_HWRM_ERROR_EVENT_DATA2_SEVERITY_LAST	HWRM_ASYNC_EVENT_CMPL_HWRM_ERROR_EVENT_DATA2_SEVERITY_FATAL
	uint8_t	opaque_v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define HWRM_ASYNC_EVENT_CMPL_HWRM_ERROR_V	UINT32_C(0x1)
	/* opaque is 7 b */
	#define HWRM_ASYNC_EVENT_CMPL_HWRM_ERROR_OPAQUE_MASK UINT32_C(0xfe)
	#define HWRM_ASYNC_EVENT_CMPL_HWRM_ERROR_OPAQUE_SFT 1
	/* 8-lsb timestamp from POR (100-msec resolution) */
	uint8_t	timestamp_lo;
	/* 16-lsb timestamp from POR (100-msec resolution) */
	uint16_t	timestamp_hi;
	/* Event specific data */
	uint32_t	event_data1;
	/* Time stamp for error event */
	#define HWRM_ASYNC_EVENT_CMPL_HWRM_ERROR_EVENT_DATA1_TIMESTAMP	UINT32_C(0x1)
} hwrm_async_event_cmpl_hwrm_error_t, *phwrm_async_event_cmpl_hwrm_error_t;

/* metadata_base_msg (size:64b/8B) */

typedef struct metadata_base_msg {
	uint16_t	md_type_link;
	/* This field classifies the data present in the meta-data. */
	#define METADATA_BASE_MSG_MD_TYPE_MASK	UINT32_C(0x1f)
	#define METADATA_BASE_MSG_MD_TYPE_SFT	0
	/* Meta data fields are not valid */
		#define METADATA_BASE_MSG_MD_TYPE_NONE	UINT32_C(0x0)
	/*
	 * This setting is used when packets are coming in-order. Depending on
	 * the state of the receive context, the meta-data will carry different
	 * information.
	 */
		#define METADATA_BASE_MSG_MD_TYPE_TLS_INSYNC  UINT32_C(0x1)
	/*
	 * With this setting HW passes the TCP sequence number of the TLS
	 * record that it is requesting a resync on in the meta data.
	 */
		#define METADATA_BASE_MSG_MD_TYPE_TLS_RESYNC  UINT32_C(0x2)
		#define METADATA_BASE_MSG_MD_TYPE_LAST	METADATA_BASE_MSG_MD_TYPE_TLS_RESYNC
	/*
	 * This field indicates where the next metadata block starts. It is
	 * counted in 16B units. A value of zero indicates that there is no
	 * metadata.
	 */
	#define METADATA_BASE_MSG_LINK_MASK	UINT32_C(0x1e0)
	#define METADATA_BASE_MSG_LINK_SFT	5
	uint16_t	unused0;
	uint32_t	unused1;
} metadata_base_msg_t, *pmetadata_base_msg_t;

/* tls_metadata_base_msg (size:64b/8B) */

typedef struct tls_metadata_base_msg {
	uint32_t	md_type_link_flags_kid_lo;
	/* This field classifies the data present in the meta-data. */
	#define TLS_METADATA_BASE_MSG_MD_TYPE_MASK		UINT32_C(0x1f)
	#define TLS_METADATA_BASE_MSG_MD_TYPE_SFT		0
	/*
	 * This setting is used when packets are coming in-order. Depending on
	 * the state of the receive context, the meta-data will carry different
	 * information.
	 */
		#define TLS_METADATA_BASE_MSG_MD_TYPE_TLS_INSYNC		UINT32_C(0x1)
	/*
	 * With this setting HW passes the TCP sequence number of the TLS
	 * record that it is requesting a resync on in the meta data.
	 */
		#define TLS_METADATA_BASE_MSG_MD_TYPE_TLS_RESYNC		UINT32_C(0x2)
		#define TLS_METADATA_BASE_MSG_MD_TYPE_LAST		TLS_METADATA_BASE_MSG_MD_TYPE_TLS_RESYNC
	/*
	 * This field indicates where the next metadata block starts. It is
	 * counted in 16B units. A value of zero indicates that there is no
	 * metadata.
	 */
	#define TLS_METADATA_BASE_MSG_LINK_MASK			UINT32_C(0x1e0)
	#define TLS_METADATA_BASE_MSG_LINK_SFT			5
	/* These are flags present in the metadata. */
	#define TLS_METADATA_BASE_MSG_FLAGS_MASK		UINT32_C(0x1fffe00)
	#define TLS_METADATA_BASE_MSG_FLAGS_SFT			9
	/*
	 * A value of 1 implies that the packet was decrypted by HW. Otherwise
	 * the packet is passed on as it came in on the wire.
	 */
	#define TLS_METADATA_BASE_MSG_FLAGS_DECRYPTED		UINT32_C(0x200)
	/*
	 * This field indicates the state of the ghash field passed in the
	 * meta-data.
	 */
	#define TLS_METADATA_BASE_MSG_FLAGS_GHASH_MASK		UINT32_C(0xc00)
	#define TLS_METADATA_BASE_MSG_FLAGS_GHASH_SFT		10
	/*
	 * This enumeration states that the ghash is not valid in the
	 * meta-data.
	 */
		#define TLS_METADATA_BASE_MSG_FLAGS_GHASH_NOT_VALID	(UINT32_C(0x0) << 10)
	/*
	 * This enumeration indicates that this pkt contains the record's
	 * tag and this pkt was received ooo, the partial_ghash field
	 * contains the ghash.
	 */
		#define TLS_METADATA_BASE_MSG_FLAGS_GHASH_CUR_REC		(UINT32_C(0x1) << 10)
	/*
	 * This enumeration indicates that the current record's tag wasn't
	 * seen and the chip is moving on to the next record, the
	 * partial_ghash field contains the ghash.
	 */
		#define TLS_METADATA_BASE_MSG_FLAGS_GHASH_PRIOR_REC	(UINT32_C(0x2) << 10)
		#define TLS_METADATA_BASE_MSG_FLAGS_GHASH_LAST		TLS_METADATA_BASE_MSG_FLAGS_GHASH_PRIOR_REC
	/* This field indicates the status of tag authentication. */
	#define TLS_METADATA_BASE_MSG_FLAGS_TAG_AUTH_STATUS_MASK	UINT32_C(0x3000)
	#define TLS_METADATA_BASE_MSG_FLAGS_TAG_AUTH_STATUS_SFT	12
	/*
	 * This enumeration is set when there is no tags present in the
	 * packet.
	 */
		#define TLS_METADATA_BASE_MSG_FLAGS_TAG_AUTH_STATUS_NONE	(UINT32_C(0x0) << 12)
	/*
	 * This enumeration states that there is at least one tag in the
	 * packet and every tag is valid.
	 */
		#define TLS_METADATA_BASE_MSG_FLAGS_TAG_AUTH_STATUS_SUCCESS   (UINT32_C(0x1) << 12)
	/*
	 * This enumeration states that there is at least one tag in the
	 * packet and at least one of the tag is invalid. The entire packet
	 * is sent decrypted to the host.
	 */
		#define TLS_METADATA_BASE_MSG_FLAGS_TAG_AUTH_STATUS_FAILURE   (UINT32_C(0x2) << 12)
		#define TLS_METADATA_BASE_MSG_FLAGS_TAG_AUTH_STATUS_LAST	TLS_METADATA_BASE_MSG_FLAGS_TAG_AUTH_STATUS_FAILURE
	/*
	 * A value of 1 indicates that this packet contains a record that
	 * starts in the packet and extends beyond the packet.
	 */
	#define TLS_METADATA_BASE_MSG_FLAGS_HEADER_FLDS_VALID	UINT32_C(0x4000)
	/*
	 * This value indicates the lower 7-bit of the Crypto Key ID
	 * associated with this operation.
	 */
	#define TLS_METADATA_BASE_MSG_KID_LO_MASK		UINT32_C(0xfe000000)
	#define TLS_METADATA_BASE_MSG_KID_LO_SFT		25
	uint16_t	kid_hi;
	/*
	 * This value indicates the upper 13-bit of the Crypto Key ID
	 * associated with this operation.
	 */
	#define TLS_METADATA_BASE_MSG_KID_HI_MASK UINT32_C(0x1fff)
	#define TLS_METADATA_BASE_MSG_KID_HI_SFT 0
	uint16_t	unused0;
} tls_metadata_base_msg_t, *ptls_metadata_base_msg_t;

/* tls_metadata_insync_msg (size:192b/24B) */

typedef struct tls_metadata_insync_msg {
	uint32_t	md_type_link_flags_kid_lo;
	/* This field classifies the data present in the meta-data. */
	#define TLS_METADATA_INSYNC_MSG_MD_TYPE_MASK		UINT32_C(0x1f)
	#define TLS_METADATA_INSYNC_MSG_MD_TYPE_SFT		0
	/*
	 * This setting is used when packets are coming in-order. Depending on
	 * the state of the receive context, the meta-data will carry different
	 * information.
	 */
		#define TLS_METADATA_INSYNC_MSG_MD_TYPE_TLS_INSYNC		UINT32_C(0x1)
		#define TLS_METADATA_INSYNC_MSG_MD_TYPE_LAST		TLS_METADATA_INSYNC_MSG_MD_TYPE_TLS_INSYNC
	/*
	 * This field indicates where the next metadata block starts. It is
	 * counted in 16B units. A value of zero indicates that there is no
	 * metadata.
	 */
	#define TLS_METADATA_INSYNC_MSG_LINK_MASK			UINT32_C(0x1e0)
	#define TLS_METADATA_INSYNC_MSG_LINK_SFT			5
	/* These are flags present in the metadata. */
	#define TLS_METADATA_INSYNC_MSG_FLAGS_MASK		UINT32_C(0x1fffe00)
	#define TLS_METADATA_INSYNC_MSG_FLAGS_SFT			9
	/*
	 * A value of 1 implies that the packet was decrypted by HW. Otherwise
	 * the packet is passed on as it came in on the wire.
	 */
	#define TLS_METADATA_INSYNC_MSG_FLAGS_DECRYPTED		UINT32_C(0x200)
	/*
	 * This field indicates the state of the ghash field passed in the
	 * meta-data.
	 */
	#define TLS_METADATA_INSYNC_MSG_FLAGS_GHASH_MASK		UINT32_C(0xc00)
	#define TLS_METADATA_INSYNC_MSG_FLAGS_GHASH_SFT		10
	/*
	 * This enumeration states that the ghash is not valid in the
	 * meta-data.
	 */
		#define TLS_METADATA_INSYNC_MSG_FLAGS_GHASH_NOT_VALID	(UINT32_C(0x0) << 10)
	/*
	 * This enumeration indicates that this pkt contains the record's
	 * tag and this pkt was received ooo, the partial_ghash field
	 * contains the ghash.
	 */
		#define TLS_METADATA_INSYNC_MSG_FLAGS_GHASH_CUR_REC		(UINT32_C(0x1) << 10)
	/*
	 * This enumeration indicates that the current record's tag wasn't
	 * seen and the chip is moving on to the next record, the
	 * partial_ghash field contains the ghash.
	 */
		#define TLS_METADATA_INSYNC_MSG_FLAGS_GHASH_PRIOR_REC	(UINT32_C(0x2) << 10)
		#define TLS_METADATA_INSYNC_MSG_FLAGS_GHASH_LAST		TLS_METADATA_INSYNC_MSG_FLAGS_GHASH_PRIOR_REC
	/* This field indicates the status of tag authentication. */
	#define TLS_METADATA_INSYNC_MSG_FLAGS_TAG_AUTH_STATUS_MASK	UINT32_C(0x3000)
	#define TLS_METADATA_INSYNC_MSG_FLAGS_TAG_AUTH_STATUS_SFT	12
	/*
	 * This enumeration is set when there is no tags present in the
	 * packet.
	 */
		#define TLS_METADATA_INSYNC_MSG_FLAGS_TAG_AUTH_STATUS_NONE	(UINT32_C(0x0) << 12)
	/*
	 * This enumeration states that there is at least one tag in the
	 * packet and every tag is valid.
	 */
		#define TLS_METADATA_INSYNC_MSG_FLAGS_TAG_AUTH_STATUS_SUCCESS   (UINT32_C(0x1) << 12)
	/*
	 * This enumeration states that there is at least one tag in the
	 * packet and at least one of the tag is invalid. The entire packet
	 * is sent decrypted to the host.
	 */
		#define TLS_METADATA_INSYNC_MSG_FLAGS_TAG_AUTH_STATUS_FAILURE   (UINT32_C(0x2) << 12)
		#define TLS_METADATA_INSYNC_MSG_FLAGS_TAG_AUTH_STATUS_LAST	TLS_METADATA_INSYNC_MSG_FLAGS_TAG_AUTH_STATUS_FAILURE
	/*
	 * A value of 1 indicates that this packet contains a record that
	 * starts in the packet and extends beyond the packet.
	 */
	#define TLS_METADATA_INSYNC_MSG_FLAGS_HEADER_FLDS_VALID	UINT32_C(0x4000)
	/*
	 * This value indicates the lower 7-bit of the Crypto Key ID
	 * associated with this operation.
	 */
	#define TLS_METADATA_INSYNC_MSG_KID_LO_MASK		UINT32_C(0xfe000000)
	#define TLS_METADATA_INSYNC_MSG_KID_LO_SFT		25
	uint16_t	kid_hi;
	/*
	 * This value indicates the upper 13-bit of the Crypto Key ID
	 * associated with this operation.
	 */
	#define TLS_METADATA_INSYNC_MSG_KID_HI_MASK UINT32_C(0x1fff)
	#define TLS_METADATA_INSYNC_MSG_KID_HI_SFT 0
	/*
	 * This field is only valid when md_type is set to tls_insync. This field
	 * indicates the offset within the current TCP packet where the TLS header
	 * starts. If there are multiple TLS headers in the packet, this provides
	 * the offset of the last TLS header.
	 *
	 * The field is calculated by subtracting TCP sequence number of the first
	 * byte of the TCP payload of the packet from the TCP sequence number of
	 * the last TLS header in the packet.
	 */
	uint16_t	tls_header_offset;
	/*
	 * This is the sequence Number of the record that was processed by the HW.
	 * If there are multiple records in a packet, this would be the sequence
	 * number of the last record.
	 */
	uint64_t	record_seq_num;
	/*
	 * This field contains cumulative partial GHASH value of all the packets
	 * decrypted by the HW associated with a TLS record. This field is valid
	 * on when packets belonging to have arrived out-of-order and HW could
	 * not decrypt every packet and authenticate the record. Partial GHASH is
	 * only sent out with packet having the TAG field.
	 */
	uint64_t	partial_ghash;
} tls_metadata_insync_msg_t, *ptls_metadata_insync_msg_t;

/* tls_metadata_resync_msg (size:256b/32B) */

typedef struct tls_metadata_resync_msg {
	uint32_t	md_type_link_flags_kid_lo;
	/* This field classifies the data present in the meta-data. */
	#define TLS_METADATA_RESYNC_MSG_MD_TYPE_MASK		UINT32_C(0x1f)
	#define TLS_METADATA_RESYNC_MSG_MD_TYPE_SFT		0
	/*
	 * With this setting HW passes the TCP sequence number of the TLS
	 * record that it is requesting a resync on in the meta data.
	 */
		#define TLS_METADATA_RESYNC_MSG_MD_TYPE_TLS_RESYNC		UINT32_C(0x2)
		#define TLS_METADATA_RESYNC_MSG_MD_TYPE_LAST		TLS_METADATA_RESYNC_MSG_MD_TYPE_TLS_RESYNC
	/*
	 * This field indicates where the next metadata block starts. It is
	 * counted in 16B units. A value of zero indicates that there is no
	 * metadata.
	 */
	#define TLS_METADATA_RESYNC_MSG_LINK_MASK		UINT32_C(0x1e0)
	#define TLS_METADATA_RESYNC_MSG_LINK_SFT			5
	/* These are flags present in the metadata. */
	#define TLS_METADATA_RESYNC_MSG_FLAGS_MASK		UINT32_C(0x1fffe00)
	#define TLS_METADATA_RESYNC_MSG_FLAGS_SFT		9
	/*
	 * A value of 1 implies that the packet was decrypted by HW. Otherwise
	 * the packet is passed on as it came in on the wire.
	 */
	#define TLS_METADATA_RESYNC_MSG_FLAGS_DECRYPTED		UINT32_C(0x200)
	/*
	 * This field indicates the state of the ghash field passed in the
	 * meta-data.
	 */
	#define TLS_METADATA_RESYNC_MSG_FLAGS_GHASH_MASK		UINT32_C(0xc00)
	#define TLS_METADATA_RESYNC_MSG_FLAGS_GHASH_SFT		10
	/*
	 * This enumeration states that the ghash is not valid in the
	 * meta-data.
	 */
		#define TLS_METADATA_RESYNC_MSG_FLAGS_GHASH_NOT_VALID	(UINT32_C(0x0) << 10)
		#define TLS_METADATA_RESYNC_MSG_FLAGS_GHASH_LAST		TLS_METADATA_RESYNC_MSG_FLAGS_GHASH_NOT_VALID
	/* This field indicates the status of tag authentication. */
	#define TLS_METADATA_RESYNC_MSG_FLAGS_TAG_AUTH_STATUS_MASK   UINT32_C(0x3000)
	#define TLS_METADATA_RESYNC_MSG_FLAGS_TAG_AUTH_STATUS_SFT	12
	/*
	 * This enumeration is set when there is no tags present in the
	 * packet.
	 */
		#define TLS_METADATA_RESYNC_MSG_FLAGS_TAG_AUTH_STATUS_NONE	(UINT32_C(0x0) << 12)
		#define TLS_METADATA_RESYNC_MSG_FLAGS_TAG_AUTH_STATUS_LAST	TLS_METADATA_RESYNC_MSG_FLAGS_TAG_AUTH_STATUS_NONE
	/*
	 * A value of 1 indicates that this packet contains a record that
	 * starts in the packet and extends beyond the packet.
	 */
	#define TLS_METADATA_RESYNC_MSG_FLAGS_HEADER_FLDS_VALID	UINT32_C(0x4000)
	/*
	 * This value indicates the lower 7-bit of the Crypto Key ID
	 * associated with this operation.
	 */
	#define TLS_METADATA_RESYNC_MSG_KID_LO_MASK		UINT32_C(0xfe000000)
	#define TLS_METADATA_RESYNC_MSG_KID_LO_SFT		25
	uint16_t	kid_hi;
	/*
	 * This value indicates the upper 13-bit of the Crypto Key ID
	 * associated with this operation.
	 */
	#define TLS_METADATA_RESYNC_MSG_KID_HI_MASK UINT32_C(0x1fff)
	#define TLS_METADATA_RESYNC_MSG_KID_HI_SFT 0
	/* This field is unused in this context. */
	uint16_t	metadata_0;
	/*
	 * This field indicates the TCP sequence number of the TLS record that HW
	 * is requesting a resync on from the Driver. HW will keep a count of the
	 * TLS records it found after this record (delta_records). Driver will
	 * provide the TLS Record Sequence Number associated with the record. HW
	 * will add the delta_records to the Record Sequence Number provided by
	 * the driver and get back on sync.
	 */
	uint32_t	resync_record_tcp_seq_num;
	uint32_t	unused0;
	/* This field is unused in this context. */
	uint64_t	metadata_2;
	/* This field is unused in this context. */
	uint64_t	metadata_3;
} tls_metadata_resync_msg_t, *ptls_metadata_resync_msg_t;

/* tx_doorbell (size:32b/4B) */

typedef struct tx_doorbell {
	uint32_t	key_idx;
	/*
	 * BD Index of next BD that will be used to transmit data
	 * on the TX ring mapped to this door bell.  NIC may
	 * read and process all BDs up to, but not including this
	 * index.
	 */
	#define TX_DOORBELL_IDX_MASK UINT32_C(0xffffff)
	#define TX_DOORBELL_IDX_SFT 0
	/*
	 * This value indicates the type of door bell operation
	 * that is begin requested.   This value is '0' for TX
	 * door bell operations.
	 */
	#define TX_DOORBELL_KEY_MASK UINT32_C(0xf0000000)
	#define TX_DOORBELL_KEY_SFT 28
	/* TX Operation */
		#define TX_DOORBELL_KEY_TX	(UINT32_C(0x0) << 28)
		#define TX_DOORBELL_KEY_LAST TX_DOORBELL_KEY_TX
} tx_doorbell_t, *ptx_doorbell_t;

/* rx_doorbell (size:32b/4B) */

typedef struct rx_doorbell {
	uint32_t	key_idx;
	/*
	 * BD Index of next BD that will be used for an empty receive
	 * buffer on the RX ring mapped to this door bell.  NIC may
	 * read and process all BDs up to, but not including this
	 * index.
	 */
	#define RX_DOORBELL_IDX_MASK UINT32_C(0xffffff)
	#define RX_DOORBELL_IDX_SFT 0
	/*
	 * This value indicates the type of door bell operation
	 * that is begin requested.   This value is '1' for RX
	 * door bell operations.
	 */
	#define RX_DOORBELL_KEY_MASK UINT32_C(0xf0000000)
	#define RX_DOORBELL_KEY_SFT 28
	/* RX Operation */
		#define RX_DOORBELL_KEY_RX	(UINT32_C(0x1) << 28)
		#define RX_DOORBELL_KEY_LAST RX_DOORBELL_KEY_RX
} rx_doorbell_t, *prx_doorbell_t;

/* cmpl_doorbell (size:32b/4B) */

typedef struct cmpl_doorbell {
	uint32_t	key_mask_valid_idx;
	/*
	 * BD Index of the most recently handed completion record
	 * on the completion ring mapped to this door bell.
	 * NIC may
	 * write this location again with a new completion.
	 */
	#define CMPL_DOORBELL_IDX_MASK	UINT32_C(0xffffff)
	#define CMPL_DOORBELL_IDX_SFT	0
	/*
	 * This indicates if the BDIDX value is valid for this
	 * update when it is '1'.  When it is '0', the BDIDX
	 * value should be ignored.
	 */
	#define CMPL_DOORBELL_IDX_VALID	UINT32_C(0x4000000)
	/*
	 * This bit indicates the new interrupt mask state for the
	 * interrupt associated with the BDIDX.  A '1', means the
	 * interrupt is to be masked.  A '0' indicates the interrupt
	 * is to be unmasked.
	 */
	#define CMPL_DOORBELL_MASK	UINT32_C(0x8000000)
	/*
	 * This value indicates the type of door bell operation
	 * that is begin requested.   This value is '2' for CMP
	 * door bell operations.
	 */
	#define CMPL_DOORBELL_KEY_MASK	UINT32_C(0xf0000000)
	#define CMPL_DOORBELL_KEY_SFT	28
	/* Completion Operation */
		#define CMPL_DOORBELL_KEY_CMPL	(UINT32_C(0x2) << 28)
		#define CMPL_DOORBELL_KEY_LAST	CMPL_DOORBELL_KEY_CMPL
} cmpl_doorbell_t, *pcmpl_doorbell_t;

/* status_doorbell (size:32b/4B) */

typedef struct status_doorbell {
	uint32_t	key_idx;
	/*
	 * BD Index of the status record for which space is now
	 * available to the NIC.
	 */
	#define STATUS_DOORBELL_IDX_MASK UINT32_C(0xffffff)
	#define STATUS_DOORBELL_IDX_SFT 0
	/*
	 * This value indicates the type of door bell operation
	 * that is begin requested.   This value is '3' for Status
	 * door bell operations.
	 */
	#define STATUS_DOORBELL_KEY_MASK UINT32_C(0xf0000000)
	#define STATUS_DOORBELL_KEY_SFT 28
	/* Status Operation */
		#define STATUS_DOORBELL_KEY_STAT  (UINT32_C(0x3) << 28)
		#define STATUS_DOORBELL_KEY_LAST STATUS_DOORBELL_KEY_STAT
} status_doorbell_t, *pstatus_doorbell_t;

/* push32_doorbell (size:1024b/128B) */

typedef struct push32_doorbell {
	uint32_t	key_sz_idx;
	/*
	 * This is the BD Index of last BD of the push packet
	 * that will be used to transmit data on the TX ring mapped
	 * to this door bell.
	 */
	#define PUSH32_DOORBELL_IDX_MASK UINT32_C(0xffffff)
	#define PUSH32_DOORBELL_IDX_SFT 0
	/*
	 * This is the number of 16B BDs spaces consumed in the TX
	 * Ring by the "backup" version of the packet being pushed.
	 * A value of 1 is invalid since backup must start with a
	 * long 32B BE.
	 * A value of 2 indicates just the first 32B BE.
	 * A value of 3 indicates 32B+16B BD.  etc.
	 * A value of 0 indicates 16x16B BD spaces are consumed.
	 */
	#define PUSH32_DOORBELL_SZ_MASK UINT32_C(0xf000000)
	#define PUSH32_DOORBELL_SZ_SFT  24
	/*
	 * This value indicates the type of door bell operation
	 * that is begin requested.   This value is 4 for push
	 * door bell operations.
	 */
	#define PUSH32_DOORBELL_KEY_MASK UINT32_C(0xf0000000)
	#define PUSH32_DOORBELL_KEY_SFT 28
	/* Push Operation */
		#define PUSH32_DOORBELL_KEY_PUSH  (UINT32_C(0x4) << 28)
		#define PUSH32_DOORBELL_KEY_LAST PUSH32_DOORBELL_KEY_PUSH
	uint16_t	flags_type;
	/* This value identifies the type of buffer descriptor. */
	#define PUSH32_DOORBELL_TYPE_MASK		UINT32_C(0x3f)
	#define PUSH32_DOORBELL_TYPE_SFT		0
	/*
	 * Indicates that this BD is 32B long and is used for
	 * normal L2 packet transmission.
	 */
		#define PUSH32_DOORBELL_TYPE_TX_BD_LONG	UINT32_C(0x10)
		#define PUSH32_DOORBELL_TYPE_LAST		PUSH32_DOORBELL_TYPE_TX_BD_LONG
	/*
	 * All bits in this field must be valid on the first BD of a packet.
	 * Only the packet_end bit must be valid for the remaining BDs
	 * of a packet.
	 */
	#define PUSH32_DOORBELL_FLAGS_MASK	UINT32_C(0xffc0)
	#define PUSH32_DOORBELL_FLAGS_SFT		6
	/*
	 * If set to 1, the packet ends with the data in the buffer
	 * pointed to by this descriptor.  This flag must be
	 * valid on every BD.
	 *
	 *	This bit must be set on all push doorbells.
	 */
	#define PUSH32_DOORBELL_FLAGS_PACKET_END	UINT32_C(0x40)
	/*
	 * If set to 1, the device will not generate a completion for
	 * this transmit packet unless there is an error in it's
	 * processing.
	 * If this bit
	 * is set to 0, then the packet will be completed normally.
	 *
	 * This bit must be valid only on the first BD of a packet.
	 */
	#define PUSH32_DOORBELL_FLAGS_NO_CMPL	UINT32_C(0x80)
	/*
	 * This value must match the sz field in the first
	 * 32b of the push operation except that if
	 * 16x16B BD locations
	 * are consumed in the ring by this packet, then
	 * this value must be 16 (not zero).
	 */
	#define PUSH32_DOORBELL_FLAGS_BD_CNT_MASK	UINT32_C(0x1f00)
	#define PUSH32_DOORBELL_FLAGS_BD_CNT_SFT	8
	/*
	 * This value is a hint for the length of the entire packet.
	 * It is used by the chip to optimize internal processing.
	 *
	 * The packet will be dropped if the hint is too short.
	 *
	 * This field is valid only on the first BD of a packet.
	 */
	#define PUSH32_DOORBELL_FLAGS_LHINT_MASK	UINT32_C(0x6000)
	#define PUSH32_DOORBELL_FLAGS_LHINT_SFT	13
	/* indicates packet length < 512B */
		#define PUSH32_DOORBELL_FLAGS_LHINT_LT512	(UINT32_C(0x0) << 13)
	/* indicates 512 <= packet length < 1KB */
		#define PUSH32_DOORBELL_FLAGS_LHINT_LT1K	(UINT32_C(0x1) << 13)
	/* indicates 1KB <= packet length < 2KB */
		#define PUSH32_DOORBELL_FLAGS_LHINT_LT2K	(UINT32_C(0x2) << 13)
	/* indicates packet length >= 2KB */
		#define PUSH32_DOORBELL_FLAGS_LHINT_GTE2K	(UINT32_C(0x3) << 13)
		#define PUSH32_DOORBELL_FLAGS_LHINT_LAST	PUSH32_DOORBELL_FLAGS_LHINT_GTE2K
	/*
	 * If set to 1, the device immediately updates the Send Consumer
	 * Index after the buffer associated with this descriptor has
	 * been transferred via DMA to NIC memory from host memory. An
	 * interrupt may or may not be generated according to the state
	 * of the interrupt avoidance mechanisms. If this bit
	 * is set to 0, then the Consumer Index is only updated as soon
	 * as one of the host interrupt coalescing conditions has been met.
	 *
	 * This bit must be valid on the first BD of a packet.
	 */
	#define PUSH32_DOORBELL_FLAGS_COAL_NOW	UINT32_C(0x8000)
	/*
	 * This is the length of the host physical buffer this BD describes
	 * in bytes.
	 *
	 * This field must be valid on all BDs of a packet.
	 */
	uint16_t	len;
	/*
	 * The opaque data field is pass through to the completion and can be
	 * used for any data that the driver wants to associate with the
	 * transmit BD.
	 *
	 * This field must be valid on the first BD of a packet.
	 */
	uint32_t	opaque;
	/*
	 * All bits in this field must be valid on the first BD of a packet.
	 * Their value on other BDs of the packet will be ignored.
	 */
	uint16_t	lflags;
	/*
	 * If set to 1, the controller replaces the TCP/UPD checksum
	 * fields of normal TCP/UPD checksum, or the inner TCP/UDP
	 * checksum field of the encapsulated TCP/UDP packets with the
	 * hardware calculated TCP/UDP checksum for the packet associated
	 * with this descriptor. The flag is ignored if the LSO flag is set.
	 *
	 * This bit must be valid on the first BD of a packet.
	 */
	#define PUSH32_DOORBELL_LFLAGS_TCP_UDP_CHKSUM	UINT32_C(0x1)
	/*
	 * If set to 1, the controller replaces the IP checksum of the
	 * normal packets, or the inner IP checksum of the encapsulated
	 * packets with the hardware calculated IP checksum for the
	 * packet associated with this descriptor.
	 *
	 * This bit must be valid on the first BD of a packet.
	 */
	#define PUSH32_DOORBELL_LFLAGS_IP_CHKSUM	UINT32_C(0x2)
	/*
	 * If set to 1, the controller will not append an Ethernet CRC
	 * to the end of the frame.
	 *
	 * This bit must be valid on the first BD of a packet.
	 *
	 * Packet must be 64B or longer when this flag is set.  It is not
	 * useful to use this bit with any form of TX offload such as
	 * CSO or LSO.  The intent is that the packet from the host already
	 * has a valid Ethernet CRC on the packet.
	 */
	#define PUSH32_DOORBELL_LFLAGS_NOCRC		UINT32_C(0x4)
	/*
	 * If set to 1, the device will record the time at which the packet
	 * was actually transmitted at the TX MAC.
	 *
	 * This bit must be valid on the first BD of a packet.
	 */
	#define PUSH32_DOORBELL_LFLAGS_STAMP		UINT32_C(0x8)
	/*
	 * If set to 1, The controller replaces the tunnel IP checksum
	 * field with hardware calculated IP checksum for the IP header
	 * of the packet associated with this descriptor.
	 *
	 * For outer UDP checksum, global outer UDP checksum TE_NIC register
	 * needs to be enabled. If the global outer UDP checksum TE_NIC register
	 * bit is set, outer UDP checksum will be calculated for the following
	 * cases:
	 * 1. Packets with tcp_udp_chksum flag set to offload checksum for inner
	 * packet AND the inner packet is TCP/UDP. If the inner packet is ICMP for
	 * example (non-TCP/UDP), even if the tcp_udp_chksum is set, the outer UDP
	 * checksum will not be calculated.
	 * 2. Packets with lso flag set which implies inner TCP checksum calculation
	 * as part of LSO operation.
	 */
	#define PUSH32_DOORBELL_LFLAGS_T_IP_CHKSUM	UINT32_C(0x10)
	/*
	 * If set to 1, the device will treat this packet with LSO(Large
	 * Send Offload) processing for both normal or encapsulated
	 * packets, which is a form of TCP segmentation.  When this bit
	 * is 1, the hdr_size and mss fields must be valid. The driver
	 * doesn't need to set t_ip_chksum, ip_chksum, and tcp_udp_chksum
	 * flags since the controller will replace the appropriate
	 * checksum fields for segmented packets.
	 *
	 * When this bit is 1, the hdr_size and mss fields must be valid.
	 */
	#define PUSH32_DOORBELL_LFLAGS_LSO		UINT32_C(0x20)
	/*
	 * If set to zero when LSO is '1', then the IPID will be treated
	 * as a 16b number and will be wrapped if it exceeds a value of
	 * 0xffff.
	 *
	 * If set to one when LSO is '1', then the IPID will be treated
	 * as a 15b number and will be wrapped if it exceeds a value 0f
	 * 0x7fff.
	 */
	#define PUSH32_DOORBELL_LFLAGS_IPID_FMT	UINT32_C(0x40)
	/*
	 * If set to zero when LSO is '1', then the IPID of the tunnel
	 * IP header will not be modified during LSO operations.
	 *
	 * If set to one when LSO is '1', then the IPID of the tunnel
	 * IP header will be incremented for each subsequent segment of an
	 * LSO operation.
	 *
	 * The flag is ignored if the LSO packet is a normal (non-tunneled)
	 * TCP packet.
	 */
	#define PUSH32_DOORBELL_LFLAGS_T_IPID		UINT32_C(0x80)
	/*
	 * If set to '1', then the RoCE ICRC will be appended to the
	 * packet.  Packet must be a valid RoCE format packet.
	 */
	#define PUSH32_DOORBELL_LFLAGS_ROCE_CRC	UINT32_C(0x100)
	/*
	 * If set to '1', then the FCoE CRC will be appended to the
	 * packet.  Packet must be a valid FCoE format packet.
	 */
	#define PUSH32_DOORBELL_LFLAGS_FCOE_CRC	UINT32_C(0x200)
	uint16_t	hdr_size;
	/*
	 * When LSO is '1', this field must contain the offset of the
	 * TCP payload from the beginning of the packet in as
	 * 16b words. In case of encapsulated/tunneling packet, this field
	 * contains the offset of the inner TCP payload from beginning of the
	 * packet as 16-bit words.
	 *
	 * This value must be valid on the first BD of a packet.
	 */
	#define PUSH32_DOORBELL_HDR_SIZE_MASK UINT32_C(0x1ff)
	#define PUSH32_DOORBELL_HDR_SIZE_SFT 0
	uint32_t	mss;
	/*
	 * This is the MSS value that will be used to do the LSO processing.
	 * The value is the length in bytes of the TCP payload for each
	 * segment generated by the LSO operation.
	 *
	 * This value must be valid on the first BD of a packet.
	 */
	#define PUSH32_DOORBELL_MSS_MASK UINT32_C(0x7fff)
	#define PUSH32_DOORBELL_MSS_SFT 0
	uint16_t	unused_2;
	/*
	 * This value selects a CFA action to perform on the packet.
	 * Set this value to zero if no CFA action is desired.
	 *
	 * This value must be valid on the first BD of a packet.
	 */
	uint16_t	cfa_action;
	/*
	 * This value is action meta-data that defines CFA edit operations
	 * that are done in addition to any action editing.
	 */
	uint32_t	cfa_meta;
	/* When key=1, This is the VLAN tag VID value. */
	#define PUSH32_DOORBELL_CFA_META_VLAN_VID_MASK	UINT32_C(0xfff)
	#define PUSH32_DOORBELL_CFA_META_VLAN_VID_SFT	0
	/* When key=1, This is the VLAN tag DE value. */
	#define PUSH32_DOORBELL_CFA_META_VLAN_DE	UINT32_C(0x1000)
	/* When key=1, This is the VLAN tag PRI value. */
	#define PUSH32_DOORBELL_CFA_META_VLAN_PRI_MASK	UINT32_C(0xe000)
	#define PUSH32_DOORBELL_CFA_META_VLAN_PRI_SFT	13
	/* When key=1, This is the VLAN tag TPID select value. */
	#define PUSH32_DOORBELL_CFA_META_VLAN_TPID_MASK	UINT32_C(0x70000)
	#define PUSH32_DOORBELL_CFA_META_VLAN_TPID_SFT	16
	/* 0x88a8 */
		#define PUSH32_DOORBELL_CFA_META_VLAN_TPID_TPID88A8  (UINT32_C(0x0) << 16)
	/* 0x8100 */
		#define PUSH32_DOORBELL_CFA_META_VLAN_TPID_TPID8100  (UINT32_C(0x1) << 16)
	/* 0x9100 */
		#define PUSH32_DOORBELL_CFA_META_VLAN_TPID_TPID9100  (UINT32_C(0x2) << 16)
	/* 0x9200 */
		#define PUSH32_DOORBELL_CFA_META_VLAN_TPID_TPID9200  (UINT32_C(0x3) << 16)
	/* 0x9300 */
		#define PUSH32_DOORBELL_CFA_META_VLAN_TPID_TPID9300  (UINT32_C(0x4) << 16)
	/* Value programmed in CFA VLANTPID register. */
		#define PUSH32_DOORBELL_CFA_META_VLAN_TPID_TPIDCFG   (UINT32_C(0x5) << 16)
		#define PUSH32_DOORBELL_CFA_META_VLAN_TPID_LAST	PUSH32_DOORBELL_CFA_META_VLAN_TPID_TPIDCFG
	/* When key=1, This is the VLAN tag TPID select value. */
	#define PUSH32_DOORBELL_CFA_META_VLAN_RESERVED_MASK UINT32_C(0xff80000)
	#define PUSH32_DOORBELL_CFA_META_VLAN_RESERVED_SFT 19
	/*
	 * This field identifies the type of edit to be performed
	 * on the packet.
	 *
	 * This value must be valid on the first BD of a packet.
	 */
	#define PUSH32_DOORBELL_CFA_META_KEY_MASK	UINT32_C(0xf0000000)
	#define PUSH32_DOORBELL_CFA_META_KEY_SFT	28
	/* No editing */
		#define PUSH32_DOORBELL_CFA_META_KEY_NONE		(UINT32_C(0x0) << 28)
	/*
	 * - meta[17:16] - TPID select value (0 = 0x8100).
	 * - meta[15:12] - PRI/DE value.
	 * - meta[11:0] - VID value.
	 */
		#define PUSH32_DOORBELL_CFA_META_KEY_VLAN_TAG	(UINT32_C(0x1) << 28)
		#define PUSH32_DOORBELL_CFA_META_KEY_LAST	PUSH32_DOORBELL_CFA_META_KEY_VLAN_TAG
	/*
	 * This is the data for the push packet.  If the packet
	 * data does not fit in the first pass, data writing
	 * can continue at offset 4 of the doorbell for up to 4 additional
	 * passes for a total data size of 512B maximum.
	 */
	uint32_t	data[25];
} push32_doorbell_t, *ppush32_doorbell_t;

/*******************
 * hwrm_func_reset *
 *******************/


/* hwrm_func_reset_input (size:192b/24B) */

typedef struct hwrm_func_reset_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	enables;
	/*
	 * This bit must be '1' for the vf_id_valid field to be
	 * configured.
	 */
	#define HWRM_FUNC_RESET_INPUT_ENABLES_VF_ID_VALID	UINT32_C(0x1)
	/*
	 * The ID of the VF that this PF is trying to reset.
	 * Only the parent PF shall be allowed to reset a child VF.
	 *
	 * A parent PF driver shall use this field only when a specific child VF
	 * is requested to be reset.
	 */
	uint16_t	vf_id;
	/* This value indicates the level of a function reset. */
	uint8_t	func_reset_level;
	/*
	 * Reset the caller function and its children VFs (if any). If no
	 * children functions exist, then reset the caller function only.
	 */
	#define HWRM_FUNC_RESET_INPUT_FUNC_RESET_LEVEL_RESETALL	UINT32_C(0x0)
	/* Reset the caller function only */
	#define HWRM_FUNC_RESET_INPUT_FUNC_RESET_LEVEL_RESETME	UINT32_C(0x1)
	/*
	 * Reset all children VFs of the caller function driver if the
	 * caller is a PF driver.
	 * It is an error to specify this level by a VF driver.
	 * It is an error to specify this level by a PF driver with
	 * no children VFs.
	 */
	#define HWRM_FUNC_RESET_INPUT_FUNC_RESET_LEVEL_RESETCHILDREN UINT32_C(0x2)
	/*
	 * Reset a specific VF of the caller function driver if the caller
	 * is the parent PF driver.
	 * It is an error to specify this level by a VF driver.
	 * It is an error to specify this level by a PF driver that is not
	 * the parent of the VF that is being requested to reset.
	 */
	#define HWRM_FUNC_RESET_INPUT_FUNC_RESET_LEVEL_RESETVF	UINT32_C(0x3)
	#define HWRM_FUNC_RESET_INPUT_FUNC_RESET_LEVEL_LAST	HWRM_FUNC_RESET_INPUT_FUNC_RESET_LEVEL_RESETVF
	uint8_t	unused_0;
} hwrm_func_reset_input_t, *phwrm_func_reset_input_t;

/* hwrm_func_reset_output (size:128b/16B) */

typedef struct hwrm_func_reset_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_func_reset_output_t, *phwrm_func_reset_output_t;

/********************
 * hwrm_func_getfid *
 ********************/


/* hwrm_func_getfid_input (size:192b/24B) */

typedef struct hwrm_func_getfid_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	enables;
	/*
	 * This bit must be '1' for the pci_id field to be
	 * configured.
	 */
	#define HWRM_FUNC_GETFID_INPUT_ENABLES_PCI_ID	UINT32_C(0x1)
	/*
	 * This value is the PCI ID of the queried function.
	 * If ARI is enabled, then it is
	 * Bus Number (8b):Function Number(8b). Otherwise, it is
	 * Bus Number (8b):Device Number (5b):Function Number(3b).
	 */
	uint16_t	pci_id;
	uint8_t	unused_0[2];
} hwrm_func_getfid_input_t, *phwrm_func_getfid_input_t;

/* hwrm_func_getfid_output (size:128b/16B) */

typedef struct hwrm_func_getfid_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * FID value.  This value is used to identify operations on the PCI
	 * bus as belonging to a particular PCI function.
	 */
	uint16_t	fid;
	uint8_t	unused_0[5];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_func_getfid_output_t, *phwrm_func_getfid_output_t;

/**********************
 * hwrm_func_vf_alloc *
 **********************/


/* hwrm_func_vf_alloc_input (size:192b/24B) */

typedef struct hwrm_func_vf_alloc_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	enables;
	/*
	 * This bit must be '1' for the first_vf_id field to be
	 * configured.
	 */
	#define HWRM_FUNC_VF_ALLOC_INPUT_ENABLES_FIRST_VF_ID	UINT32_C(0x1)
	/*
	 * This value is used to identify a Virtual Function (VF).
	 * The scope of VF ID is local within a PF.
	 */
	uint16_t	first_vf_id;
	/* The number of virtual functions requested. */
	uint16_t	num_vfs;
} hwrm_func_vf_alloc_input_t, *phwrm_func_vf_alloc_input_t;

/* hwrm_func_vf_alloc_output (size:128b/16B) */

typedef struct hwrm_func_vf_alloc_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* The ID of the first VF allocated. */
	uint16_t	first_vf_id;
	uint8_t	unused_0[5];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_func_vf_alloc_output_t, *phwrm_func_vf_alloc_output_t;

/*********************
 * hwrm_func_vf_free *
 *********************/


/* hwrm_func_vf_free_input (size:192b/24B) */

typedef struct hwrm_func_vf_free_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	enables;
	/*
	 * This bit must be '1' for the first_vf_id field to be
	 * configured.
	 */
	#define HWRM_FUNC_VF_FREE_INPUT_ENABLES_FIRST_VF_ID	UINT32_C(0x1)
	/*
	 * This value is used to identify a Virtual Function (VF).
	 * The scope of VF ID is local within a PF.
	 */
	uint16_t	first_vf_id;
	/*
	 * The number of virtual functions requested.
	 * 0xFFFF - Cleanup all children of this PF.
	 */
	uint16_t	num_vfs;
} hwrm_func_vf_free_input_t, *phwrm_func_vf_free_input_t;

/* hwrm_func_vf_free_output (size:128b/16B) */

typedef struct hwrm_func_vf_free_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_func_vf_free_output_t, *phwrm_func_vf_free_output_t;

/********************
 * hwrm_func_vf_cfg *
 ********************/


/* hwrm_func_vf_cfg_input (size:448b/56B) */

typedef struct hwrm_func_vf_cfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	enables;
	/*
	 * This bit must be '1' for the mtu field to be
	 * configured.
	 */
	#define HWRM_FUNC_VF_CFG_INPUT_ENABLES_MTU		UINT32_C(0x1)
	/*
	 * This bit must be '1' for the guest_vlan field to be
	 * configured.
	 */
	#define HWRM_FUNC_VF_CFG_INPUT_ENABLES_GUEST_VLAN	UINT32_C(0x2)
	/*
	 * This bit must be '1' for the async_event_cr field to be
	 * configured.
	 */
	#define HWRM_FUNC_VF_CFG_INPUT_ENABLES_ASYNC_EVENT_CR	UINT32_C(0x4)
	/*
	 * This bit must be '1' for the dflt_mac_addr field to be
	 * configured.
	 */
	#define HWRM_FUNC_VF_CFG_INPUT_ENABLES_DFLT_MAC_ADDR	UINT32_C(0x8)
	/*
	 * This bit must be '1' for the num_rsscos_ctxs field to be
	 * configured.
	 */
	#define HWRM_FUNC_VF_CFG_INPUT_ENABLES_NUM_RSSCOS_CTXS	UINT32_C(0x10)
	/*
	 * This bit must be '1' for the num_cmpl_rings field to be
	 * configured.
	 */
	#define HWRM_FUNC_VF_CFG_INPUT_ENABLES_NUM_CMPL_RINGS	UINT32_C(0x20)
	/*
	 * This bit must be '1' for the num_tx_rings field to be
	 * configured.
	 */
	#define HWRM_FUNC_VF_CFG_INPUT_ENABLES_NUM_TX_RINGS	UINT32_C(0x40)
	/*
	 * This bit must be '1' for the num_rx_rings field to be
	 * configured.
	 */
	#define HWRM_FUNC_VF_CFG_INPUT_ENABLES_NUM_RX_RINGS	UINT32_C(0x80)
	/*
	 * This bit must be '1' for the num_l2_ctxs field to be
	 * configured.
	 */
	#define HWRM_FUNC_VF_CFG_INPUT_ENABLES_NUM_L2_CTXS	UINT32_C(0x100)
	/*
	 * This bit must be '1' for the num_vnics field to be
	 * configured.
	 */
	#define HWRM_FUNC_VF_CFG_INPUT_ENABLES_NUM_VNICS		UINT32_C(0x200)
	/*
	 * This bit must be '1' for the num_stat_ctxs field to be
	 * configured.
	 */
	#define HWRM_FUNC_VF_CFG_INPUT_ENABLES_NUM_STAT_CTXS	UINT32_C(0x400)
	/*
	 * This bit must be '1' for the num_hw_ring_grps field to be
	 * configured.
	 */
	#define HWRM_FUNC_VF_CFG_INPUT_ENABLES_NUM_HW_RING_GRPS	UINT32_C(0x800)
	/*
	 * The maximum transmission unit requested on the function.
	 * The HWRM should make sure that the mtu of
	 * the function does not exceed the mtu of the physical
	 * port that this function is associated with.
	 *
	 * In addition to requesting mtu per function, it is
	 * possible to configure mtu per transmit ring.
	 * By default, the mtu of each transmit ring associated
	 * with a function is equal to the mtu of the function.
	 * The HWRM should make sure that the mtu of each transmit
	 * ring that is assigned to a function has a valid mtu.
	 */
	uint16_t	mtu;
	/*
	 * The guest VLAN for the function being configured.
	 * This field's format is same as 802.1Q Tag's
	 * Tag Control Information (TCI) format that includes both
	 * Priority Code Point (PCP) and VLAN Identifier (VID).
	 */
	uint16_t	guest_vlan;
	/*
	 * ID of the target completion ring for receiving asynchronous
	 * event completions. If this field is not valid, then the
	 * HWRM shall use the default completion ring of the function
	 * that is being configured as the target completion ring for
	 * providing any asynchronous event completions for that
	 * function.
	 * If this field is valid, then the HWRM shall use the
	 * completion ring identified by this ID as the target
	 * completion ring for providing any asynchronous event
	 * completions for the function that is being configured.
	 */
	uint16_t	async_event_cr;
	/*
	 * This value is the current MAC address requested by the VF
	 * driver to be configured on this VF. A value of
	 * 00-00-00-00-00-00 indicates no MAC address configuration
	 * is requested by the VF driver.
	 * The parent PF driver may reject or overwrite this
	 * MAC address.
	 */
	uint8_t	dflt_mac_addr[6];
	uint32_t	flags;
	/*
	 * This bit requests that the firmware test to see if all the assets
	 * requested in this command (i.e. number of TX rings) are available.
	 * The firmware will return an error if the requested assets are
	 * not available. The firwmare will NOT reserve the assets if they
	 * are available.
	 */
	#define HWRM_FUNC_VF_CFG_INPUT_FLAGS_TX_ASSETS_TEST		UINT32_C(0x1)
	/*
	 * This bit requests that the firmware test to see if all the assets
	 * requested in this command (i.e. number of RX rings) are available.
	 * The firmware will return an error if the requested assets are
	 * not available. The firwmare will NOT reserve the assets if they
	 * are available.
	 */
	#define HWRM_FUNC_VF_CFG_INPUT_FLAGS_RX_ASSETS_TEST		UINT32_C(0x2)
	/*
	 * This bit requests that the firmware test to see if all the assets
	 * requested in this command (i.e. number of CMPL rings) are available.
	 * The firmware will return an error if the requested assets are
	 * not available. The firwmare will NOT reserve the assets if they
	 * are available.
	 */
	#define HWRM_FUNC_VF_CFG_INPUT_FLAGS_CMPL_ASSETS_TEST	UINT32_C(0x4)
	/*
	 * This bit requests that the firmware test to see if all the assets
	 * requested in this command (i.e. number of RSS ctx) are available.
	 * The firmware will return an error if the requested assets are
	 * not available. The firwmare will NOT reserve the assets if they
	 * are available.
	 */
	#define HWRM_FUNC_VF_CFG_INPUT_FLAGS_RSSCOS_CTX_ASSETS_TEST	UINT32_C(0x8)
	/*
	 * This bit requests that the firmware test to see if all the assets
	 * requested in this command (i.e. number of ring groups) are available.
	 * The firmware will return an error if the requested assets are
	 * not available. The firwmare will NOT reserve the assets if they
	 * are available.
	 */
	#define HWRM_FUNC_VF_CFG_INPUT_FLAGS_RING_GRP_ASSETS_TEST	UINT32_C(0x10)
	/*
	 * This bit requests that the firmware test to see if all the assets
	 * requested in this command (i.e. number of stat ctx) are available.
	 * The firmware will return an error if the requested assets are
	 * not available. The firwmare will NOT reserve the assets if they
	 * are available.
	 */
	#define HWRM_FUNC_VF_CFG_INPUT_FLAGS_STAT_CTX_ASSETS_TEST	UINT32_C(0x20)
	/*
	 * This bit requests that the firmware test to see if all the assets
	 * requested in this command (i.e. number of VNICs) are available.
	 * The firmware will return an error if the requested assets are
	 * not available. The firwmare will NOT reserve the assets if they
	 * are available.
	 */
	#define HWRM_FUNC_VF_CFG_INPUT_FLAGS_VNIC_ASSETS_TEST	UINT32_C(0x40)
	/*
	 * This bit requests that the firmware test to see if all the assets
	 * requested in this command (i.e. number of L2 ctx) are available.
	 * The firmware will return an error if the requested assets are
	 * not available. The firwmare will NOT reserve the assets if they
	 * are available.
	 */
	#define HWRM_FUNC_VF_CFG_INPUT_FLAGS_L2_CTX_ASSETS_TEST	UINT32_C(0x80)
	/*
	 * If this bit is set to 1, the VF driver is requesting FW to enable
	 * PPP TX PUSH feature on all the TX rings specified in the
	 * num_tx_rings field. By default, the PPP TX push feature is
	 * disabled for all the TX rings of the VF. This flag is ignored if
	 * the num_tx_rings field is not specified or the VF doesn't support
	 * PPP tx push feature.
	 */
	#define HWRM_FUNC_VF_CFG_INPUT_FLAGS_PPP_PUSH_MODE_ENABLE	UINT32_C(0x100)
	/*
	 * If this bit is set to 1, the VF driver is requesting FW to disable
	 * PPP TX PUSH feature on all the TX rings of the VF. This flag is
	 * ignored if the VF doesn't support PPP tx push feature.
	 */
	#define HWRM_FUNC_VF_CFG_INPUT_FLAGS_PPP_PUSH_MODE_DISABLE	UINT32_C(0x200)
	/* The number of RSS/COS contexts requested for the VF. */
	uint16_t	num_rsscos_ctxs;
	/* The number of completion rings requested for the VF. */
	uint16_t	num_cmpl_rings;
	/* The number of transmit rings requested for the VF. */
	uint16_t	num_tx_rings;
	/* The number of receive rings requested for the VF. */
	uint16_t	num_rx_rings;
	/* The number of L2 contexts requested for the VF. */
	uint16_t	num_l2_ctxs;
	/* The number of vnics requested for the VF. */
	uint16_t	num_vnics;
	/* The number of statistic contexts requested for the VF. */
	uint16_t	num_stat_ctxs;
	/* The number of HW ring groups requested for the VF. */
	uint16_t	num_hw_ring_grps;
	uint8_t	unused_0[4];
} hwrm_func_vf_cfg_input_t, *phwrm_func_vf_cfg_input_t;

/* hwrm_func_vf_cfg_output (size:128b/16B) */

typedef struct hwrm_func_vf_cfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_func_vf_cfg_output_t, *phwrm_func_vf_cfg_output_t;

/*******************
 * hwrm_func_qcaps *
 *******************/


/* hwrm_func_qcaps_input (size:192b/24B) */

typedef struct hwrm_func_qcaps_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * Function ID of the function that is being queried.
	 * 0xFF... (All Fs) if the query is for the requesting
	 * function.
	 * 0xFFFE (REQUESTING_PARENT_FID) This is a special FID
	 * to be used by a trusted VF to query its parent PF.
	 */
	uint16_t	fid;
	uint8_t	unused_0[6];
} hwrm_func_qcaps_input_t, *phwrm_func_qcaps_input_t;

/* hwrm_func_qcaps_output (size:704b/88B) */

typedef struct hwrm_func_qcaps_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * FID value.  This value is used to identify operations on the PCI
	 * bus as belonging to a particular PCI function.
	 */
	uint16_t	fid;
	/*
	 * Port ID of port that this function is associated with.
	 * Valid only for the PF.
	 * 0xFF... (All Fs) if this function is not associated with
	 * any port.
	 * 0xFF... (All Fs) if this function is called from a VF.
	 */
	uint16_t	port_id;
	uint32_t	flags;
	/* If 1, then Push mode is supported on this function. */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_PUSH_MODE_SUPPORTED		UINT32_C(0x1)
	/*
	 * If 1, then the global MSI-X auto-masking is enabled for the
	 * device.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_GLOBAL_MSIX_AUTOMASKING		UINT32_C(0x2)
	/*
	 * If 1, then the Precision Time Protocol (PTP) processing
	 * is supported on this function.
	 * The HWRM should enable PTP on only a single Physical
	 * Function (PF) per port.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_PTP_SUPPORTED			UINT32_C(0x4)
	/*
	 * If 1, then RDMA over Converged Ethernet (RoCE) v1
	 * is supported on this function.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_ROCE_V1_SUPPORTED			UINT32_C(0x8)
	/*
	 * If 1, then RDMA over Converged Ethernet (RoCE) v2
	 * is supported on this function.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_ROCE_V2_SUPPORTED			UINT32_C(0x10)
	/*
	 * If 1, then control and configuration of WoL magic packet
	 * are supported on this function.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_WOL_MAGICPKT_SUPPORTED		UINT32_C(0x20)
	/*
	 * If 1, then control and configuration of bitmap pattern
	 * packet are supported on this function.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_WOL_BMP_SUPPORTED			UINT32_C(0x40)
	/*
	 * If set to 1, then the control and configuration of rate limit
	 * of an allocated TX ring on the queried function is supported.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_TX_RING_RL_SUPPORTED		UINT32_C(0x80)
	/*
	 * If 1, then control and configuration of minimum and
	 * maximum bandwidths are supported on the queried function.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_TX_BW_CFG_SUPPORTED		UINT32_C(0x100)
	/*
	 * If the query is for a VF, then this flag shall be ignored.
	 * If this query is for a PF and this flag is set to 1,
	 * then the PF has the capability to set the rate limits
	 * on the TX rings of its children VFs.
	 * If this query is for a PF and this flag is set to 0, then
	 * the PF does not have the capability to set the rate limits
	 * on the TX rings of its children VFs.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_VF_TX_RING_RL_SUPPORTED		UINT32_C(0x200)
	/*
	 * If the query is for a VF, then this flag shall be ignored.
	 * If this query is for a PF and this flag is set to 1,
	 * then the PF has the capability to set the minimum and/or
	 * maximum bandwidths for its children VFs.
	 * If this query is for a PF and this flag is set to 0, then
	 * the PF does not have the capability to set the minimum or
	 * maximum bandwidths for its children VFs.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_VF_BW_CFG_SUPPORTED		UINT32_C(0x400)
	/*
	 * Standard TX Ring mode is used for the allocation of TX ring
	 * and underlying scheduling resources that allow bandwidth
	 * reservation and limit settings on the queried function.
	 * If set to 1, then standard TX ring mode is supported
	 * on the queried function.
	 * If set to 0, then standard TX ring mode is not available
	 * on the queried function.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_STD_TX_RING_MODE_SUPPORTED		UINT32_C(0x800)
	/*
	 * If the query is for a VF, then this flag shall be ignored,
	 * If this query is for a PF and this flag is set to 1,
	 * then the PF has the capability to detect GENEVE tunnel
	 * flags.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_GENEVE_TUN_FLAGS_SUPPORTED		UINT32_C(0x1000)
	/*
	 * If the query is for a VF, then this flag shall be ignored,
	 * If this query is for a PF and this flag is set to 1,
	 * then the PF has the capability to detect NVGRE tunnel
	 * flags.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_NVGRE_TUN_FLAGS_SUPPORTED		UINT32_C(0x2000)
	/*
	 * If the query is for a VF, then this flag shall be ignored,
	 * If this query is for a PF and this flag is set to 1,
	 * then the PF has the capability to detect GRE tunnel
	 * flags.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_GRE_TUN_FLAGS_SUPPORTED		UINT32_C(0x4000)
	/*
	 * If the query is for a VF, then this flag shall be ignored,
	 * If this query is for a PF and this flag is set to 1,
	 * then the PF has the capability to detect MPLS tunnel
	 * flags.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_MPLS_TUN_FLAGS_SUPPORTED		UINT32_C(0x8000)
	/*
	 * If the query is for a VF, then this flag shall be ignored,
	 * If this query is for a PF and this flag is set to 1,
	 * then the PF has the capability to support pcie stats.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_PCIE_STATS_SUPPORTED		UINT32_C(0x10000)
	/*
	 * If the query is for a VF, then this flag shall be ignored,
	 * If this query is for a PF and this flag is set to 1,
	 * then the PF has the capability to adopt the VF's belonging
	 * to another PF.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_ADOPTED_PF_SUPPORTED		UINT32_C(0x20000)
	/*
	 * If the query is for a VF, then this flag shall be ignored,
	 * If this query is for a PF and this flag is set to 1,
	 * then the PF has the administrative privilege to configure another PF
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_ADMIN_PF_SUPPORTED			UINT32_C(0x40000)
	/*
	 * If the query is for a VF, then this flag shall be ignored.
	 * If this query is for a PF and this flag is set to 1, then
	 * the PF will know that the firmware has the capability to track
	 * the virtual link status.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_LINK_ADMIN_STATUS_SUPPORTED	UINT32_C(0x80000)
	/*
	 * If 1, then this function supports the push mode that uses
	 * write combine buffers and the long inline tx buffer descriptor.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_WCB_PUSH_MODE			UINT32_C(0x100000)
	/*
	 * If 1, then FW has capability to allocate TX rings dynamically
	 * in ring alloc even if PF reserved pool is zero.
	 * This bit will be used only for PFs.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_DYNAMIC_TX_RING_ALLOC		UINT32_C(0x200000)
	/*
	 * When this bit is '1', it indicates that core firmware is
	 * capable of Hot Reset.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_HOT_RESET_CAPABLE			UINT32_C(0x400000)
	/*
	 * This flag will be set to 1 by the FW if FW supports adapter error
	 * recovery.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_ERROR_RECOVERY_CAPABLE		UINT32_C(0x800000)
	/*
	 * If the query is for a VF, then this flag shall be ignored.
	 * If this query is for a PF and this flag is set to 1, then
	 * the PF has the capability to support extended stats.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_EXT_STATS_SUPPORTED		UINT32_C(0x1000000)
	/*
	 * If the query is for a VF, then this flag shall be ignored.
	 * If this query is for a PF and this flag is set to 1, then host
	 * must initiate reset or reload (or fastboot) the firmware image
	 * upon detection of device shutdown state.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_ERR_RECOVER_RELOAD			UINT32_C(0x2000000)
	/*
	 * If the query is for a VF, then this flag (always set to 0) shall
	 * be ignored. If this query is for a PF and this flag is set to 1,
	 * host, when registered for the default vnic change async event,
	 * receives async notification whenever a default vnic state is
	 * changed for any of child or adopted VFs.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_NOTIFY_VF_DEF_VNIC_CHNG_SUPPORTED	UINT32_C(0x4000000)
	/* If set to 1, then the vlan acceleration for TX is disabled. */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_VLAN_ACCELERATION_TX_DISABLED	UINT32_C(0x8000000)
	/*
	 * When this bit is '1', it indicates that core firmware supports
	 * DBG_COREDUMP_XXX commands.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_COREDUMP_CMD_SUPPORTED		UINT32_C(0x10000000)
	/*
	 * When this bit is '1', it indicates that core firmware supports
	 * DBG_CRASHDUMP_XXX commands.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_CRASHDUMP_CMD_SUPPORTED		UINT32_C(0x20000000)
	/*
	 * If the query is for a VF, then this flag should be ignored.
	 * If the query is for a PF and this flag is set to 1, then
	 * the PF has the capability to support retrieval of
	 * rx_port_stats_ext_pfc_wd statistics (supported by the PFC
	 * WatchDog feature) via the hwrm_port_qstats_ext_pfc_wd command.
	 * If this flag is set to 1, only that (supported) command should
	 * be used for retrieval of PFC related statistics (rather than
	 * hwrm_port_qstats_ext command, which could previously be used).
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_PFC_WD_STATS_SUPPORTED		UINT32_C(0x40000000)
	/*
	 * When this bit is '1', it indicates that core firmware supports
	 * DBG_QCAPS command
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_DBG_QCAPS_CMD_SUPPORTED		UINT32_C(0x80000000)
	/*
	 * This value is current MAC address configured for this
	 * function. A value of 00-00-00-00-00-00 indicates no
	 * MAC address is currently configured.
	 */
	uint8_t	mac_address[6];
	/*
	 * The maximum number of RSS/COS contexts that can be
	 * allocated to the function.
	 */
	uint16_t	max_rsscos_ctx;
	/*
	 * The maximum number of completion rings that can be
	 * allocated to the function.
	 */
	uint16_t	max_cmpl_rings;
	/*
	 * The maximum number of transmit rings that can be
	 * allocated to the function.
	 */
	uint16_t	max_tx_rings;
	/*
	 * The maximum number of receive rings that can be
	 * allocated to the function.
	 */
	uint16_t	max_rx_rings;
	/*
	 * The maximum number of L2 contexts that can be
	 * allocated to the function.
	 */
	uint16_t	max_l2_ctxs;
	/*
	 * The maximum number of VNICs that can be
	 * allocated to the function.
	 */
	uint16_t	max_vnics;
	/*
	 * The identifier for the first VF enabled on a PF. This
	 * is valid only on the PF with SR-IOV enabled.
	 * 0xFF... (All Fs) if this command is called on a PF with
	 * SR-IOV disabled or on a VF.
	 */
	uint16_t	first_vf_id;
	/*
	 * The maximum number of VFs that can be
	 * allocated to the function. This is valid only on the
	 * PF with SR-IOV enabled. 0xFF... (All Fs) if this
	 * command is called on a PF with SR-IOV disabled or
	 * on a VF.
	 */
	uint16_t	max_vfs;
	/*
	 * The maximum number of statistic contexts that can be
	 * allocated to the function.
	 */
	uint16_t	max_stat_ctx;
	/*
	 * The maximum number of Encapsulation records that can be
	 * offloaded by this function.
	 */
	uint32_t	max_encap_records;
	/*
	 * The maximum number of decapsulation records that can
	 * be offloaded by this function.
	 */
	uint32_t	max_decap_records;
	/*
	 * The maximum number of Exact Match (EM) flows that can be
	 * offloaded by this function on the TX side.
	 */
	uint32_t	max_tx_em_flows;
	/*
	 * The maximum number of Wildcard Match (WM) flows that can
	 * be offloaded by this function on the TX side.
	 */
	uint32_t	max_tx_wm_flows;
	/*
	 * The maximum number of Exact Match (EM) flows that can be
	 * offloaded by this function on the RX side.
	 */
	uint32_t	max_rx_em_flows;
	/*
	 * The maximum number of Wildcard Match (WM) flows that can
	 * be offloaded by this function on the RX side.
	 */
	uint32_t	max_rx_wm_flows;
	/*
	 * The maximum number of multicast filters that can
	 * be supported by this function on the RX side.
	 */
	uint32_t	max_mcast_filters;
	/*
	 * The maximum value of flow_id that can be supported
	 * in completion records.
	 */
	uint32_t	max_flow_id;
	/*
	 * The maximum number of HW ring groups that can be
	 * supported on this function.
	 */
	uint32_t	max_hw_ring_grps;
	/*
	 * The maximum number of strict priority transmit rings
	 * that can be allocated to the function.
	 * This number indicates the maximum number of TX rings
	 * that can be assigned strict priorities out of the
	 * maximum number of TX rings that can be allocated
	 * (max_tx_rings) to the function.
	 */
	uint16_t	max_sp_tx_rings;
	uint8_t	unused_0[2];
	uint32_t	flags_ext;
	/*
	 * If 1, the device can be configured to set the ECN bits in the
	 * IP header of received packets if the receive queue length
	 * exceeds a given threshold.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_EXT_ECN_MARK_SUPPORTED			UINT32_C(0x1)
	/*
	 * If 1, the device can report the number of received packets
	 * that it marked as having experienced congestion.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_EXT_ECN_STATS_SUPPORTED			UINT32_C(0x2)
	/*
	 * If 1, the device can report extended hw statistics (including
	 * additional tpa statistics).
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_EXT_EXT_HW_STATS_SUPPORTED		UINT32_C(0x4)
	/*
	 * If set to 1, then the core firmware has support to enable/
	 * disable hot reset support for interface dynamically through
	 * HWRM_FUNC_CFG.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_EXT_HOT_RESET_IF_SUPPORT		UINT32_C(0x8)
	/* If 1, the proxy mode is supported on this function */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_EXT_PROXY_MODE_SUPPORT			UINT32_C(0x10)
	/*
	 * If 1, the tx rings source interface override feature is supported
	 * on this function.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_EXT_TX_PROXY_SRC_INTF_OVERRIDE_SUPPORT	UINT32_C(0x20)
	/*
	 * If 1, the device supports scheduler queues. SCHQs can be managed
	 * using RING_SCHQ_ALLOC/CFG/FREE commands.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_EXT_SCHQ_SUPPORTED			UINT32_C(0x40)
	/*
	 * If set to 1, then this function supports the TX push mode that
	 * uses ping-pong buffers from the push pages.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_EXT_PPP_PUSH_MODE_SUPPORTED		UINT32_C(0x80)
	/*
	 * If set to 1, then this function doesn't have the privilege to
	 * configure the EVB mode of the port it uses.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_EXT_EVB_MODE_CFG_NOT_SUPPORTED		UINT32_C(0x100)
	/*
	 * If set to 1, then the HW and FW support the SoC packet DMA
	 * datapath between SoC and NIC. This function can act as the
	 * HWRM communication transport agent on behalf of the SoC SPD
	 * software module. This capability is only advertised to the
	 * SoC PFs.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_EXT_SOC_SPD_SUPPORTED			UINT32_C(0x200)
	/*
	 * If set to 1, then this function supports FW_LIVEPATCH for
	 * firmware livepatch commands.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_EXT_FW_LIVEPATCH_SUPPORTED		UINT32_C(0x400)
	/*
	 * When this bit is '1', it indicates that core firmware is
	 * capable of fast Reset.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_EXT_FAST_RESET_CAPABLE			UINT32_C(0x800)
	/*
	 * When this bit is '1', it indicates that firmware and hardware
	 * are capable of updating tx_metadata via hwrm_ring_cfg command.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_EXT_TX_METADATA_CFG_CAPABLE		UINT32_C(0x1000)
	/*
	 * If set to 1, then the device can report the action
	 * needed to activate set nvm options.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_EXT_NVM_OPTION_ACTION_SUPPORTED		UINT32_C(0x2000)
	/*
	 * When this bit is '1', it indicates that the BD metadata feature
	 * is supported for this function.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_EXT_BD_METADATA_SUPPORTED		UINT32_C(0x4000)
	/*
	 * When this bit is '1', it indicates that the echo request feature
	 * is supported for this function. If the driver registers for the
	 * echo request asynchronous event, then the firmware can send an
	 * unsolicited echo request to the driver and expect an echo
	 * response.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_EXT_ECHO_REQUEST_SUPPORTED		UINT32_C(0x8000)
	/*
	 * When this bit is '1', it indicates that core firmware supports
	 * NPAR 1.2 on this function.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_EXT_NPAR_1_2_SUPPORTED			UINT32_C(0x10000)
	/* When this bit is '1', it indicates that PTM feature is supported. */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_EXT_PTP_PTM_SUPPORTED			UINT32_C(0x20000)
	/* When this bit is '1', it indicates that PPS feature is supported. */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_EXT_PTP_PPS_SUPPORTED			UINT32_C(0x40000)
	/*
	 * When this bit is '1', it indicates that VF config. change
	 * async event is supported on the parent PF if the async.
	 * event is registered by the PF.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_EXT_VF_CFG_ASYNC_FOR_PF_SUPPORTED	UINT32_C(0x80000)
	/*
	 * When this bit is '1', the NIC supports configuration of
	 * partition_min_bw and partition_max_bw.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_EXT_PARTITION_BW_SUPPORTED		UINT32_C(0x100000)
	/*
	 * When this bit is '1', the FW supports configuration of
	 * PCP and TPID values of the default VLAN.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_EXT_DFLT_VLAN_TPID_PCP_SUPPORTED	UINT32_C(0x200000)
	/* When this bit is '1', it indicates that HW and FW support KTLS. */
	#define HWRM_FUNC_QCAPS_OUTPUT_FLAGS_EXT_KTLS_SUPPORTED			UINT32_C(0x400000)
	/* The maximum number of SCHQs supported by this device. */
	uint8_t	max_schqs;
	uint8_t	mpc_chnls_cap;
	/*
	 * When this bit is '1', it indicates that HW and firmware
	 * supports the use of a MPC channel with destination set
	 * to the TX crypto engine block.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_MPC_CHNLS_CAP_TCE	UINT32_C(0x1)
	/*
	 * When this bit is '1', it indicates that HW and firmware
	 * supports the use of a MPC channel with destination set
	 * to the RX crypto engine block.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_MPC_CHNLS_CAP_RCE	UINT32_C(0x2)
	/*
	 * When this bit is '1', it indicates that HW and firmware
	 * supports the use of a MPC channel with destination set
	 * to the TX configurable flow processing block.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_MPC_CHNLS_CAP_TE_CFA	UINT32_C(0x4)
	/*
	 * When this bit is '1', it indicates that HW and firmware
	 * supports the use of a MPC channel with destination set
	 * to the RX configurable flow processing block.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_MPC_CHNLS_CAP_RE_CFA	UINT32_C(0x8)
	/*
	 * When this bit is '1', it indicates that HW and firmware
	 * supports the use of a MPC channel with destination set
	 * to the primate processor block.
	 */
	#define HWRM_FUNC_QCAPS_OUTPUT_MPC_CHNLS_CAP_PRIMATE	UINT32_C(0x10)
	uint8_t	unused_1;
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_func_qcaps_output_t, *phwrm_func_qcaps_output_t;

/******************
 * hwrm_func_qcfg *
 ******************/


/* hwrm_func_qcfg_input (size:192b/24B) */

typedef struct hwrm_func_qcfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * Function ID of the function that is being queried.
	 * 0xFF... (All Fs) if the query is for the requesting
	 * function.
	 * 0xFFFE (REQUESTING_PARENT_FID) This is a special FID
	 * to be used by a trusted VF to query its parent PF.
	 */
	uint16_t	fid;
	uint8_t	unused_0[6];
} hwrm_func_qcfg_input_t, *phwrm_func_qcfg_input_t;

/* hwrm_func_qcfg_output (size:832b/104B) */

typedef struct hwrm_func_qcfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * FID value.  This value is used to identify operations on the PCI
	 * bus as belonging to a particular PCI function.
	 */
	uint16_t	fid;
	/*
	 * Port ID of port that this function is associated with.
	 * 0xFF... (All Fs) if this function is not associated with
	 * any port.
	 */
	uint16_t	port_id;
	/*
	 * This value is the current VLAN setting for this
	 * function. The value of 0 for this field indicates
	 * no priority tagging or VLAN is used.
	 * This field's format is same as 802.1Q Tag's
	 * Tag Control Information (TCI) format that includes both
	 * Priority Code Point (PCP) and VLAN Identifier (VID).
	 */
	uint16_t	vlan;
	uint16_t	flags;
	/*
	 * If 1, then magic packet based Out-Of-Box WoL is enabled on
	 * the port associated with this function.
	 */
	#define HWRM_FUNC_QCFG_OUTPUT_FLAGS_OOB_WOL_MAGICPKT_ENABLED	UINT32_C(0x1)
	/*
	 * If 1, then bitmap pattern based Out-Of-Box WoL packet is enabled
	 * on the port associated with this function.
	 */
	#define HWRM_FUNC_QCFG_OUTPUT_FLAGS_OOB_WOL_BMP_ENABLED	UINT32_C(0x2)
	/*
	 * If set to 1, then FW based DCBX agent is enabled and running on
	 * the port associated with this function.
	 * If set to 0, then DCBX agent is not running in the firmware.
	 */
	#define HWRM_FUNC_QCFG_OUTPUT_FLAGS_FW_DCBX_AGENT_ENABLED	UINT32_C(0x4)
	/*
	 * Standard TX Ring mode is used for the allocation of TX ring
	 * and underlying scheduling resources that allow bandwidth
	 * reservation and limit settings on the queried function.
	 * If set to 1, then standard TX ring mode is enabled
	 * on the queried function.
	 * If set to 0, then the standard TX ring mode is disabled
	 * on the queried function. In this extended TX ring resource
	 * mode, the minimum and maximum bandwidth settings are not
	 * supported to allow the allocation of TX rings to span multiple
	 * scheduler nodes.
	 */
	#define HWRM_FUNC_QCFG_OUTPUT_FLAGS_STD_TX_RING_MODE_ENABLED	UINT32_C(0x8)
	/*
	 * If set to 1 then FW based LLDP agent is enabled and running on
	 * the port associated with this function.
	 * If set to 0 then the LLDP agent is not running in the firmware.
	 */
	#define HWRM_FUNC_QCFG_OUTPUT_FLAGS_FW_LLDP_AGENT_ENABLED	UINT32_C(0x10)
	/*
	 * If set to 1, then multi-host mode is active for this function.
	 * The NIC is attached to two or more independent host systems
	 * through two or more PCIe endpoints.
	 * If set to 0, then multi-host mode is inactive for this function
	 * or not applicable for this device.
	 */
	#define HWRM_FUNC_QCFG_OUTPUT_FLAGS_MULTI_HOST		UINT32_C(0x20)
	/*
	 * If the function that is being queried is a PF, then the HWRM shall
	 * set this field to 0 and the HWRM client shall ignore this field.
	 * If the function that is being queried is a VF, then the HWRM shall
	 * set this field to 1 if the queried VF is trusted, otherwise the HWRM
	 * shall set this field to 0.
	 */
	#define HWRM_FUNC_QCFG_OUTPUT_FLAGS_TRUSTED_VF		UINT32_C(0x40)
	/*
	 * If set to 1, then secure mode is enabled for this function or device.
	 * If set to 0, then secure mode is disabled (or normal mode) for this
	 * function or device.
	 */
	#define HWRM_FUNC_QCFG_OUTPUT_FLAGS_SECURE_MODE_ENABLED	UINT32_C(0x80)
	/*
	 * If set to 1, then this PF is enabled with a preboot driver that
	 * requires access to the legacy L2 ring model and legacy 32b
	 * doorbells. If set to 0, then this PF is not allowed to use
	 * the legacy L2 rings. This feature is not allowed on VFs and
	 * is only relevant for devices that require a context backing
	 * store.
	 */
	#define HWRM_FUNC_QCFG_OUTPUT_FLAGS_PREBOOT_LEGACY_L2_RINGS	UINT32_C(0x100)
	/*
	 * If set to 1, then the firmware and all currently registered driver
	 * instances support hot reset. The hot reset support will be updated
	 * dynamically based on the driver interface advertisement.
	 * If set to 0, then the adapter is not currently able to initiate
	 * hot reset.
	 */
	#define HWRM_FUNC_QCFG_OUTPUT_FLAGS_HOT_RESET_ALLOWED		UINT32_C(0x200)
	/*
	 * If set to 1, then the PPP tx push mode is enabled for all the
	 * reserved TX rings of this function. If set to 0, then PPP tx push
	 * mode is disabled for all the reserved TX rings of this function.
	 */
	#define HWRM_FUNC_QCFG_OUTPUT_FLAGS_PPP_PUSH_MODE_ENABLED	UINT32_C(0x400)
	/*
	 * If set to 1, then the firmware will notify driver using async
	 * event when a ring is disabled due to a Hardware error.
	 */
	#define HWRM_FUNC_QCFG_OUTPUT_FLAGS_RING_MONITOR_ENABLED	UINT32_C(0x800)
	/*
	 * If set to 1, then the firmware and all currently registered driver
	 * instances support fast reset. The fast reset support will be
	 * updated dynamically based on the driver interface advertisement.
	 * If set to 0, then the adapter is not currently able to initiate
	 * fast reset.
	 */
	#define HWRM_FUNC_QCFG_OUTPUT_FLAGS_FAST_RESET_ALLOWED	UINT32_C(0x1000)
	/*
	 * If set to 1, then multi-root mode is active for this function.
	 * The NIC is attached to a single host with a single operating
	 * system, but through two or more PCIe endpoints.
	 * If set to 0, then multi-root mode is inactive for this function
	 * or not applicable for this device.
	 */
	#define HWRM_FUNC_QCFG_OUTPUT_FLAGS_MULTI_ROOT		UINT32_C(0x2000)
	/*
	 * This value is current MAC address configured for this
	 * function. A value of 00-00-00-00-00-00 indicates no
	 * MAC address is currently configured.
	 */
	uint8_t	mac_address[6];
	/*
	 * This value is current PCI ID of this
	 * function. If ARI is enabled, then it is
	 * Bus Number (8b):Function Number(8b). Otherwise, it is
	 * Bus Number (8b):Device Number (4b):Function Number(4b).
	 * If multi-host mode is active, the 4 lsb will indicate
	 * the PF index for this function.
	 */
	uint16_t	pci_id;
	/*
	 * The number of RSS/COS contexts currently
	 * allocated to the function.
	 */
	uint16_t	alloc_rsscos_ctx;
	/*
	 * The number of completion rings currently allocated to
	 * the function. This does not include the rings allocated
	 * to any children functions if any.
	 */
	uint16_t	alloc_cmpl_rings;
	/*
	 * The number of transmit rings currently allocated to
	 * the function. This does not include the rings allocated
	 * to any children functions if any.
	 */
	uint16_t	alloc_tx_rings;
	/*
	 * The number of receive rings currently allocated to
	 * the function. This does not include the rings allocated
	 * to any children functions if any.
	 */
	uint16_t	alloc_rx_rings;
	/* The allocated number of L2 contexts to the function. */
	uint16_t	alloc_l2_ctx;
	/* The allocated number of vnics to the function. */
	uint16_t	alloc_vnics;
	/*
	 * The maximum transmission unit of the function.
	 * If the reported mtu value is non-zero then it will used for the
	 * rings allocated on this function. otherwise the default
	 * value is used if ring MTU is not specified.
	 */
	uint16_t	mtu;
	/*
	 * The maximum receive unit of the function.
	 * For vnics allocated on this function, this default
	 * value is used if vnic MRU is not specified.
	 */
	uint16_t	mru;
	/* The statistics context assigned to a function. */
	uint16_t	stat_ctx_id;
	/*
	 * The HWRM shall return Unknown value for this field
	 * when this command is used to query VF's configuration.
	 */
	uint8_t	port_partition_type;
	/* Single physical function */
	#define HWRM_FUNC_QCFG_OUTPUT_PORT_PARTITION_TYPE_SPF	UINT32_C(0x0)
	/* Multiple physical functions */
	#define HWRM_FUNC_QCFG_OUTPUT_PORT_PARTITION_TYPE_MPFS	UINT32_C(0x1)
	/* Network Partitioning 1.0 */
	#define HWRM_FUNC_QCFG_OUTPUT_PORT_PARTITION_TYPE_NPAR1_0 UINT32_C(0x2)
	/* Network Partitioning 1.5 */
	#define HWRM_FUNC_QCFG_OUTPUT_PORT_PARTITION_TYPE_NPAR1_5 UINT32_C(0x3)
	/* Network Partitioning 2.0 */
	#define HWRM_FUNC_QCFG_OUTPUT_PORT_PARTITION_TYPE_NPAR2_0 UINT32_C(0x4)
	/* Network Partitioning 1.2 */
	#define HWRM_FUNC_QCFG_OUTPUT_PORT_PARTITION_TYPE_NPAR1_2 UINT32_C(0x5)
	/* Unknown */
	#define HWRM_FUNC_QCFG_OUTPUT_PORT_PARTITION_TYPE_UNKNOWN UINT32_C(0xff)
	#define HWRM_FUNC_QCFG_OUTPUT_PORT_PARTITION_TYPE_LAST   HWRM_FUNC_QCFG_OUTPUT_PORT_PARTITION_TYPE_UNKNOWN
	/*
	 * This field will indicate number of physical functions on this port_partition.
	 * HWRM shall return unavail (i.e. value of 0) for this field
	 * when this command is used to query VF's configuration or
	 * from older firmware that doesn't support this field.
	 */
	uint8_t	port_pf_cnt;
	/* number of PFs is not available */
	#define HWRM_FUNC_QCFG_OUTPUT_PORT_PF_CNT_UNAVAIL UINT32_C(0x0)
	#define HWRM_FUNC_QCFG_OUTPUT_PORT_PF_CNT_LAST   HWRM_FUNC_QCFG_OUTPUT_PORT_PF_CNT_UNAVAIL
	/*
	 * The default VNIC ID assigned to a function that is
	 * being queried.
	 */
	uint16_t	dflt_vnic_id;
	uint16_t	max_mtu_configured;
	/*
	 * Minimum guaranteed transmit bandwidth for this function. When
	 * specified for a PF, does not affect traffic from the PF's child VFs.
	 * A value of 0 indicates the minimum bandwidth is not configured.
	 */
	uint32_t	min_bw;
	/* The bandwidth value. */
	#define HWRM_FUNC_QCFG_OUTPUT_MIN_BW_BW_VALUE_MASK		UINT32_C(0xfffffff)
	#define HWRM_FUNC_QCFG_OUTPUT_MIN_BW_BW_VALUE_SFT		0
	/* The granularity of the value (bits or bytes). */
	#define HWRM_FUNC_QCFG_OUTPUT_MIN_BW_SCALE			UINT32_C(0x10000000)
	/* Value is in bits. */
		#define HWRM_FUNC_QCFG_OUTPUT_MIN_BW_SCALE_BITS		(UINT32_C(0x0) << 28)
	/* Value is in bytes. */
		#define HWRM_FUNC_QCFG_OUTPUT_MIN_BW_SCALE_BYTES		(UINT32_C(0x1) << 28)
		#define HWRM_FUNC_QCFG_OUTPUT_MIN_BW_SCALE_LAST		HWRM_FUNC_QCFG_OUTPUT_MIN_BW_SCALE_BYTES
	/* bw_value_unit is 3 b */
	#define HWRM_FUNC_QCFG_OUTPUT_MIN_BW_BW_VALUE_UNIT_MASK	UINT32_C(0xe0000000)
	#define HWRM_FUNC_QCFG_OUTPUT_MIN_BW_BW_VALUE_UNIT_SFT	29
	/* Value is in Mb or MB (base 10). */
		#define HWRM_FUNC_QCFG_OUTPUT_MIN_BW_BW_VALUE_UNIT_MEGA	(UINT32_C(0x0) << 29)
	/* Value is in Kb or KB (base 10). */
		#define HWRM_FUNC_QCFG_OUTPUT_MIN_BW_BW_VALUE_UNIT_KILO	(UINT32_C(0x2) << 29)
	/* Value is in bits or bytes. */
		#define HWRM_FUNC_QCFG_OUTPUT_MIN_BW_BW_VALUE_UNIT_BASE	(UINT32_C(0x4) << 29)
	/* Value is in Gb or GB (base 10). */
		#define HWRM_FUNC_QCFG_OUTPUT_MIN_BW_BW_VALUE_UNIT_GIGA	(UINT32_C(0x6) << 29)
	/* Value is in 1/100th of a percentage of link bandwidth. */
		#define HWRM_FUNC_QCFG_OUTPUT_MIN_BW_BW_VALUE_UNIT_PERCENT1_100  (UINT32_C(0x1) << 29)
	/* Invalid unit */
		#define HWRM_FUNC_QCFG_OUTPUT_MIN_BW_BW_VALUE_UNIT_INVALID	(UINT32_C(0x7) << 29)
		#define HWRM_FUNC_QCFG_OUTPUT_MIN_BW_BW_VALUE_UNIT_LAST	HWRM_FUNC_QCFG_OUTPUT_MIN_BW_BW_VALUE_UNIT_INVALID
	/*
	 * Maximum transmit rate for this function. When specified for a PF,
	 * does not affect traffic from the PF's child VFs.
	 * A value of 0 indicates that the maximum bandwidth is not configured.
	 */
	uint32_t	max_bw;
	/* The bandwidth value. */
	#define HWRM_FUNC_QCFG_OUTPUT_MAX_BW_BW_VALUE_MASK		UINT32_C(0xfffffff)
	#define HWRM_FUNC_QCFG_OUTPUT_MAX_BW_BW_VALUE_SFT		0
	/* The granularity of the value (bits or bytes). */
	#define HWRM_FUNC_QCFG_OUTPUT_MAX_BW_SCALE			UINT32_C(0x10000000)
	/* Value is in bits. */
		#define HWRM_FUNC_QCFG_OUTPUT_MAX_BW_SCALE_BITS		(UINT32_C(0x0) << 28)
	/* Value is in bytes. */
		#define HWRM_FUNC_QCFG_OUTPUT_MAX_BW_SCALE_BYTES		(UINT32_C(0x1) << 28)
		#define HWRM_FUNC_QCFG_OUTPUT_MAX_BW_SCALE_LAST		HWRM_FUNC_QCFG_OUTPUT_MAX_BW_SCALE_BYTES
	/* bw_value_unit is 3 b */
	#define HWRM_FUNC_QCFG_OUTPUT_MAX_BW_BW_VALUE_UNIT_MASK	UINT32_C(0xe0000000)
	#define HWRM_FUNC_QCFG_OUTPUT_MAX_BW_BW_VALUE_UNIT_SFT	29
	/* Value is in Mb or MB (base 10). */
		#define HWRM_FUNC_QCFG_OUTPUT_MAX_BW_BW_VALUE_UNIT_MEGA	(UINT32_C(0x0) << 29)
	/* Value is in Kb or KB (base 10). */
		#define HWRM_FUNC_QCFG_OUTPUT_MAX_BW_BW_VALUE_UNIT_KILO	(UINT32_C(0x2) << 29)
	/* Value is in bits or bytes. */
		#define HWRM_FUNC_QCFG_OUTPUT_MAX_BW_BW_VALUE_UNIT_BASE	(UINT32_C(0x4) << 29)
	/* Value is in Gb or GB (base 10). */
		#define HWRM_FUNC_QCFG_OUTPUT_MAX_BW_BW_VALUE_UNIT_GIGA	(UINT32_C(0x6) << 29)
	/* Value is in 1/100th of a percentage of link bandwidth. */
		#define HWRM_FUNC_QCFG_OUTPUT_MAX_BW_BW_VALUE_UNIT_PERCENT1_100  (UINT32_C(0x1) << 29)
	/* Invalid unit */
		#define HWRM_FUNC_QCFG_OUTPUT_MAX_BW_BW_VALUE_UNIT_INVALID	(UINT32_C(0x7) << 29)
		#define HWRM_FUNC_QCFG_OUTPUT_MAX_BW_BW_VALUE_UNIT_LAST	HWRM_FUNC_QCFG_OUTPUT_MAX_BW_BW_VALUE_UNIT_INVALID
	/*
	 * This value indicates the Edge virtual bridge mode for the
	 * domain that this function belongs to.
	 */
	uint8_t	evb_mode;
	/* No Edge Virtual Bridging (EVB) */
	#define HWRM_FUNC_QCFG_OUTPUT_EVB_MODE_NO_EVB UINT32_C(0x0)
	/* Virtual Ethernet Bridge (VEB) */
	#define HWRM_FUNC_QCFG_OUTPUT_EVB_MODE_VEB	UINT32_C(0x1)
	/* Virtual Ethernet Port Aggregator (VEPA) */
	#define HWRM_FUNC_QCFG_OUTPUT_EVB_MODE_VEPA   UINT32_C(0x2)
	#define HWRM_FUNC_QCFG_OUTPUT_EVB_MODE_LAST  HWRM_FUNC_QCFG_OUTPUT_EVB_MODE_VEPA
	uint8_t	options;
	/*
	 * This value indicates the PCIE device cache line size.
	 * The cache line size allows the DMA writes to terminate and
	 * start at the cache boundary.
	 */
	#define HWRM_FUNC_QCFG_OUTPUT_OPTIONS_CACHE_LINESIZE_MASK	UINT32_C(0x3)
	#define HWRM_FUNC_QCFG_OUTPUT_OPTIONS_CACHE_LINESIZE_SFT	0
	/* Cache Line Size 64 bytes */
		#define HWRM_FUNC_QCFG_OUTPUT_OPTIONS_CACHE_LINESIZE_SIZE_64	UINT32_C(0x0)
	/* Cache Line Size 128 bytes */
		#define HWRM_FUNC_QCFG_OUTPUT_OPTIONS_CACHE_LINESIZE_SIZE_128	UINT32_C(0x1)
		#define HWRM_FUNC_QCFG_OUTPUT_OPTIONS_CACHE_LINESIZE_LAST	HWRM_FUNC_QCFG_OUTPUT_OPTIONS_CACHE_LINESIZE_SIZE_128
	/* This value is the virtual link admin state setting. */
	#define HWRM_FUNC_QCFG_OUTPUT_OPTIONS_LINK_ADMIN_STATE_MASK	UINT32_C(0xc)
	#define HWRM_FUNC_QCFG_OUTPUT_OPTIONS_LINK_ADMIN_STATE_SFT	2
	/* Admin link state is in forced down mode. */
		#define HWRM_FUNC_QCFG_OUTPUT_OPTIONS_LINK_ADMIN_STATE_FORCED_DOWN  (UINT32_C(0x0) << 2)
	/* Admin link state is in forced up mode. */
		#define HWRM_FUNC_QCFG_OUTPUT_OPTIONS_LINK_ADMIN_STATE_FORCED_UP	(UINT32_C(0x1) << 2)
	/* Admin link state is in auto mode  - follows the physical link state. */
		#define HWRM_FUNC_QCFG_OUTPUT_OPTIONS_LINK_ADMIN_STATE_AUTO	(UINT32_C(0x2) << 2)
		#define HWRM_FUNC_QCFG_OUTPUT_OPTIONS_LINK_ADMIN_STATE_LAST	HWRM_FUNC_QCFG_OUTPUT_OPTIONS_LINK_ADMIN_STATE_AUTO
	/* Reserved for future. */
	#define HWRM_FUNC_QCFG_OUTPUT_OPTIONS_RSVD_MASK		UINT32_C(0xf0)
	#define HWRM_FUNC_QCFG_OUTPUT_OPTIONS_RSVD_SFT			4
	/*
	 * The number of VFs that are allocated to the function.
	 * This is valid only on the PF with SR-IOV enabled.
	 * 0xFF... (All Fs) if this command is called on a PF with
	 * SR-IOV disabled or on a VF.
	 */
	uint16_t	alloc_vfs;
	/*
	 * The number of allocated multicast filters for this
	 * function on the RX side.
	 */
	uint32_t	alloc_mcast_filters;
	/*
	 * The number of allocated HW ring groups for this
	 * function.
	 */
	uint32_t	alloc_hw_ring_grps;
	/*
	 * The number of strict priority transmit rings out of
	 * currently allocated TX rings to the function
	 * (alloc_tx_rings).
	 */
	uint16_t	alloc_sp_tx_rings;
	/*
	 * The number of statistics contexts
	 * currently reserved for the function.
	 */
	uint16_t	alloc_stat_ctx;
	/*
	 * This field specifies how many NQs are reserved for the PF.
	 * Remaining NQs that belong to the PF are available for VFs.
	 * Once a PF has created VFs, it cannot change how many NQs are
	 * reserved for itself (since the NQs must be contiguous in HW).
	 */
	uint16_t	alloc_msix;
	/*
	 * The number of registered VF’s associated with the PF. This field
	 * should be ignored when the request received on the VF interface.
	 * This field will be updated on the PF interface to initiate
	 * the unregister request on PF in the HOT Reset Process.
	 */
	uint16_t	registered_vfs;
	/*
	 * The size of the doorbell BAR in KBytes reserved for L2 including
	 * any area that is shared between L2 and RoCE.  The L2 driver
	 * should only map the L2 portion of the doorbell BAR.  Any rounding
	 * of the BAR size to the native CPU page size should be performed
	 * by the driver.  If the value is zero, no special partitioning
	 * of the doorbell BAR between L2 and RoCE is required.
	 */
	uint16_t	l2_doorbell_bar_size_kb;
	uint8_t	unused_1;
	/*
	 * For backward compatibility this field must be set to 1.
	 * Older drivers might look for this field to be 1 before
	 * processing the message.
	 */
	uint8_t	always_1;
	/*
	 * This GRC address location is used by the Host driver interfaces to poll
	 * the adapter ready state to re-initiate the registration process again
	 * after receiving the RESET Notify event.
	 */
	uint32_t	reset_addr_poll;
	/*
	 * This field specifies legacy L2 doorbell size in KBytes. Drivers should use
	 * this value to find out the doorbell page offset from the BAR.
	 */
	uint16_t	legacy_l2_db_size_kb;
	uint16_t	svif_info;
	/*
	 * This field specifies the source virtual interface of the function being
	 * queried. Drivers can use this to program svif field in the L2 context
	 * table
	 */
	#define HWRM_FUNC_QCFG_OUTPUT_SVIF_INFO_SVIF_MASK	UINT32_C(0x7fff)
	#define HWRM_FUNC_QCFG_OUTPUT_SVIF_INFO_SVIF_SFT	0
	/* This field specifies whether svif is valid or not */
	#define HWRM_FUNC_QCFG_OUTPUT_SVIF_INFO_SVIF_VALID	UINT32_C(0x8000)
	uint8_t	mpc_chnls;
	/*
	 * When this bit is '1', it indicates that a MPC channel with
	 * destination set to the TX crypto engine block is enabled.
	 */
	#define HWRM_FUNC_QCFG_OUTPUT_MPC_CHNLS_TCE_ENABLED	UINT32_C(0x1)
	/*
	 * When this bit is '1', it indicates that a MPC channel with
	 * destination set to the RX crypto engine block is enabled.
	 */
	#define HWRM_FUNC_QCFG_OUTPUT_MPC_CHNLS_RCE_ENABLED	UINT32_C(0x2)
	/*
	 * When this bit is '1', it indicates that a MPC channel with
	 * destination set to the TX configurable flow processing block is
	 * enabled.
	 */
	#define HWRM_FUNC_QCFG_OUTPUT_MPC_CHNLS_TE_CFA_ENABLED	UINT32_C(0x4)
	/*
	 * When this bit is '1', it indicates that a MPC channel with
	 * destination set to the RX configurable flow processing block is
	 * enabled.
	 */
	#define HWRM_FUNC_QCFG_OUTPUT_MPC_CHNLS_RE_CFA_ENABLED	UINT32_C(0x8)
	/*
	 * When this bit is '1', it indicates that a MPC channel with
	 * destination set to the primate processor block is enabled.
	 */
	#define HWRM_FUNC_QCFG_OUTPUT_MPC_CHNLS_PRIMATE_ENABLED	UINT32_C(0x10)
	uint8_t	unused_2[3];
	/*
	 * Minimum guaranteed bandwidth for the network partition made up
	 * of the caller physical function and all its child virtual
	 * functions. The rate is specified as a percentage of the bandwidth
	 * of the link the partition is associated with. A value of 0
	 * indicates that no minimum bandwidth is configured.
	 * The format of this field is defined to match min_bw, even though
	 * the partition minimum rate is always specified as a percentage.
	 */
	uint32_t	partition_min_bw;
	/* The bandwidth value. */
	#define HWRM_FUNC_QCFG_OUTPUT_PARTITION_MIN_BW_BW_VALUE_MASK		UINT32_C(0xfffffff)
	#define HWRM_FUNC_QCFG_OUTPUT_PARTITION_MIN_BW_BW_VALUE_SFT		0
	/*
	 * The granularity of the value (bits or bytes). Firmware never sets
	 * this field.
	 */
	#define HWRM_FUNC_QCFG_OUTPUT_PARTITION_MIN_BW_SCALE			UINT32_C(0x10000000)
	/* Value is in bits. */
		#define HWRM_FUNC_QCFG_OUTPUT_PARTITION_MIN_BW_SCALE_BITS		(UINT32_C(0x0) << 28)
	/* Value is in bytes. */
		#define HWRM_FUNC_QCFG_OUTPUT_PARTITION_MIN_BW_SCALE_BYTES		(UINT32_C(0x1) << 28)
		#define HWRM_FUNC_QCFG_OUTPUT_PARTITION_MIN_BW_SCALE_LAST		HWRM_FUNC_QCFG_OUTPUT_PARTITION_MIN_BW_SCALE_BYTES
	/* Always percentage of link bandwidth. */
	#define HWRM_FUNC_QCFG_OUTPUT_PARTITION_MIN_BW_BW_VALUE_UNIT_MASK	UINT32_C(0xe0000000)
	#define HWRM_FUNC_QCFG_OUTPUT_PARTITION_MIN_BW_BW_VALUE_UNIT_SFT	29
	/* Bandwidth value is in hundredths of a percent of link bandwidth. */
		#define HWRM_FUNC_QCFG_OUTPUT_PARTITION_MIN_BW_BW_VALUE_UNIT_PERCENT1_100  (UINT32_C(0x1) << 29)
		#define HWRM_FUNC_QCFG_OUTPUT_PARTITION_MIN_BW_BW_VALUE_UNIT_LAST	HWRM_FUNC_QCFG_OUTPUT_PARTITION_MIN_BW_BW_VALUE_UNIT_PERCENT1_100
	/*
	 * The maximum bandwidth that may be used by the network partition
	 * made up of the caller physical function and all its child virtual
	 * functions. The rate is specified as a percentage of the bandwidth
	 * of the link the partition is associated with. A value of 0
	 * indicates that no maximum bandwidth is configured.
	 * The format of this field is defined to match max_bw, even though
	 * the partition bandwidth must be specified as a percentage.
	 */
	uint32_t	partition_max_bw;
	/* The bandwidth value. */
	#define HWRM_FUNC_QCFG_OUTPUT_PARTITION_MAX_BW_BW_VALUE_MASK		UINT32_C(0xfffffff)
	#define HWRM_FUNC_QCFG_OUTPUT_PARTITION_MAX_BW_BW_VALUE_SFT		0
	/*
	 * The granularity of the value (bits or bytes). Firmware never sets
	 * this field.
	 */
	#define HWRM_FUNC_QCFG_OUTPUT_PARTITION_MAX_BW_SCALE			UINT32_C(0x10000000)
	/* Value is in bits. */
		#define HWRM_FUNC_QCFG_OUTPUT_PARTITION_MAX_BW_SCALE_BITS		(UINT32_C(0x0) << 28)
	/* Value is in bytes. */
		#define HWRM_FUNC_QCFG_OUTPUT_PARTITION_MAX_BW_SCALE_BYTES		(UINT32_C(0x1) << 28)
		#define HWRM_FUNC_QCFG_OUTPUT_PARTITION_MAX_BW_SCALE_LAST		HWRM_FUNC_QCFG_OUTPUT_PARTITION_MAX_BW_SCALE_BYTES
	/* Always a percentage of link bandwidth. */
	#define HWRM_FUNC_QCFG_OUTPUT_PARTITION_MAX_BW_BW_VALUE_UNIT_MASK	UINT32_C(0xe0000000)
	#define HWRM_FUNC_QCFG_OUTPUT_PARTITION_MAX_BW_BW_VALUE_UNIT_SFT	29
	/* Value is in hundredths of a percent of link bandwidth. */
		#define HWRM_FUNC_QCFG_OUTPUT_PARTITION_MAX_BW_BW_VALUE_UNIT_PERCENT1_100  (UINT32_C(0x1) << 29)
		#define HWRM_FUNC_QCFG_OUTPUT_PARTITION_MAX_BW_BW_VALUE_UNIT_LAST	HWRM_FUNC_QCFG_OUTPUT_PARTITION_MAX_BW_BW_VALUE_UNIT_PERCENT1_100
	uint8_t	unused_3[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_func_qcfg_output_t, *phwrm_func_qcfg_output_t;

/*****************
 * hwrm_func_cfg *
 *****************/


/* hwrm_func_cfg_input (size:832b/104B) */

typedef struct hwrm_func_cfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * Function ID of the function that is being
	 * configured.
	 * If set to 0xFF... (All Fs), then the the configuration is
	 * for the requesting function.
	 */
	uint16_t	fid;
	/*
	 * This field specifies how many NQs will be reserved for the PF.
	 * Remaining NQs that belong to the PF become available for VFs.
	 * Once a PF has created VFs, it cannot change how many NQs are
	 * reserved for itself (since the NQs must be contiguous in HW).
	 */
	uint16_t	num_msix;
	uint32_t	flags;
	/*
	 * When this bit is '1', the function is disabled with
	 * source MAC address check.
	 * This is an anti-spoofing check. If this flag is set,
	 * then the function shall be configured to disallow
	 * transmission of frames with the source MAC address that
	 * is configured for this function.
	 */
	#define HWRM_FUNC_CFG_INPUT_FLAGS_SRC_MAC_ADDR_CHECK_DISABLE	UINT32_C(0x1)
	/*
	 * When this bit is '1', the function is enabled with
	 * source MAC address check.
	 * This is an anti-spoofing check. If this flag is set,
	 * then the function shall be configured to allow
	 * transmission of frames with the source MAC address that
	 * is configured for this function.
	 */
	#define HWRM_FUNC_CFG_INPUT_FLAGS_SRC_MAC_ADDR_CHECK_ENABLE	UINT32_C(0x2)
	/* reserved. */
	#define HWRM_FUNC_CFG_INPUT_FLAGS_RSVD_MASK			UINT32_C(0x1fc)
	#define HWRM_FUNC_CFG_INPUT_FLAGS_RSVD_SFT			2
	/*
	 * Standard TX Ring mode is used for the allocation of TX ring
	 * and underlying scheduling resources that allow bandwidth
	 * reservation and limit settings on the queried function.
	 * If set to 1, then standard TX ring mode is requested to be
	 * enabled on the function being configured.
	 */
	#define HWRM_FUNC_CFG_INPUT_FLAGS_STD_TX_RING_MODE_ENABLE	UINT32_C(0x200)
	/*
	 * Standard TX Ring mode is used for the allocation of TX ring
	 * and underlying scheduling resources that allow bandwidth
	 * reservation and limit settings on the queried function.
	 * If set to 1, then the standard TX ring mode is requested to
	 * be disabled on the function being configured. In this extended
	 * TX ring resource mode, the minimum and maximum bandwidth settings
	 * are not supported to allow the allocation of TX rings to
	 * span multiple scheduler nodes.
	 */
	#define HWRM_FUNC_CFG_INPUT_FLAGS_STD_TX_RING_MODE_DISABLE	UINT32_C(0x400)
	/*
	 * If this bit is set, virtual mac address configured
	 * in this command will be persistent over warm boot.
	 */
	#define HWRM_FUNC_CFG_INPUT_FLAGS_VIRT_MAC_PERSIST		UINT32_C(0x800)
	/*
	 * This bit only applies to the VF. If this bit is set, the statistic
	 * context counters will not be cleared when the statistic context is freed
	 * or a function reset is called on VF. This bit will be cleared when the PF
	 * is unloaded or a function reset is called on the PF.
	 */
	#define HWRM_FUNC_CFG_INPUT_FLAGS_NO_AUTOCLEAR_STATISTIC	UINT32_C(0x1000)
	/*
	 * This bit requests that the firmware test to see if all the assets
	 * requested in this command (i.e. number of TX rings) are available.
	 * The firmware will return an error if the requested assets are
	 * not available. The firwmare will NOT reserve the assets if they
	 * are available.
	 */
	#define HWRM_FUNC_CFG_INPUT_FLAGS_TX_ASSETS_TEST		UINT32_C(0x2000)
	/*
	 * This bit requests that the firmware test to see if all the assets
	 * requested in this command (i.e. number of RX rings) are available.
	 * The firmware will return an error if the requested assets are
	 * not available. The firwmare will NOT reserve the assets if they
	 * are available.
	 */
	#define HWRM_FUNC_CFG_INPUT_FLAGS_RX_ASSETS_TEST		UINT32_C(0x4000)
	/*
	 * This bit requests that the firmware test to see if all the assets
	 * requested in this command (i.e. number of CMPL rings) are available.
	 * The firmware will return an error if the requested assets are
	 * not available. The firwmare will NOT reserve the assets if they
	 * are available.
	 */
	#define HWRM_FUNC_CFG_INPUT_FLAGS_CMPL_ASSETS_TEST		UINT32_C(0x8000)
	/*
	 * This bit requests that the firmware test to see if all the assets
	 * requested in this command (i.e. number of RSS ctx) are available.
	 * The firmware will return an error if the requested assets are
	 * not available. The firwmare will NOT reserve the assets if they
	 * are available.
	 */
	#define HWRM_FUNC_CFG_INPUT_FLAGS_RSSCOS_CTX_ASSETS_TEST	UINT32_C(0x10000)
	/*
	 * This bit requests that the firmware test to see if all the assets
	 * requested in this command (i.e. number of ring groups) are available.
	 * The firmware will return an error if the requested assets are
	 * not available. The firwmare will NOT reserve the assets if they
	 * are available.
	 */
	#define HWRM_FUNC_CFG_INPUT_FLAGS_RING_GRP_ASSETS_TEST	UINT32_C(0x20000)
	/*
	 * This bit requests that the firmware test to see if all the assets
	 * requested in this command (i.e. number of stat ctx) are available.
	 * The firmware will return an error if the requested assets are
	 * not available. The firwmare will NOT reserve the assets if they
	 * are available.
	 */
	#define HWRM_FUNC_CFG_INPUT_FLAGS_STAT_CTX_ASSETS_TEST	UINT32_C(0x40000)
	/*
	 * This bit requests that the firmware test to see if all the assets
	 * requested in this command (i.e. number of VNICs) are available.
	 * The firmware will return an error if the requested assets are
	 * not available. The firwmare will NOT reserve the assets if they
	 * are available.
	 */
	#define HWRM_FUNC_CFG_INPUT_FLAGS_VNIC_ASSETS_TEST		UINT32_C(0x80000)
	/*
	 * This bit requests that the firmware test to see if all the assets
	 * requested in this command (i.e. number of L2 ctx) are available.
	 * The firmware will return an error if the requested assets are
	 * not available. The firwmare will NOT reserve the assets if they
	 * are available.
	 */
	#define HWRM_FUNC_CFG_INPUT_FLAGS_L2_CTX_ASSETS_TEST		UINT32_C(0x100000)
	/*
	 * This configuration change can be initiated by a PF driver. This
	 * configuration request shall be targeted to a VF. From local host
	 * resident HWRM clients, only the parent PF driver shall be allowed
	 * to initiate this change on one of its children VFs. If this bit is
	 * set to 1, then the VF that is being configured is requested to be
	 * trusted.
	 */
	#define HWRM_FUNC_CFG_INPUT_FLAGS_TRUSTED_VF_ENABLE		UINT32_C(0x200000)
	/*
	 * When this bit it set, even if PF reserved pool size is zero,
	 * FW will allow driver to create TX rings in ring alloc,
	 * by reserving TX ring, S3 node dynamically.
	 */
	#define HWRM_FUNC_CFG_INPUT_FLAGS_DYNAMIC_TX_RING_ALLOC	UINT32_C(0x400000)
	/*
	 * This bit requests that the firmware test to see if all the assets
	 * requested in this command (i.e. number of NQ rings) are available.
	 * The firmware will return an error if the requested assets are
	 * not available. The firwmare will NOT reserve the assets if they
	 * are available.
	 */
	#define HWRM_FUNC_CFG_INPUT_FLAGS_NQ_ASSETS_TEST		UINT32_C(0x800000)
	/*
	 * This configuration change can be initiated by a PF driver. This
	 * configuration request shall be targeted to a VF. From local host
	 * resident HWRM clients, only the parent PF driver shall be allowed
	 * to initiate this change on one of its children VFs. If this bit is
	 * set to 1, then the VF that is being configured is requested to be
	 * untrusted.
	 */
	#define HWRM_FUNC_CFG_INPUT_FLAGS_TRUSTED_VF_DISABLE		UINT32_C(0x1000000)
	/*
	 * This bit is used by preboot drivers on a PF that require access
	 * to the legacy L2 ring model and legacy 32b doorbells. This
	 * feature is not allowed on VFs and is only relevant for devices
	 * that require a context backing store.
	 */
	#define HWRM_FUNC_CFG_INPUT_FLAGS_PREBOOT_LEGACY_L2_RINGS	UINT32_C(0x2000000)
	/*
	 * If this bit is set to 0, then the interface does not support hot
	 * reset capability which it advertised with the hot_reset_support
	 * flag in HWRM_FUNC_DRV_RGTR. If any of the function has set this
	 * flag to 0, adapter cannot do the hot reset. In this state, if the
	 * firmware receives a hot reset request, firmware must fail the
	 * request. If this bit is set to 1, then interface is renabling the
	 * hot reset capability.
	 */
	#define HWRM_FUNC_CFG_INPUT_FLAGS_HOT_RESET_IF_EN_DIS		UINT32_C(0x4000000)
	/*
	 * If this bit is set to 1, the PF driver is requesting FW
	 * to enable PPP TX PUSH feature on all the TX rings specified in
	 * the num_tx_rings field. By default, the PPP TX push feature is
	 * disabled for all the TX rings of the function. This flag is
	 * ignored if num_tx_rings field is not specified or the function
	 * doesn't support PPP tx push feature.
	 */
	#define HWRM_FUNC_CFG_INPUT_FLAGS_PPP_PUSH_MODE_ENABLE	UINT32_C(0x8000000)
	/*
	 * If this bit is set to 1, the PF driver is requesting FW
	 * to disable PPP TX PUSH feature on all the TX rings specified in
	 * the num_tx_rings field. This flag is ignored if num_tx_rings
	 * field is not specified or the function doesn't support PPP tx
	 * push feature.
	 */
	#define HWRM_FUNC_CFG_INPUT_FLAGS_PPP_PUSH_MODE_DISABLE	UINT32_C(0x10000000)
	/*
	 * If this bit is set to 1, the driver is requesting FW to enable
	 * the BD_METADATA feature for this function. The FW returns error
	 * on this request if the TX_METADATA is enabled for this function.
	 */
	#define HWRM_FUNC_CFG_INPUT_FLAGS_BD_METADATA_ENABLE		UINT32_C(0x20000000)
	/*
	 * If this bit is set to 1, the driver is requesting FW to disable
	 * the BD_METADATA feature for this function. The FW returns error
	 * on this request if the TX_METADATA is enabled for this function.
	 */
	#define HWRM_FUNC_CFG_INPUT_FLAGS_BD_METADATA_DISABLE		UINT32_C(0x40000000)
	uint32_t	enables;
	/*
	 * This bit must be '1' for the mtu field to be
	 * configured.
	 */
	#define HWRM_FUNC_CFG_INPUT_ENABLES_MTU			UINT32_C(0x1)
	/*
	 * This bit must be '1' for the mru field to be
	 * configured.
	 */
	#define HWRM_FUNC_CFG_INPUT_ENABLES_MRU			UINT32_C(0x2)
	/*
	 * This bit must be '1' for the num_rsscos_ctxs field to be
	 * configured.
	 */
	#define HWRM_FUNC_CFG_INPUT_ENABLES_NUM_RSSCOS_CTXS	UINT32_C(0x4)
	/*
	 * This bit must be '1' for the num_cmpl_rings field to be
	 * configured.
	 */
	#define HWRM_FUNC_CFG_INPUT_ENABLES_NUM_CMPL_RINGS	UINT32_C(0x8)
	/*
	 * This bit must be '1' for the num_tx_rings field to be
	 * configured.
	 */
	#define HWRM_FUNC_CFG_INPUT_ENABLES_NUM_TX_RINGS		UINT32_C(0x10)
	/*
	 * This bit must be '1' for the num_rx_rings field to be
	 * configured.
	 */
	#define HWRM_FUNC_CFG_INPUT_ENABLES_NUM_RX_RINGS		UINT32_C(0x20)
	/*
	 * This bit must be '1' for the num_l2_ctxs field to be
	 * configured.
	 */
	#define HWRM_FUNC_CFG_INPUT_ENABLES_NUM_L2_CTXS		UINT32_C(0x40)
	/*
	 * This bit must be '1' for the num_vnics field to be
	 * configured.
	 */
	#define HWRM_FUNC_CFG_INPUT_ENABLES_NUM_VNICS		UINT32_C(0x80)
	/*
	 * This bit must be '1' for the num_stat_ctxs field to be
	 * configured.
	 */
	#define HWRM_FUNC_CFG_INPUT_ENABLES_NUM_STAT_CTXS		UINT32_C(0x100)
	/*
	 * This bit must be '1' for the dflt_mac_addr field to be
	 * configured.
	 */
	#define HWRM_FUNC_CFG_INPUT_ENABLES_DFLT_MAC_ADDR		UINT32_C(0x200)
	/*
	 * This bit must be '1' for the dflt_vlan field to be
	 * configured.
	 */
	#define HWRM_FUNC_CFG_INPUT_ENABLES_DFLT_VLAN		UINT32_C(0x400)
	/*
	 * This bit must be '1' for the dflt_ip_addr field to be
	 * configured.
	 */
	#define HWRM_FUNC_CFG_INPUT_ENABLES_DFLT_IP_ADDR		UINT32_C(0x800)
	/*
	 * This bit must be '1' for the min_bw field to be
	 * configured.
	 */
	#define HWRM_FUNC_CFG_INPUT_ENABLES_MIN_BW		UINT32_C(0x1000)
	/*
	 * This bit must be '1' for the max_bw field to be
	 * configured.
	 */
	#define HWRM_FUNC_CFG_INPUT_ENABLES_MAX_BW		UINT32_C(0x2000)
	/*
	 * This bit must be '1' for the async_event_cr field to be
	 * configured.
	 */
	#define HWRM_FUNC_CFG_INPUT_ENABLES_ASYNC_EVENT_CR	UINT32_C(0x4000)
	/*
	 * This bit must be '1' for the vlan_antispoof_mode field to be
	 * configured.
	 */
	#define HWRM_FUNC_CFG_INPUT_ENABLES_VLAN_ANTISPOOF_MODE	UINT32_C(0x8000)
	/*
	 * This bit must be '1' for the allowed_vlan_pris field to be
	 * configured.
	 */
	#define HWRM_FUNC_CFG_INPUT_ENABLES_ALLOWED_VLAN_PRIS	UINT32_C(0x10000)
	/*
	 * This bit must be '1' for the evb_mode field to be
	 * configured.
	 */
	#define HWRM_FUNC_CFG_INPUT_ENABLES_EVB_MODE		UINT32_C(0x20000)
	/*
	 * This bit must be '1' for the num_mcast_filters field to be
	 * configured.
	 */
	#define HWRM_FUNC_CFG_INPUT_ENABLES_NUM_MCAST_FILTERS	UINT32_C(0x40000)
	/*
	 * This bit must be '1' for the num_hw_ring_grps field to be
	 * configured.
	 */
	#define HWRM_FUNC_CFG_INPUT_ENABLES_NUM_HW_RING_GRPS	UINT32_C(0x80000)
	/*
	 * This bit must be '1' for the cache_linesize field to be
	 * configured.
	 */
	#define HWRM_FUNC_CFG_INPUT_ENABLES_CACHE_LINESIZE	UINT32_C(0x100000)
	/*
	 * This bit must be '1' for the num_msix field to be
	 * configured.
	 */
	#define HWRM_FUNC_CFG_INPUT_ENABLES_NUM_MSIX		UINT32_C(0x200000)
	/*
	 * This bit must be '1' for the link admin state field to be
	 * configured.
	 */
	#define HWRM_FUNC_CFG_INPUT_ENABLES_ADMIN_LINK_STATE	UINT32_C(0x400000)
	/*
	 * This bit must be '1' for the hot_reset_if_en_dis field to be
	 * configured.
	 */
	#define HWRM_FUNC_CFG_INPUT_ENABLES_HOT_RESET_IF_SUPPORT	UINT32_C(0x800000)
	/*
	 * This bit must be '1' for the schq_id field to be
	 * configured.
	 */
	#define HWRM_FUNC_CFG_INPUT_ENABLES_SCHQ_ID		UINT32_C(0x1000000)
	/*
	 * This bit must be '1' for the mpc_chnls field to be
	 * configured.
	 */
	#define HWRM_FUNC_CFG_INPUT_ENABLES_MPC_CHNLS		UINT32_C(0x2000000)
	/*
	 * This bit must be '1' for the partition_min_bw field to be
	 * configured.
	 */
	#define HWRM_FUNC_CFG_INPUT_ENABLES_PARTITION_MIN_BW	UINT32_C(0x4000000)
	/*
	 * This bit must be '1' for the partition_max_bw field to be
	 * configured.
	 */
	#define HWRM_FUNC_CFG_INPUT_ENABLES_PARTITION_MAX_BW	UINT32_C(0x8000000)
	/*
	 * This bit must be '1' for the tpid field to be
	 * configured. This bit is only valid when dflt_vlan enable
	 * bit is set.
	 */
	#define HWRM_FUNC_CFG_INPUT_ENABLES_TPID			UINT32_C(0x10000000)
	/*
	 * The maximum transmission unit of the function.
	 * The HWRM should make sure that the mtu of
	 * the function does not exceed the mtu of the physical
	 * port that this function is associated with.
	 *
	 * In addition to configuring mtu per function, it is
	 * possible to configure mtu per transmit ring.
	 * By default, the mtu of each transmit ring associated
	 * with a function is equal to the mtu of the function.
	 * The HWRM should make sure that the mtu of each transmit
	 * ring that is assigned to a function has a valid mtu.
	 */
	uint16_t	mtu;
	/*
	 * The maximum receive unit of the function.
	 * The HWRM should make sure that the mru of
	 * the function does not exceed the mru of the physical
	 * port that this function is associated with.
	 *
	 * In addition to configuring mru per function, it is
	 * possible to configure mru per vnic.
	 * By default, the mru of each vnic associated
	 * with a function is equal to the mru of the function.
	 * The HWRM should make sure that the mru of each vnic
	 * that is assigned to a function has a valid mru.
	 */
	uint16_t	mru;
	/*
	 * The number of RSS/COS contexts requested for the
	 * function.
	 */
	uint16_t	num_rsscos_ctxs;
	/*
	 * The number of completion rings requested for the
	 * function. This does not include the rings allocated
	 * to any children functions if any.
	 */
	uint16_t	num_cmpl_rings;
	/*
	 * The number of transmit rings requested for the function.
	 * This does not include the rings allocated to any
	 * children functions if any.
	 */
	uint16_t	num_tx_rings;
	/*
	 * The number of receive rings requested for the function.
	 * This does not include the rings allocated
	 * to any children functions if any.
	 */
	uint16_t	num_rx_rings;
	/* The requested number of L2 contexts for the function. */
	uint16_t	num_l2_ctxs;
	/* The requested number of vnics for the function. */
	uint16_t	num_vnics;
	/* The requested number of statistic contexts for the function. */
	uint16_t	num_stat_ctxs;
	/*
	 * The number of HW ring groups that should
	 * be reserved for this function.
	 */
	uint16_t	num_hw_ring_grps;
	/* The default MAC address for the function being configured. */
	uint8_t	dflt_mac_addr[6];
	/*
	 * The default VLAN for the function being configured.
	 * This field's format is same as 802.1Q Tag's
	 * Tag Control Information (TCI) format that includes both
	 * Priority Code Point (PCP) and VLAN Identifier (VID).
	 */
	uint16_t	dflt_vlan;
	/*
	 * The default IP address for the function being configured.
	 * This address is only used in enabling source property check.
	 */
	uint32_t	dflt_ip_addr[4];
	/*
	 * Minimum guaranteed transmit bandwidth for this function. When
	 * specified for a PF, does not affect traffic from the PF's child VFs.
	 * A value of 0 indicates the minimum bandwidth is not configured.
	 */
	uint32_t	min_bw;
	/* The bandwidth value. */
	#define HWRM_FUNC_CFG_INPUT_MIN_BW_BW_VALUE_MASK		UINT32_C(0xfffffff)
	#define HWRM_FUNC_CFG_INPUT_MIN_BW_BW_VALUE_SFT		0
	/* The granularity of the value (bits or bytes). */
	#define HWRM_FUNC_CFG_INPUT_MIN_BW_SCALE			UINT32_C(0x10000000)
	/* Value is in bits. */
		#define HWRM_FUNC_CFG_INPUT_MIN_BW_SCALE_BITS		(UINT32_C(0x0) << 28)
	/* Value is in bytes. */
		#define HWRM_FUNC_CFG_INPUT_MIN_BW_SCALE_BYTES		(UINT32_C(0x1) << 28)
		#define HWRM_FUNC_CFG_INPUT_MIN_BW_SCALE_LAST		HWRM_FUNC_CFG_INPUT_MIN_BW_SCALE_BYTES
	/* bw_value_unit is 3 b */
	#define HWRM_FUNC_CFG_INPUT_MIN_BW_BW_VALUE_UNIT_MASK	UINT32_C(0xe0000000)
	#define HWRM_FUNC_CFG_INPUT_MIN_BW_BW_VALUE_UNIT_SFT	29
	/* Value is in Mb or MB (base 10). */
		#define HWRM_FUNC_CFG_INPUT_MIN_BW_BW_VALUE_UNIT_MEGA	(UINT32_C(0x0) << 29)
	/* Value is in Kb or KB (base 10). */
		#define HWRM_FUNC_CFG_INPUT_MIN_BW_BW_VALUE_UNIT_KILO	(UINT32_C(0x2) << 29)
	/* Value is in bits or bytes. */
		#define HWRM_FUNC_CFG_INPUT_MIN_BW_BW_VALUE_UNIT_BASE	(UINT32_C(0x4) << 29)
	/* Value is in Gb or GB (base 10). */
		#define HWRM_FUNC_CFG_INPUT_MIN_BW_BW_VALUE_UNIT_GIGA	(UINT32_C(0x6) << 29)
	/* Value is in 1/100th of a percentage of total bandwidth. */
		#define HWRM_FUNC_CFG_INPUT_MIN_BW_BW_VALUE_UNIT_PERCENT1_100  (UINT32_C(0x1) << 29)
	/* Invalid unit */
		#define HWRM_FUNC_CFG_INPUT_MIN_BW_BW_VALUE_UNIT_INVALID	(UINT32_C(0x7) << 29)
		#define HWRM_FUNC_CFG_INPUT_MIN_BW_BW_VALUE_UNIT_LAST	HWRM_FUNC_CFG_INPUT_MIN_BW_BW_VALUE_UNIT_INVALID
	/*
	 * Maximum transmit rate for this function. When specified for a PF,
	 * does not affect traffic from the PF's child VFs.
	 * A value of 0 indicates that the maximum bandwidth is not configured.
	 */
	uint32_t	max_bw;
	/* The bandwidth value. */
	#define HWRM_FUNC_CFG_INPUT_MAX_BW_BW_VALUE_MASK		UINT32_C(0xfffffff)
	#define HWRM_FUNC_CFG_INPUT_MAX_BW_BW_VALUE_SFT		0
	/* The granularity of the value (bits or bytes). */
	#define HWRM_FUNC_CFG_INPUT_MAX_BW_SCALE			UINT32_C(0x10000000)
	/* Value is in bits. */
		#define HWRM_FUNC_CFG_INPUT_MAX_BW_SCALE_BITS		(UINT32_C(0x0) << 28)
	/* Value is in bytes. */
		#define HWRM_FUNC_CFG_INPUT_MAX_BW_SCALE_BYTES		(UINT32_C(0x1) << 28)
		#define HWRM_FUNC_CFG_INPUT_MAX_BW_SCALE_LAST		HWRM_FUNC_CFG_INPUT_MAX_BW_SCALE_BYTES
	/* bw_value_unit is 3 b */
	#define HWRM_FUNC_CFG_INPUT_MAX_BW_BW_VALUE_UNIT_MASK	UINT32_C(0xe0000000)
	#define HWRM_FUNC_CFG_INPUT_MAX_BW_BW_VALUE_UNIT_SFT	29
	/* Value is in Mb or MB (base 10). */
		#define HWRM_FUNC_CFG_INPUT_MAX_BW_BW_VALUE_UNIT_MEGA	(UINT32_C(0x0) << 29)
	/* Value is in Kb or KB (base 10). */
		#define HWRM_FUNC_CFG_INPUT_MAX_BW_BW_VALUE_UNIT_KILO	(UINT32_C(0x2) << 29)
	/* Value is in bits or bytes. */
		#define HWRM_FUNC_CFG_INPUT_MAX_BW_BW_VALUE_UNIT_BASE	(UINT32_C(0x4) << 29)
	/* Value is in Gb or GB (base 10). */
		#define HWRM_FUNC_CFG_INPUT_MAX_BW_BW_VALUE_UNIT_GIGA	(UINT32_C(0x6) << 29)
	/* Value is in 1/100th of a percentage of total bandwidth. */
		#define HWRM_FUNC_CFG_INPUT_MAX_BW_BW_VALUE_UNIT_PERCENT1_100  (UINT32_C(0x1) << 29)
	/* Invalid unit */
		#define HWRM_FUNC_CFG_INPUT_MAX_BW_BW_VALUE_UNIT_INVALID	(UINT32_C(0x7) << 29)
		#define HWRM_FUNC_CFG_INPUT_MAX_BW_BW_VALUE_UNIT_LAST	HWRM_FUNC_CFG_INPUT_MAX_BW_BW_VALUE_UNIT_INVALID
	/*
	 * ID of the target completion ring for receiving asynchronous
	 * event completions. If this field is not valid, then the
	 * HWRM shall use the default completion ring of the function
	 * that is being configured as the target completion ring for
	 * providing any asynchronous event completions for that
	 * function.
	 * If this field is valid, then the HWRM shall use the
	 * completion ring identified by this ID as the target
	 * completion ring for providing any asynchronous event
	 * completions for the function that is being configured.
	 */
	uint16_t	async_event_cr;
	/* VLAN Anti-spoofing mode. */
	uint8_t	vlan_antispoof_mode;
	/* No VLAN anti-spoofing checks are enabled */
	#define HWRM_FUNC_CFG_INPUT_VLAN_ANTISPOOF_MODE_NOCHECK		UINT32_C(0x0)
	/* Validate VLAN against the configured VLAN(s) */
	#define HWRM_FUNC_CFG_INPUT_VLAN_ANTISPOOF_MODE_VALIDATE_VLAN	UINT32_C(0x1)
	/* Insert VLAN if it does not exist, otherwise discard */
	#define HWRM_FUNC_CFG_INPUT_VLAN_ANTISPOOF_MODE_INSERT_IF_VLANDNE	UINT32_C(0x2)
	/* Insert VLAN if it does not exist, override VLAN if it exists */
	#define HWRM_FUNC_CFG_INPUT_VLAN_ANTISPOOF_MODE_INSERT_OR_OVERRIDE_VLAN UINT32_C(0x3)
	#define HWRM_FUNC_CFG_INPUT_VLAN_ANTISPOOF_MODE_LAST		HWRM_FUNC_CFG_INPUT_VLAN_ANTISPOOF_MODE_INSERT_OR_OVERRIDE_VLAN
	/*
	 * This bit field defines VLAN PRIs that are allowed on
	 * this function.
	 * If nth bit is set, then VLAN PRI n is allowed on this
	 * function.
	 */
	uint8_t	allowed_vlan_pris;
	/*
	 * The evb_mode is configured on a per port basis. The default evb_mode
	 * is configured based on the NVM EVB mode setting upon firmware
	 * initialization. The HWRM allows a PF driver to change EVB mode for a
	 * port used by the PF only when one of the following conditions is
	 * satisfied.
	 * 1. The current operating mode is single function mode.
	 *	(ie. one PF per port)
	 * 2. For SmartNIC, any one of the PAXC PFs is permitted to change the
	 *	EVB mode of the port used by the PAXC PF. None of the X86 PFs
	 *	should have privileges.
	 * The HWRM doesn't permit any PFs to change the underlying EVB mode
	 * when running as MHB or NPAR mode in performance NIC configuration.
	 * The HWRM doesn't permit a VF driver to change the EVB mode.
	 * Once the HWRM determines a function doesn't meet the conditions
	 * to configure the EVB mode, it sets the evb_mode_cfg_not_supported
	 * flag in HWRM_FUNC_QCAPS command response for the function.
	 * The HWRM takes into account the switching of EVB mode from one to
	 * another and reconfigure hardware resources as reqiured. The
	 * switching from VEB to VEPA mode requires the disabling of the
	 * loopback traffic. Additionally, source knockouts are handled
	 * differently in VEB and VEPA modes.
	 */
	uint8_t	evb_mode;
	/* No Edge Virtual Bridging (EVB) */
	#define HWRM_FUNC_CFG_INPUT_EVB_MODE_NO_EVB UINT32_C(0x0)
	/* Virtual Ethernet Bridge (VEB) */
	#define HWRM_FUNC_CFG_INPUT_EVB_MODE_VEB	UINT32_C(0x1)
	/* Virtual Ethernet Port Aggregator (VEPA) */
	#define HWRM_FUNC_CFG_INPUT_EVB_MODE_VEPA   UINT32_C(0x2)
	#define HWRM_FUNC_CFG_INPUT_EVB_MODE_LAST  HWRM_FUNC_CFG_INPUT_EVB_MODE_VEPA
	uint8_t	options;
	/*
	 * This value indicates the PCIE device cache line size.
	 * The cache line size allows the DMA writes to terminate and
	 * start at the cache boundary.
	 */
	#define HWRM_FUNC_CFG_INPUT_OPTIONS_CACHE_LINESIZE_MASK	UINT32_C(0x3)
	#define HWRM_FUNC_CFG_INPUT_OPTIONS_CACHE_LINESIZE_SFT	0
	/* Cache Line Size 64 bytes */
		#define HWRM_FUNC_CFG_INPUT_OPTIONS_CACHE_LINESIZE_SIZE_64	UINT32_C(0x0)
	/* Cache Line Size 128 bytes */
		#define HWRM_FUNC_CFG_INPUT_OPTIONS_CACHE_LINESIZE_SIZE_128	UINT32_C(0x1)
		#define HWRM_FUNC_CFG_INPUT_OPTIONS_CACHE_LINESIZE_LAST	HWRM_FUNC_CFG_INPUT_OPTIONS_CACHE_LINESIZE_SIZE_128
	/* This value is the virtual link admin state setting. */
	#define HWRM_FUNC_CFG_INPUT_OPTIONS_LINK_ADMIN_STATE_MASK	UINT32_C(0xc)
	#define HWRM_FUNC_CFG_INPUT_OPTIONS_LINK_ADMIN_STATE_SFT	2
	/* Admin state is forced down. */
		#define HWRM_FUNC_CFG_INPUT_OPTIONS_LINK_ADMIN_STATE_FORCED_DOWN  (UINT32_C(0x0) << 2)
	/* Admin state is forced up. */
		#define HWRM_FUNC_CFG_INPUT_OPTIONS_LINK_ADMIN_STATE_FORCED_UP	(UINT32_C(0x1) << 2)
	/* Admin state is in auto mode - is to follow the physical link state. */
		#define HWRM_FUNC_CFG_INPUT_OPTIONS_LINK_ADMIN_STATE_AUTO	(UINT32_C(0x2) << 2)
		#define HWRM_FUNC_CFG_INPUT_OPTIONS_LINK_ADMIN_STATE_LAST	HWRM_FUNC_CFG_INPUT_OPTIONS_LINK_ADMIN_STATE_AUTO
	/* Reserved for future. */
	#define HWRM_FUNC_CFG_INPUT_OPTIONS_RSVD_MASK		UINT32_C(0xf0)
	#define HWRM_FUNC_CFG_INPUT_OPTIONS_RSVD_SFT			4
	/*
	 * The number of multicast filters that should
	 * be reserved for this function on the RX side.
	 */
	uint16_t	num_mcast_filters;
	/* Used by a PF driver to associate a SCHQ with a VF. */
	uint16_t	schq_id;
	uint16_t	mpc_chnls;
	/*
	 * When this bit is '1', the caller requests to enable a MPC
	 * channel with destination to the TX crypto engine block.
	 * When this bit is ‘0’, this flag has no effect.
	 */
	#define HWRM_FUNC_CFG_INPUT_MPC_CHNLS_TCE_ENABLE	UINT32_C(0x1)
	/*
	 * When this bit is '1', the caller requests to disable a MPC
	 * channel with destination to the TX crypto engine block.
	 * When this bit is ‘0’, this flag has no effect.
	 */
	#define HWRM_FUNC_CFG_INPUT_MPC_CHNLS_TCE_DISABLE	UINT32_C(0x2)
	/*
	 * When this bit is '1', the caller requests to enable a MPC
	 * channel with destination to the RX crypto engine block.
	 * When this bit is ‘0’, this flag has no effect.
	 */
	#define HWRM_FUNC_CFG_INPUT_MPC_CHNLS_RCE_ENABLE	UINT32_C(0x4)
	/*
	 * When this bit is '1', the caller requests to disable a MPC
	 * channel with destination to the RX crypto engine block.
	 * When this bit is ‘0’, this flag has no effect.
	 */
	#define HWRM_FUNC_CFG_INPUT_MPC_CHNLS_RCE_DISABLE	UINT32_C(0x8)
	/*
	 * When this bit is '1', the caller requests to enable a MPC
	 * channel with destination to the TX configurable flow processing
	 * block. When this bit is ‘0’, this flag has no effect.
	 */
	#define HWRM_FUNC_CFG_INPUT_MPC_CHNLS_TE_CFA_ENABLE	UINT32_C(0x10)
	/*
	 * When this bit is '1', the caller requests to disable a MPC
	 * channel with destination to the TX configurable flow processing
	 * block block. When this bit is ‘0’, this flag has no effect.
	 */
	#define HWRM_FUNC_CFG_INPUT_MPC_CHNLS_TE_CFA_DISABLE	UINT32_C(0x20)
	/*
	 * When this bit is '1', the caller requests to enable a MPC
	 * channel with destination to the RX configurable flow processing
	 * block. When this bit is ‘0’, this flag has no effect.
	 */
	#define HWRM_FUNC_CFG_INPUT_MPC_CHNLS_RE_CFA_ENABLE	UINT32_C(0x40)
	/*
	 * When this bit is '1', the caller requests to disable a MPC
	 * channel with destination to the RX configurable flow processing
	 * block block. When this bit is ‘0’, this flag has no effect.
	 */
	#define HWRM_FUNC_CFG_INPUT_MPC_CHNLS_RE_CFA_DISABLE	UINT32_C(0x80)
	/*
	 * When this bit is '1', the caller requests to enable a MPC
	 * channel with destination to the primate processor block.
	 * When this bit is ‘0’, this flag has no effect.
	 */
	#define HWRM_FUNC_CFG_INPUT_MPC_CHNLS_PRIMATE_ENABLE	UINT32_C(0x100)
	/*
	 * When this bit is '1', the caller requests to disable a MPC
	 * channel with destination to the primate processor block.
	 * When this bit is ‘0’, this flag has no effect.
	 */
	#define HWRM_FUNC_CFG_INPUT_MPC_CHNLS_PRIMATE_DISABLE	UINT32_C(0x200)
	/*
	 * Minimum guaranteed bandwidth for the network partition made up
	 * of the caller physical function and all its child virtual
	 * functions. The rate is specified as a percentage of the bandwidth
	 * of the link the partition is associated with. A value of 0
	 * indicates that no minimum bandwidth is configured. The sum of the
	 * minimum bandwidths for all partitions on a link must not exceed
	 * 100%.
	 * The format of this field is defined to match min_bw, even though
	 * it does not allow all the options for min_bw at this time.
	 */
	uint32_t	partition_min_bw;
	/* The bandwidth value. */
	#define HWRM_FUNC_CFG_INPUT_PARTITION_MIN_BW_BW_VALUE_MASK		UINT32_C(0xfffffff)
	#define HWRM_FUNC_CFG_INPUT_PARTITION_MIN_BW_BW_VALUE_SFT		0
	/*
	 * The granularity of the value (bits or bytes). Firmware ignores
	 * this field.
	 */
	#define HWRM_FUNC_CFG_INPUT_PARTITION_MIN_BW_SCALE			UINT32_C(0x10000000)
	/* Value is in bits. */
		#define HWRM_FUNC_CFG_INPUT_PARTITION_MIN_BW_SCALE_BITS		(UINT32_C(0x0) << 28)
	/* Value is in bytes. */
		#define HWRM_FUNC_CFG_INPUT_PARTITION_MIN_BW_SCALE_BYTES		(UINT32_C(0x1) << 28)
		#define HWRM_FUNC_CFG_INPUT_PARTITION_MIN_BW_SCALE_LAST		HWRM_FUNC_CFG_INPUT_PARTITION_MIN_BW_SCALE_BYTES
	/* Bandwidth units. Must be set to percent1_100. */
	#define HWRM_FUNC_CFG_INPUT_PARTITION_MIN_BW_BW_VALUE_UNIT_MASK	UINT32_C(0xe0000000)
	#define HWRM_FUNC_CFG_INPUT_PARTITION_MIN_BW_BW_VALUE_UNIT_SFT	29
	/* Value is in hundredths of a percent of link bandwidth. */
		#define HWRM_FUNC_CFG_INPUT_PARTITION_MIN_BW_BW_VALUE_UNIT_PERCENT1_100  (UINT32_C(0x1) << 29)
		#define HWRM_FUNC_CFG_INPUT_PARTITION_MIN_BW_BW_VALUE_UNIT_LAST	HWRM_FUNC_CFG_INPUT_PARTITION_MIN_BW_BW_VALUE_UNIT_PERCENT1_100
	/*
	 * The maximum bandwidth that may be used by the network partition
	 * made up of the caller physical function and all its child virtual
	 * functions. The rate is specified as a percentage of the bandwidth
	 * of the link the partition is associated with. A value of 0
	 * indicates that no maximum bandwidth is configured.
	 * The format of this field is defined to match max_bw, even though it
	 * does not allow all the options for max_bw at this time.
	 */
	uint32_t	partition_max_bw;
	/* The bandwidth value. */
	#define HWRM_FUNC_CFG_INPUT_PARTITION_MAX_BW_BW_VALUE_MASK		UINT32_C(0xfffffff)
	#define HWRM_FUNC_CFG_INPUT_PARTITION_MAX_BW_BW_VALUE_SFT		0
	/*
	 * The granularity of the value (bits or bytes). Firmware ignores
	 * this field.
	 */
	#define HWRM_FUNC_CFG_INPUT_PARTITION_MAX_BW_SCALE			UINT32_C(0x10000000)
	/* Value is in bits. */
		#define HWRM_FUNC_CFG_INPUT_PARTITION_MAX_BW_SCALE_BITS		(UINT32_C(0x0) << 28)
	/* Value is in bytes. */
		#define HWRM_FUNC_CFG_INPUT_PARTITION_MAX_BW_SCALE_BYTES		(UINT32_C(0x1) << 28)
		#define HWRM_FUNC_CFG_INPUT_PARTITION_MAX_BW_SCALE_LAST		HWRM_FUNC_CFG_INPUT_PARTITION_MAX_BW_SCALE_BYTES
	/* Bandwidth units. Must be set to percent1_100. */
	#define HWRM_FUNC_CFG_INPUT_PARTITION_MAX_BW_BW_VALUE_UNIT_MASK	UINT32_C(0xe0000000)
	#define HWRM_FUNC_CFG_INPUT_PARTITION_MAX_BW_BW_VALUE_UNIT_SFT	29
	/* Value is in hundredths of a percent of link bandwidth. */
		#define HWRM_FUNC_CFG_INPUT_PARTITION_MAX_BW_BW_VALUE_UNIT_PERCENT1_100  (UINT32_C(0x1) << 29)
		#define HWRM_FUNC_CFG_INPUT_PARTITION_MAX_BW_BW_VALUE_UNIT_LAST	HWRM_FUNC_CFG_INPUT_PARTITION_MAX_BW_BW_VALUE_UNIT_PERCENT1_100
	/*
	 * The TPID for the function for which default VLAN
	 * is configured. If the dflt_vlan is not specified
	 * with the TPID, FW returns error. If the TPID is
	 * not specified with dflt_vlan, the default TPID of
	 * 0x8100 will be used. This field is specified in
	 * network byte order.
	 */
	uint16_t	tpid;
	uint8_t	unused_0[2];
} hwrm_func_cfg_input_t, *phwrm_func_cfg_input_t;

/* hwrm_func_cfg_output (size:128b/16B) */

typedef struct hwrm_func_cfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_func_cfg_output_t, *phwrm_func_cfg_output_t;

/********************
 * hwrm_func_qstats *
 ********************/


/* hwrm_func_qstats_input (size:192b/24B) */

typedef struct hwrm_func_qstats_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * Function ID of the function that is being queried.
	 * 0xFF... (All Fs) if the query is for the requesting
	 * function.
	 * A privileged PF can query for other function's statistics.
	 */
	uint16_t	fid;
	/* This flags indicates the type of statistics request. */
	uint8_t	flags;
	/* This value is not used to avoid backward compatibility issues. */
	#define HWRM_FUNC_QSTATS_INPUT_FLAGS_UNUSED	UINT32_C(0x0)
	/*
	 * flags should be set to 1 when request is for only RoCE statistics.
	 * This will be honored only if the caller_fid is a privileged PF.
	 * In all other cases FID and caller_fid should be the same.
	 */
	#define HWRM_FUNC_QSTATS_INPUT_FLAGS_ROCE_ONLY	UINT32_C(0x1)
	/*
	 * flags should be set to 2 when request is for the counter mask,
	 * representing the width of each of the stats counters, rather
	 * than counters themselves.
	 */
	#define HWRM_FUNC_QSTATS_INPUT_FLAGS_COUNTER_MASK UINT32_C(0x2)
	#define HWRM_FUNC_QSTATS_INPUT_FLAGS_LAST	HWRM_FUNC_QSTATS_INPUT_FLAGS_COUNTER_MASK
	uint8_t	unused_0[5];
} hwrm_func_qstats_input_t, *phwrm_func_qstats_input_t;

/* hwrm_func_qstats_output (size:1408b/176B) */

typedef struct hwrm_func_qstats_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Number of transmitted unicast packets on the function. */
	uint64_t	tx_ucast_pkts;
	/* Number of transmitted multicast packets on the function. */
	uint64_t	tx_mcast_pkts;
	/* Number of transmitted broadcast packets on the function. */
	uint64_t	tx_bcast_pkts;
	/*
	 * Number of transmitted packets that were discarded due to
	 * internal NIC resource problems.  For transmit, this
	 * can only happen if TMP is configured to allow dropping
	 * in HOL blocking conditions, which is not a normal
	 * configuration.
	 */
	uint64_t	tx_discard_pkts;
	/*
	 * Number of dropped packets on transmit path on the function.
	 * These are packets that have been marked for drop by
	 * the TE CFA block or are packets that exceeded the
	 * transmit MTU limit for the function.
	 */
	uint64_t	tx_drop_pkts;
	/* Number of transmitted bytes for unicast traffic on the function. */
	uint64_t	tx_ucast_bytes;
	/* Number of transmitted bytes for multicast traffic on the function. */
	uint64_t	tx_mcast_bytes;
	/* Number of transmitted bytes for broadcast traffic on the function. */
	uint64_t	tx_bcast_bytes;
	/* Number of received unicast packets on the function. */
	uint64_t	rx_ucast_pkts;
	/* Number of received multicast packets on the function. */
	uint64_t	rx_mcast_pkts;
	/* Number of received broadcast packets on the function. */
	uint64_t	rx_bcast_pkts;
	/*
	 * Number of received packets that were discarded on the function
	 * due to resource limitations.  This can happen for 3 reasons.
	 * # The BD used for the packet has a bad format.
	 * # There were no BDs available in the ring for the packet.
	 * # There were no BDs available on-chip for the packet.
	 */
	uint64_t	rx_discard_pkts;
	/*
	 * Number of dropped packets on received path on the function.
	 * These are packets that have been marked for drop by the
	 * RE CFA.
	 */
	uint64_t	rx_drop_pkts;
	/* Number of received bytes for unicast traffic on the function. */
	uint64_t	rx_ucast_bytes;
	/* Number of received bytes for multicast traffic on the function. */
	uint64_t	rx_mcast_bytes;
	/* Number of received bytes for broadcast traffic on the function. */
	uint64_t	rx_bcast_bytes;
	/* Number of aggregated unicast packets on the function. */
	uint64_t	rx_agg_pkts;
	/* Number of aggregated unicast bytes on the function. */
	uint64_t	rx_agg_bytes;
	/* Number of aggregation events on the function. */
	uint64_t	rx_agg_events;
	/* Number of aborted aggregations on the function. */
	uint64_t	rx_agg_aborts;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_func_qstats_output_t, *phwrm_func_qstats_output_t;

/************************
 * hwrm_func_qstats_ext *
 ************************/


/* hwrm_func_qstats_ext_input (size:256b/32B) */

typedef struct hwrm_func_qstats_ext_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * Function ID of the function that is being queried.
	 * 0xFF... (All Fs) if the query is for the requesting
	 * function.
	 * A privileged PF can query for other function's statistics.
	 */
	uint16_t	fid;
	/* This flags indicates the type of statistics request. */
	uint8_t	flags;
	/* This value is not used to avoid backward compatibility issues. */
	#define HWRM_FUNC_QSTATS_EXT_INPUT_FLAGS_UNUSED	UINT32_C(0x0)
	/*
	 * flags should be set to 1 when request is for only RoCE statistics.
	 * This will be honored only if the caller_fid is a privileged PF.
	 * In all other cases FID and caller_fid should be the same.
	 */
	#define HWRM_FUNC_QSTATS_EXT_INPUT_FLAGS_ROCE_ONLY	UINT32_C(0x1)
	/*
	 * flags should be set to 2 when request is for the counter mask
	 * representing the width of each of the stats counters, rather
	 * than counters themselves.
	 */
	#define HWRM_FUNC_QSTATS_EXT_INPUT_FLAGS_COUNTER_MASK UINT32_C(0x2)
	#define HWRM_FUNC_QSTATS_EXT_INPUT_FLAGS_LAST	HWRM_FUNC_QSTATS_EXT_INPUT_FLAGS_COUNTER_MASK
	uint8_t	unused_0[1];
	uint32_t	enables;
	/*
	 * This bit must be '1' for the schq_id and traffic_class fields to
	 * be configured.
	 */
	#define HWRM_FUNC_QSTATS_EXT_INPUT_ENABLES_SCHQ_ID	UINT32_C(0x1)
	/* Specifies the SCHQ for which to gather statistics */
	uint16_t	schq_id;
	/*
	 * Specifies the traffic class for which to gather statistics. Valid
	 * values are 0 through (max_configurable_queues - 1), where
	 * max_configurable_queues is in the response of HWRM_QUEUE_QPORTCFG
	 */
	uint16_t	traffic_class;
	uint8_t	unused_1[4];
} hwrm_func_qstats_ext_input_t, *phwrm_func_qstats_ext_input_t;

/* hwrm_func_qstats_ext_output (size:1536b/192B) */

typedef struct hwrm_func_qstats_ext_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Number of received unicast packets */
	uint64_t	rx_ucast_pkts;
	/* Number of received multicast packets */
	uint64_t	rx_mcast_pkts;
	/* Number of received broadcast packets */
	uint64_t	rx_bcast_pkts;
	/* Number of discarded packets on received path */
	uint64_t	rx_discard_pkts;
	/* Number of packets on receive path with error */
	uint64_t	rx_error_pkts;
	/* Number of received bytes for unicast traffic */
	uint64_t	rx_ucast_bytes;
	/* Number of received bytes for multicast traffic */
	uint64_t	rx_mcast_bytes;
	/* Number of received bytes for broadcast traffic */
	uint64_t	rx_bcast_bytes;
	/* Number of transmitted unicast packets */
	uint64_t	tx_ucast_pkts;
	/* Number of transmitted multicast packets */
	uint64_t	tx_mcast_pkts;
	/* Number of transmitted broadcast packets */
	uint64_t	tx_bcast_pkts;
	/* Number of packets on transmit path with error */
	uint64_t	tx_error_pkts;
	/* Number of discarded packets on transmit path */
	uint64_t	tx_discard_pkts;
	/* Number of transmitted bytes for unicast traffic */
	uint64_t	tx_ucast_bytes;
	/* Number of transmitted bytes for multicast traffic */
	uint64_t	tx_mcast_bytes;
	/* Number of transmitted bytes for broadcast traffic */
	uint64_t	tx_bcast_bytes;
	/* Number of TPA eligible packets */
	uint64_t	rx_tpa_eligible_pkt;
	/* Number of TPA eligible bytes */
	uint64_t	rx_tpa_eligible_bytes;
	/* Number of TPA packets */
	uint64_t	rx_tpa_pkt;
	/* Number of TPA bytes */
	uint64_t	rx_tpa_bytes;
	/* Number of TPA errors */
	uint64_t	rx_tpa_errors;
	/* Number of TPA errors */
	uint64_t	rx_tpa_events;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_func_qstats_ext_output_t, *phwrm_func_qstats_ext_output_t;

/***********************
 * hwrm_func_clr_stats *
 ***********************/


/* hwrm_func_clr_stats_input (size:192b/24B) */

typedef struct hwrm_func_clr_stats_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * Function ID of the function.
	 * 0xFF... (All Fs) if the query is for the requesting
	 * function.
	 */
	uint16_t	fid;
	uint8_t	unused_0[6];
} hwrm_func_clr_stats_input_t, *phwrm_func_clr_stats_input_t;

/* hwrm_func_clr_stats_output (size:128b/16B) */

typedef struct hwrm_func_clr_stats_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_func_clr_stats_output_t, *phwrm_func_clr_stats_output_t;

/**************************
 * hwrm_func_vf_resc_free *
 **************************/


/* hwrm_func_vf_resc_free_input (size:192b/24B) */

typedef struct hwrm_func_vf_resc_free_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * This value is used to identify a Virtual Function (VF).
	 * The scope of VF ID is local within a PF.
	 */
	uint16_t	vf_id;
	uint8_t	unused_0[6];
} hwrm_func_vf_resc_free_input_t, *phwrm_func_vf_resc_free_input_t;

/* hwrm_func_vf_resc_free_output (size:128b/16B) */

typedef struct hwrm_func_vf_resc_free_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_func_vf_resc_free_output_t, *phwrm_func_vf_resc_free_output_t;

/**********************
 * hwrm_func_drv_rgtr *
 **********************/


/* hwrm_func_drv_rgtr_input (size:896b/112B) */

typedef struct hwrm_func_drv_rgtr_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	flags;
	/*
	 * When this bit is '1', the function driver is requesting
	 * all requests from its children VF drivers to be
	 * forwarded to itself.
	 * This flag can only be set by the PF driver.
	 * If a VF driver sets this flag, it should be ignored
	 * by the HWRM.
	 */
	#define HWRM_FUNC_DRV_RGTR_INPUT_FLAGS_FWD_ALL_MODE		UINT32_C(0x1)
	/*
	 * When this bit is '1', the function is requesting none of
	 * the requests from its children VF drivers to be
	 * forwarded to itself.
	 * This flag can only be set by the PF driver.
	 * If a VF driver sets this flag, it should be ignored
	 * by the HWRM.
	 */
	#define HWRM_FUNC_DRV_RGTR_INPUT_FLAGS_FWD_NONE_MODE		UINT32_C(0x2)
	/*
	 * When this bit is '1', then ver_maj_8b, ver_min_8b, ver_upd_8b
	 * fields shall be ignored and ver_maj, ver_min, ver_upd
	 * and ver_patch shall be used for the driver version information.
	 * When this bit is '0', then ver_maj_8b, ver_min_8b, ver_upd_8b
	 * fields shall be used for the driver version information and
	 * ver_maj, ver_min, ver_upd and ver_patch shall be ignored.
	 */
	#define HWRM_FUNC_DRV_RGTR_INPUT_FLAGS_16BIT_VER_MODE		UINT32_C(0x4)
	/*
	 * When this bit is '1', the function is indicating support of
	 * 64bit flow handle.  The firmware that only supports 64bit flow
	 * handle should check this bit before allowing processing of
	 * HWRM_CFA_FLOW_XXX commands from the requesting function as firmware
	 * with 64bit flow handle support can only be compatible with drivers
	 * that support 64bit flow handle. The legacy drivers that don't support
	 * 64bit flow handle won't be able to use HWRM_CFA_FLOW_XXX commands when
	 * running with new firmware that only supports 64bit flow handle. The new
	 * firmware support 64bit flow handle returns HWRM_ERR_CODE_CMD_NOT_SUPPORTED
	 * status to the legacy driver when encounters these commands.
	 */
	#define HWRM_FUNC_DRV_RGTR_INPUT_FLAGS_FLOW_HANDLE_64BIT_MODE	UINT32_C(0x8)
	/*
	 * When this bit is '1', the function is indicating support of
	 * Hot Reset. The driver interface will destroy the resources,
	 * unregister the function and register again up on receiving
	 * the RESET_NOTIFY Async notification from the core firmware.
	 * The core firmware will this use flag and trigger the Hot Reset
	 * process only if all the registered driver instances are capable
	 * of this support.
	 */
	#define HWRM_FUNC_DRV_RGTR_INPUT_FLAGS_HOT_RESET_SUPPORT	UINT32_C(0x10)
	/*
	 * When this bit is 1, the function is indicating the support of the
	 * error recovery capability. Error recovery support will be used by
	 * firmware only if all the driver instances support error recovery
	 * process. By setting this bit, driver is indicating support for
	 * corresponding async event completion message. These will be
	 * delivered to the driver even if they did not register for it.
	 * If supported, after receiving reset notify async event with fatal
	 * flag set in event data1, then all the drivers have to tear down
	 * their resources without sending any HWRM commands to FW.
	 */
	#define HWRM_FUNC_DRV_RGTR_INPUT_FLAGS_ERROR_RECOVERY_SUPPORT	UINT32_C(0x20)
	/*
	 * When this bit is 1, the function is indicating the support of the
	 * Master capability. The Firmware will use this capability to select the
	 * Master function. The master function will be used to initiate
	 * designated functionality like error recovery etc… If none of the
	 * registered PF’s or trusted VF’s indicate this support, then
	 * firmware will select the 1st registered PF as Master capable instance.
	 */
	#define HWRM_FUNC_DRV_RGTR_INPUT_FLAGS_MASTER_SUPPORT		UINT32_C(0x40)
	/*
	 * When this bit is 1, the function is indicating the support of the
	 * fast reset capability. Fast reset support will be used by
	 * firmware only if all the driver instances support fast reset
	 * process. By setting this bit, driver is indicating support for
	 * corresponding async event completion message. These will be
	 * delivered to the driver even if they did not register for it.
	 * If supported, after receiving reset notify async event with fast
	 * reset flag set in event data1, then all the drivers have to tear
	 * down their resources without sending any HWRM commands to FW.
	 */
	#define HWRM_FUNC_DRV_RGTR_INPUT_FLAGS_FAST_RESET_SUPPORT	UINT32_C(0x80)
	uint32_t	enables;
	/*
	 * This bit must be '1' for the os_type field to be
	 * configured.
	 */
	#define HWRM_FUNC_DRV_RGTR_INPUT_ENABLES_OS_TYPE		UINT32_C(0x1)
	/*
	 * This bit must be '1' for the ver field to be
	 * configured.
	 */
	#define HWRM_FUNC_DRV_RGTR_INPUT_ENABLES_VER		UINT32_C(0x2)
	/*
	 * This bit must be '1' for the timestamp field to be
	 * configured.
	 */
	#define HWRM_FUNC_DRV_RGTR_INPUT_ENABLES_TIMESTAMP	UINT32_C(0x4)
	/*
	 * This bit must be '1' for the vf_req_fwd field to be
	 * configured.
	 */
	#define HWRM_FUNC_DRV_RGTR_INPUT_ENABLES_VF_REQ_FWD	UINT32_C(0x8)
	/*
	 * This bit must be '1' for the async_event_fwd field to be
	 * configured.
	 */
	#define HWRM_FUNC_DRV_RGTR_INPUT_ENABLES_ASYNC_EVENT_FWD	UINT32_C(0x10)
	/* This value indicates the type of OS.  The values are based on CIM_OperatingSystem.mof file as published by the DMTF. */
	uint16_t	os_type;
	/* Unknown */
	#define HWRM_FUNC_DRV_RGTR_INPUT_OS_TYPE_UNKNOWN   UINT32_C(0x0)
	/* Other OS not listed below. */
	#define HWRM_FUNC_DRV_RGTR_INPUT_OS_TYPE_OTHER	UINT32_C(0x1)
	/* MSDOS OS. */
	#define HWRM_FUNC_DRV_RGTR_INPUT_OS_TYPE_MSDOS	UINT32_C(0xe)
	/* Windows OS. */
	#define HWRM_FUNC_DRV_RGTR_INPUT_OS_TYPE_WINDOWS   UINT32_C(0x12)
	/* Solaris OS. */
	#define HWRM_FUNC_DRV_RGTR_INPUT_OS_TYPE_SOLARIS   UINT32_C(0x1d)
	/* Linux OS. */
	#define HWRM_FUNC_DRV_RGTR_INPUT_OS_TYPE_LINUX	UINT32_C(0x24)
	/* FreeBSD OS. */
	#define HWRM_FUNC_DRV_RGTR_INPUT_OS_TYPE_FREEBSD   UINT32_C(0x2a)
	/* VMware ESXi OS. */
	#define HWRM_FUNC_DRV_RGTR_INPUT_OS_TYPE_ESXI	UINT32_C(0x68)
	/* Microsoft Windows 8 64-bit OS. */
	#define HWRM_FUNC_DRV_RGTR_INPUT_OS_TYPE_WIN864	UINT32_C(0x73)
	/* Microsoft Windows Server 2012 R2 OS. */
	#define HWRM_FUNC_DRV_RGTR_INPUT_OS_TYPE_WIN2012R2 UINT32_C(0x74)
	/* UEFI driver. */
	#define HWRM_FUNC_DRV_RGTR_INPUT_OS_TYPE_UEFI	UINT32_C(0x8000)
	#define HWRM_FUNC_DRV_RGTR_INPUT_OS_TYPE_LAST	HWRM_FUNC_DRV_RGTR_INPUT_OS_TYPE_UEFI
	/* This is the 8bit major version of the driver. */
	uint8_t	ver_maj_8b;
	/* This is the 8bit minor version of the driver. */
	uint8_t	ver_min_8b;
	/* This is the 8bit update version of the driver. */
	uint8_t	ver_upd_8b;
	uint8_t	unused_0[3];
	/*
	 * This is a 32-bit timestamp provided by the driver for
	 * keep alive.
	 * The timestamp is in multiples of 1ms.
	 */
	uint32_t	timestamp;
	uint8_t	unused_1[4];
	/*
	 * This is a 256-bit bit mask provided by the PF driver for
	 * letting the HWRM know what commands issued by the VF driver
	 * to the HWRM should be forwarded to the PF driver.
	 * Nth bit refers to the Nth req_type.
	 *
	 * Setting Nth bit to 1 indicates that requests from the
	 * VF driver with req_type equal to N shall be forwarded to
	 * the parent PF driver.
	 *
	 * This field is not valid for the VF driver.
	 */
	uint32_t	vf_req_fwd[8];
	/*
	 * This is a 256-bit bit mask provided by the function driver
	 * (PF or VF driver) to indicate the list of asynchronous event
	 * completions to be forwarded.
	 *
	 * Nth bit refers to the Nth event_id.
	 *
	 * Setting Nth bit to 1 by the function driver shall result in
	 * the HWRM forwarding asynchronous event completion with
	 * event_id equal to N.
	 *
	 * If all bits are set to 0 (value of 0), then the HWRM shall
	 * not forward any asynchronous event completion to this
	 * function driver.
	 */
	uint32_t	async_event_fwd[8];
	/* This is the 16bit major version of the driver. */
	uint16_t	ver_maj;
	/* This is the 16bit minor version of the driver. */
	uint16_t	ver_min;
	/* This is the 16bit update version of the driver. */
	uint16_t	ver_upd;
	/* This is the 16bit patch version of the driver. */
	uint16_t	ver_patch;
} hwrm_func_drv_rgtr_input_t, *phwrm_func_drv_rgtr_input_t;

/* hwrm_func_drv_rgtr_output (size:128b/16B) */

typedef struct hwrm_func_drv_rgtr_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint32_t	flags;
	/*
	 * When this bit is '1', it indicates that the
	 * HWRM_FUNC_DRV_IF_CHANGE call is supported.
	 */
	#define HWRM_FUNC_DRV_RGTR_OUTPUT_FLAGS_IF_CHANGE_SUPPORTED	UINT32_C(0x1)
	uint8_t	unused_0[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_func_drv_rgtr_output_t, *phwrm_func_drv_rgtr_output_t;

/************************
 * hwrm_func_drv_unrgtr *
 ************************/


/* hwrm_func_drv_unrgtr_input (size:192b/24B) */

typedef struct hwrm_func_drv_unrgtr_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	flags;
	/*
	 * When this bit is '1', the function driver is notifying
	 * the HWRM to prepare for the shutdown.
	 */
	#define HWRM_FUNC_DRV_UNRGTR_INPUT_FLAGS_PREPARE_FOR_SHUTDOWN	UINT32_C(0x1)
	uint8_t	unused_0[4];
} hwrm_func_drv_unrgtr_input_t, *phwrm_func_drv_unrgtr_input_t;

/* hwrm_func_drv_unrgtr_output (size:128b/16B) */

typedef struct hwrm_func_drv_unrgtr_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_func_drv_unrgtr_output_t, *phwrm_func_drv_unrgtr_output_t;

/**********************
 * hwrm_func_buf_rgtr *
 **********************/


/* hwrm_func_buf_rgtr_input (size:1024b/128B) */

typedef struct hwrm_func_buf_rgtr_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	enables;
	/*
	 * This bit must be '1' for the vf_id field to be
	 * configured.
	 */
	#define HWRM_FUNC_BUF_RGTR_INPUT_ENABLES_VF_ID		UINT32_C(0x1)
	/*
	 * This bit must be '1' for the err_buf_addr field to be
	 * configured.
	 */
	#define HWRM_FUNC_BUF_RGTR_INPUT_ENABLES_ERR_BUF_ADDR	UINT32_C(0x2)
	/*
	 * This value is used to identify a Virtual Function (VF).
	 * The scope of VF ID is local within a PF.
	 */
	uint16_t	vf_id;
	/*
	 * This field represents the number of pages used for request
	 * buffer(s).
	 */
	uint16_t	req_buf_num_pages;
	/*
	 * This field represents the page size used for request
	 * buffer(s).
	 */
	uint16_t	req_buf_page_size;
	/* 16 bytes */
	#define HWRM_FUNC_BUF_RGTR_INPUT_REQ_BUF_PAGE_SIZE_16B UINT32_C(0x4)
	/* 4 Kbytes */
	#define HWRM_FUNC_BUF_RGTR_INPUT_REQ_BUF_PAGE_SIZE_4K  UINT32_C(0xc)
	/* 8 Kbytes */
	#define HWRM_FUNC_BUF_RGTR_INPUT_REQ_BUF_PAGE_SIZE_8K  UINT32_C(0xd)
	/* 64 Kbytes */
	#define HWRM_FUNC_BUF_RGTR_INPUT_REQ_BUF_PAGE_SIZE_64K UINT32_C(0x10)
	/* 2 Mbytes */
	#define HWRM_FUNC_BUF_RGTR_INPUT_REQ_BUF_PAGE_SIZE_2M  UINT32_C(0x15)
	/* 4 Mbytes */
	#define HWRM_FUNC_BUF_RGTR_INPUT_REQ_BUF_PAGE_SIZE_4M  UINT32_C(0x16)
	/* 1 Gbytes */
	#define HWRM_FUNC_BUF_RGTR_INPUT_REQ_BUF_PAGE_SIZE_1G  UINT32_C(0x1e)
	#define HWRM_FUNC_BUF_RGTR_INPUT_REQ_BUF_PAGE_SIZE_LAST HWRM_FUNC_BUF_RGTR_INPUT_REQ_BUF_PAGE_SIZE_1G
	/* The length of the request buffer per VF in bytes. */
	uint16_t	req_buf_len;
	/* The length of the response buffer in bytes. */
	uint16_t	resp_buf_len;
	uint8_t	unused_0[2];
	/* This field represents the page address of page #0. */
	uint64_t	req_buf_page_addr0;
	/* This field represents the page address of page #1. */
	uint64_t	req_buf_page_addr1;
	/* This field represents the page address of page #2. */
	uint64_t	req_buf_page_addr2;
	/* This field represents the page address of page #3. */
	uint64_t	req_buf_page_addr3;
	/* This field represents the page address of page #4. */
	uint64_t	req_buf_page_addr4;
	/* This field represents the page address of page #5. */
	uint64_t	req_buf_page_addr5;
	/* This field represents the page address of page #6. */
	uint64_t	req_buf_page_addr6;
	/* This field represents the page address of page #7. */
	uint64_t	req_buf_page_addr7;
	/* This field represents the page address of page #8. */
	uint64_t	req_buf_page_addr8;
	/* This field represents the page address of page #9. */
	uint64_t	req_buf_page_addr9;
	/*
	 * This field is used to receive the error reporting from
	 * the chipset. Only applicable for PFs.
	 */
	uint64_t	error_buf_addr;
	/*
	 * This field is used to receive the response forwarded by the
	 * HWRM.
	 */
	uint64_t	resp_buf_addr;
} hwrm_func_buf_rgtr_input_t, *phwrm_func_buf_rgtr_input_t;

/* hwrm_func_buf_rgtr_output (size:128b/16B) */

typedef struct hwrm_func_buf_rgtr_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_func_buf_rgtr_output_t, *phwrm_func_buf_rgtr_output_t;

/************************
 * hwrm_func_buf_unrgtr *
 ************************/


/* hwrm_func_buf_unrgtr_input (size:192b/24B) */

typedef struct hwrm_func_buf_unrgtr_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	enables;
	/*
	 * This bit must be '1' for the vf_id field to be
	 * configured.
	 */
	#define HWRM_FUNC_BUF_UNRGTR_INPUT_ENABLES_VF_ID	UINT32_C(0x1)
	/*
	 * This value is used to identify a Virtual Function (VF).
	 * The scope of VF ID is local within a PF.
	 */
	uint16_t	vf_id;
	uint8_t	unused_0[2];
} hwrm_func_buf_unrgtr_input_t, *phwrm_func_buf_unrgtr_input_t;

/* hwrm_func_buf_unrgtr_output (size:128b/16B) */

typedef struct hwrm_func_buf_unrgtr_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_func_buf_unrgtr_output_t, *phwrm_func_buf_unrgtr_output_t;

/**********************
 * hwrm_func_drv_qver *
 **********************/


/* hwrm_func_drv_qver_input (size:192b/24B) */

typedef struct hwrm_func_drv_qver_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Reserved for future use. */
	uint32_t	reserved;
	/*
	 * Function ID of the function that is being queried.
	 * 0xFF... (All Fs) if the query is for the requesting
	 * function.
	 */
	uint16_t	fid;
	uint8_t	unused_0[2];
} hwrm_func_drv_qver_input_t, *phwrm_func_drv_qver_input_t;

/* hwrm_func_drv_qver_output (size:256b/32B) */

typedef struct hwrm_func_drv_qver_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* This value indicates the type of OS.  The values are based on CIM_OperatingSystem.mof file as published by the DMTF. */
	uint16_t	os_type;
	/* Unknown */
	#define HWRM_FUNC_DRV_QVER_OUTPUT_OS_TYPE_UNKNOWN   UINT32_C(0x0)
	/* Other OS not listed below. */
	#define HWRM_FUNC_DRV_QVER_OUTPUT_OS_TYPE_OTHER	UINT32_C(0x1)
	/* MSDOS OS. */
	#define HWRM_FUNC_DRV_QVER_OUTPUT_OS_TYPE_MSDOS	UINT32_C(0xe)
	/* Windows OS. */
	#define HWRM_FUNC_DRV_QVER_OUTPUT_OS_TYPE_WINDOWS   UINT32_C(0x12)
	/* Solaris OS. */
	#define HWRM_FUNC_DRV_QVER_OUTPUT_OS_TYPE_SOLARIS   UINT32_C(0x1d)
	/* Linux OS. */
	#define HWRM_FUNC_DRV_QVER_OUTPUT_OS_TYPE_LINUX	UINT32_C(0x24)
	/* FreeBSD OS. */
	#define HWRM_FUNC_DRV_QVER_OUTPUT_OS_TYPE_FREEBSD   UINT32_C(0x2a)
	/* VMware ESXi OS. */
	#define HWRM_FUNC_DRV_QVER_OUTPUT_OS_TYPE_ESXI	UINT32_C(0x68)
	/* Microsoft Windows 8 64-bit OS. */
	#define HWRM_FUNC_DRV_QVER_OUTPUT_OS_TYPE_WIN864	UINT32_C(0x73)
	/* Microsoft Windows Server 2012 R2 OS. */
	#define HWRM_FUNC_DRV_QVER_OUTPUT_OS_TYPE_WIN2012R2 UINT32_C(0x74)
	/* UEFI driver. */
	#define HWRM_FUNC_DRV_QVER_OUTPUT_OS_TYPE_UEFI	UINT32_C(0x8000)
	#define HWRM_FUNC_DRV_QVER_OUTPUT_OS_TYPE_LAST	HWRM_FUNC_DRV_QVER_OUTPUT_OS_TYPE_UEFI
	/* This is the 8bit major version of the driver. */
	uint8_t	ver_maj_8b;
	/* This is the 8bit minor version of the driver. */
	uint8_t	ver_min_8b;
	/* This is the 8bit update version of the driver. */
	uint8_t	ver_upd_8b;
	uint8_t	unused_0[3];
	/* This is the 16bit major version of the driver. */
	uint16_t	ver_maj;
	/* This is the 16bit minor version of the driver. */
	uint16_t	ver_min;
	/* This is the 16bit update version of the driver. */
	uint16_t	ver_upd;
	/* This is the 16bit patch version of the driver. */
	uint16_t	ver_patch;
	uint8_t	unused_1[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_func_drv_qver_output_t, *phwrm_func_drv_qver_output_t;

/****************************
 * hwrm_func_resource_qcaps *
 ****************************/


/* hwrm_func_resource_qcaps_input (size:192b/24B) */

typedef struct hwrm_func_resource_qcaps_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * Function ID of the function that is being queried.
	 * 0xFF... (All Fs) if the query is for the requesting
	 * function.
	 */
	uint16_t	fid;
	uint8_t	unused_0[6];
} hwrm_func_resource_qcaps_input_t, *phwrm_func_resource_qcaps_input_t;

/* hwrm_func_resource_qcaps_output (size:448b/56B) */

typedef struct hwrm_func_resource_qcaps_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Maximum guaranteed number of VFs supported by PF. Not applicable for VFs. */
	uint16_t	max_vfs;
	/* Maximum guaranteed number of MSI-X vectors supported by function */
	uint16_t	max_msix;
	/* Hint of strategy to be used by PF driver to reserve resources for its VF */
	uint16_t	vf_reservation_strategy;
	/* The PF driver should evenly divide its remaining resources among all VFs. */
	#define HWRM_FUNC_RESOURCE_QCAPS_OUTPUT_VF_RESERVATION_STRATEGY_MAXIMAL	UINT32_C(0x0)
	/* The PF driver should only reserve minimal resources for each VF. */
	#define HWRM_FUNC_RESOURCE_QCAPS_OUTPUT_VF_RESERVATION_STRATEGY_MINIMAL	UINT32_C(0x1)
	/*
	 * The PF driver should not reserve any resources for each VF until the
	 * the VF interface is brought up.
	 */
	#define HWRM_FUNC_RESOURCE_QCAPS_OUTPUT_VF_RESERVATION_STRATEGY_MINIMAL_STATIC UINT32_C(0x2)
	#define HWRM_FUNC_RESOURCE_QCAPS_OUTPUT_VF_RESERVATION_STRATEGY_LAST	HWRM_FUNC_RESOURCE_QCAPS_OUTPUT_VF_RESERVATION_STRATEGY_MINIMAL_STATIC
	/* Minimum guaranteed number of RSS/COS contexts */
	uint16_t	min_rsscos_ctx;
	/* Maximum non-guaranteed number of RSS/COS contexts */
	uint16_t	max_rsscos_ctx;
	/* Minimum guaranteed number of completion rings */
	uint16_t	min_cmpl_rings;
	/* Maximum non-guaranteed number of completion rings */
	uint16_t	max_cmpl_rings;
	/* Minimum guaranteed number of transmit rings */
	uint16_t	min_tx_rings;
	/* Maximum non-guaranteed number of transmit rings */
	uint16_t	max_tx_rings;
	/* Minimum guaranteed number of receive rings */
	uint16_t	min_rx_rings;
	/* Maximum non-guaranteed number of receive rings */
	uint16_t	max_rx_rings;
	/* Minimum guaranteed number of L2 contexts */
	uint16_t	min_l2_ctxs;
	/* Maximum non-guaranteed number of L2 contexts */
	uint16_t	max_l2_ctxs;
	/* Minimum guaranteed number of VNICs */
	uint16_t	min_vnics;
	/* Maximum non-guaranteed number of VNICs */
	uint16_t	max_vnics;
	/* Minimum guaranteed number of statistic contexts */
	uint16_t	min_stat_ctx;
	/* Maximum non-guaranteed number of statistic contexts */
	uint16_t	max_stat_ctx;
	/* Minimum guaranteed number of ring groups */
	uint16_t	min_hw_ring_grps;
	/* Maximum non-guaranteed number of ring groups */
	uint16_t	max_hw_ring_grps;
	/*
	 * Maximum number of inputs into the transmit scheduler for this function.
	 * The number of TX rings assigned to the function cannot exceed this value.
	 */
	uint16_t	max_tx_scheduler_inputs;
	uint16_t	flags;
	/*
	 * When this bit is '1', it indicates that VF_RESOURCE_CFG supports
	 * feature to reserve all minimum resources when minimum >= 1, otherwise
	 * returns an error.
	 */
	#define HWRM_FUNC_RESOURCE_QCAPS_OUTPUT_FLAGS_MIN_GUARANTEED	UINT32_C(0x1)
	uint8_t	unused_0[5];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_func_resource_qcaps_output_t, *phwrm_func_resource_qcaps_output_t;

/*****************************
 * hwrm_func_vf_resource_cfg *
 *****************************/


/* hwrm_func_vf_resource_cfg_input (size:448b/56B) */

typedef struct hwrm_func_vf_resource_cfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* VF ID that is being configured by PF */
	uint16_t	vf_id;
	/* Maximum guaranteed number of MSI-X vectors for the function */
	uint16_t	max_msix;
	/* Minimum guaranteed number of RSS/COS contexts */
	uint16_t	min_rsscos_ctx;
	/* Maximum non-guaranteed number of RSS/COS contexts */
	uint16_t	max_rsscos_ctx;
	/* Minimum guaranteed number of completion rings */
	uint16_t	min_cmpl_rings;
	/* Maximum non-guaranteed number of completion rings */
	uint16_t	max_cmpl_rings;
	/* Minimum guaranteed number of transmit rings */
	uint16_t	min_tx_rings;
	/* Maximum non-guaranteed number of transmit rings */
	uint16_t	max_tx_rings;
	/* Minimum guaranteed number of receive rings */
	uint16_t	min_rx_rings;
	/* Maximum non-guaranteed number of receive rings */
	uint16_t	max_rx_rings;
	/* Minimum guaranteed number of L2 contexts */
	uint16_t	min_l2_ctxs;
	/* Maximum non-guaranteed number of L2 contexts */
	uint16_t	max_l2_ctxs;
	/* Minimum guaranteed number of VNICs */
	uint16_t	min_vnics;
	/* Maximum non-guaranteed number of VNICs */
	uint16_t	max_vnics;
	/* Minimum guaranteed number of statistic contexts */
	uint16_t	min_stat_ctx;
	/* Maximum non-guaranteed number of statistic contexts */
	uint16_t	max_stat_ctx;
	/* Minimum guaranteed number of ring groups */
	uint16_t	min_hw_ring_grps;
	/* Maximum non-guaranteed number of ring groups */
	uint16_t	max_hw_ring_grps;
	uint16_t	flags;
	/*
	 * If this bit is set, all minimum resources requested should be
	 * reserved if minimum >= 1, otherwise return error. In case of
	 * error, keep all existing reservations before the call.
	 */
	#define HWRM_FUNC_VF_RESOURCE_CFG_INPUT_FLAGS_MIN_GUARANTEED	UINT32_C(0x1)
	uint8_t	unused_0[2];
} hwrm_func_vf_resource_cfg_input_t, *phwrm_func_vf_resource_cfg_input_t;

/* hwrm_func_vf_resource_cfg_output (size:256b/32B) */

typedef struct hwrm_func_vf_resource_cfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Reserved number of RSS/COS contexts */
	uint16_t	reserved_rsscos_ctx;
	/* Reserved number of completion rings */
	uint16_t	reserved_cmpl_rings;
	/* Reserved number of transmit rings */
	uint16_t	reserved_tx_rings;
	/* Reserved number of receive rings */
	uint16_t	reserved_rx_rings;
	/* Reserved number of L2 contexts */
	uint16_t	reserved_l2_ctxs;
	/* Reserved number of VNICs */
	uint16_t	reserved_vnics;
	/* Reserved number of statistic contexts */
	uint16_t	reserved_stat_ctx;
	/* Reserved number of ring groups */
	uint16_t	reserved_hw_ring_grps;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_func_vf_resource_cfg_output_t, *phwrm_func_vf_resource_cfg_output_t;

/*********************************
 * hwrm_func_backing_store_qcaps *
 *********************************/


/* hwrm_func_backing_store_qcaps_input (size:128b/16B) */

typedef struct hwrm_func_backing_store_qcaps_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
} hwrm_func_backing_store_qcaps_input_t, *phwrm_func_backing_store_qcaps_input_t;

/* hwrm_func_backing_store_qcaps_output (size:832b/104B) */

typedef struct hwrm_func_backing_store_qcaps_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Maximum number of QP context entries supported for this function. */
	uint32_t	qp_max_entries;
	/*
	 * Minimum number of QP context entries that are needed to be reserved
	 * for QP1 for the PF and its VFs. PF drivers must allocate at least
	 * this many QP context entries, even if RoCE will not be used.
	 */
	uint16_t	qp_min_qp1_entries;
	/* Maximum number of QP context entries that can be used for L2. */
	uint16_t	qp_max_l2_entries;
	/* Number of bytes that must be allocated for each context entry. */
	uint16_t	qp_entry_size;
	/* Maximum number of SRQ context entries that can be used for L2. */
	uint16_t	srq_max_l2_entries;
	/* Maximum number of SRQ context entries supported for this function. */
	uint32_t	srq_max_entries;
	/* Number of bytes that must be allocated for each context entry. */
	uint16_t	srq_entry_size;
	/* Maximum number of CQ context entries that can be used for L2. */
	uint16_t	cq_max_l2_entries;
	/* Maximum number of CQ context entries supported for this function. */
	uint32_t	cq_max_entries;
	/* Number of bytes that must be allocated for each context entry. */
	uint16_t	cq_entry_size;
	/* Maximum number of VNIC context entries supported for this function. */
	uint16_t	vnic_max_vnic_entries;
	/* Maximum number of Ring table context entries supported for this function. */
	uint16_t	vnic_max_ring_table_entries;
	/* Number of bytes that must be allocated for each context entry. */
	uint16_t	vnic_entry_size;
	/* Maximum number of statistic context entries supported for this function. */
	uint32_t	stat_max_entries;
	/* Number of bytes that must be allocated for each context entry. */
	uint16_t	stat_entry_size;
	/* Number of bytes that must be allocated for each context entry. */
	uint16_t	tqm_entry_size;
	/* Minimum number of TQM context entries required per ring. */
	uint32_t	tqm_min_entries_per_ring;
	/*
	 * Maximum number of TQM context entries supported per ring. This is
	 * actually a recommended TQM queue size based on worst case usage of
	 * the TQM queue.
	 *
	 * TQM fastpath rings should be sized large enough to accommodate the
	 * maximum number of QPs (either L2 or RoCE, or both if shared)
	 * that can be enqueued to the TQM ring.
	 *
	 * TQM slowpath rings should be sized as follows:
	 *
	 * num_entries = num_vnics + num_l2_tx_rings + 2 * num_roce_qps + tqm_min_size
	 *
	 * Where:
	 *   num_vnics is the number of VNICs allocated in the VNIC backing store
	 *   num_l2_tx_rings is the number of L2 rings in the QP backing store
	 *   num_roce_qps is the number of RoCE QPs in the QP backing store
	 *   tqm_min_size is tqm_min_entries_per_ring reported by
	 *	HWRM_FUNC_BACKING_STORE_QCAPS
	 *
	 * Note that TQM ring sizes cannot be extended while the system is
	 * operational. If a PF driver needs to extend a TQM ring, it needs
	 * to reset the function (e.g. HWRM_FUNC_RESET) and then reallocate
	 * the backing store.
	 */
	uint32_t	tqm_max_entries_per_ring;
	/*
	 * Maximum number of MR plus AV context entries supported for this
	 * function.
	 */
	uint32_t	mrav_max_entries;
	/* Number of bytes that must be allocated for each context entry. */
	uint16_t	mrav_entry_size;
	/* Number of bytes that must be allocated for each context entry. */
	uint16_t	tim_entry_size;
	/* Maximum number of Timer context entries supported for this function. */
	uint32_t	tim_max_entries;
	/*
	 * When this field is zero, the 32b `mrav_num_entries` field in the
	 * `backing_store_cfg` and `backing_store_qcfg` commands represents
	 * the total number of MR plus AV entries allowed in the MR/AV backing
	 * store PBL.
	 *
	 * When this field is non-zero, the 32b `mrav_num_entries` field in
	 * the `backing_store_cfg` and `backing_store_qcfg` commands is
	 * logically divided into two 16b fields. Bits `[31:16]` represents
	 * the `mr_num_entries` and bits `[15:0]` represents `av_num_entries`.
	 * Both of these values are represented in a unit granularity
	 * specified by this field. For example, if this field is 16 and
	 * `mrav_num_entries` is `0x02000100`, then the number of MR entries
	 * is 8192 and the number of AV entries is 4096.
	 */
	uint16_t	mrav_num_entries_units;
	/*
	 * The number of entries specified for any TQM ring must be a
	 * multiple of this value to prevent any resource allocation
	 * limitations.
	 */
	uint8_t	tqm_entries_multiple;
	/*
	 * Initializer to be used by drivers
	 * to initialize context memory to ensure
	 * context subsystem flags an error for an attack
	 * before the first time context load.
	 */
	uint8_t	ctx_kind_initializer;
	/*
	 * Specifies which context kinds need to be initialized with the
	 * ctx_kind_initializer.
	 */
	uint16_t	ctx_init_mask;
	/*
	 * If this bit is '1' then this context type should be initialized
	 * with the ctx_kind_initializer at the specified offset.
	 */
	#define HWRM_FUNC_BACKING_STORE_QCAPS_OUTPUT_CTX_INIT_MASK_QP	UINT32_C(0x1)
	/*
	 * If this bit is '1' then this context type should be initialized
	 * with the ctx_kind_initializer at the specified offset.
	 */
	#define HWRM_FUNC_BACKING_STORE_QCAPS_OUTPUT_CTX_INIT_MASK_SRQ	UINT32_C(0x2)
	/*
	 * If this bit is '1' then this context type should be initialized
	 * with the ctx_kind_initializer at the specified offset.
	 */
	#define HWRM_FUNC_BACKING_STORE_QCAPS_OUTPUT_CTX_INIT_MASK_CQ	UINT32_C(0x4)
	/*
	 * If this bit is '1' then this context type should be initialized
	 * with the ctx_kind_initializer at the specified offset.
	 */
	#define HWRM_FUNC_BACKING_STORE_QCAPS_OUTPUT_CTX_INIT_MASK_VNIC	UINT32_C(0x8)
	/*
	 * If this bit is '1' then this context type should be initialized
	 * with the ctx_kind_initializer at the specified offset.
	 */
	#define HWRM_FUNC_BACKING_STORE_QCAPS_OUTPUT_CTX_INIT_MASK_STAT	UINT32_C(0x10)
	/*
	 * If this bit is '1' then this context type should be initialized
	 * with the ctx_kind_initializer at the specified offset.
	 */
	#define HWRM_FUNC_BACKING_STORE_QCAPS_OUTPUT_CTX_INIT_MASK_MRAV	UINT32_C(0x20)
	/*
	 * If this bit is '1' then the Tx KTLS context type should be
	 * initialized with the ctx_kind_initializer at the specified offset.
	 */
	#define HWRM_FUNC_BACKING_STORE_QCAPS_OUTPUT_CTX_INIT_MASK_TKC	UINT32_C(0x40)
	/*
	 * If this bit is '1' then the Rx KTLS context type should be
	 * initialized with the ctx_kind_initializer at the specified offset.
	 */
	#define HWRM_FUNC_BACKING_STORE_QCAPS_OUTPUT_CTX_INIT_MASK_RKC	UINT32_C(0x80)
	/*
	 * Specifies the doubleword offset of ctx_kind_initializer for this
	 * context type.
	 */
	uint8_t	qp_init_offset;
	/*
	 * Specifies the doubleword offset of ctx_kind_initializer for this
	 * context type.
	 */
	uint8_t	srq_init_offset;
	/*
	 * Specifies the doubleword offset of ctx_kind_initializer for this
	 * context type.
	 */
	uint8_t	cq_init_offset;
	/*
	 * Specifies the doubleword offset of ctx_kind_initializer for this
	 * context type.
	 */
	uint8_t	vnic_init_offset;
	/*
	 * Count of TQM fastpath rings to be used for allocating backing store.
	 * Backing store configuration must be specified for each TQM ring from
	 * this count in `backing_store_cfg`.
	 * Only first 8 TQM FP rings will be advertised with this field.
	 */
	uint8_t	tqm_fp_rings_count;
	/*
	 * Specifies the doubleword offset of ctx_kind_initializer for this
	 * context type.
	 */
	uint8_t	stat_init_offset;
	/*
	 * Specifies the doubleword offset of ctx_kind_initializer for this
	 * context type.
	 */
	uint8_t	mrav_init_offset;
	/*
	 * Count of TQM extended fastpath rings to be used for allocating
	 * backing store beyond 8 rings(rings 9,10,11)
	 * Backing store configuration must be specified for each TQM ring from
	 * this count in `backing_store_cfg`.
	 */
	uint8_t	tqm_fp_rings_count_ext;
	/*
	 * Specifies the doubleword offset of ctx_kind_initializer for Tx
	 * KTLS context type.
	 */
	uint8_t	tkc_init_offset;
	/*
	 * Specifies the doubleword offset of ctx_kind_initializer for Rx
	 * KTLS context type.
	 */
	uint8_t	rkc_init_offset;
	/* Tx KTLS context entry size in bytes. */
	uint16_t	tkc_entry_size;
	/* Rx KTLS context entry size in bytes. */
	uint16_t	rkc_entry_size;
	/*
	 * Maximum number of Tx KTLS context entries supported for this
	 * function.
	 */
	uint32_t	tkc_max_entries;
	/*
	 * Maximum number of Rx KTLS context entries supported for this
	 * function.
	 */
	uint32_t	rkc_max_entries;
	/* Reserved for future. */
	uint8_t	rsvd[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_func_backing_store_qcaps_output_t, *phwrm_func_backing_store_qcaps_output_t;

/* tqm_fp_ring_cfg (size:128b/16B) */

typedef struct tqm_fp_ring_cfg {
	/* TQM ring page size and level. */
	uint8_t	tqm_ring_pg_size_tqm_ring_lvl;
	/* TQM ring PBL indirect levels. */
	#define TQM_FP_RING_CFG_TQM_RING_CFG_TQM_RING_LVL_MASK	UINT32_C(0xf)
	#define TQM_FP_RING_CFG_TQM_RING_CFG_TQM_RING_LVL_SFT	0
	/* PBL pointer is physical start address. */
		#define TQM_FP_RING_CFG_TQM_RING_CFG_TQM_RING_LVL_LVL_0	UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
		#define TQM_FP_RING_CFG_TQM_RING_CFG_TQM_RING_LVL_LVL_1	UINT32_C(0x1)
	/*
	 * PBL pointer points to PDE table with each entry pointing to
	 * PTE tables.
	 */
		#define TQM_FP_RING_CFG_TQM_RING_CFG_TQM_RING_LVL_LVL_2	UINT32_C(0x2)
		#define TQM_FP_RING_CFG_TQM_RING_CFG_TQM_RING_LVL_LAST	TQM_FP_RING_CFG_TQM_RING_CFG_TQM_RING_LVL_LVL_2
	/* TQM ring page size. */
	#define TQM_FP_RING_CFG_TQM_RING_CFG_TQM_RING_PG_SIZE_MASK  UINT32_C(0xf0)
	#define TQM_FP_RING_CFG_TQM_RING_CFG_TQM_RING_PG_SIZE_SFT   4
	/* 4KB. */
		#define TQM_FP_RING_CFG_TQM_RING_CFG_TQM_RING_PG_SIZE_PG_4K   (UINT32_C(0x0) << 4)
	/* 8KB. */
		#define TQM_FP_RING_CFG_TQM_RING_CFG_TQM_RING_PG_SIZE_PG_8K   (UINT32_C(0x1) << 4)
	/* 64KB. */
		#define TQM_FP_RING_CFG_TQM_RING_CFG_TQM_RING_PG_SIZE_PG_64K  (UINT32_C(0x2) << 4)
	/* 2MB. */
		#define TQM_FP_RING_CFG_TQM_RING_CFG_TQM_RING_PG_SIZE_PG_2M   (UINT32_C(0x3) << 4)
	/* 8MB. */
		#define TQM_FP_RING_CFG_TQM_RING_CFG_TQM_RING_PG_SIZE_PG_8M   (UINT32_C(0x4) << 4)
	/* 1GB. */
		#define TQM_FP_RING_CFG_TQM_RING_CFG_TQM_RING_PG_SIZE_PG_1G   (UINT32_C(0x5) << 4)
		#define TQM_FP_RING_CFG_TQM_RING_CFG_TQM_RING_PG_SIZE_LAST   TQM_FP_RING_CFG_TQM_RING_CFG_TQM_RING_PG_SIZE_PG_1G
	uint8_t	unused[3];
	/* Number of TQM ring entries. */
	uint32_t	tqm_ring_num_entries;
	/* TQM ring page directory. */
	uint64_t	tqm_ring_page_dir;
} tqm_fp_ring_cfg_t, *ptqm_fp_ring_cfg_t;

/*******************************
 * hwrm_func_backing_store_cfg *
 *******************************/


/* hwrm_func_backing_store_cfg_input (size:2688b/336B) */

typedef struct hwrm_func_backing_store_cfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	flags;
	/*
	 * When set, the firmware only uses on-chip resources and does not
	 * expect any backing store to be provided by the host driver. This
	 * mode provides minimal L2 functionality (e.g. limited L2 resources,
	 * no RoCE).
	 */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_FLAGS_PREBOOT_MODE		UINT32_C(0x1)
	/*
	 * When set, the 32b `mrav_num_entries` field is logically divided
	 * into two 16b fields, `mr_num_entries` and `av_num_entries`.
	 */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_FLAGS_MRAV_RESERVATION_SPLIT	UINT32_C(0x2)
	uint32_t	enables;
	/*
	 * This bit must be '1' for the qp fields to be
	 * configured.
	 */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_ENABLES_QP		UINT32_C(0x1)
	/*
	 * This bit must be '1' for the srq fields to be
	 * configured.
	 */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_ENABLES_SRQ		UINT32_C(0x2)
	/*
	 * This bit must be '1' for the cq fields to be
	 * configured.
	 */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_ENABLES_CQ		UINT32_C(0x4)
	/*
	 * This bit must be '1' for the vnic fields to be
	 * configured.
	 */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_ENABLES_VNIC	UINT32_C(0x8)
	/*
	 * This bit must be '1' for the stat fields to be
	 * configured.
	 */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_ENABLES_STAT	UINT32_C(0x10)
	/*
	 * This bit must be '1' for the tqm_sp fields to be
	 * configured.
	 */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_ENABLES_TQM_SP	UINT32_C(0x20)
	/*
	 * This bit must be '1' for the tqm_ring0 fields to be
	 * configured.
	 */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_ENABLES_TQM_RING0	UINT32_C(0x40)
	/*
	 * This bit must be '1' for the tqm_ring1 fields to be
	 * configured.
	 */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_ENABLES_TQM_RING1	UINT32_C(0x80)
	/*
	 * This bit must be '1' for the tqm_ring2 fields to be
	 * configured.
	 */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_ENABLES_TQM_RING2	UINT32_C(0x100)
	/*
	 * This bit must be '1' for the tqm_ring3 fields to be
	 * configured.
	 */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_ENABLES_TQM_RING3	UINT32_C(0x200)
	/*
	 * This bit must be '1' for the tqm_ring4 fields to be
	 * configured.
	 */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_ENABLES_TQM_RING4	UINT32_C(0x400)
	/*
	 * This bit must be '1' for the tqm_ring5 fields to be
	 * configured.
	 */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_ENABLES_TQM_RING5	UINT32_C(0x800)
	/*
	 * This bit must be '1' for the tqm_ring6 fields to be
	 * configured.
	 */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_ENABLES_TQM_RING6	UINT32_C(0x1000)
	/*
	 * This bit must be '1' for the tqm_ring7 fields to be
	 * configured.
	 */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_ENABLES_TQM_RING7	UINT32_C(0x2000)
	/*
	 * This bit must be '1' for the mrav fields to be
	 * configured.
	 */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_ENABLES_MRAV	UINT32_C(0x4000)
	/*
	 * This bit must be '1' for the tim fields to be
	 * configured.
	 */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_ENABLES_TIM		UINT32_C(0x8000)
	/*
	 * This bit must be '1' for the tqm_ring8 fields to be
	 * configured.
	 */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_ENABLES_TQM_RING8	UINT32_C(0x10000)
	/*
	 * This bit must be '1' for the tqm_ring9 fields to be
	 * configured.
	 */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_ENABLES_TQM_RING9	UINT32_C(0x20000)
	/*
	 * This bit must be '1' for the tqm_ring10 fields to be
	 * configured.
	 */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_ENABLES_TQM_RING10	UINT32_C(0x40000)
	/*
	 * This bit must be '1' for the Tx KTLS context
	 * fields to be configured.
	 */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_ENABLES_TKC		UINT32_C(0x80000)
	/*
	 * This bit must be '1' for the Rx KTLS context
	 * fields to be configured.
	 */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_ENABLES_RKC		UINT32_C(0x100000)
	/* QPC page size and level. */
	uint8_t	qpc_pg_size_qpc_lvl;
	/* QPC PBL indirect levels. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_QPC_LVL_MASK	UINT32_C(0xf)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_QPC_LVL_SFT	0
	/* PBL pointer is physical start address. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_QPC_LVL_LVL_0	UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_QPC_LVL_LVL_1	UINT32_C(0x1)
	/* PBL pointer points to PDE table with each entry pointing to PTE tables. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_QPC_LVL_LVL_2	UINT32_C(0x2)
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_QPC_LVL_LAST	HWRM_FUNC_BACKING_STORE_CFG_INPUT_QPC_LVL_LVL_2
	/* QPC page size. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_QPC_PG_SIZE_MASK  UINT32_C(0xf0)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_QPC_PG_SIZE_SFT   4
	/* 4KB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_QPC_PG_SIZE_PG_4K   (UINT32_C(0x0) << 4)
	/* 8KB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_QPC_PG_SIZE_PG_8K   (UINT32_C(0x1) << 4)
	/* 64KB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_QPC_PG_SIZE_PG_64K  (UINT32_C(0x2) << 4)
	/* 2MB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_QPC_PG_SIZE_PG_2M   (UINT32_C(0x3) << 4)
	/* 8MB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_QPC_PG_SIZE_PG_8M   (UINT32_C(0x4) << 4)
	/* 1GB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_QPC_PG_SIZE_PG_1G   (UINT32_C(0x5) << 4)
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_QPC_PG_SIZE_LAST   HWRM_FUNC_BACKING_STORE_CFG_INPUT_QPC_PG_SIZE_PG_1G
	/* SRQ page size and level. */
	uint8_t	srq_pg_size_srq_lvl;
	/* SRQ PBL indirect levels. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_SRQ_LVL_MASK	UINT32_C(0xf)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_SRQ_LVL_SFT	0
	/* PBL pointer is physical start address. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_SRQ_LVL_LVL_0	UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_SRQ_LVL_LVL_1	UINT32_C(0x1)
	/* PBL pointer points to PDE table with each entry pointing to PTE tables. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_SRQ_LVL_LVL_2	UINT32_C(0x2)
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_SRQ_LVL_LAST	HWRM_FUNC_BACKING_STORE_CFG_INPUT_SRQ_LVL_LVL_2
	/* SRQ page size. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_SRQ_PG_SIZE_MASK  UINT32_C(0xf0)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_SRQ_PG_SIZE_SFT   4
	/* 4KB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_SRQ_PG_SIZE_PG_4K   (UINT32_C(0x0) << 4)
	/* 8KB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_SRQ_PG_SIZE_PG_8K   (UINT32_C(0x1) << 4)
	/* 64KB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_SRQ_PG_SIZE_PG_64K  (UINT32_C(0x2) << 4)
	/* 2MB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_SRQ_PG_SIZE_PG_2M   (UINT32_C(0x3) << 4)
	/* 8MB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_SRQ_PG_SIZE_PG_8M   (UINT32_C(0x4) << 4)
	/* 1GB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_SRQ_PG_SIZE_PG_1G   (UINT32_C(0x5) << 4)
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_SRQ_PG_SIZE_LAST   HWRM_FUNC_BACKING_STORE_CFG_INPUT_SRQ_PG_SIZE_PG_1G
	/* CQ page size and level. */
	uint8_t	cq_pg_size_cq_lvl;
	/* CQ PBL indirect levels. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_CQ_LVL_MASK	UINT32_C(0xf)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_CQ_LVL_SFT	0
	/* PBL pointer is physical start address. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_CQ_LVL_LVL_0	UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_CQ_LVL_LVL_1	UINT32_C(0x1)
	/* PBL pointer points to PDE table with each entry pointing to PTE tables. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_CQ_LVL_LVL_2	UINT32_C(0x2)
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_CQ_LVL_LAST	HWRM_FUNC_BACKING_STORE_CFG_INPUT_CQ_LVL_LVL_2
	/* CQ page size. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_CQ_PG_SIZE_MASK  UINT32_C(0xf0)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_CQ_PG_SIZE_SFT   4
	/* 4KB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_CQ_PG_SIZE_PG_4K   (UINT32_C(0x0) << 4)
	/* 8KB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_CQ_PG_SIZE_PG_8K   (UINT32_C(0x1) << 4)
	/* 64KB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_CQ_PG_SIZE_PG_64K  (UINT32_C(0x2) << 4)
	/* 2MB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_CQ_PG_SIZE_PG_2M   (UINT32_C(0x3) << 4)
	/* 8MB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_CQ_PG_SIZE_PG_8M   (UINT32_C(0x4) << 4)
	/* 1GB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_CQ_PG_SIZE_PG_1G   (UINT32_C(0x5) << 4)
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_CQ_PG_SIZE_LAST   HWRM_FUNC_BACKING_STORE_CFG_INPUT_CQ_PG_SIZE_PG_1G
	/* VNIC page size and level. */
	uint8_t	vnic_pg_size_vnic_lvl;
	/* VNIC PBL indirect levels. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_VNIC_LVL_MASK	UINT32_C(0xf)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_VNIC_LVL_SFT	0
	/* PBL pointer is physical start address. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_VNIC_LVL_LVL_0	UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_VNIC_LVL_LVL_1	UINT32_C(0x1)
	/* PBL pointer points to PDE table with each entry pointing to PTE tables. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_VNIC_LVL_LVL_2	UINT32_C(0x2)
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_VNIC_LVL_LAST	HWRM_FUNC_BACKING_STORE_CFG_INPUT_VNIC_LVL_LVL_2
	/* VNIC page size. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_VNIC_PG_SIZE_MASK  UINT32_C(0xf0)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_VNIC_PG_SIZE_SFT   4
	/* 4KB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_VNIC_PG_SIZE_PG_4K   (UINT32_C(0x0) << 4)
	/* 8KB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_VNIC_PG_SIZE_PG_8K   (UINT32_C(0x1) << 4)
	/* 64KB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_VNIC_PG_SIZE_PG_64K  (UINT32_C(0x2) << 4)
	/* 2MB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_VNIC_PG_SIZE_PG_2M   (UINT32_C(0x3) << 4)
	/* 8MB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_VNIC_PG_SIZE_PG_8M   (UINT32_C(0x4) << 4)
	/* 1GB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_VNIC_PG_SIZE_PG_1G   (UINT32_C(0x5) << 4)
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_VNIC_PG_SIZE_LAST   HWRM_FUNC_BACKING_STORE_CFG_INPUT_VNIC_PG_SIZE_PG_1G
	/* Stat page size and level. */
	uint8_t	stat_pg_size_stat_lvl;
	/* Stat PBL indirect levels. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_STAT_LVL_MASK	UINT32_C(0xf)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_STAT_LVL_SFT	0
	/* PBL pointer is physical start address. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_STAT_LVL_LVL_0	UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_STAT_LVL_LVL_1	UINT32_C(0x1)
	/* PBL pointer points to PDE table with each entry pointing to PTE tables. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_STAT_LVL_LVL_2	UINT32_C(0x2)
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_STAT_LVL_LAST	HWRM_FUNC_BACKING_STORE_CFG_INPUT_STAT_LVL_LVL_2
	/* Stat page size. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_STAT_PG_SIZE_MASK  UINT32_C(0xf0)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_STAT_PG_SIZE_SFT   4
	/* 4KB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_STAT_PG_SIZE_PG_4K   (UINT32_C(0x0) << 4)
	/* 8KB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_STAT_PG_SIZE_PG_8K   (UINT32_C(0x1) << 4)
	/* 64KB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_STAT_PG_SIZE_PG_64K  (UINT32_C(0x2) << 4)
	/* 2MB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_STAT_PG_SIZE_PG_2M   (UINT32_C(0x3) << 4)
	/* 8MB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_STAT_PG_SIZE_PG_8M   (UINT32_C(0x4) << 4)
	/* 1GB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_STAT_PG_SIZE_PG_1G   (UINT32_C(0x5) << 4)
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_STAT_PG_SIZE_LAST   HWRM_FUNC_BACKING_STORE_CFG_INPUT_STAT_PG_SIZE_PG_1G
	/* TQM slow path page size and level. */
	uint8_t	tqm_sp_pg_size_tqm_sp_lvl;
	/* TQM slow path PBL indirect levels. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_SP_LVL_MASK	UINT32_C(0xf)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_SP_LVL_SFT	0
	/* PBL pointer is physical start address. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_SP_LVL_LVL_0	UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_SP_LVL_LVL_1	UINT32_C(0x1)
	/* PBL pointer points to PDE table with each entry pointing to PTE tables. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_SP_LVL_LVL_2	UINT32_C(0x2)
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_SP_LVL_LAST	HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_SP_LVL_LVL_2
	/* TQM slow path page size. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_SP_PG_SIZE_MASK  UINT32_C(0xf0)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_SP_PG_SIZE_SFT   4
	/* 4KB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_SP_PG_SIZE_PG_4K   (UINT32_C(0x0) << 4)
	/* 8KB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_SP_PG_SIZE_PG_8K   (UINT32_C(0x1) << 4)
	/* 64KB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_SP_PG_SIZE_PG_64K  (UINT32_C(0x2) << 4)
	/* 2MB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_SP_PG_SIZE_PG_2M   (UINT32_C(0x3) << 4)
	/* 8MB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_SP_PG_SIZE_PG_8M   (UINT32_C(0x4) << 4)
	/* 1GB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_SP_PG_SIZE_PG_1G   (UINT32_C(0x5) << 4)
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_SP_PG_SIZE_LAST   HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_SP_PG_SIZE_PG_1G
	/* TQM ring 0 page size and level. */
	uint8_t	tqm_ring0_pg_size_tqm_ring0_lvl;
	/* TQM ring 0 PBL indirect levels. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING0_LVL_MASK	UINT32_C(0xf)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING0_LVL_SFT	0
	/* PBL pointer is physical start address. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING0_LVL_LVL_0	UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING0_LVL_LVL_1	UINT32_C(0x1)
	/* PBL pointer points to PDE table with each entry pointing to PTE tables. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING0_LVL_LVL_2	UINT32_C(0x2)
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING0_LVL_LAST	HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING0_LVL_LVL_2
	/* TQM ring 0 page size. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING0_PG_SIZE_MASK  UINT32_C(0xf0)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING0_PG_SIZE_SFT   4
	/* 4KB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING0_PG_SIZE_PG_4K   (UINT32_C(0x0) << 4)
	/* 8KB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING0_PG_SIZE_PG_8K   (UINT32_C(0x1) << 4)
	/* 64KB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING0_PG_SIZE_PG_64K  (UINT32_C(0x2) << 4)
	/* 2MB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING0_PG_SIZE_PG_2M   (UINT32_C(0x3) << 4)
	/* 8MB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING0_PG_SIZE_PG_8M   (UINT32_C(0x4) << 4)
	/* 1GB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING0_PG_SIZE_PG_1G   (UINT32_C(0x5) << 4)
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING0_PG_SIZE_LAST   HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING0_PG_SIZE_PG_1G
	/* TQM ring 1 page size and level. */
	uint8_t	tqm_ring1_pg_size_tqm_ring1_lvl;
	/* TQM ring 1 PBL indirect levels. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING1_LVL_MASK	UINT32_C(0xf)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING1_LVL_SFT	0
	/* PBL pointer is physical start address. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING1_LVL_LVL_0	UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING1_LVL_LVL_1	UINT32_C(0x1)
	/* PBL pointer points to PDE table with each entry pointing to PTE tables. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING1_LVL_LVL_2	UINT32_C(0x2)
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING1_LVL_LAST	HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING1_LVL_LVL_2
	/* TQM ring 1 page size. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING1_PG_SIZE_MASK  UINT32_C(0xf0)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING1_PG_SIZE_SFT   4
	/* 4KB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING1_PG_SIZE_PG_4K   (UINT32_C(0x0) << 4)
	/* 8KB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING1_PG_SIZE_PG_8K   (UINT32_C(0x1) << 4)
	/* 64KB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING1_PG_SIZE_PG_64K  (UINT32_C(0x2) << 4)
	/* 2MB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING1_PG_SIZE_PG_2M   (UINT32_C(0x3) << 4)
	/* 8MB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING1_PG_SIZE_PG_8M   (UINT32_C(0x4) << 4)
	/* 1GB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING1_PG_SIZE_PG_1G   (UINT32_C(0x5) << 4)
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING1_PG_SIZE_LAST   HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING1_PG_SIZE_PG_1G
	/* TQM ring 2 page size and level. */
	uint8_t	tqm_ring2_pg_size_tqm_ring2_lvl;
	/* TQM ring 2 PBL indirect levels. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING2_LVL_MASK	UINT32_C(0xf)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING2_LVL_SFT	0
	/* PBL pointer is physical start address. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING2_LVL_LVL_0	UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING2_LVL_LVL_1	UINT32_C(0x1)
	/* PBL pointer points to PDE table with each entry pointing to PTE tables. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING2_LVL_LVL_2	UINT32_C(0x2)
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING2_LVL_LAST	HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING2_LVL_LVL_2
	/* TQM ring 2 page size. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING2_PG_SIZE_MASK  UINT32_C(0xf0)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING2_PG_SIZE_SFT   4
	/* 4KB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING2_PG_SIZE_PG_4K   (UINT32_C(0x0) << 4)
	/* 8KB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING2_PG_SIZE_PG_8K   (UINT32_C(0x1) << 4)
	/* 64KB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING2_PG_SIZE_PG_64K  (UINT32_C(0x2) << 4)
	/* 2MB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING2_PG_SIZE_PG_2M   (UINT32_C(0x3) << 4)
	/* 8MB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING2_PG_SIZE_PG_8M   (UINT32_C(0x4) << 4)
	/* 1GB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING2_PG_SIZE_PG_1G   (UINT32_C(0x5) << 4)
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING2_PG_SIZE_LAST   HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING2_PG_SIZE_PG_1G
	/* TQM ring 3 page size and level. */
	uint8_t	tqm_ring3_pg_size_tqm_ring3_lvl;
	/* TQM ring 3 PBL indirect levels. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING3_LVL_MASK	UINT32_C(0xf)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING3_LVL_SFT	0
	/* PBL pointer is physical start address. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING3_LVL_LVL_0	UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING3_LVL_LVL_1	UINT32_C(0x1)
	/* PBL pointer points to PDE table with each entry pointing to PTE tables. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING3_LVL_LVL_2	UINT32_C(0x2)
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING3_LVL_LAST	HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING3_LVL_LVL_2
	/* TQM ring 3 page size. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING3_PG_SIZE_MASK  UINT32_C(0xf0)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING3_PG_SIZE_SFT   4
	/* 4KB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING3_PG_SIZE_PG_4K   (UINT32_C(0x0) << 4)
	/* 8KB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING3_PG_SIZE_PG_8K   (UINT32_C(0x1) << 4)
	/* 64KB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING3_PG_SIZE_PG_64K  (UINT32_C(0x2) << 4)
	/* 2MB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING3_PG_SIZE_PG_2M   (UINT32_C(0x3) << 4)
	/* 8MB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING3_PG_SIZE_PG_8M   (UINT32_C(0x4) << 4)
	/* 1GB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING3_PG_SIZE_PG_1G   (UINT32_C(0x5) << 4)
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING3_PG_SIZE_LAST   HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING3_PG_SIZE_PG_1G
	/* TQM ring 4 page size and level. */
	uint8_t	tqm_ring4_pg_size_tqm_ring4_lvl;
	/* TQM ring 4 PBL indirect levels. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING4_LVL_MASK	UINT32_C(0xf)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING4_LVL_SFT	0
	/* PBL pointer is physical start address. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING4_LVL_LVL_0	UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING4_LVL_LVL_1	UINT32_C(0x1)
	/* PBL pointer points to PDE table with each entry pointing to PTE tables. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING4_LVL_LVL_2	UINT32_C(0x2)
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING4_LVL_LAST	HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING4_LVL_LVL_2
	/* TQM ring 4 page size. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING4_PG_SIZE_MASK  UINT32_C(0xf0)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING4_PG_SIZE_SFT   4
	/* 4KB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING4_PG_SIZE_PG_4K   (UINT32_C(0x0) << 4)
	/* 8KB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING4_PG_SIZE_PG_8K   (UINT32_C(0x1) << 4)
	/* 64KB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING4_PG_SIZE_PG_64K  (UINT32_C(0x2) << 4)
	/* 2MB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING4_PG_SIZE_PG_2M   (UINT32_C(0x3) << 4)
	/* 8MB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING4_PG_SIZE_PG_8M   (UINT32_C(0x4) << 4)
	/* 1GB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING4_PG_SIZE_PG_1G   (UINT32_C(0x5) << 4)
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING4_PG_SIZE_LAST   HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING4_PG_SIZE_PG_1G
	/* TQM ring 5 page size and level. */
	uint8_t	tqm_ring5_pg_size_tqm_ring5_lvl;
	/* TQM ring 5 PBL indirect levels. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING5_LVL_MASK	UINT32_C(0xf)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING5_LVL_SFT	0
	/* PBL pointer is physical start address. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING5_LVL_LVL_0	UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING5_LVL_LVL_1	UINT32_C(0x1)
	/* PBL pointer points to PDE table with each entry pointing to PTE tables. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING5_LVL_LVL_2	UINT32_C(0x2)
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING5_LVL_LAST	HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING5_LVL_LVL_2
	/* TQM ring 5 page size. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING5_PG_SIZE_MASK  UINT32_C(0xf0)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING5_PG_SIZE_SFT   4
	/* 4KB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING5_PG_SIZE_PG_4K   (UINT32_C(0x0) << 4)
	/* 8KB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING5_PG_SIZE_PG_8K   (UINT32_C(0x1) << 4)
	/* 64KB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING5_PG_SIZE_PG_64K  (UINT32_C(0x2) << 4)
	/* 2MB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING5_PG_SIZE_PG_2M   (UINT32_C(0x3) << 4)
	/* 8MB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING5_PG_SIZE_PG_8M   (UINT32_C(0x4) << 4)
	/* 1GB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING5_PG_SIZE_PG_1G   (UINT32_C(0x5) << 4)
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING5_PG_SIZE_LAST   HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING5_PG_SIZE_PG_1G
	/* TQM ring 6 page size and level. */
	uint8_t	tqm_ring6_pg_size_tqm_ring6_lvl;
	/* TQM ring 6 PBL indirect levels. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING6_LVL_MASK	UINT32_C(0xf)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING6_LVL_SFT	0
	/* PBL pointer is physical start address. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING6_LVL_LVL_0	UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING6_LVL_LVL_1	UINT32_C(0x1)
	/* PBL pointer points to PDE table with each entry pointing to PTE tables. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING6_LVL_LVL_2	UINT32_C(0x2)
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING6_LVL_LAST	HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING6_LVL_LVL_2
	/* TQM ring 6 page size. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING6_PG_SIZE_MASK  UINT32_C(0xf0)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING6_PG_SIZE_SFT   4
	/* 4KB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING6_PG_SIZE_PG_4K   (UINT32_C(0x0) << 4)
	/* 8KB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING6_PG_SIZE_PG_8K   (UINT32_C(0x1) << 4)
	/* 64KB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING6_PG_SIZE_PG_64K  (UINT32_C(0x2) << 4)
	/* 2MB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING6_PG_SIZE_PG_2M   (UINT32_C(0x3) << 4)
	/* 8MB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING6_PG_SIZE_PG_8M   (UINT32_C(0x4) << 4)
	/* 1GB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING6_PG_SIZE_PG_1G   (UINT32_C(0x5) << 4)
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING6_PG_SIZE_LAST   HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING6_PG_SIZE_PG_1G
	/* TQM ring 7 page size and level. */
	uint8_t	tqm_ring7_pg_size_tqm_ring7_lvl;
	/* TQM ring 7 PBL indirect levels. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING7_LVL_MASK	UINT32_C(0xf)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING7_LVL_SFT	0
	/* PBL pointer is physical start address. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING7_LVL_LVL_0	UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING7_LVL_LVL_1	UINT32_C(0x1)
	/* PBL pointer points to PDE table with each entry pointing to PTE tables. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING7_LVL_LVL_2	UINT32_C(0x2)
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING7_LVL_LAST	HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING7_LVL_LVL_2
	/* TQM ring 7 page size. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING7_PG_SIZE_MASK  UINT32_C(0xf0)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING7_PG_SIZE_SFT   4
	/* 4KB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING7_PG_SIZE_PG_4K   (UINT32_C(0x0) << 4)
	/* 8KB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING7_PG_SIZE_PG_8K   (UINT32_C(0x1) << 4)
	/* 64KB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING7_PG_SIZE_PG_64K  (UINT32_C(0x2) << 4)
	/* 2MB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING7_PG_SIZE_PG_2M   (UINT32_C(0x3) << 4)
	/* 8MB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING7_PG_SIZE_PG_8M   (UINT32_C(0x4) << 4)
	/* 1GB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING7_PG_SIZE_PG_1G   (UINT32_C(0x5) << 4)
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING7_PG_SIZE_LAST   HWRM_FUNC_BACKING_STORE_CFG_INPUT_TQM_RING7_PG_SIZE_PG_1G
	/* MR/AV page size and level. */
	uint8_t	mrav_pg_size_mrav_lvl;
	/* MR/AV PBL indirect levels. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_MRAV_LVL_MASK	UINT32_C(0xf)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_MRAV_LVL_SFT	0
	/* PBL pointer is physical start address. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_MRAV_LVL_LVL_0	UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_MRAV_LVL_LVL_1	UINT32_C(0x1)
	/* PBL pointer points to PDE table with each entry pointing to PTE tables. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_MRAV_LVL_LVL_2	UINT32_C(0x2)
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_MRAV_LVL_LAST	HWRM_FUNC_BACKING_STORE_CFG_INPUT_MRAV_LVL_LVL_2
	/* MR/AV page size. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_MRAV_PG_SIZE_MASK  UINT32_C(0xf0)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_MRAV_PG_SIZE_SFT   4
	/* 4KB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_MRAV_PG_SIZE_PG_4K   (UINT32_C(0x0) << 4)
	/* 8KB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_MRAV_PG_SIZE_PG_8K   (UINT32_C(0x1) << 4)
	/* 64KB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_MRAV_PG_SIZE_PG_64K  (UINT32_C(0x2) << 4)
	/* 2MB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_MRAV_PG_SIZE_PG_2M   (UINT32_C(0x3) << 4)
	/* 8MB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_MRAV_PG_SIZE_PG_8M   (UINT32_C(0x4) << 4)
	/* 1GB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_MRAV_PG_SIZE_PG_1G   (UINT32_C(0x5) << 4)
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_MRAV_PG_SIZE_LAST   HWRM_FUNC_BACKING_STORE_CFG_INPUT_MRAV_PG_SIZE_PG_1G
	/* Timer page size and level. */
	uint8_t	tim_pg_size_tim_lvl;
	/* Timer PBL indirect levels. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TIM_LVL_MASK	UINT32_C(0xf)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TIM_LVL_SFT	0
	/* PBL pointer is physical start address. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TIM_LVL_LVL_0	UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TIM_LVL_LVL_1	UINT32_C(0x1)
	/* PBL pointer points to PDE table with each entry pointing to PTE tables. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TIM_LVL_LVL_2	UINT32_C(0x2)
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TIM_LVL_LAST	HWRM_FUNC_BACKING_STORE_CFG_INPUT_TIM_LVL_LVL_2
	/* Timer page size. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TIM_PG_SIZE_MASK  UINT32_C(0xf0)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TIM_PG_SIZE_SFT   4
	/* 4KB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TIM_PG_SIZE_PG_4K   (UINT32_C(0x0) << 4)
	/* 8KB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TIM_PG_SIZE_PG_8K   (UINT32_C(0x1) << 4)
	/* 64KB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TIM_PG_SIZE_PG_64K  (UINT32_C(0x2) << 4)
	/* 2MB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TIM_PG_SIZE_PG_2M   (UINT32_C(0x3) << 4)
	/* 8MB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TIM_PG_SIZE_PG_8M   (UINT32_C(0x4) << 4)
	/* 1GB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TIM_PG_SIZE_PG_1G   (UINT32_C(0x5) << 4)
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TIM_PG_SIZE_LAST   HWRM_FUNC_BACKING_STORE_CFG_INPUT_TIM_PG_SIZE_PG_1G
	/* QP page directory. */
	uint64_t	qpc_page_dir;
	/* SRQ page directory. */
	uint64_t	srq_page_dir;
	/* CQ page directory. */
	uint64_t	cq_page_dir;
	/* VNIC page directory. */
	uint64_t	vnic_page_dir;
	/* Stat page directory. */
	uint64_t	stat_page_dir;
	/* TQM slowpath page directory. */
	uint64_t	tqm_sp_page_dir;
	/* TQM ring 0 page directory. */
	uint64_t	tqm_ring0_page_dir;
	/* TQM ring 1 page directory. */
	uint64_t	tqm_ring1_page_dir;
	/* TQM ring 2 page directory. */
	uint64_t	tqm_ring2_page_dir;
	/* TQM ring 3 page directory. */
	uint64_t	tqm_ring3_page_dir;
	/* TQM ring 4 page directory. */
	uint64_t	tqm_ring4_page_dir;
	/* TQM ring 5 page directory. */
	uint64_t	tqm_ring5_page_dir;
	/* TQM ring 6 page directory. */
	uint64_t	tqm_ring6_page_dir;
	/* TQM ring 7 page directory. */
	uint64_t	tqm_ring7_page_dir;
	/* MR/AV page directory. */
	uint64_t	mrav_page_dir;
	/* Timer page directory. */
	uint64_t	tim_page_dir;
	/* Number of QPs. */
	uint32_t	qp_num_entries;
	/* Number of SRQs. */
	uint32_t	srq_num_entries;
	/* Number of CQs. */
	uint32_t	cq_num_entries;
	/* Number of Stats. */
	uint32_t	stat_num_entries;
	/*
	 * Number of TQM slowpath entries.
	 *
	 * TQM slowpath rings should be sized as follows:
	 *
	 * num_entries = num_vnics + num_l2_tx_rings + 2 * num_roce_qps + tqm_min_size
	 *
	 * Where:
	 *   num_vnics is the number of VNICs allocated in the VNIC backing store
	 *   num_l2_tx_rings is the number of L2 rings in the QP backing store
	 *   num_roce_qps is the number of RoCE QPs in the QP backing store
	 *   tqm_min_size is tqm_min_entries_per_ring reported by
	 *	HWRM_FUNC_BACKING_STORE_QCAPS
	 *
	 * Note that TQM ring sizes cannot be extended while the system is
	 * operational. If a PF driver needs to extend a TQM ring, it needs
	 * to reset the function (e.g. HWRM_FUNC_RESET) and then reallocate
	 * the backing store.
	 */
	uint32_t	tqm_sp_num_entries;
	/*
	 * Number of TQM ring 0 entries.
	 *
	 * TQM fastpath rings should be sized large enough to accommodate the
	 * maximum number of QPs (either L2 or RoCE, or both if shared)
	 * that can be enqueued to the TQM ring.
	 *
	 * Note that TQM ring sizes cannot be extended while the system is
	 * operational. If a PF driver needs to extend a TQM ring, it needs
	 * to reset the function (e.g. HWRM_FUNC_RESET) and then reallocate
	 * the backing store.
	 */
	uint32_t	tqm_ring0_num_entries;
	/*
	 * Number of TQM ring 1 entries.
	 *
	 * TQM fastpath rings should be sized large enough to accommodate the
	 * maximum number of QPs (either L2 or RoCE, or both if shared)
	 * that can be enqueued to the TQM ring.
	 *
	 * Note that TQM ring sizes cannot be extended while the system is
	 * operational. If a PF driver needs to extend a TQM ring, it needs
	 * to reset the function (e.g. HWRM_FUNC_RESET) and then reallocate
	 * the backing store.
	 */
	uint32_t	tqm_ring1_num_entries;
	/*
	 * Number of TQM ring 2 entries.
	 *
	 * TQM fastpath rings should be sized large enough to accommodate the
	 * maximum number of QPs (either L2 or RoCE, or both if shared)
	 * that can be enqueued to the TQM ring.
	 *
	 * Note that TQM ring sizes cannot be extended while the system is
	 * operational. If a PF driver needs to extend a TQM ring, it needs
	 * to reset the function (e.g. HWRM_FUNC_RESET) and then reallocate
	 * the backing store.
	 */
	uint32_t	tqm_ring2_num_entries;
	/*
	 * Number of TQM ring 3 entries.
	 *
	 * TQM fastpath rings should be sized large enough to accommodate the
	 * maximum number of QPs (either L2 or RoCE, or both if shared)
	 * that can be enqueued to the TQM ring.
	 *
	 * Note that TQM ring sizes cannot be extended while the system is
	 * operational. If a PF driver needs to extend a TQM ring, it needs
	 * to reset the function (e.g. HWRM_FUNC_RESET) and then reallocate
	 * the backing store.
	 */
	uint32_t	tqm_ring3_num_entries;
	/*
	 * Number of TQM ring 4 entries.
	 *
	 * TQM fastpath rings should be sized large enough to accommodate the
	 * maximum number of QPs (either L2 or RoCE, or both if shared)
	 * that can be enqueued to the TQM ring.
	 *
	 * Note that TQM ring sizes cannot be extended while the system is
	 * operational. If a PF driver needs to extend a TQM ring, it needs
	 * to reset the function (e.g. HWRM_FUNC_RESET) and then reallocate
	 * the backing store.
	 */
	uint32_t	tqm_ring4_num_entries;
	/*
	 * Number of TQM ring 5 entries.
	 *
	 * TQM fastpath rings should be sized large enough to accommodate the
	 * maximum number of QPs (either L2 or RoCE, or both if shared)
	 * that can be enqueued to the TQM ring.
	 *
	 * Note that TQM ring sizes cannot be extended while the system is
	 * operational. If a PF driver needs to extend a TQM ring, it needs
	 * to reset the function (e.g. HWRM_FUNC_RESET) and then reallocate
	 * the backing store.
	 */
	uint32_t	tqm_ring5_num_entries;
	/*
	 * Number of TQM ring 6 entries.
	 *
	 * TQM fastpath rings should be sized large enough to accommodate the
	 * maximum number of QPs (either L2 or RoCE, or both if shared)
	 * that can be enqueued to the TQM ring.
	 *
	 * Note that TQM ring sizes cannot be extended while the system is
	 * operational. If a PF driver needs to extend a TQM ring, it needs
	 * to reset the function (e.g. HWRM_FUNC_RESET) and then reallocate
	 * the backing store.
	 */
	uint32_t	tqm_ring6_num_entries;
	/*
	 * Number of TQM ring 7 entries.
	 *
	 * TQM fastpath rings should be sized large enough to accommodate the
	 * maximum number of QPs (either L2 or RoCE, or both if shared)
	 * that can be enqueued to the TQM ring.
	 *
	 * Note that TQM ring sizes cannot be extended while the system is
	 * operational. If a PF driver needs to extend a TQM ring, it needs
	 * to reset the function (e.g. HWRM_FUNC_RESET) and then reallocate
	 * the backing store.
	 */
	uint32_t	tqm_ring7_num_entries;
	/*
	 * If the MR/AV split reservation flag is not set, then this field
	 * represents the total number of MR plus AV entries. For versions
	 * of firmware that support the split reservation, when it is not
	 * specified half of the entries will be reserved for MRs and the
	 * other half for AVs.
	 *
	 * If the MR/AV split reservation flag is set, then this
	 * field is logically divided into two 16b fields. Bits `[31:16]`
	 * represents the `mr_num_entries` and bits `[15:0]` represents
	 * `av_num_entries`. The granularity of these values is defined by
	 * the `mrav_num_entries_unit` field returned by the
	 * `backing_store_qcaps` command.
	 */
	uint32_t	mrav_num_entries;
	/* Number of Timer entries. */
	uint32_t	tim_num_entries;
	/* Number of entries to reserve for QP1 */
	uint16_t	qp_num_qp1_entries;
	/* Number of entries to reserve for L2 */
	uint16_t	qp_num_l2_entries;
	/* Number of bytes that have been allocated for each context entry. */
	uint16_t	qp_entry_size;
	/* Number of entries to reserve for L2 */
	uint16_t	srq_num_l2_entries;
	/* Number of bytes that have been allocated for each context entry. */
	uint16_t	srq_entry_size;
	/* Number of entries to reserve for L2 */
	uint16_t	cq_num_l2_entries;
	/* Number of bytes that have been allocated for each context entry. */
	uint16_t	cq_entry_size;
	/* Number of entries to reserve for VNIC entries */
	uint16_t	vnic_num_vnic_entries;
	/* Number of entries to reserve for Ring table entries */
	uint16_t	vnic_num_ring_table_entries;
	/* Number of bytes that have been allocated for each context entry. */
	uint16_t	vnic_entry_size;
	/* Number of bytes that have been allocated for each context entry. */
	uint16_t	stat_entry_size;
	/* Number of bytes that have been allocated for each context entry. */
	uint16_t	tqm_entry_size;
	/* Number of bytes that have been allocated for each context entry. */
	uint16_t	mrav_entry_size;
	/* Number of bytes that have been allocated for each context entry. */
	uint16_t	tim_entry_size;
	/* TQM ring page size and level. */
	uint8_t	tqm_ring8_pg_size_tqm_ring_lvl;
	/* TQM ring PBL indirect levels. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RING8_TQM_RING_LVL_MASK	UINT32_C(0xf)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RING8_TQM_RING_LVL_SFT	0
	/* PBL pointer is physical start address. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RING8_TQM_RING_LVL_LVL_0	UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RING8_TQM_RING_LVL_LVL_1	UINT32_C(0x1)
	/*
	 * PBL pointer points to PDE table with each entry pointing to
	 * PTE tables.
	 */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RING8_TQM_RING_LVL_LVL_2	UINT32_C(0x2)
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RING8_TQM_RING_LVL_LAST	HWRM_FUNC_BACKING_STORE_CFG_INPUT_RING8_TQM_RING_LVL_LVL_2
	/* TQM ring page size. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RING8_TQM_RING_PG_SIZE_MASK  UINT32_C(0xf0)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RING8_TQM_RING_PG_SIZE_SFT   4
	/* 4KB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RING8_TQM_RING_PG_SIZE_PG_4K   (UINT32_C(0x0) << 4)
	/* 8KB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RING8_TQM_RING_PG_SIZE_PG_8K   (UINT32_C(0x1) << 4)
	/* 64KB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RING8_TQM_RING_PG_SIZE_PG_64K  (UINT32_C(0x2) << 4)
	/* 2MB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RING8_TQM_RING_PG_SIZE_PG_2M   (UINT32_C(0x3) << 4)
	/* 8MB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RING8_TQM_RING_PG_SIZE_PG_8M   (UINT32_C(0x4) << 4)
	/* 1GB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RING8_TQM_RING_PG_SIZE_PG_1G   (UINT32_C(0x5) << 4)
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RING8_TQM_RING_PG_SIZE_LAST   HWRM_FUNC_BACKING_STORE_CFG_INPUT_RING8_TQM_RING_PG_SIZE_PG_1G
	uint8_t	ring8_unused[3];
	/* Number of TQM ring entries. */
	uint32_t	tqm_ring8_num_entries;
	/* TQM ring page directory. */
	uint64_t	tqm_ring8_page_dir;
	/* TQM ring page size and level. */
	uint8_t	tqm_ring9_pg_size_tqm_ring_lvl;
	/* TQM ring PBL indirect levels. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RING9_TQM_RING_LVL_MASK	UINT32_C(0xf)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RING9_TQM_RING_LVL_SFT	0
	/* PBL pointer is physical start address. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RING9_TQM_RING_LVL_LVL_0	UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RING9_TQM_RING_LVL_LVL_1	UINT32_C(0x1)
	/*
	 * PBL pointer points to PDE table with each entry pointing to
	 * PTE tables.
	 */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RING9_TQM_RING_LVL_LVL_2	UINT32_C(0x2)
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RING9_TQM_RING_LVL_LAST	HWRM_FUNC_BACKING_STORE_CFG_INPUT_RING9_TQM_RING_LVL_LVL_2
	/* TQM ring page size. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RING9_TQM_RING_PG_SIZE_MASK  UINT32_C(0xf0)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RING9_TQM_RING_PG_SIZE_SFT   4
	/* 4KB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RING9_TQM_RING_PG_SIZE_PG_4K   (UINT32_C(0x0) << 4)
	/* 8KB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RING9_TQM_RING_PG_SIZE_PG_8K   (UINT32_C(0x1) << 4)
	/* 64KB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RING9_TQM_RING_PG_SIZE_PG_64K  (UINT32_C(0x2) << 4)
	/* 2MB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RING9_TQM_RING_PG_SIZE_PG_2M   (UINT32_C(0x3) << 4)
	/* 8MB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RING9_TQM_RING_PG_SIZE_PG_8M   (UINT32_C(0x4) << 4)
	/* 1GB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RING9_TQM_RING_PG_SIZE_PG_1G   (UINT32_C(0x5) << 4)
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RING9_TQM_RING_PG_SIZE_LAST   HWRM_FUNC_BACKING_STORE_CFG_INPUT_RING9_TQM_RING_PG_SIZE_PG_1G
	uint8_t	ring9_unused[3];
	/* Number of TQM ring entries. */
	uint32_t	tqm_ring9_num_entries;
	/* TQM ring page directory. */
	uint64_t	tqm_ring9_page_dir;
	/* TQM ring page size and level. */
	uint8_t	tqm_ring10_pg_size_tqm_ring_lvl;
	/* TQM ring PBL indirect levels. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RING10_TQM_RING_LVL_MASK	UINT32_C(0xf)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RING10_TQM_RING_LVL_SFT	0
	/* PBL pointer is physical start address. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RING10_TQM_RING_LVL_LVL_0	UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RING10_TQM_RING_LVL_LVL_1	UINT32_C(0x1)
	/*
	 * PBL pointer points to PDE table with each entry pointing to
	 * PTE tables.
	 */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RING10_TQM_RING_LVL_LVL_2	UINT32_C(0x2)
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RING10_TQM_RING_LVL_LAST	HWRM_FUNC_BACKING_STORE_CFG_INPUT_RING10_TQM_RING_LVL_LVL_2
	/* TQM ring page size. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RING10_TQM_RING_PG_SIZE_MASK  UINT32_C(0xf0)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RING10_TQM_RING_PG_SIZE_SFT   4
	/* 4KB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RING10_TQM_RING_PG_SIZE_PG_4K   (UINT32_C(0x0) << 4)
	/* 8KB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RING10_TQM_RING_PG_SIZE_PG_8K   (UINT32_C(0x1) << 4)
	/* 64KB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RING10_TQM_RING_PG_SIZE_PG_64K  (UINT32_C(0x2) << 4)
	/* 2MB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RING10_TQM_RING_PG_SIZE_PG_2M   (UINT32_C(0x3) << 4)
	/* 8MB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RING10_TQM_RING_PG_SIZE_PG_8M   (UINT32_C(0x4) << 4)
	/* 1GB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RING10_TQM_RING_PG_SIZE_PG_1G   (UINT32_C(0x5) << 4)
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RING10_TQM_RING_PG_SIZE_LAST   HWRM_FUNC_BACKING_STORE_CFG_INPUT_RING10_TQM_RING_PG_SIZE_PG_1G
	uint8_t	ring10_unused[3];
	/* Number of TQM ring entries. */
	uint32_t	tqm_ring10_num_entries;
	/* TQM ring page directory. */
	uint64_t	tqm_ring10_page_dir;
	/* Number of Tx KTLS context entries allocated. */
	uint32_t	tkc_num_entries;
	/* Number of Rx KTLS context entries allocated. */
	uint32_t	rkc_num_entries;
	/* Tx KTLS context page directory. */
	uint64_t	tkc_page_dir;
	/* Rx KTLS context page directory. */
	uint64_t	rkc_page_dir;
	/* Number of bytes allocated for each Tx KTLS context entry. */
	uint16_t	tkc_entry_size;
	/* Number of bytes allocated for each Rx KTLS context entry. */
	uint16_t	rkc_entry_size;
	/* Tx KTLS context page size and level. */
	uint8_t	tkc_pg_size_tkc_lvl;
	/* Tx KTLS context PBL indirect levels. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TKC_LVL_MASK	UINT32_C(0xf)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TKC_LVL_SFT	0
	/* PBL pointer is physical start address. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TKC_LVL_LVL_0	UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TKC_LVL_LVL_1	UINT32_C(0x1)
	/* PBL pointer points to PDE table with each entry pointing to PTE tables. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TKC_LVL_LVL_2	UINT32_C(0x2)
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TKC_LVL_LAST	HWRM_FUNC_BACKING_STORE_CFG_INPUT_TKC_LVL_LVL_2
	/* Tx KTLS context page size. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TKC_PG_SIZE_MASK  UINT32_C(0xf0)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TKC_PG_SIZE_SFT   4
	/* 4KB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TKC_PG_SIZE_PG_4K   (UINT32_C(0x0) << 4)
	/* 8KB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TKC_PG_SIZE_PG_8K   (UINT32_C(0x1) << 4)
	/* 64KB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TKC_PG_SIZE_PG_64K  (UINT32_C(0x2) << 4)
	/* 2MB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TKC_PG_SIZE_PG_2M   (UINT32_C(0x3) << 4)
	/* 8MB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TKC_PG_SIZE_PG_8M   (UINT32_C(0x4) << 4)
	/* 1GB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TKC_PG_SIZE_PG_1G   (UINT32_C(0x5) << 4)
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_TKC_PG_SIZE_LAST   HWRM_FUNC_BACKING_STORE_CFG_INPUT_TKC_PG_SIZE_PG_1G
	/* Rx KTLS context page size and level. */
	uint8_t	rkc_pg_size_tkc_lvl;
	/* Rx KTLS context PBL indirect levels. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RKC_LVL_MASK	UINT32_C(0xf)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RKC_LVL_SFT	0
	/* PBL pointer is physical start address. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RKC_LVL_LVL_0	UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RKC_LVL_LVL_1	UINT32_C(0x1)
	/*
	 * PBL pointer points to PDE table with each entry pointing to
	 * PTE tables.
	 */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RKC_LVL_LVL_2	UINT32_C(0x2)
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RKC_LVL_LAST	HWRM_FUNC_BACKING_STORE_CFG_INPUT_RKC_LVL_LVL_2
	/* Rx KTLS context page size. */
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RKC_PG_SIZE_MASK  UINT32_C(0xf0)
	#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RKC_PG_SIZE_SFT   4
	/* 4KB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RKC_PG_SIZE_PG_4K   (UINT32_C(0x0) << 4)
	/* 8KB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RKC_PG_SIZE_PG_8K   (UINT32_C(0x1) << 4)
	/* 64KB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RKC_PG_SIZE_PG_64K  (UINT32_C(0x2) << 4)
	/* 2MB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RKC_PG_SIZE_PG_2M   (UINT32_C(0x3) << 4)
	/* 8MB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RKC_PG_SIZE_PG_8M   (UINT32_C(0x4) << 4)
	/* 1GB. */
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RKC_PG_SIZE_PG_1G   (UINT32_C(0x5) << 4)
		#define HWRM_FUNC_BACKING_STORE_CFG_INPUT_RKC_PG_SIZE_LAST   HWRM_FUNC_BACKING_STORE_CFG_INPUT_RKC_PG_SIZE_PG_1G
	/* Reserved for future. */
	uint8_t	rsvd[2];
} hwrm_func_backing_store_cfg_input_t, *phwrm_func_backing_store_cfg_input_t;

/* hwrm_func_backing_store_cfg_output (size:128b/16B) */

typedef struct hwrm_func_backing_store_cfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_func_backing_store_cfg_output_t, *phwrm_func_backing_store_cfg_output_t;

/********************************
 * hwrm_func_backing_store_qcfg *
 ********************************/


/* hwrm_func_backing_store_qcfg_input (size:128b/16B) */

typedef struct hwrm_func_backing_store_qcfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
} hwrm_func_backing_store_qcfg_input_t, *phwrm_func_backing_store_qcfg_input_t;

/* hwrm_func_backing_store_qcfg_output (size:2496b/312B) */

typedef struct hwrm_func_backing_store_qcfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint32_t	flags;
	/*
	 * When set, the firmware only uses on-chip resources and does not
	 * expect any backing store to be provided by the host driver. This
	 * mode provides minimal L2 functionality (e.g. limited L2 resources,
	 * no RoCE).
	 */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_FLAGS_PREBOOT_MODE		UINT32_C(0x1)
	/*
	 * When set, the 32b `mrav_num_entries` field is logically divided
	 * into two 16b fields, `mr_num_entries` and `av_num_entries`.
	 */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_FLAGS_MRAV_RESERVATION_SPLIT	UINT32_C(0x2)
	uint32_t	enables;
	/*
	 * This bit must be '1' for the qp fields to be
	 * configured.
	 */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_ENABLES_QP		UINT32_C(0x1)
	/*
	 * This bit must be '1' for the srq fields to be
	 * configured.
	 */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_ENABLES_SRQ		UINT32_C(0x2)
	/*
	 * This bit must be '1' for the cq fields to be
	 * configured.
	 */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_ENABLES_CQ		UINT32_C(0x4)
	/*
	 * This bit must be '1' for the vnic fields to be
	 * configured.
	 */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_ENABLES_VNIC	UINT32_C(0x8)
	/*
	 * This bit must be '1' for the stat fields to be
	 * configured.
	 */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_ENABLES_STAT	UINT32_C(0x10)
	/*
	 * This bit must be '1' for the tqm_sp fields to be
	 * configured.
	 */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_ENABLES_TQM_SP	UINT32_C(0x20)
	/*
	 * This bit must be '1' for the tqm_ring0 fields to be
	 * configured.
	 */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_ENABLES_TQM_RING0	UINT32_C(0x40)
	/*
	 * This bit must be '1' for the tqm_ring1 fields to be
	 * configured.
	 */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_ENABLES_TQM_RING1	UINT32_C(0x80)
	/*
	 * This bit must be '1' for the tqm_ring2 fields to be
	 * configured.
	 */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_ENABLES_TQM_RING2	UINT32_C(0x100)
	/*
	 * This bit must be '1' for the tqm_ring3 fields to be
	 * configured.
	 */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_ENABLES_TQM_RING3	UINT32_C(0x200)
	/*
	 * This bit must be '1' for the tqm_ring4 fields to be
	 * configured.
	 */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_ENABLES_TQM_RING4	UINT32_C(0x400)
	/*
	 * This bit must be '1' for the tqm_ring5 fields to be
	 * configured.
	 */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_ENABLES_TQM_RING5	UINT32_C(0x800)
	/*
	 * This bit must be '1' for the tqm_ring6 fields to be
	 * configured.
	 */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_ENABLES_TQM_RING6	UINT32_C(0x1000)
	/*
	 * This bit must be '1' for the tqm_ring7 fields to be
	 * configured.
	 */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_ENABLES_TQM_RING7	UINT32_C(0x2000)
	/*
	 * This bit must be '1' for the mrav fields to be
	 * configured.
	 */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_ENABLES_MRAV	UINT32_C(0x4000)
	/*
	 * This bit must be '1' for the tim fields to be
	 * configured.
	 */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_ENABLES_TIM		UINT32_C(0x8000)
	/*
	 * This bit must be '1' for the tqm_ring8 fields to be
	 * configured.
	 */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_ENABLES_TQM_RING8	UINT32_C(0x10000)
	/*
	 * This bit must be '1' for the tqm_ring9 fields to be
	 * configured.
	 */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_ENABLES_TQM_RING9	UINT32_C(0x20000)
	/*
	 * This bit must be '1' for the tqm_ring10 fields to be
	 * configured.
	 */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_ENABLES_TQM_RING10	UINT32_C(0x40000)
	/*
	 * This bit must be '1' for the Tx KTLS context
	 * fields to be configured.
	 */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_ENABLES_TKC		UINT32_C(0x80000)
	/*
	 * This bit must be '1' for the Rx KTLS context
	 * fields to be configured.
	 */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_ENABLES_RKC		UINT32_C(0x100000)
	/* QPC page size and level. */
	uint8_t	qpc_pg_size_qpc_lvl;
	/* QPC PBL indirect levels. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_QPC_LVL_MASK	UINT32_C(0xf)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_QPC_LVL_SFT	0
	/* PBL pointer is physical start address. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_QPC_LVL_LVL_0	UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_QPC_LVL_LVL_1	UINT32_C(0x1)
	/* PBL pointer points to PDE table with each entry pointing to PTE tables. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_QPC_LVL_LVL_2	UINT32_C(0x2)
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_QPC_LVL_LAST	HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_QPC_LVL_LVL_2
	/* QPC page size. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_QPC_PG_SIZE_MASK  UINT32_C(0xf0)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_QPC_PG_SIZE_SFT   4
	/* 4KB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_QPC_PG_SIZE_PG_4K   (UINT32_C(0x0) << 4)
	/* 8KB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_QPC_PG_SIZE_PG_8K   (UINT32_C(0x1) << 4)
	/* 64KB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_QPC_PG_SIZE_PG_64K  (UINT32_C(0x2) << 4)
	/* 2MB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_QPC_PG_SIZE_PG_2M   (UINT32_C(0x3) << 4)
	/* 8MB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_QPC_PG_SIZE_PG_8M   (UINT32_C(0x4) << 4)
	/* 1GB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_QPC_PG_SIZE_PG_1G   (UINT32_C(0x5) << 4)
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_QPC_PG_SIZE_LAST   HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_QPC_PG_SIZE_PG_1G
	/* SRQ page size and level. */
	uint8_t	srq_pg_size_srq_lvl;
	/* SRQ PBL indirect levels. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_SRQ_LVL_MASK	UINT32_C(0xf)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_SRQ_LVL_SFT	0
	/* PBL pointer is physical start address. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_SRQ_LVL_LVL_0	UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_SRQ_LVL_LVL_1	UINT32_C(0x1)
	/* PBL pointer points to PDE table with each entry pointing to PTE tables. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_SRQ_LVL_LVL_2	UINT32_C(0x2)
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_SRQ_LVL_LAST	HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_SRQ_LVL_LVL_2
	/* SRQ page size. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_SRQ_PG_SIZE_MASK  UINT32_C(0xf0)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_SRQ_PG_SIZE_SFT   4
	/* 4KB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_SRQ_PG_SIZE_PG_4K   (UINT32_C(0x0) << 4)
	/* 8KB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_SRQ_PG_SIZE_PG_8K   (UINT32_C(0x1) << 4)
	/* 64KB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_SRQ_PG_SIZE_PG_64K  (UINT32_C(0x2) << 4)
	/* 2MB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_SRQ_PG_SIZE_PG_2M   (UINT32_C(0x3) << 4)
	/* 8MB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_SRQ_PG_SIZE_PG_8M   (UINT32_C(0x4) << 4)
	/* 1GB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_SRQ_PG_SIZE_PG_1G   (UINT32_C(0x5) << 4)
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_SRQ_PG_SIZE_LAST   HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_SRQ_PG_SIZE_PG_1G
	/* CQ page size and level. */
	uint8_t	cq_pg_size_cq_lvl;
	/* CQ PBL indirect levels. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_CQ_LVL_MASK	UINT32_C(0xf)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_CQ_LVL_SFT	0
	/* PBL pointer is physical start address. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_CQ_LVL_LVL_0	UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_CQ_LVL_LVL_1	UINT32_C(0x1)
	/* PBL pointer points to PDE table with each entry pointing to PTE tables. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_CQ_LVL_LVL_2	UINT32_C(0x2)
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_CQ_LVL_LAST	HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_CQ_LVL_LVL_2
	/* CQ page size. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_CQ_PG_SIZE_MASK  UINT32_C(0xf0)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_CQ_PG_SIZE_SFT   4
	/* 4KB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_CQ_PG_SIZE_PG_4K   (UINT32_C(0x0) << 4)
	/* 8KB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_CQ_PG_SIZE_PG_8K   (UINT32_C(0x1) << 4)
	/* 64KB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_CQ_PG_SIZE_PG_64K  (UINT32_C(0x2) << 4)
	/* 2MB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_CQ_PG_SIZE_PG_2M   (UINT32_C(0x3) << 4)
	/* 8MB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_CQ_PG_SIZE_PG_8M   (UINT32_C(0x4) << 4)
	/* 1GB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_CQ_PG_SIZE_PG_1G   (UINT32_C(0x5) << 4)
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_CQ_PG_SIZE_LAST   HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_CQ_PG_SIZE_PG_1G
	/* VNIC page size and level. */
	uint8_t	vnic_pg_size_vnic_lvl;
	/* VNIC PBL indirect levels. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_VNIC_LVL_MASK	UINT32_C(0xf)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_VNIC_LVL_SFT	0
	/* PBL pointer is physical start address. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_VNIC_LVL_LVL_0	UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_VNIC_LVL_LVL_1	UINT32_C(0x1)
	/* PBL pointer points to PDE table with each entry pointing to PTE tables. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_VNIC_LVL_LVL_2	UINT32_C(0x2)
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_VNIC_LVL_LAST	HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_VNIC_LVL_LVL_2
	/* VNIC page size. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_VNIC_PG_SIZE_MASK  UINT32_C(0xf0)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_VNIC_PG_SIZE_SFT   4
	/* 4KB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_VNIC_PG_SIZE_PG_4K   (UINT32_C(0x0) << 4)
	/* 8KB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_VNIC_PG_SIZE_PG_8K   (UINT32_C(0x1) << 4)
	/* 64KB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_VNIC_PG_SIZE_PG_64K  (UINT32_C(0x2) << 4)
	/* 2MB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_VNIC_PG_SIZE_PG_2M   (UINT32_C(0x3) << 4)
	/* 8MB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_VNIC_PG_SIZE_PG_8M   (UINT32_C(0x4) << 4)
	/* 1GB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_VNIC_PG_SIZE_PG_1G   (UINT32_C(0x5) << 4)
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_VNIC_PG_SIZE_LAST   HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_VNIC_PG_SIZE_PG_1G
	/* Stat page size and level. */
	uint8_t	stat_pg_size_stat_lvl;
	/* Stat PBL indirect levels. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_STAT_LVL_MASK	UINT32_C(0xf)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_STAT_LVL_SFT	0
	/* PBL pointer is physical start address. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_STAT_LVL_LVL_0	UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_STAT_LVL_LVL_1	UINT32_C(0x1)
	/* PBL pointer points to PDE table with each entry pointing to PTE tables. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_STAT_LVL_LVL_2	UINT32_C(0x2)
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_STAT_LVL_LAST	HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_STAT_LVL_LVL_2
	/* Stat page size. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_STAT_PG_SIZE_MASK  UINT32_C(0xf0)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_STAT_PG_SIZE_SFT   4
	/* 4KB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_STAT_PG_SIZE_PG_4K   (UINT32_C(0x0) << 4)
	/* 8KB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_STAT_PG_SIZE_PG_8K   (UINT32_C(0x1) << 4)
	/* 64KB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_STAT_PG_SIZE_PG_64K  (UINT32_C(0x2) << 4)
	/* 2MB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_STAT_PG_SIZE_PG_2M   (UINT32_C(0x3) << 4)
	/* 8MB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_STAT_PG_SIZE_PG_8M   (UINT32_C(0x4) << 4)
	/* 1GB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_STAT_PG_SIZE_PG_1G   (UINT32_C(0x5) << 4)
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_STAT_PG_SIZE_LAST   HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_STAT_PG_SIZE_PG_1G
	/* TQM slow path page size and level. */
	uint8_t	tqm_sp_pg_size_tqm_sp_lvl;
	/* TQM slow path PBL indirect levels. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_SP_LVL_MASK	UINT32_C(0xf)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_SP_LVL_SFT	0
	/* PBL pointer is physical start address. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_SP_LVL_LVL_0	UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_SP_LVL_LVL_1	UINT32_C(0x1)
	/* PBL pointer points to PDE table with each entry pointing to PTE tables. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_SP_LVL_LVL_2	UINT32_C(0x2)
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_SP_LVL_LAST	HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_SP_LVL_LVL_2
	/* TQM slow path page size. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_SP_PG_SIZE_MASK  UINT32_C(0xf0)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_SP_PG_SIZE_SFT   4
	/* 4KB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_SP_PG_SIZE_PG_4K   (UINT32_C(0x0) << 4)
	/* 8KB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_SP_PG_SIZE_PG_8K   (UINT32_C(0x1) << 4)
	/* 64KB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_SP_PG_SIZE_PG_64K  (UINT32_C(0x2) << 4)
	/* 2MB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_SP_PG_SIZE_PG_2M   (UINT32_C(0x3) << 4)
	/* 8MB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_SP_PG_SIZE_PG_8M   (UINT32_C(0x4) << 4)
	/* 1GB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_SP_PG_SIZE_PG_1G   (UINT32_C(0x5) << 4)
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_SP_PG_SIZE_LAST   HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_SP_PG_SIZE_PG_1G
	/* TQM ring 0 page size and level. */
	uint8_t	tqm_ring0_pg_size_tqm_ring0_lvl;
	/* TQM ring 0 PBL indirect levels. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING0_LVL_MASK	UINT32_C(0xf)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING0_LVL_SFT	0
	/* PBL pointer is physical start address. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING0_LVL_LVL_0	UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING0_LVL_LVL_1	UINT32_C(0x1)
	/* PBL pointer points to PDE table with each entry pointing to PTE tables. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING0_LVL_LVL_2	UINT32_C(0x2)
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING0_LVL_LAST	HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING0_LVL_LVL_2
	/* TQM ring 0 page size. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING0_PG_SIZE_MASK  UINT32_C(0xf0)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING0_PG_SIZE_SFT   4
	/* 4KB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING0_PG_SIZE_PG_4K   (UINT32_C(0x0) << 4)
	/* 8KB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING0_PG_SIZE_PG_8K   (UINT32_C(0x1) << 4)
	/* 64KB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING0_PG_SIZE_PG_64K  (UINT32_C(0x2) << 4)
	/* 2MB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING0_PG_SIZE_PG_2M   (UINT32_C(0x3) << 4)
	/* 8MB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING0_PG_SIZE_PG_8M   (UINT32_C(0x4) << 4)
	/* 1GB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING0_PG_SIZE_PG_1G   (UINT32_C(0x5) << 4)
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING0_PG_SIZE_LAST   HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING0_PG_SIZE_PG_1G
	/* TQM ring 1 page size and level. */
	uint8_t	tqm_ring1_pg_size_tqm_ring1_lvl;
	/* TQM ring 1 PBL indirect levels. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING1_LVL_MASK	UINT32_C(0xf)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING1_LVL_SFT	0
	/* PBL pointer is physical start address. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING1_LVL_LVL_0	UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING1_LVL_LVL_1	UINT32_C(0x1)
	/* PBL pointer points to PDE table with each entry pointing to PTE tables. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING1_LVL_LVL_2	UINT32_C(0x2)
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING1_LVL_LAST	HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING1_LVL_LVL_2
	/* TQM ring 1 page size. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING1_PG_SIZE_MASK  UINT32_C(0xf0)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING1_PG_SIZE_SFT   4
	/* 4KB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING1_PG_SIZE_PG_4K   (UINT32_C(0x0) << 4)
	/* 8KB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING1_PG_SIZE_PG_8K   (UINT32_C(0x1) << 4)
	/* 64KB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING1_PG_SIZE_PG_64K  (UINT32_C(0x2) << 4)
	/* 2MB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING1_PG_SIZE_PG_2M   (UINT32_C(0x3) << 4)
	/* 8MB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING1_PG_SIZE_PG_8M   (UINT32_C(0x4) << 4)
	/* 1GB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING1_PG_SIZE_PG_1G   (UINT32_C(0x5) << 4)
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING1_PG_SIZE_LAST   HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING1_PG_SIZE_PG_1G
	/* TQM ring 2 page size and level. */
	uint8_t	tqm_ring2_pg_size_tqm_ring2_lvl;
	/* TQM ring 2 PBL indirect levels. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING2_LVL_MASK	UINT32_C(0xf)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING2_LVL_SFT	0
	/* PBL pointer is physical start address. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING2_LVL_LVL_0	UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING2_LVL_LVL_1	UINT32_C(0x1)
	/* PBL pointer points to PDE table with each entry pointing to PTE tables. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING2_LVL_LVL_2	UINT32_C(0x2)
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING2_LVL_LAST	HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING2_LVL_LVL_2
	/* TQM ring 2 page size. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING2_PG_SIZE_MASK  UINT32_C(0xf0)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING2_PG_SIZE_SFT   4
	/* 4KB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING2_PG_SIZE_PG_4K   (UINT32_C(0x0) << 4)
	/* 8KB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING2_PG_SIZE_PG_8K   (UINT32_C(0x1) << 4)
	/* 64KB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING2_PG_SIZE_PG_64K  (UINT32_C(0x2) << 4)
	/* 2MB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING2_PG_SIZE_PG_2M   (UINT32_C(0x3) << 4)
	/* 8MB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING2_PG_SIZE_PG_8M   (UINT32_C(0x4) << 4)
	/* 1GB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING2_PG_SIZE_PG_1G   (UINT32_C(0x5) << 4)
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING2_PG_SIZE_LAST   HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING2_PG_SIZE_PG_1G
	/* TQM ring 3 page size and level. */
	uint8_t	tqm_ring3_pg_size_tqm_ring3_lvl;
	/* TQM ring 3 PBL indirect levels. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING3_LVL_MASK	UINT32_C(0xf)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING3_LVL_SFT	0
	/* PBL pointer is physical start address. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING3_LVL_LVL_0	UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING3_LVL_LVL_1	UINT32_C(0x1)
	/* PBL pointer points to PDE table with each entry pointing to PTE tables. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING3_LVL_LVL_2	UINT32_C(0x2)
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING3_LVL_LAST	HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING3_LVL_LVL_2
	/* TQM ring 3 page size. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING3_PG_SIZE_MASK  UINT32_C(0xf0)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING3_PG_SIZE_SFT   4
	/* 4KB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING3_PG_SIZE_PG_4K   (UINT32_C(0x0) << 4)
	/* 8KB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING3_PG_SIZE_PG_8K   (UINT32_C(0x1) << 4)
	/* 64KB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING3_PG_SIZE_PG_64K  (UINT32_C(0x2) << 4)
	/* 2MB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING3_PG_SIZE_PG_2M   (UINT32_C(0x3) << 4)
	/* 8MB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING3_PG_SIZE_PG_8M   (UINT32_C(0x4) << 4)
	/* 1GB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING3_PG_SIZE_PG_1G   (UINT32_C(0x5) << 4)
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING3_PG_SIZE_LAST   HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING3_PG_SIZE_PG_1G
	/* TQM ring 4 page size and level. */
	uint8_t	tqm_ring4_pg_size_tqm_ring4_lvl;
	/* TQM ring 4 PBL indirect levels. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING4_LVL_MASK	UINT32_C(0xf)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING4_LVL_SFT	0
	/* PBL pointer is physical start address. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING4_LVL_LVL_0	UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING4_LVL_LVL_1	UINT32_C(0x1)
	/* PBL pointer points to PDE table with each entry pointing to PTE tables. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING4_LVL_LVL_2	UINT32_C(0x2)
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING4_LVL_LAST	HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING4_LVL_LVL_2
	/* TQM ring 4 page size. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING4_PG_SIZE_MASK  UINT32_C(0xf0)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING4_PG_SIZE_SFT   4
	/* 4KB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING4_PG_SIZE_PG_4K   (UINT32_C(0x0) << 4)
	/* 8KB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING4_PG_SIZE_PG_8K   (UINT32_C(0x1) << 4)
	/* 64KB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING4_PG_SIZE_PG_64K  (UINT32_C(0x2) << 4)
	/* 2MB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING4_PG_SIZE_PG_2M   (UINT32_C(0x3) << 4)
	/* 8MB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING4_PG_SIZE_PG_8M   (UINT32_C(0x4) << 4)
	/* 1GB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING4_PG_SIZE_PG_1G   (UINT32_C(0x5) << 4)
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING4_PG_SIZE_LAST   HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING4_PG_SIZE_PG_1G
	/* TQM ring 5 page size and level. */
	uint8_t	tqm_ring5_pg_size_tqm_ring5_lvl;
	/* TQM ring 5 PBL indirect levels. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING5_LVL_MASK	UINT32_C(0xf)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING5_LVL_SFT	0
	/* PBL pointer is physical start address. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING5_LVL_LVL_0	UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING5_LVL_LVL_1	UINT32_C(0x1)
	/* PBL pointer points to PDE table with each entry pointing to PTE tables. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING5_LVL_LVL_2	UINT32_C(0x2)
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING5_LVL_LAST	HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING5_LVL_LVL_2
	/* TQM ring 5 page size. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING5_PG_SIZE_MASK  UINT32_C(0xf0)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING5_PG_SIZE_SFT   4
	/* 4KB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING5_PG_SIZE_PG_4K   (UINT32_C(0x0) << 4)
	/* 8KB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING5_PG_SIZE_PG_8K   (UINT32_C(0x1) << 4)
	/* 64KB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING5_PG_SIZE_PG_64K  (UINT32_C(0x2) << 4)
	/* 2MB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING5_PG_SIZE_PG_2M   (UINT32_C(0x3) << 4)
	/* 8MB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING5_PG_SIZE_PG_8M   (UINT32_C(0x4) << 4)
	/* 1GB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING5_PG_SIZE_PG_1G   (UINT32_C(0x5) << 4)
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING5_PG_SIZE_LAST   HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING5_PG_SIZE_PG_1G
	/* TQM ring 6 page size and level. */
	uint8_t	tqm_ring6_pg_size_tqm_ring6_lvl;
	/* TQM ring 6 PBL indirect levels. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING6_LVL_MASK	UINT32_C(0xf)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING6_LVL_SFT	0
	/* PBL pointer is physical start address. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING6_LVL_LVL_0	UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING6_LVL_LVL_1	UINT32_C(0x1)
	/* PBL pointer points to PDE table with each entry pointing to PTE tables. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING6_LVL_LVL_2	UINT32_C(0x2)
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING6_LVL_LAST	HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING6_LVL_LVL_2
	/* TQM ring 6 page size. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING6_PG_SIZE_MASK  UINT32_C(0xf0)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING6_PG_SIZE_SFT   4
	/* 4KB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING6_PG_SIZE_PG_4K   (UINT32_C(0x0) << 4)
	/* 8KB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING6_PG_SIZE_PG_8K   (UINT32_C(0x1) << 4)
	/* 64KB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING6_PG_SIZE_PG_64K  (UINT32_C(0x2) << 4)
	/* 2MB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING6_PG_SIZE_PG_2M   (UINT32_C(0x3) << 4)
	/* 8MB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING6_PG_SIZE_PG_8M   (UINT32_C(0x4) << 4)
	/* 1GB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING6_PG_SIZE_PG_1G   (UINT32_C(0x5) << 4)
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING6_PG_SIZE_LAST   HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING6_PG_SIZE_PG_1G
	/* TQM ring 7 page size and level. */
	uint8_t	tqm_ring7_pg_size_tqm_ring7_lvl;
	/* TQM ring 7 PBL indirect levels. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING7_LVL_MASK	UINT32_C(0xf)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING7_LVL_SFT	0
	/* PBL pointer is physical start address. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING7_LVL_LVL_0	UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING7_LVL_LVL_1	UINT32_C(0x1)
	/* PBL pointer points to PDE table with each entry pointing to PTE tables. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING7_LVL_LVL_2	UINT32_C(0x2)
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING7_LVL_LAST	HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING7_LVL_LVL_2
	/* TQM ring 7 page size. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING7_PG_SIZE_MASK  UINT32_C(0xf0)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING7_PG_SIZE_SFT   4
	/* 4KB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING7_PG_SIZE_PG_4K   (UINT32_C(0x0) << 4)
	/* 8KB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING7_PG_SIZE_PG_8K   (UINT32_C(0x1) << 4)
	/* 64KB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING7_PG_SIZE_PG_64K  (UINT32_C(0x2) << 4)
	/* 2MB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING7_PG_SIZE_PG_2M   (UINT32_C(0x3) << 4)
	/* 8MB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING7_PG_SIZE_PG_8M   (UINT32_C(0x4) << 4)
	/* 1GB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING7_PG_SIZE_PG_1G   (UINT32_C(0x5) << 4)
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING7_PG_SIZE_LAST   HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TQM_RING7_PG_SIZE_PG_1G
	/* MR/AV page size and level. */
	uint8_t	mrav_pg_size_mrav_lvl;
	/* MR/AV PBL indirect levels. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_MRAV_LVL_MASK	UINT32_C(0xf)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_MRAV_LVL_SFT	0
	/* PBL pointer is physical start address. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_MRAV_LVL_LVL_0	UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_MRAV_LVL_LVL_1	UINT32_C(0x1)
	/* PBL pointer points to PDE table with each entry pointing to PTE tables. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_MRAV_LVL_LVL_2	UINT32_C(0x2)
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_MRAV_LVL_LAST	HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_MRAV_LVL_LVL_2
	/* MR/AV page size. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_MRAV_PG_SIZE_MASK  UINT32_C(0xf0)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_MRAV_PG_SIZE_SFT   4
	/* 4KB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_MRAV_PG_SIZE_PG_4K   (UINT32_C(0x0) << 4)
	/* 8KB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_MRAV_PG_SIZE_PG_8K   (UINT32_C(0x1) << 4)
	/* 64KB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_MRAV_PG_SIZE_PG_64K  (UINT32_C(0x2) << 4)
	/* 2MB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_MRAV_PG_SIZE_PG_2M   (UINT32_C(0x3) << 4)
	/* 8MB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_MRAV_PG_SIZE_PG_8M   (UINT32_C(0x4) << 4)
	/* 1GB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_MRAV_PG_SIZE_PG_1G   (UINT32_C(0x5) << 4)
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_MRAV_PG_SIZE_LAST   HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_MRAV_PG_SIZE_PG_1G
	/* Timer page size and level. */
	uint8_t	tim_pg_size_tim_lvl;
	/* Timer PBL indirect levels. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TIM_LVL_MASK	UINT32_C(0xf)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TIM_LVL_SFT	0
	/* PBL pointer is physical start address. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TIM_LVL_LVL_0	UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TIM_LVL_LVL_1	UINT32_C(0x1)
	/* PBL pointer points to PDE table with each entry pointing to PTE tables. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TIM_LVL_LVL_2	UINT32_C(0x2)
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TIM_LVL_LAST	HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TIM_LVL_LVL_2
	/* Timer page size. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TIM_PG_SIZE_MASK  UINT32_C(0xf0)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TIM_PG_SIZE_SFT   4
	/* 4KB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TIM_PG_SIZE_PG_4K   (UINT32_C(0x0) << 4)
	/* 8KB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TIM_PG_SIZE_PG_8K   (UINT32_C(0x1) << 4)
	/* 64KB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TIM_PG_SIZE_PG_64K  (UINT32_C(0x2) << 4)
	/* 2MB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TIM_PG_SIZE_PG_2M   (UINT32_C(0x3) << 4)
	/* 8MB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TIM_PG_SIZE_PG_8M   (UINT32_C(0x4) << 4)
	/* 1GB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TIM_PG_SIZE_PG_1G   (UINT32_C(0x5) << 4)
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TIM_PG_SIZE_LAST   HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TIM_PG_SIZE_PG_1G
	/* QP page directory. */
	uint64_t	qpc_page_dir;
	/* SRQ page directory. */
	uint64_t	srq_page_dir;
	/* CQ page directory. */
	uint64_t	cq_page_dir;
	/* VNIC page directory. */
	uint64_t	vnic_page_dir;
	/* Stat page directory. */
	uint64_t	stat_page_dir;
	/* TQM slowpath page directory. */
	uint64_t	tqm_sp_page_dir;
	/* TQM ring 0 page directory. */
	uint64_t	tqm_ring0_page_dir;
	/* TQM ring 1 page directory. */
	uint64_t	tqm_ring1_page_dir;
	/* TQM ring 2 page directory. */
	uint64_t	tqm_ring2_page_dir;
	/* TQM ring 3 page directory. */
	uint64_t	tqm_ring3_page_dir;
	/* TQM ring 4 page directory. */
	uint64_t	tqm_ring4_page_dir;
	/* TQM ring 5 page directory. */
	uint64_t	tqm_ring5_page_dir;
	/* TQM ring 6 page directory. */
	uint64_t	tqm_ring6_page_dir;
	/* TQM ring 7 page directory. */
	uint64_t	tqm_ring7_page_dir;
	/* MR/AV page directory. */
	uint64_t	mrav_page_dir;
	/* Timer page directory. */
	uint64_t	tim_page_dir;
	/* Number of entries to reserve for QP1 */
	uint16_t	qp_num_qp1_entries;
	/* Number of entries to reserve for L2 */
	uint16_t	qp_num_l2_entries;
	/* Number of QPs. */
	uint32_t	qp_num_entries;
	/* Number of SRQs. */
	uint32_t	srq_num_entries;
	/* Number of entries to reserve for L2 */
	uint16_t	srq_num_l2_entries;
	/* Number of entries to reserve for L2 */
	uint16_t	cq_num_l2_entries;
	/* Number of CQs. */
	uint32_t	cq_num_entries;
	/* Number of entries to reserve for VNIC entries */
	uint16_t	vnic_num_vnic_entries;
	/* Number of entries to reserve for Ring table entries */
	uint16_t	vnic_num_ring_table_entries;
	/* Number of Stats. */
	uint32_t	stat_num_entries;
	/* Number of TQM slowpath entries. */
	uint32_t	tqm_sp_num_entries;
	/* Number of TQM ring 0 entries. */
	uint32_t	tqm_ring0_num_entries;
	/* Number of TQM ring 1 entries. */
	uint32_t	tqm_ring1_num_entries;
	/* Number of TQM ring 2 entries. */
	uint32_t	tqm_ring2_num_entries;
	/* Number of TQM ring 3 entries. */
	uint32_t	tqm_ring3_num_entries;
	/* Number of TQM ring 4 entries. */
	uint32_t	tqm_ring4_num_entries;
	/* Number of TQM ring 5 entries. */
	uint32_t	tqm_ring5_num_entries;
	/* Number of TQM ring 6 entries. */
	uint32_t	tqm_ring6_num_entries;
	/* Number of TQM ring 7 entries. */
	uint32_t	tqm_ring7_num_entries;
	/*
	 * If the MR/AV split reservation flag is not set, then this field
	 * represents the total number of MR plus AV entries. For versions
	 * of firmware that support the split reservation, when it is not
	 * specified half of the entries will be reserved for MRs and the
	 * other half for AVs.
	 *
	 * If the MR/AV split reservation flag is set, then this
	 * field is logically divided into two 16b fields. Bits `[31:16]`
	 * represents the `mr_num_entries` and bits `[15:0]` represents
	 * `av_num_entries`. The granularity of these values is defined by
	 * the `mrav_num_entries_unit` field returned by the
	 * `backing_store_qcaps` command.
	 */
	uint32_t	mrav_num_entries;
	/* Number of Timer entries. */
	uint32_t	tim_num_entries;
	/* TQM ring page size and level. */
	uint8_t	tqm_ring8_pg_size_tqm_ring_lvl;
	/* TQM ring PBL indirect levels. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RING8_TQM_RING_LVL_MASK	UINT32_C(0xf)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RING8_TQM_RING_LVL_SFT	0
	/* PBL pointer is physical start address. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RING8_TQM_RING_LVL_LVL_0	UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RING8_TQM_RING_LVL_LVL_1	UINT32_C(0x1)
	/*
	 * PBL pointer points to PDE table with each entry pointing to
	 * PTE tables.
	 */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RING8_TQM_RING_LVL_LVL_2	UINT32_C(0x2)
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RING8_TQM_RING_LVL_LAST	HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RING8_TQM_RING_LVL_LVL_2
	/* TQM ring page size. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RING8_TQM_RING_PG_SIZE_MASK  UINT32_C(0xf0)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RING8_TQM_RING_PG_SIZE_SFT   4
	/* 4KB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RING8_TQM_RING_PG_SIZE_PG_4K   (UINT32_C(0x0) << 4)
	/* 8KB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RING8_TQM_RING_PG_SIZE_PG_8K   (UINT32_C(0x1) << 4)
	/* 64KB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RING8_TQM_RING_PG_SIZE_PG_64K  (UINT32_C(0x2) << 4)
	/* 2MB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RING8_TQM_RING_PG_SIZE_PG_2M   (UINT32_C(0x3) << 4)
	/* 8MB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RING8_TQM_RING_PG_SIZE_PG_8M   (UINT32_C(0x4) << 4)
	/* 1GB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RING8_TQM_RING_PG_SIZE_PG_1G   (UINT32_C(0x5) << 4)
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RING8_TQM_RING_PG_SIZE_LAST   HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RING8_TQM_RING_PG_SIZE_PG_1G
	uint8_t	ring8_unused[3];
	/* Number of TQM ring entries. */
	uint32_t	tqm_ring8_num_entries;
	/* TQM ring page directory. */
	uint64_t	tqm_ring8_page_dir;
	/* TQM ring page size and level. */
	uint8_t	tqm_ring9_pg_size_tqm_ring_lvl;
	/* TQM ring PBL indirect levels. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RING9_TQM_RING_LVL_MASK	UINT32_C(0xf)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RING9_TQM_RING_LVL_SFT	0
	/* PBL pointer is physical start address. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RING9_TQM_RING_LVL_LVL_0	UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RING9_TQM_RING_LVL_LVL_1	UINT32_C(0x1)
	/*
	 * PBL pointer points to PDE table with each entry pointing to
	 * PTE tables.
	 */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RING9_TQM_RING_LVL_LVL_2	UINT32_C(0x2)
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RING9_TQM_RING_LVL_LAST	HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RING9_TQM_RING_LVL_LVL_2
	/* TQM ring page size. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RING9_TQM_RING_PG_SIZE_MASK  UINT32_C(0xf0)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RING9_TQM_RING_PG_SIZE_SFT   4
	/* 4KB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RING9_TQM_RING_PG_SIZE_PG_4K   (UINT32_C(0x0) << 4)
	/* 8KB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RING9_TQM_RING_PG_SIZE_PG_8K   (UINT32_C(0x1) << 4)
	/* 64KB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RING9_TQM_RING_PG_SIZE_PG_64K  (UINT32_C(0x2) << 4)
	/* 2MB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RING9_TQM_RING_PG_SIZE_PG_2M   (UINT32_C(0x3) << 4)
	/* 8MB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RING9_TQM_RING_PG_SIZE_PG_8M   (UINT32_C(0x4) << 4)
	/* 1GB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RING9_TQM_RING_PG_SIZE_PG_1G   (UINT32_C(0x5) << 4)
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RING9_TQM_RING_PG_SIZE_LAST   HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RING9_TQM_RING_PG_SIZE_PG_1G
	uint8_t	ring9_unused[3];
	/* Number of TQM ring entries. */
	uint32_t	tqm_ring9_num_entries;
	/* TQM ring page directory. */
	uint64_t	tqm_ring9_page_dir;
	/* TQM ring page size and level. */
	uint8_t	tqm_ring10_pg_size_tqm_ring_lvl;
	/* TQM ring PBL indirect levels. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RING10_TQM_RING_LVL_MASK	UINT32_C(0xf)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RING10_TQM_RING_LVL_SFT	0
	/* PBL pointer is physical start address. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RING10_TQM_RING_LVL_LVL_0	UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RING10_TQM_RING_LVL_LVL_1	UINT32_C(0x1)
	/*
	 * PBL pointer points to PDE table with each entry pointing to
	 * PTE tables.
	 */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RING10_TQM_RING_LVL_LVL_2	UINT32_C(0x2)
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RING10_TQM_RING_LVL_LAST	HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RING10_TQM_RING_LVL_LVL_2
	/* TQM ring page size. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RING10_TQM_RING_PG_SIZE_MASK  UINT32_C(0xf0)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RING10_TQM_RING_PG_SIZE_SFT   4
	/* 4KB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RING10_TQM_RING_PG_SIZE_PG_4K   (UINT32_C(0x0) << 4)
	/* 8KB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RING10_TQM_RING_PG_SIZE_PG_8K   (UINT32_C(0x1) << 4)
	/* 64KB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RING10_TQM_RING_PG_SIZE_PG_64K  (UINT32_C(0x2) << 4)
	/* 2MB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RING10_TQM_RING_PG_SIZE_PG_2M   (UINT32_C(0x3) << 4)
	/* 8MB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RING10_TQM_RING_PG_SIZE_PG_8M   (UINT32_C(0x4) << 4)
	/* 1GB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RING10_TQM_RING_PG_SIZE_PG_1G   (UINT32_C(0x5) << 4)
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RING10_TQM_RING_PG_SIZE_LAST   HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RING10_TQM_RING_PG_SIZE_PG_1G
	uint8_t	ring10_unused[3];
	/* Number of TQM ring entries. */
	uint32_t	tqm_ring10_num_entries;
	/* TQM ring page directory. */
	uint64_t	tqm_ring10_page_dir;
	/* Number of Tx KTLS context entries. */
	uint32_t	tkc_num_entries;
	/* Number of Rx KTLS context entries. */
	uint32_t	rkc_num_entries;
	/* Tx KTLS context page directory. */
	uint64_t	tkc_page_dir;
	/* Rx KTLS context page directory. */
	uint64_t	rkc_page_dir;
	/* Tx KTLS context page size and level. */
	uint8_t	tkc_pg_size_tkc_lvl;
	/* Tx KTLS context PBL indirect levels. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TKC_LVL_MASK	UINT32_C(0xf)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TKC_LVL_SFT	0
	/* PBL pointer is physical start address. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TKC_LVL_LVL_0	UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TKC_LVL_LVL_1	UINT32_C(0x1)
	/*
	 * PBL pointer points to PDE table with each entry pointing to
	 * PTE tables.
	 */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TKC_LVL_LVL_2	UINT32_C(0x2)
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TKC_LVL_LAST	HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TKC_LVL_LVL_2
	/* Tx KTLS context page size. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TKC_PG_SIZE_MASK  UINT32_C(0xf0)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TKC_PG_SIZE_SFT   4
	/* 4KB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TKC_PG_SIZE_PG_4K   (UINT32_C(0x0) << 4)
	/* 8KB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TKC_PG_SIZE_PG_8K   (UINT32_C(0x1) << 4)
	/* 64KB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TKC_PG_SIZE_PG_64K  (UINT32_C(0x2) << 4)
	/* 2MB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TKC_PG_SIZE_PG_2M   (UINT32_C(0x3) << 4)
	/* 8MB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TKC_PG_SIZE_PG_8M   (UINT32_C(0x4) << 4)
	/* 1GB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TKC_PG_SIZE_PG_1G   (UINT32_C(0x5) << 4)
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TKC_PG_SIZE_LAST   HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_TKC_PG_SIZE_PG_1G
	/* Rx KTLS context page size and level. */
	uint8_t	rkc_pg_size_tkc_lvl;
	/* Rx KTLS context PBL indirect levels. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RKC_LVL_MASK	UINT32_C(0xf)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RKC_LVL_SFT	0
	/* PBL pointer is physical start address. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RKC_LVL_LVL_0	UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RKC_LVL_LVL_1	UINT32_C(0x1)
	/*
	 * PBL pointer points to PDE table with each entry pointing to
	 * PTE tables.
	 */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RKC_LVL_LVL_2	UINT32_C(0x2)
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RKC_LVL_LAST	HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RKC_LVL_LVL_2
	/* Rx KTLS context page size. */
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RKC_PG_SIZE_MASK  UINT32_C(0xf0)
	#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RKC_PG_SIZE_SFT   4
	/* 4KB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RKC_PG_SIZE_PG_4K   (UINT32_C(0x0) << 4)
	/* 8KB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RKC_PG_SIZE_PG_8K   (UINT32_C(0x1) << 4)
	/* 64KB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RKC_PG_SIZE_PG_64K  (UINT32_C(0x2) << 4)
	/* 2MB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RKC_PG_SIZE_PG_2M   (UINT32_C(0x3) << 4)
	/* 8MB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RKC_PG_SIZE_PG_8M   (UINT32_C(0x4) << 4)
	/* 1GB. */
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RKC_PG_SIZE_PG_1G   (UINT32_C(0x5) << 4)
		#define HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RKC_PG_SIZE_LAST   HWRM_FUNC_BACKING_STORE_QCFG_OUTPUT_RKC_PG_SIZE_PG_1G
	uint8_t	unused_1[5];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as 1
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field
	 * is written last.
	 */
	uint8_t	valid;
} hwrm_func_backing_store_qcfg_output_t, *phwrm_func_backing_store_qcfg_output_t;

/****************************
 * hwrm_error_recovery_qcfg *
 ****************************/


/* hwrm_error_recovery_qcfg_input (size:192b/24B) */

typedef struct hwrm_error_recovery_qcfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint8_t	unused_0[8];
} hwrm_error_recovery_qcfg_input_t, *phwrm_error_recovery_qcfg_input_t;

/* hwrm_error_recovery_qcfg_output (size:1664b/208B) */

typedef struct hwrm_error_recovery_qcfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint32_t	flags;
	/*
	 * When this flag is set to 1, error recovery will be initiated
	 * through master function driver.
	 */
	#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_FLAGS_HOST	UINT32_C(0x1)
	/*
	 * When this flag is set to 1, error recovery will be performed
	 * through Co processor.
	 */
	#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_FLAGS_CO_CPU	UINT32_C(0x2)
	/*
	 * Driver Polling frequency. This value is in units of 100msec.
	 * Typical value would be 10 to indicate 1sec.
	 * Drivers can poll FW health status, Heartbeat, reset_counter with
	 * this frequency.
	 */
	uint32_t	driver_polling_freq;
	/*
	 * This value is in units of 100msec.
	 * Typical value would be 30 to indicate 3sec.
	 * Master function wait period from detecting a fatal error to
	 * initiating reset. In this time period Master PF expects every
	 * active driver will detect fatal error.
	 */
	uint32_t	master_func_wait_period;
	/*
	 * This value is in units of 100msec.
	 * Typical value would be 50 to indicate 5sec.
	 * Normal function wait period from fatal error detection to
	 * polling FW health status. In this time period, drivers should not
	 * do any PCIe MMIO transaction and should not send any HWRM commands.
	 */
	uint32_t	normal_func_wait_period;
	/*
	 * This value is in units of 100msec.
	 * Typical value would be 20 to indicate 2sec.
	 * This field indicates that, master function wait period after chip
	 * reset. After this time, master function should reinitialize with
	 * FW.
	 */
	uint32_t	master_func_wait_period_after_reset;
	/*
	 * This value is in units of 100msec.
	 * Typical value would be 60 to indicate 6sec.
	 * This field is applicable to both master and normal functions.
	 * Even after chip reset, if FW status not changed to ready,
	 * then all the functions can poll for this much time and bailout.
	 */
	uint32_t	max_bailout_time_after_reset;
	/*
	 * FW health status register.
	 * Lower 2 bits indicates address space location and upper 30 bits
	 * indicates upper 30bits of the register address.
	 * A value of 0xFFFF-FFFF indicates this register does not exist.
	 */
	uint32_t	fw_health_status_reg;
	/* Lower 2 bits indicates address space location. */
	#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_FW_HEALTH_STATUS_REG_ADDR_SPACE_MASK	UINT32_C(0x3)
	#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_FW_HEALTH_STATUS_REG_ADDR_SPACE_SFT	0
	/*
	 * If value is 0, this register is located in PCIe config space.
	 * Drivers have to map appropriate window to access this
	 * register.
	 */
		#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_FW_HEALTH_STATUS_REG_ADDR_SPACE_PCIE_CFG  UINT32_C(0x0)
	/*
	 * If value is 1, this register is located in GRC address space.
	 * Drivers have to map appropriate window to access this
	 * register.
	 */
		#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_FW_HEALTH_STATUS_REG_ADDR_SPACE_GRC	UINT32_C(0x1)
	/*
	 * If value is 2, this register is located in first BAR address
	 * space. Drivers have to map appropriate window to access this
	 * register.
	 */
		#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_FW_HEALTH_STATUS_REG_ADDR_SPACE_BAR0	UINT32_C(0x2)
	/*
	 * If value is 3, this register is located in second BAR address
	 * space. Drivers have to map appropriate window to access this
	 * Drivers have to map appropriate window to access this
	 * register.
	 */
		#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_FW_HEALTH_STATUS_REG_ADDR_SPACE_BAR1	UINT32_C(0x3)
		#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_FW_HEALTH_STATUS_REG_ADDR_SPACE_LAST	HWRM_ERROR_RECOVERY_QCFG_OUTPUT_FW_HEALTH_STATUS_REG_ADDR_SPACE_BAR1
	/* Upper 30bits of the register address. */
	#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_FW_HEALTH_STATUS_REG_ADDR_MASK	UINT32_C(0xfffffffc)
	#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_FW_HEALTH_STATUS_REG_ADDR_SFT	2
	/*
	 * FW HeartBeat register.
	 * Lower 2 bits indicates address space location and upper 30 bits
	 * indicates actual address.
	 * A value of 0xFFFF-FFFF indicates this register does not exist.
	 */
	uint32_t	fw_heartbeat_reg;
	/* Lower 2 bits indicates address space location. */
	#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_FW_HEARTBEAT_REG_ADDR_SPACE_MASK	UINT32_C(0x3)
	#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_FW_HEARTBEAT_REG_ADDR_SPACE_SFT	0
	/*
	 * If value is 0, this register is located in PCIe config space.
	 * Drivers have to map appropriate window to access this
	 * register.
	 */
		#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_FW_HEARTBEAT_REG_ADDR_SPACE_PCIE_CFG  UINT32_C(0x0)
	/*
	 * If value is 1, this register is located in GRC address space.
	 * Drivers have to map appropriate window to access this
	 * register.
	 */
		#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_FW_HEARTBEAT_REG_ADDR_SPACE_GRC	UINT32_C(0x1)
	/*
	 * If value is 2, this register is located in first BAR address
	 * space. Drivers have to map appropriate window to access this
	 * register.
	 */
		#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_FW_HEARTBEAT_REG_ADDR_SPACE_BAR0	UINT32_C(0x2)
	/*
	 * If value is 3, this register is located in second BAR address
	 * space. Drivers have to map appropriate window to access this
	 * register.
	 */
		#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_FW_HEARTBEAT_REG_ADDR_SPACE_BAR1	UINT32_C(0x3)
		#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_FW_HEARTBEAT_REG_ADDR_SPACE_LAST	HWRM_ERROR_RECOVERY_QCFG_OUTPUT_FW_HEARTBEAT_REG_ADDR_SPACE_BAR1
	/* Upper 30bits of the register address. */
	#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_FW_HEARTBEAT_REG_ADDR_MASK	UINT32_C(0xfffffffc)
	#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_FW_HEARTBEAT_REG_ADDR_SFT	2
	/*
	 * FW reset counter.
	 * Lower 2 bits indicates address space location and upper 30 bits
	 * indicates actual address.
	 * A value of 0xFFFF-FFFF indicates this register does not exist.
	 */
	uint32_t	fw_reset_cnt_reg;
	/* Lower 2 bits indicates address space location. */
	#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_FW_RESET_CNT_REG_ADDR_SPACE_MASK	UINT32_C(0x3)
	#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_FW_RESET_CNT_REG_ADDR_SPACE_SFT	0
	/*
	 * If value is 0, this register is located in PCIe config space.
	 * Drivers have to map appropriate window to access this
	 * register.
	 */
		#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_FW_RESET_CNT_REG_ADDR_SPACE_PCIE_CFG  UINT32_C(0x0)
	/*
	 * If value is 1, this register is located in GRC address space.
	 * Drivers have to map appropriate window to access this
	 * register.
	 */
		#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_FW_RESET_CNT_REG_ADDR_SPACE_GRC	UINT32_C(0x1)
	/*
	 * If value is 2, this register is located in first BAR address
	 * space. Drivers have to map appropriate window to access this
	 * register.
	 */
		#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_FW_RESET_CNT_REG_ADDR_SPACE_BAR0	UINT32_C(0x2)
	/*
	 * If value is 3, this register is located in second BAR address
	 * space. Drivers have to map appropriate window to access this
	 * register.
	 */
		#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_FW_RESET_CNT_REG_ADDR_SPACE_BAR1	UINT32_C(0x3)
		#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_FW_RESET_CNT_REG_ADDR_SPACE_LAST	HWRM_ERROR_RECOVERY_QCFG_OUTPUT_FW_RESET_CNT_REG_ADDR_SPACE_BAR1
	/* Upper 30bits of the register address. */
	#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_FW_RESET_CNT_REG_ADDR_MASK	UINT32_C(0xfffffffc)
	#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_FW_RESET_CNT_REG_ADDR_SFT	2
	/*
	 * Reset Inprogress Register address for PFs.
	 * Lower 2 bits indicates address space location and upper 30 bits
	 * indicates actual address.
	 * A value of 0xFFFF-FFFF indicates this register does not exist.
	 */
	uint32_t	reset_inprogress_reg;
	/* Lower 2 bits indicates address space location. */
	#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_RESET_INPROGRESS_REG_ADDR_SPACE_MASK	UINT32_C(0x3)
	#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_RESET_INPROGRESS_REG_ADDR_SPACE_SFT	0
	/*
	 * If value is 0, this register is located in PCIe config space.
	 * Drivers have to map appropriate window to access this
	 * register.
	 */
		#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_RESET_INPROGRESS_REG_ADDR_SPACE_PCIE_CFG  UINT32_C(0x0)
	/*
	 * If value is 1, this register is located in GRC address space.
	 * Drivers have to map appropriate window to access this
	 * register.
	 */
		#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_RESET_INPROGRESS_REG_ADDR_SPACE_GRC	UINT32_C(0x1)
	/*
	 * If value is 2, this register is located in first BAR address
	 * space. Drivers have to map appropriate window to access this
	 * register.
	 */
		#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_RESET_INPROGRESS_REG_ADDR_SPACE_BAR0	UINT32_C(0x2)
	/*
	 * If value is 3, this register is located in second BAR address
	 * space. Drivers have to map appropriate window to access this
	 * register.
	 */
		#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_RESET_INPROGRESS_REG_ADDR_SPACE_BAR1	UINT32_C(0x3)
		#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_RESET_INPROGRESS_REG_ADDR_SPACE_LAST	HWRM_ERROR_RECOVERY_QCFG_OUTPUT_RESET_INPROGRESS_REG_ADDR_SPACE_BAR1
	/* Upper 30bits of the register address. */
	#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_RESET_INPROGRESS_REG_ADDR_MASK	UINT32_C(0xfffffffc)
	#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_RESET_INPROGRESS_REG_ADDR_SFT	2
	/* This field indicates the mask value for reset_inprogress_reg. */
	uint32_t	reset_inprogress_reg_mask;
	uint8_t	unused_0[3];
	/*
	 * Array of registers and value count to reset the Chip
	 * Each array count has reset_reg, reset_reg_val, delay_after_reset
	 * in TLV format. Depending upon Chip type, number of reset registers
	 * will vary. Drivers have to write reset_reg_val in the reset_reg
	 * location in the same sequence in order to recover from a fatal
	 * error.
	 */
	uint8_t	reg_array_cnt;
	/*
	 * Reset register.
	 * Lower 2 bits indicates address space location and upper 30 bits
	 * indicates actual address.
	 * A value of 0xFFFF-FFFF indicates this register does not exist.
	 */
	uint32_t	reset_reg[16];
	/* Lower 2 bits indicates address space location. */
	#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_RESET_REG_ADDR_SPACE_MASK	UINT32_C(0x3)
	#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_RESET_REG_ADDR_SPACE_SFT	0
	/*
	 * If value is 0, this register is located in PCIe config space.
	 * Drivers have to map appropriate window to access this
	 * register.
	 */
		#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_RESET_REG_ADDR_SPACE_PCIE_CFG  UINT32_C(0x0)
	/*
	 * If value is 1, this register is located in GRC address space.
	 * Drivers have to map appropriate window to access this
	 * register.
	 */
		#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_RESET_REG_ADDR_SPACE_GRC	UINT32_C(0x1)
	/*
	 * If value is 2, this register is located in first BAR address
	 * space. Drivers have to map appropriate window to access this
	 * register.
	 */
		#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_RESET_REG_ADDR_SPACE_BAR0	UINT32_C(0x2)
	/*
	 * If value is 3, this register is located in second BAR address
	 * space. Drivers have to map appropriate window to access this
	 * register.
	 */
		#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_RESET_REG_ADDR_SPACE_BAR1	UINT32_C(0x3)
		#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_RESET_REG_ADDR_SPACE_LAST	HWRM_ERROR_RECOVERY_QCFG_OUTPUT_RESET_REG_ADDR_SPACE_BAR1
	/* Upper 30bits of the register address. */
	#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_RESET_REG_ADDR_MASK	UINT32_C(0xfffffffc)
	#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_RESET_REG_ADDR_SFT	2
	/* Value to be written in reset_reg to reset the controller. */
	uint32_t	reset_reg_val[16];
	/*
	 * This value is in units of 1msec.
	 * Typical value would be 10 to indicate 10msec.
	 * Some of the operations like Core reset require delay before
	 * accessing PCIE MMIO register space.
	 * If this value is non-zero, drivers have to wait for
	 * this much time after writing reset_reg_val in reset_reg.
	 */
	uint8_t	delay_after_reset[16];
	/*
	 * Error recovery counter.
	 * Lower 2 bits indicates address space location and upper 30 bits
	 * indicates actual address.
	 * A value of 0xFFFF-FFFF indicates this register does not exist.
	 */
	uint32_t	err_recovery_cnt_reg;
	/* Lower 2 bits indicates address space location. */
	#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_ERR_RECOVERY_CNT_REG_ADDR_SPACE_MASK	UINT32_C(0x3)
	#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_ERR_RECOVERY_CNT_REG_ADDR_SPACE_SFT	0
	/*
	 * If value is 0, this register is located in PCIe config space.
	 * Drivers have to map appropriate window to access this
	 * register.
	 */
		#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_ERR_RECOVERY_CNT_REG_ADDR_SPACE_PCIE_CFG  UINT32_C(0x0)
	/*
	 * If value is 1, this register is located in GRC address space.
	 * Drivers have to map appropriate window to access this
	 * register.
	 */
		#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_ERR_RECOVERY_CNT_REG_ADDR_SPACE_GRC	UINT32_C(0x1)
	/*
	 * If value is 2, this register is located in first BAR address
	 * space. Drivers have to map appropriate window to access this
	 * register.
	 */
		#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_ERR_RECOVERY_CNT_REG_ADDR_SPACE_BAR0	UINT32_C(0x2)
	/*
	 * If value is 3, this register is located in second BAR address
	 * space. Drivers have to map appropriate window to access this
	 * register.
	 */
		#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_ERR_RECOVERY_CNT_REG_ADDR_SPACE_BAR1	UINT32_C(0x3)
		#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_ERR_RECOVERY_CNT_REG_ADDR_SPACE_LAST	HWRM_ERROR_RECOVERY_QCFG_OUTPUT_ERR_RECOVERY_CNT_REG_ADDR_SPACE_BAR1
	/* Upper 30bits of the register address. */
	#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_ERR_RECOVERY_CNT_REG_ADDR_MASK	UINT32_C(0xfffffffc)
	#define HWRM_ERROR_RECOVERY_QCFG_OUTPUT_ERR_RECOVERY_CNT_REG_ADDR_SFT	2
	uint8_t	unused_1[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field
	 * is written last.
	 */
	uint8_t	valid;
} hwrm_error_recovery_qcfg_output_t, *phwrm_error_recovery_qcfg_output_t;

/***************************
 * hwrm_func_echo_response *
 ***************************/


/* hwrm_func_echo_response_input (size:192b/24B) */

typedef struct hwrm_func_echo_response_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	event_data1;
	uint32_t	event_data2;
} hwrm_func_echo_response_input_t, *phwrm_func_echo_response_input_t;

/* hwrm_func_echo_response_output (size:128b/16B) */

typedef struct hwrm_func_echo_response_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_func_echo_response_output_t, *phwrm_func_echo_response_output_t;

/**************************
 * hwrm_func_ptp_pin_qcfg *
 **************************/


/* hwrm_func_ptp_pin_qcfg_input (size:192b/24B) */

typedef struct hwrm_func_ptp_pin_qcfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint8_t	unused_0[8];
} hwrm_func_ptp_pin_qcfg_input_t, *phwrm_func_ptp_pin_qcfg_input_t;

/* hwrm_func_ptp_pin_qcfg_output (size:128b/16B) */

typedef struct hwrm_func_ptp_pin_qcfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * The number of TSIO pins that are configured on this board
	 * Up to 4 pins can be returned in the response.
	 */
	uint8_t	num_pins;
	/* Pin state */
	uint8_t	state;
	/*
	 * When this bit is '1', TSIO pin 0 is enabled.
	 * When this bit is '0', TSIO pin 0 is disabled.
	 */
	#define HWRM_FUNC_PTP_PIN_QCFG_OUTPUT_STATE_PIN0_ENABLED	UINT32_C(0x1)
	/*
	 * When this bit is '1', TSIO pin 1 is enabled.
	 * When this bit is '0', TSIO pin 1 is disabled.
	 */
	#define HWRM_FUNC_PTP_PIN_QCFG_OUTPUT_STATE_PIN1_ENABLED	UINT32_C(0x2)
	/*
	 * When this bit is '1', TSIO pin 2 is enabled.
	 * When this bit is '0', TSIO pin 2 is disabled.
	 */
	#define HWRM_FUNC_PTP_PIN_QCFG_OUTPUT_STATE_PIN2_ENABLED	UINT32_C(0x4)
	/*
	 * When this bit is '1', TSIO pin 3 is enabled.
	 * When this bit is '0', TSIO pin 3 is disabled.
	 */
	#define HWRM_FUNC_PTP_PIN_QCFG_OUTPUT_STATE_PIN3_ENABLED	UINT32_C(0x8)
	/* Type of function for Pin #0. */
	uint8_t	pin0_usage;
	/* No function is configured. */
	#define HWRM_FUNC_PTP_PIN_QCFG_OUTPUT_PIN0_USAGE_NONE	UINT32_C(0x0)
	/* PPS IN is configured. */
	#define HWRM_FUNC_PTP_PIN_QCFG_OUTPUT_PIN0_USAGE_PPS_IN   UINT32_C(0x1)
	/* PPS OUT is configured. */
	#define HWRM_FUNC_PTP_PIN_QCFG_OUTPUT_PIN0_USAGE_PPS_OUT  UINT32_C(0x2)
	/* SYNC IN is configured. */
	#define HWRM_FUNC_PTP_PIN_QCFG_OUTPUT_PIN0_USAGE_SYNC_IN  UINT32_C(0x3)
	/* SYNC OUT is configured. */
	#define HWRM_FUNC_PTP_PIN_QCFG_OUTPUT_PIN0_USAGE_SYNC_OUT UINT32_C(0x4)
	#define HWRM_FUNC_PTP_PIN_QCFG_OUTPUT_PIN0_USAGE_LAST	HWRM_FUNC_PTP_PIN_QCFG_OUTPUT_PIN0_USAGE_SYNC_OUT
	/* Type of function for Pin #1. */
	uint8_t	pin1_usage;
	/* No function is configured. */
	#define HWRM_FUNC_PTP_PIN_QCFG_OUTPUT_PIN1_USAGE_NONE	UINT32_C(0x0)
	/* PPS IN is configured. */
	#define HWRM_FUNC_PTP_PIN_QCFG_OUTPUT_PIN1_USAGE_PPS_IN   UINT32_C(0x1)
	/* PPS OUT is configured. */
	#define HWRM_FUNC_PTP_PIN_QCFG_OUTPUT_PIN1_USAGE_PPS_OUT  UINT32_C(0x2)
	/* SYNC IN is configured. */
	#define HWRM_FUNC_PTP_PIN_QCFG_OUTPUT_PIN1_USAGE_SYNC_IN  UINT32_C(0x3)
	/* SYNC OUT is configured. */
	#define HWRM_FUNC_PTP_PIN_QCFG_OUTPUT_PIN1_USAGE_SYNC_OUT UINT32_C(0x4)
	#define HWRM_FUNC_PTP_PIN_QCFG_OUTPUT_PIN1_USAGE_LAST	HWRM_FUNC_PTP_PIN_QCFG_OUTPUT_PIN1_USAGE_SYNC_OUT
	/* Type of function for Pin #2. */
	uint8_t	pin2_usage;
	/* No function is configured. */
	#define HWRM_FUNC_PTP_PIN_QCFG_OUTPUT_PIN2_USAGE_NONE	UINT32_C(0x0)
	/* PPS IN is configured. */
	#define HWRM_FUNC_PTP_PIN_QCFG_OUTPUT_PIN2_USAGE_PPS_IN   UINT32_C(0x1)
	/* PPS OUT is configured. */
	#define HWRM_FUNC_PTP_PIN_QCFG_OUTPUT_PIN2_USAGE_PPS_OUT  UINT32_C(0x2)
	/* SYNC IN is configured. */
	#define HWRM_FUNC_PTP_PIN_QCFG_OUTPUT_PIN2_USAGE_SYNC_IN  UINT32_C(0x3)
	/* SYNC OUT is configured. */
	#define HWRM_FUNC_PTP_PIN_QCFG_OUTPUT_PIN2_USAGE_SYNC_OUT UINT32_C(0x4)
	#define HWRM_FUNC_PTP_PIN_QCFG_OUTPUT_PIN2_USAGE_LAST	HWRM_FUNC_PTP_PIN_QCFG_OUTPUT_PIN2_USAGE_SYNC_OUT
	/* Type of function for Pin #3. */
	uint8_t	pin3_usage;
	/* No function is configured. */
	#define HWRM_FUNC_PTP_PIN_QCFG_OUTPUT_PIN3_USAGE_NONE	UINT32_C(0x0)
	/* PPS IN is configured. */
	#define HWRM_FUNC_PTP_PIN_QCFG_OUTPUT_PIN3_USAGE_PPS_IN   UINT32_C(0x1)
	/* PPS OUT is configured. */
	#define HWRM_FUNC_PTP_PIN_QCFG_OUTPUT_PIN3_USAGE_PPS_OUT  UINT32_C(0x2)
	/* SYNC IN is configured. */
	#define HWRM_FUNC_PTP_PIN_QCFG_OUTPUT_PIN3_USAGE_SYNC_IN  UINT32_C(0x3)
	/* SYNC OUT is configured. */
	#define HWRM_FUNC_PTP_PIN_QCFG_OUTPUT_PIN3_USAGE_SYNC_OUT UINT32_C(0x4)
	#define HWRM_FUNC_PTP_PIN_QCFG_OUTPUT_PIN3_USAGE_LAST	HWRM_FUNC_PTP_PIN_QCFG_OUTPUT_PIN3_USAGE_SYNC_OUT
	uint8_t	unused_0;
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_func_ptp_pin_qcfg_output_t, *phwrm_func_ptp_pin_qcfg_output_t;

/*************************
 * hwrm_func_ptp_pin_cfg *
 *************************/


/* hwrm_func_ptp_pin_cfg_input (size:256b/32B) */

typedef struct hwrm_func_ptp_pin_cfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	enables;
	/*
	 * This bit must be '1' for the pin0_state field to be
	 * configured.
	 */
	#define HWRM_FUNC_PTP_PIN_CFG_INPUT_ENABLES_PIN0_STATE	UINT32_C(0x1)
	/*
	 * This bit must be '1' for the pin0_usage field to be
	 * configured.
	 */
	#define HWRM_FUNC_PTP_PIN_CFG_INPUT_ENABLES_PIN0_USAGE	UINT32_C(0x2)
	/*
	 * This bit must be '1' for the pin1_state field to be
	 * configured.
	 */
	#define HWRM_FUNC_PTP_PIN_CFG_INPUT_ENABLES_PIN1_STATE	UINT32_C(0x4)
	/*
	 * This bit must be '1' for the pin1_usage field to be
	 * configured.
	 */
	#define HWRM_FUNC_PTP_PIN_CFG_INPUT_ENABLES_PIN1_USAGE	UINT32_C(0x8)
	/*
	 * This bit must be '1' for the pin2_state field to be
	 * configured.
	 */
	#define HWRM_FUNC_PTP_PIN_CFG_INPUT_ENABLES_PIN2_STATE	UINT32_C(0x10)
	/*
	 * This bit must be '1' for the pin2_usage field to be
	 * configured.
	 */
	#define HWRM_FUNC_PTP_PIN_CFG_INPUT_ENABLES_PIN2_USAGE	UINT32_C(0x20)
	/*
	 * This bit must be '1' for the pin3_state field to be
	 * configured.
	 */
	#define HWRM_FUNC_PTP_PIN_CFG_INPUT_ENABLES_PIN3_STATE	UINT32_C(0x40)
	/*
	 * This bit must be '1' for the pin3_usage field to be
	 * configured.
	 */
	#define HWRM_FUNC_PTP_PIN_CFG_INPUT_ENABLES_PIN3_USAGE	UINT32_C(0x80)
	/* Enable or disable functionality of Pin #0. */
	uint8_t	pin0_state;
	/* Disabled */
	#define HWRM_FUNC_PTP_PIN_CFG_INPUT_PIN0_STATE_DISABLED UINT32_C(0x0)
	/* Enabled */
	#define HWRM_FUNC_PTP_PIN_CFG_INPUT_PIN0_STATE_ENABLED  UINT32_C(0x1)
	#define HWRM_FUNC_PTP_PIN_CFG_INPUT_PIN0_STATE_LAST	HWRM_FUNC_PTP_PIN_CFG_INPUT_PIN0_STATE_ENABLED
	/* Configure function for TSIO pin#0. */
	uint8_t	pin0_usage;
	/* No function is configured. */
	#define HWRM_FUNC_PTP_PIN_CFG_INPUT_PIN0_USAGE_NONE	UINT32_C(0x0)
	/* PPS IN is configured. */
	#define HWRM_FUNC_PTP_PIN_CFG_INPUT_PIN0_USAGE_PPS_IN   UINT32_C(0x1)
	/* PPS OUT is configured. */
	#define HWRM_FUNC_PTP_PIN_CFG_INPUT_PIN0_USAGE_PPS_OUT  UINT32_C(0x2)
	/* SYNC IN is configured. */
	#define HWRM_FUNC_PTP_PIN_CFG_INPUT_PIN0_USAGE_SYNC_IN  UINT32_C(0x3)
	/* SYNC OUT is configured. */
	#define HWRM_FUNC_PTP_PIN_CFG_INPUT_PIN0_USAGE_SYNC_OUT UINT32_C(0x4)
	#define HWRM_FUNC_PTP_PIN_CFG_INPUT_PIN0_USAGE_LAST	HWRM_FUNC_PTP_PIN_CFG_INPUT_PIN0_USAGE_SYNC_OUT
	/* Enable or disable functionality of Pin #1. */
	uint8_t	pin1_state;
	/* Disabled */
	#define HWRM_FUNC_PTP_PIN_CFG_INPUT_PIN1_STATE_DISABLED UINT32_C(0x0)
	/* Enabled */
	#define HWRM_FUNC_PTP_PIN_CFG_INPUT_PIN1_STATE_ENABLED  UINT32_C(0x1)
	#define HWRM_FUNC_PTP_PIN_CFG_INPUT_PIN1_STATE_LAST	HWRM_FUNC_PTP_PIN_CFG_INPUT_PIN1_STATE_ENABLED
	/* Configure function for TSIO pin#1. */
	uint8_t	pin1_usage;
	/* No function is configured. */
	#define HWRM_FUNC_PTP_PIN_CFG_INPUT_PIN1_USAGE_NONE	UINT32_C(0x0)
	/* PPS IN is configured. */
	#define HWRM_FUNC_PTP_PIN_CFG_INPUT_PIN1_USAGE_PPS_IN   UINT32_C(0x1)
	/* PPS OUT is configured. */
	#define HWRM_FUNC_PTP_PIN_CFG_INPUT_PIN1_USAGE_PPS_OUT  UINT32_C(0x2)
	/* SYNC IN is configured. */
	#define HWRM_FUNC_PTP_PIN_CFG_INPUT_PIN1_USAGE_SYNC_IN  UINT32_C(0x3)
	/* SYNC OUT is configured. */
	#define HWRM_FUNC_PTP_PIN_CFG_INPUT_PIN1_USAGE_SYNC_OUT UINT32_C(0x4)
	#define HWRM_FUNC_PTP_PIN_CFG_INPUT_PIN1_USAGE_LAST	HWRM_FUNC_PTP_PIN_CFG_INPUT_PIN1_USAGE_SYNC_OUT
	/* Enable or disable functionality of Pin #2. */
	uint8_t	pin2_state;
	/* Disabled */
	#define HWRM_FUNC_PTP_PIN_CFG_INPUT_PIN2_STATE_DISABLED UINT32_C(0x0)
	/* Enabled */
	#define HWRM_FUNC_PTP_PIN_CFG_INPUT_PIN2_STATE_ENABLED  UINT32_C(0x1)
	#define HWRM_FUNC_PTP_PIN_CFG_INPUT_PIN2_STATE_LAST	HWRM_FUNC_PTP_PIN_CFG_INPUT_PIN2_STATE_ENABLED
	/* Configure function for TSIO pin#2. */
	uint8_t	pin2_usage;
	/* No function is configured. */
	#define HWRM_FUNC_PTP_PIN_CFG_INPUT_PIN2_USAGE_NONE	UINT32_C(0x0)
	/* PPS IN is configured. */
	#define HWRM_FUNC_PTP_PIN_CFG_INPUT_PIN2_USAGE_PPS_IN   UINT32_C(0x1)
	/* PPS OUT is configured. */
	#define HWRM_FUNC_PTP_PIN_CFG_INPUT_PIN2_USAGE_PPS_OUT  UINT32_C(0x2)
	/* SYNC IN is configured. */
	#define HWRM_FUNC_PTP_PIN_CFG_INPUT_PIN2_USAGE_SYNC_IN  UINT32_C(0x3)
	/* SYNC OUT is configured. */
	#define HWRM_FUNC_PTP_PIN_CFG_INPUT_PIN2_USAGE_SYNC_OUT UINT32_C(0x4)
	#define HWRM_FUNC_PTP_PIN_CFG_INPUT_PIN2_USAGE_LAST	HWRM_FUNC_PTP_PIN_CFG_INPUT_PIN2_USAGE_SYNC_OUT
	/* Enable or disable functionality of Pin #3. */
	uint8_t	pin3_state;
	/* Disabled */
	#define HWRM_FUNC_PTP_PIN_CFG_INPUT_PIN3_STATE_DISABLED UINT32_C(0x0)
	/* Enabled */
	#define HWRM_FUNC_PTP_PIN_CFG_INPUT_PIN3_STATE_ENABLED  UINT32_C(0x1)
	#define HWRM_FUNC_PTP_PIN_CFG_INPUT_PIN3_STATE_LAST	HWRM_FUNC_PTP_PIN_CFG_INPUT_PIN3_STATE_ENABLED
	/* Configure function for TSIO pin#3. */
	uint8_t	pin3_usage;
	/* No function is configured. */
	#define HWRM_FUNC_PTP_PIN_CFG_INPUT_PIN3_USAGE_NONE	UINT32_C(0x0)
	/* PPS IN is configured. */
	#define HWRM_FUNC_PTP_PIN_CFG_INPUT_PIN3_USAGE_PPS_IN   UINT32_C(0x1)
	/* PPS OUT is configured. */
	#define HWRM_FUNC_PTP_PIN_CFG_INPUT_PIN3_USAGE_PPS_OUT  UINT32_C(0x2)
	/* SYNC IN is configured. */
	#define HWRM_FUNC_PTP_PIN_CFG_INPUT_PIN3_USAGE_SYNC_IN  UINT32_C(0x3)
	/* SYNC OUT is configured. */
	#define HWRM_FUNC_PTP_PIN_CFG_INPUT_PIN3_USAGE_SYNC_OUT UINT32_C(0x4)
	#define HWRM_FUNC_PTP_PIN_CFG_INPUT_PIN3_USAGE_LAST	HWRM_FUNC_PTP_PIN_CFG_INPUT_PIN3_USAGE_SYNC_OUT
	uint8_t	unused_0[4];
} hwrm_func_ptp_pin_cfg_input_t, *phwrm_func_ptp_pin_cfg_input_t;

/* hwrm_func_ptp_pin_cfg_output (size:128b/16B) */

typedef struct hwrm_func_ptp_pin_cfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_func_ptp_pin_cfg_output_t, *phwrm_func_ptp_pin_cfg_output_t;

/*********************
 * hwrm_func_ptp_cfg *
 *********************/


/* hwrm_func_ptp_cfg_input (size:320b/40B) */

typedef struct hwrm_func_ptp_cfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint16_t	enables;
	/*
	 * This bit must be '1' for the ptp_pps_event field to be
	 * configured.
	 */
	#define HWRM_FUNC_PTP_CFG_INPUT_ENABLES_PTP_PPS_EVENT		UINT32_C(0x1)
	/*
	 * This bit must be '1' for the ptp_freq_adj_dll_source field to be
	 * configured.
	 */
	#define HWRM_FUNC_PTP_CFG_INPUT_ENABLES_PTP_FREQ_ADJ_DLL_SOURCE	UINT32_C(0x2)
	/*
	 * This bit must be '1' for the ptp_freq_adj_dll_phase field to be
	 * configured.
	 */
	#define HWRM_FUNC_PTP_CFG_INPUT_ENABLES_PTP_FREQ_ADJ_DLL_PHASE	UINT32_C(0x4)
	/*
	 * This bit must be '1' for the ptp_freq_adj_ext_period field to be
	 * configured.
	 */
	#define HWRM_FUNC_PTP_CFG_INPUT_ENABLES_PTP_FREQ_ADJ_EXT_PERIOD	UINT32_C(0x8)
	/*
	 * This bit must be '1' for the ptp_freq_adj_ext_up field to be
	 * configured.
	 */
	#define HWRM_FUNC_PTP_CFG_INPUT_ENABLES_PTP_FREQ_ADJ_EXT_UP	UINT32_C(0x10)
	/*
	 * This bit must be '1' for the ptp_freq_adj_ext_phase field to be
	 * configured.
	 */
	#define HWRM_FUNC_PTP_CFG_INPUT_ENABLES_PTP_FREQ_ADJ_EXT_PHASE	UINT32_C(0x20)
	/* This field is used to enable interrupt for a specific PPS event. */
	uint8_t	ptp_pps_event;
	/*
	 * When this bit is set to '1', interrupt is enabled for internal
	 * PPS event. Latches timestamp on PPS_OUT TSIO Pin. If user does
	 * not configure PPS_OUT on a TSIO pin, then firmware will allocate
	 * PPS_OUT to an unallocated pin.
	 */
	#define HWRM_FUNC_PTP_CFG_INPUT_PTP_PPS_EVENT_INTERNAL	UINT32_C(0x1)
	/*
	 * When this bit is set to '1', interrupt is enabled for external
	 * PPS event. Latches timestamp on PPS_IN TSIO pin.
	 */
	#define HWRM_FUNC_PTP_CFG_INPUT_PTP_PPS_EVENT_EXTERNAL	UINT32_C(0x2)
	/*
	 * This field is used to set the source signal used to discipline
	 * PHC (PTP Hardware Clock)
	 */
	uint8_t	ptp_freq_adj_dll_source;
	/* No source is selected. Use servo to discipline PHC */
	#define HWRM_FUNC_PTP_CFG_INPUT_PTP_FREQ_ADJ_DLL_SOURCE_NONE	UINT32_C(0x0)
	/* TSIO Pin #0 is selected as source signal. */
	#define HWRM_FUNC_PTP_CFG_INPUT_PTP_FREQ_ADJ_DLL_SOURCE_TSIO_0  UINT32_C(0x1)
	/* TSIO Pin #1 is selected as source signal. */
	#define HWRM_FUNC_PTP_CFG_INPUT_PTP_FREQ_ADJ_DLL_SOURCE_TSIO_1  UINT32_C(0x2)
	/* TSIO Pin #2 is selected as source signal. */
	#define HWRM_FUNC_PTP_CFG_INPUT_PTP_FREQ_ADJ_DLL_SOURCE_TSIO_2  UINT32_C(0x3)
	/* TSIO Pin #3 is selected as source signal. */
	#define HWRM_FUNC_PTP_CFG_INPUT_PTP_FREQ_ADJ_DLL_SOURCE_TSIO_3  UINT32_C(0x4)
	/* Port #0 is selected as source signal. */
	#define HWRM_FUNC_PTP_CFG_INPUT_PTP_FREQ_ADJ_DLL_SOURCE_PORT_0  UINT32_C(0x5)
	/* Port #1 is selected as source signal. */
	#define HWRM_FUNC_PTP_CFG_INPUT_PTP_FREQ_ADJ_DLL_SOURCE_PORT_1  UINT32_C(0x6)
	/* Port #2 is selected as source signal. */
	#define HWRM_FUNC_PTP_CFG_INPUT_PTP_FREQ_ADJ_DLL_SOURCE_PORT_2  UINT32_C(0x7)
	/* Port #3 is selected as source signal. */
	#define HWRM_FUNC_PTP_CFG_INPUT_PTP_FREQ_ADJ_DLL_SOURCE_PORT_3  UINT32_C(0x8)
	/* Invalid signal. */
	#define HWRM_FUNC_PTP_CFG_INPUT_PTP_FREQ_ADJ_DLL_SOURCE_INVALID UINT32_C(0xff)
	#define HWRM_FUNC_PTP_CFG_INPUT_PTP_FREQ_ADJ_DLL_SOURCE_LAST   HWRM_FUNC_PTP_CFG_INPUT_PTP_FREQ_ADJ_DLL_SOURCE_INVALID
	/*
	 * This field is used to provide phase adjustment for DLL
	 * used to discipline PHC (PTP Hardware clock)
	 */
	uint8_t	ptp_freq_adj_dll_phase;
	/* No Phase adjustment. */
	#define HWRM_FUNC_PTP_CFG_INPUT_PTP_FREQ_ADJ_DLL_PHASE_NONE UINT32_C(0x0)
	/* 4Khz sync in frequency. */
	#define HWRM_FUNC_PTP_CFG_INPUT_PTP_FREQ_ADJ_DLL_PHASE_4K   UINT32_C(0x1)
	/* 8Khz sync in frequency. */
	#define HWRM_FUNC_PTP_CFG_INPUT_PTP_FREQ_ADJ_DLL_PHASE_8K   UINT32_C(0x2)
	/* 10Mhz sync in frequency. */
	#define HWRM_FUNC_PTP_CFG_INPUT_PTP_FREQ_ADJ_DLL_PHASE_10M  UINT32_C(0x3)
	#define HWRM_FUNC_PTP_CFG_INPUT_PTP_FREQ_ADJ_DLL_PHASE_LAST HWRM_FUNC_PTP_CFG_INPUT_PTP_FREQ_ADJ_DLL_PHASE_10M
	uint8_t	unused_0[3];
	/*
	 * Period in nanoseconds (ns) for external signal
	 * input.
	 */
	uint32_t	ptp_freq_adj_ext_period;
	/*
	 * Up time in nanoseconds (ns) of the duty cycle
	 * of the external signal. This value should be
	 * less than ptp_freq_adj_ext_period.
	 */
	uint32_t	ptp_freq_adj_ext_up;
	/*
	 * Phase value is provided. Lower 16 bits of the
	 * field are used for Phase input.
	 */
	uint32_t	ptp_freq_adj_ext_phase_lower;
	/*
	 * Phase value is provided. This 32 bit field is used
	 * with the 16 bit value from ptp_freq_adj_ext_phase_lower
	 * to provide a 48 bit value input for Phase.
	 */
	uint32_t	ptp_freq_adj_ext_phase_upper;
} hwrm_func_ptp_cfg_input_t, *phwrm_func_ptp_cfg_input_t;

/* hwrm_func_ptp_cfg_output (size:128b/16B) */

typedef struct hwrm_func_ptp_cfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_func_ptp_cfg_output_t, *phwrm_func_ptp_cfg_output_t;

/**************************
 * hwrm_func_ptp_ts_query *
 **************************/


/* hwrm_func_ptp_ts_query_input (size:192b/24B) */

typedef struct hwrm_func_ptp_ts_query_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	flags;
	/* If set, the response includes PPS event timestamps */
	#define HWRM_FUNC_PTP_TS_QUERY_INPUT_FLAGS_PPS_TIME	UINT32_C(0x1)
	/* If set, the response includes PTM timestamps */
	#define HWRM_FUNC_PTP_TS_QUERY_INPUT_FLAGS_PTM_TIME	UINT32_C(0x2)
	uint8_t	unused_0[4];
} hwrm_func_ptp_ts_query_input_t, *phwrm_func_ptp_ts_query_input_t;

/* hwrm_func_ptp_ts_query_output (size:320b/40B) */

typedef struct hwrm_func_ptp_ts_query_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Timestamp value of last PPS event latched. */
	uint64_t	pps_event_ts;
	/* PTM local timestamp value. */
	uint64_t	ptm_res_local_ts;
	/* PTM Master timestamp value. */
	uint64_t	ptm_pmstr_ts;
	/* PTM Master propagation delay */
	uint32_t	ptm_mstr_prop_dly;
	uint8_t	unused_0[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_func_ptp_ts_query_output_t, *phwrm_func_ptp_ts_query_output_t;

/***********************
 * hwrm_func_vlan_qcfg *
 ***********************/


/* hwrm_func_vlan_qcfg_input (size:192b/24B) */

typedef struct hwrm_func_vlan_qcfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * Function ID of the function that is being
	 * configured.
	 * If set to 0xFF... (All Fs), then the configuration is
	 * for the requesting function.
	 */
	uint16_t	fid;
	uint8_t	unused_0[6];
} hwrm_func_vlan_qcfg_input_t, *phwrm_func_vlan_qcfg_input_t;

/* hwrm_func_vlan_qcfg_output (size:320b/40B) */

typedef struct hwrm_func_vlan_qcfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint64_t	unused_0;
	/* S-TAG VLAN identifier configured for the function. */
	uint16_t	stag_vid;
	/* S-TAG PCP value configured for the function. */
	uint8_t	stag_pcp;
	uint8_t	unused_1;
	/*
	 * S-TAG TPID value configured for the function. This field is specified in
	 * network byte order.
	 */
	uint16_t	stag_tpid;
	/* C-TAG VLAN identifier configured for the function. */
	uint16_t	ctag_vid;
	/* C-TAG PCP value configured for the function. */
	uint8_t	ctag_pcp;
	uint8_t	unused_2;
	/*
	 * C-TAG TPID value configured for the function. This field is specified in
	 * network byte order.
	 */
	uint16_t	ctag_tpid;
	/* Future use. */
	uint32_t	rsvd2;
	/* Future use. */
	uint32_t	rsvd3;
	uint8_t	unused_3[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_func_vlan_qcfg_output_t, *phwrm_func_vlan_qcfg_output_t;

/**********************
 * hwrm_func_vlan_cfg *
 **********************/


/* hwrm_func_vlan_cfg_input (size:384b/48B) */

typedef struct hwrm_func_vlan_cfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * Function ID of the function that is being
	 * configured.
	 * If set to 0xFF... (All Fs), then the configuration is
	 * for the requesting function.
	 */
	uint16_t	fid;
	uint8_t	unused_0[2];
	uint32_t	enables;
	/*
	 * This bit must be '1' for the stag_vid field to be
	 * configured.
	 */
	#define HWRM_FUNC_VLAN_CFG_INPUT_ENABLES_STAG_VID	UINT32_C(0x1)
	/*
	 * This bit must be '1' for the ctag_vid field to be
	 * configured.
	 */
	#define HWRM_FUNC_VLAN_CFG_INPUT_ENABLES_CTAG_VID	UINT32_C(0x2)
	/*
	 * This bit must be '1' for the stag_pcp field to be
	 * configured.
	 */
	#define HWRM_FUNC_VLAN_CFG_INPUT_ENABLES_STAG_PCP	UINT32_C(0x4)
	/*
	 * This bit must be '1' for the ctag_pcp field to be
	 * configured.
	 */
	#define HWRM_FUNC_VLAN_CFG_INPUT_ENABLES_CTAG_PCP	UINT32_C(0x8)
	/*
	 * This bit must be '1' for the stag_tpid field to be
	 * configured.
	 */
	#define HWRM_FUNC_VLAN_CFG_INPUT_ENABLES_STAG_TPID	UINT32_C(0x10)
	/*
	 * This bit must be '1' for the ctag_tpid field to be
	 * configured.
	 */
	#define HWRM_FUNC_VLAN_CFG_INPUT_ENABLES_CTAG_TPID	UINT32_C(0x20)
	/* S-TAG VLAN identifier configured for the function. */
	uint16_t	stag_vid;
	/* S-TAG PCP value configured for the function. */
	uint8_t	stag_pcp;
	uint8_t	unused_1;
	/*
	 * S-TAG TPID value configured for the function. This field is specified in
	 * network byte order.
	 */
	uint16_t	stag_tpid;
	/* C-TAG VLAN identifier configured for the function. */
	uint16_t	ctag_vid;
	/* C-TAG PCP value configured for the function. */
	uint8_t	ctag_pcp;
	uint8_t	unused_2;
	/*
	 * C-TAG TPID value configured for the function. This field is specified in
	 * network byte order.
	 */
	uint16_t	ctag_tpid;
	/* Future use. */
	uint32_t	rsvd1;
	/* Future use. */
	uint32_t	rsvd2;
	uint8_t	unused_3[4];
} hwrm_func_vlan_cfg_input_t, *phwrm_func_vlan_cfg_input_t;

/* hwrm_func_vlan_cfg_output (size:128b/16B) */

typedef struct hwrm_func_vlan_cfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_func_vlan_cfg_output_t, *phwrm_func_vlan_cfg_output_t;

/*******************************
 * hwrm_func_vf_vnic_ids_query *
 *******************************/


/* hwrm_func_vf_vnic_ids_query_input (size:256b/32B) */

typedef struct hwrm_func_vf_vnic_ids_query_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * This value is used to identify a Virtual Function (VF).
	 * The scope of VF ID is local within a PF.
	 */
	uint16_t	vf_id;
	uint8_t	unused_0[2];
	/* Max number of vnic ids in vnic id table */
	uint32_t	max_vnic_id_cnt;
	/* This is the address for VF VNIC ID table */
	uint64_t	vnic_id_tbl_addr;
} hwrm_func_vf_vnic_ids_query_input_t, *phwrm_func_vf_vnic_ids_query_input_t;

/* hwrm_func_vf_vnic_ids_query_output (size:128b/16B) */

typedef struct hwrm_func_vf_vnic_ids_query_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * Actual number of vnic ids
	 *
	 * Each VNIC ID is written as a 32-bit number.
	 */
	uint32_t	vnic_id_cnt;
	uint8_t	unused_0[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_func_vf_vnic_ids_query_output_t, *phwrm_func_vf_vnic_ids_query_output_t;

/***********************
 * hwrm_func_vf_bw_cfg *
 ***********************/


/* hwrm_func_vf_bw_cfg_input (size:960b/120B) */

typedef struct hwrm_func_vf_bw_cfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * The number of VF functions that are being configured.
	 * The cmd space allows up to 50 VFs' BW to be configured with one cmd.
	 */
	uint16_t	num_vfs;
	uint16_t	unused[3];
	/* These 16-bit fields contain the VF fid and the rate scale percentage. */
	uint16_t	vfn[48];
	/* The physical VF id the adjustment will be made to. */
	#define HWRM_FUNC_VF_BW_CFG_INPUT_VFN_VFID_MASK	UINT32_C(0xfff)
	#define HWRM_FUNC_VF_BW_CFG_INPUT_VFN_VFID_SFT	0
	/*
	 * This field configures the rate scale percentage of the VF as specified
	 * by the physical VF id.
	 */
	#define HWRM_FUNC_VF_BW_CFG_INPUT_VFN_RATE_MASK	UINT32_C(0xf000)
	#define HWRM_FUNC_VF_BW_CFG_INPUT_VFN_RATE_SFT	12
	/* 0% of the max tx rate */
		#define HWRM_FUNC_VF_BW_CFG_INPUT_VFN_RATE_PCT_0	(UINT32_C(0x0) << 12)
	/* 6.66% of the max tx rate */
		#define HWRM_FUNC_VF_BW_CFG_INPUT_VFN_RATE_PCT_6_66   (UINT32_C(0x1) << 12)
	/* 13.33% of the max tx rate */
		#define HWRM_FUNC_VF_BW_CFG_INPUT_VFN_RATE_PCT_13_33  (UINT32_C(0x2) << 12)
	/* 20% of the max tx rate */
		#define HWRM_FUNC_VF_BW_CFG_INPUT_VFN_RATE_PCT_20	(UINT32_C(0x3) << 12)
	/* 26.66% of the max tx rate */
		#define HWRM_FUNC_VF_BW_CFG_INPUT_VFN_RATE_PCT_26_66  (UINT32_C(0x4) << 12)
	/* 33% of the max tx rate */
		#define HWRM_FUNC_VF_BW_CFG_INPUT_VFN_RATE_PCT_33_33  (UINT32_C(0x5) << 12)
	/* 40% of the max tx rate */
		#define HWRM_FUNC_VF_BW_CFG_INPUT_VFN_RATE_PCT_40	(UINT32_C(0x6) << 12)
	/* 46.66% of the max tx rate */
		#define HWRM_FUNC_VF_BW_CFG_INPUT_VFN_RATE_PCT_46_66  (UINT32_C(0x7) << 12)
	/* 53.33% of the max tx rate */
		#define HWRM_FUNC_VF_BW_CFG_INPUT_VFN_RATE_PCT_53_33  (UINT32_C(0x8) << 12)
	/* 60% of the max tx rate */
		#define HWRM_FUNC_VF_BW_CFG_INPUT_VFN_RATE_PCT_60	(UINT32_C(0x9) << 12)
	/* 66.66% of the max tx rate */
		#define HWRM_FUNC_VF_BW_CFG_INPUT_VFN_RATE_PCT_66_66  (UINT32_C(0xa) << 12)
	/* 53.33% of the max tx rate */
		#define HWRM_FUNC_VF_BW_CFG_INPUT_VFN_RATE_PCT_73_33  (UINT32_C(0xb) << 12)
	/* 80% of the max tx rate */
		#define HWRM_FUNC_VF_BW_CFG_INPUT_VFN_RATE_PCT_80	(UINT32_C(0xc) << 12)
	/* 86.66% of the max tx rate */
		#define HWRM_FUNC_VF_BW_CFG_INPUT_VFN_RATE_PCT_86_66  (UINT32_C(0xd) << 12)
	/* 93.33% of the max tx rate */
		#define HWRM_FUNC_VF_BW_CFG_INPUT_VFN_RATE_PCT_93_33  (UINT32_C(0xe) << 12)
	/* 100% of the max tx rate */
		#define HWRM_FUNC_VF_BW_CFG_INPUT_VFN_RATE_PCT_100	(UINT32_C(0xf) << 12)
		#define HWRM_FUNC_VF_BW_CFG_INPUT_VFN_RATE_LAST	HWRM_FUNC_VF_BW_CFG_INPUT_VFN_RATE_PCT_100
} hwrm_func_vf_bw_cfg_input_t, *phwrm_func_vf_bw_cfg_input_t;

/* hwrm_func_vf_bw_cfg_output (size:128b/16B) */

typedef struct hwrm_func_vf_bw_cfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_func_vf_bw_cfg_output_t, *phwrm_func_vf_bw_cfg_output_t;

/************************
 * hwrm_func_vf_bw_qcfg *
 ************************/


/* hwrm_func_vf_bw_qcfg_input (size:960b/120B) */

typedef struct hwrm_func_vf_bw_qcfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * The number of VF functions that are being queried.
	 * The inline response space allows the host to query up to 50 VFs'
	 * rate scale percentage
	 */
	uint16_t	num_vfs;
	uint16_t	unused[3];
	/* These 16-bit fields contain the VF fid */
	uint16_t	vfn[48];
	/* The physical VF id of interest */
	#define HWRM_FUNC_VF_BW_QCFG_INPUT_VFN_VFID_MASK UINT32_C(0xfff)
	#define HWRM_FUNC_VF_BW_QCFG_INPUT_VFN_VFID_SFT 0
} hwrm_func_vf_bw_qcfg_input_t, *phwrm_func_vf_bw_qcfg_input_t;

/* hwrm_func_vf_bw_qcfg_output (size:960b/120B) */

typedef struct hwrm_func_vf_bw_qcfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * The number of VF functions that are being queried.
	 * The inline response space allows the host to query up to 50 VFs' rate
	 * scale percentage
	 */
	uint16_t	num_vfs;
	uint16_t	unused[3];
	/* These 16-bit fields contain the VF fid and the rate scale percentage. */
	uint16_t	vfn[48];
	/* The physical VF id the adjustment will be made to. */
	#define HWRM_FUNC_VF_BW_QCFG_OUTPUT_VFN_VFID_MASK	UINT32_C(0xfff)
	#define HWRM_FUNC_VF_BW_QCFG_OUTPUT_VFN_VFID_SFT	0
	/*
	 * This field configures the rate scale percentage of the VF as specified
	 * by the physical VF id.
	 */
	#define HWRM_FUNC_VF_BW_QCFG_OUTPUT_VFN_RATE_MASK	UINT32_C(0xf000)
	#define HWRM_FUNC_VF_BW_QCFG_OUTPUT_VFN_RATE_SFT	12
	/* 0% of the max tx rate */
		#define HWRM_FUNC_VF_BW_QCFG_OUTPUT_VFN_RATE_PCT_0	(UINT32_C(0x0) << 12)
	/* 6.66% of the max tx rate */
		#define HWRM_FUNC_VF_BW_QCFG_OUTPUT_VFN_RATE_PCT_6_66   (UINT32_C(0x1) << 12)
	/* 13.33% of the max tx rate */
		#define HWRM_FUNC_VF_BW_QCFG_OUTPUT_VFN_RATE_PCT_13_33  (UINT32_C(0x2) << 12)
	/* 20% of the max tx rate */
		#define HWRM_FUNC_VF_BW_QCFG_OUTPUT_VFN_RATE_PCT_20	(UINT32_C(0x3) << 12)
	/* 26.66% of the max tx rate */
		#define HWRM_FUNC_VF_BW_QCFG_OUTPUT_VFN_RATE_PCT_26_66  (UINT32_C(0x4) << 12)
	/* 33% of the max tx rate */
		#define HWRM_FUNC_VF_BW_QCFG_OUTPUT_VFN_RATE_PCT_33_33  (UINT32_C(0x5) << 12)
	/* 40% of the max tx rate */
		#define HWRM_FUNC_VF_BW_QCFG_OUTPUT_VFN_RATE_PCT_40	(UINT32_C(0x6) << 12)
	/* 46.66% of the max tx rate */
		#define HWRM_FUNC_VF_BW_QCFG_OUTPUT_VFN_RATE_PCT_46_66  (UINT32_C(0x7) << 12)
	/* 53.33% of the max tx rate */
		#define HWRM_FUNC_VF_BW_QCFG_OUTPUT_VFN_RATE_PCT_53_33  (UINT32_C(0x8) << 12)
	/* 60% of the max tx rate */
		#define HWRM_FUNC_VF_BW_QCFG_OUTPUT_VFN_RATE_PCT_60	(UINT32_C(0x9) << 12)
	/* 66.66% of the max tx rate */
		#define HWRM_FUNC_VF_BW_QCFG_OUTPUT_VFN_RATE_PCT_66_66  (UINT32_C(0xa) << 12)
	/* 53.33% of the max tx rate */
		#define HWRM_FUNC_VF_BW_QCFG_OUTPUT_VFN_RATE_PCT_73_33  (UINT32_C(0xb) << 12)
	/* 80% of the max tx rate */
		#define HWRM_FUNC_VF_BW_QCFG_OUTPUT_VFN_RATE_PCT_80	(UINT32_C(0xc) << 12)
	/* 86.66% of the max tx rate */
		#define HWRM_FUNC_VF_BW_QCFG_OUTPUT_VFN_RATE_PCT_86_66  (UINT32_C(0xd) << 12)
	/* 93.33% of the max tx rate */
		#define HWRM_FUNC_VF_BW_QCFG_OUTPUT_VFN_RATE_PCT_93_33  (UINT32_C(0xe) << 12)
	/* 100% of the max tx rate */
		#define HWRM_FUNC_VF_BW_QCFG_OUTPUT_VFN_RATE_PCT_100	(UINT32_C(0xf) << 12)
		#define HWRM_FUNC_VF_BW_QCFG_OUTPUT_VFN_RATE_LAST	HWRM_FUNC_VF_BW_QCFG_OUTPUT_VFN_RATE_PCT_100
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_func_vf_bw_qcfg_output_t, *phwrm_func_vf_bw_qcfg_output_t;

/***************************
 * hwrm_func_drv_if_change *
 ***************************/


/* hwrm_func_drv_if_change_input (size:192b/24B) */

typedef struct hwrm_func_drv_if_change_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	flags;
	/*
	 * When this bit is '1', the function driver is indicating
	 * that the IF state is changing to UP state.  The call should
	 * be made at the beginning of the driver's open call before
	 * resources are allocated.  After making the call, the driver
	 * should check the response to see if any resources may have
	 * changed (see the response below).  If the driver fails
	 * the open call, the driver should make this call again with
	 * this bit cleared to indicate that the IF state is not UP.
	 * During the driver's close call when the IF state is changing
	 * to DOWN, the driver should make this call with the bit cleared
	 * after all resources have been freed.
	 */
	#define HWRM_FUNC_DRV_IF_CHANGE_INPUT_FLAGS_UP	UINT32_C(0x1)
	uint32_t	unused;
} hwrm_func_drv_if_change_input_t, *phwrm_func_drv_if_change_input_t;

/* hwrm_func_drv_if_change_output (size:128b/16B) */

typedef struct hwrm_func_drv_if_change_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint32_t	flags;
	/*
	 * When this bit is '1', it indicates that the resources reserved
	 * for this function may have changed.  The driver should check
	 * resource capabilities and reserve resources again before
	 * allocating resources.
	 */
	#define HWRM_FUNC_DRV_IF_CHANGE_OUTPUT_FLAGS_RESC_CHANGE	UINT32_C(0x1)
	/*
	 * When this bit is '1', it indicates that the firmware got changed / reset.
	 * The driver should do complete re-initialization when that bit is set.
	 */
	#define HWRM_FUNC_DRV_IF_CHANGE_OUTPUT_FLAGS_HOT_FW_RESET_DONE	UINT32_C(0x2)
	uint8_t	unused_0[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_func_drv_if_change_output_t, *phwrm_func_drv_if_change_output_t;

/*******************************
 * hwrm_func_host_pf_ids_query *
 *******************************/


/* hwrm_func_host_pf_ids_query_input (size:192b/24B) */

typedef struct hwrm_func_host_pf_ids_query_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint8_t	host;
	/*
	 * # If this bit is set to '1', the query will contain PF(s)
	 * belongs to SOC host.
	 */
	#define HWRM_FUNC_HOST_PF_IDS_QUERY_INPUT_HOST_SOC	UINT32_C(0x1)
	/*
	 * # If this bit is set to '1', the query will contain PF(s)
	 * belongs to EP0 host.
	 */
	#define HWRM_FUNC_HOST_PF_IDS_QUERY_INPUT_HOST_EP_0	UINT32_C(0x2)
	/*
	 * # If this bit is set to '1', the query will contain PF(s)
	 * belongs to EP1 host.
	 */
	#define HWRM_FUNC_HOST_PF_IDS_QUERY_INPUT_HOST_EP_1	UINT32_C(0x4)
	/*
	 * # If this bit is set to '1', the query will contain PF(s)
	 * belongs to EP2 host.
	 */
	#define HWRM_FUNC_HOST_PF_IDS_QUERY_INPUT_HOST_EP_2	UINT32_C(0x8)
	/*
	 * # If this bit is set to '1', the query will contain PF(s)
	 * belongs to EP3 host.
	 */
	#define HWRM_FUNC_HOST_PF_IDS_QUERY_INPUT_HOST_EP_3	UINT32_C(0x10)
	/*
	 * This provides a filter of what PF(s) will be returned in the
	 * query..
	 */
	uint8_t	filter;
	/*
	 * all available PF(s) belong to the host(s) (defined in the
	 * host field). This includes the hidden PFs.
	 */
	#define HWRM_FUNC_HOST_PF_IDS_QUERY_INPUT_FILTER_ALL  UINT32_C(0x0)
	/*
	 * all available PF(s) belong to the host(s) (defined in the
	 * host field) that is available for L2 traffic.
	 */
	#define HWRM_FUNC_HOST_PF_IDS_QUERY_INPUT_FILTER_L2   UINT32_C(0x1)
	/*
	 * all available PF(s) belong to the host(s) (defined in the
	 * host field) that is available for ROCE traffic.
	 */
	#define HWRM_FUNC_HOST_PF_IDS_QUERY_INPUT_FILTER_ROCE UINT32_C(0x2)
	#define HWRM_FUNC_HOST_PF_IDS_QUERY_INPUT_FILTER_LAST HWRM_FUNC_HOST_PF_IDS_QUERY_INPUT_FILTER_ROCE
	uint8_t	unused_1[6];
} hwrm_func_host_pf_ids_query_input_t, *phwrm_func_host_pf_ids_query_input_t;

/* hwrm_func_host_pf_ids_query_output (size:128b/16B) */

typedef struct hwrm_func_host_pf_ids_query_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* This provides the first PF ID of the device. */
	uint16_t	first_pf_id;
	uint16_t	pf_ordinal_mask;
	/*
	 * When this bit is '1', it indicates first PF belongs to one of
	 * the hosts defined in the input request.
	 */
	#define HWRM_FUNC_HOST_PF_IDS_QUERY_OUTPUT_PF_ORDINAL_MASK_FUNC_0	UINT32_C(0x1)
	/*
	 * When this bit is '1', it indicates 2nd PF belongs to one of the
	 * hosts defined in the input request.
	 */
	#define HWRM_FUNC_HOST_PF_IDS_QUERY_OUTPUT_PF_ORDINAL_MASK_FUNC_1	UINT32_C(0x2)
	/*
	 * When this bit is '1', it indicates 3rd PF belongs to one of the
	 * hosts defined in the input request.
	 */
	#define HWRM_FUNC_HOST_PF_IDS_QUERY_OUTPUT_PF_ORDINAL_MASK_FUNC_2	UINT32_C(0x4)
	/*
	 * When this bit is '1', it indicates 4th PF belongs to one of the
	 * hosts defined in the input request.
	 */
	#define HWRM_FUNC_HOST_PF_IDS_QUERY_OUTPUT_PF_ORDINAL_MASK_FUNC_3	UINT32_C(0x8)
	/*
	 * When this bit is '1', it indicates 5th PF belongs to one of the
	 * hosts defined in the input request.
	 */
	#define HWRM_FUNC_HOST_PF_IDS_QUERY_OUTPUT_PF_ORDINAL_MASK_FUNC_4	UINT32_C(0x10)
	/*
	 * When this bit is '1', it indicates 6th PF belongs to one of the
	 * hosts defined in the input request.
	 */
	#define HWRM_FUNC_HOST_PF_IDS_QUERY_OUTPUT_PF_ORDINAL_MASK_FUNC_5	UINT32_C(0x20)
	/*
	 * When this bit is '1', it indicates 7th PF belongs to one of the
	 * hosts defined in the input request.
	 */
	#define HWRM_FUNC_HOST_PF_IDS_QUERY_OUTPUT_PF_ORDINAL_MASK_FUNC_6	UINT32_C(0x40)
	/*
	 * When this bit is '1', it indicates 8th PF belongs to one of the
	 * hosts defined in the input request.
	 */
	#define HWRM_FUNC_HOST_PF_IDS_QUERY_OUTPUT_PF_ORDINAL_MASK_FUNC_7	UINT32_C(0x80)
	/*
	 * When this bit is '1', it indicates 9th PF belongs to one of the
	 * hosts defined in the input request.
	 */
	#define HWRM_FUNC_HOST_PF_IDS_QUERY_OUTPUT_PF_ORDINAL_MASK_FUNC_8	UINT32_C(0x100)
	/*
	 * When this bit is '1', it indicates 10th PF belongs to one of the
	 * hosts defined in the input request.
	 */
	#define HWRM_FUNC_HOST_PF_IDS_QUERY_OUTPUT_PF_ORDINAL_MASK_FUNC_9	UINT32_C(0x200)
	/*
	 * When this bit is '1', it indicates 11th PF belongs to one of the
	 * hosts defined in the input request.
	 */
	#define HWRM_FUNC_HOST_PF_IDS_QUERY_OUTPUT_PF_ORDINAL_MASK_FUNC_10	UINT32_C(0x400)
	/*
	 * When this bit is '1', it indicates 12th PF belongs to one of the
	 * hosts defined in the input request.
	 */
	#define HWRM_FUNC_HOST_PF_IDS_QUERY_OUTPUT_PF_ORDINAL_MASK_FUNC_11	UINT32_C(0x800)
	/*
	 * When this bit is '1', it indicates 13th PF belongs to one of the
	 * hosts defined in the input request.
	 */
	#define HWRM_FUNC_HOST_PF_IDS_QUERY_OUTPUT_PF_ORDINAL_MASK_FUNC_12	UINT32_C(0x1000)
	/*
	 * When this bit is '1', it indicates 14th PF belongs to one of the
	 * hosts defined in the input request.
	 */
	#define HWRM_FUNC_HOST_PF_IDS_QUERY_OUTPUT_PF_ORDINAL_MASK_FUNC_13	UINT32_C(0x2000)
	/*
	 * When this bit is '1', it indicates 15th PF belongs to one of the
	 * hosts defined in the input request.
	 */
	#define HWRM_FUNC_HOST_PF_IDS_QUERY_OUTPUT_PF_ORDINAL_MASK_FUNC_14	UINT32_C(0x4000)
	/*
	 * When this bit is '1', it indicates 16th PF belongs to one of the
	 * hosts defined in the input request.
	 */
	#define HWRM_FUNC_HOST_PF_IDS_QUERY_OUTPUT_PF_ORDINAL_MASK_FUNC_15	UINT32_C(0x8000)
	uint8_t	unused_1[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_func_host_pf_ids_query_output_t, *phwrm_func_host_pf_ids_query_output_t;

/*********************
 * hwrm_func_spd_cfg *
 *********************/


/* hwrm_func_spd_cfg_input (size:384b/48B) */

typedef struct hwrm_func_spd_cfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	flags;
	/* Set this bit is '1' to enable the SPD datapath forwarding. */
	#define HWRM_FUNC_SPD_CFG_INPUT_FLAGS_FWD_ENABLE	UINT32_C(0x1)
	/* Set this bit is '1' to disable the SPD datapath forwarding. */
	#define HWRM_FUNC_SPD_CFG_INPUT_FLAGS_FWD_DISABLE	UINT32_C(0x2)
	/*
	 * Set this bit is '1' to enable the SPD datapath checksum
	 * feature.
	 */
	#define HWRM_FUNC_SPD_CFG_INPUT_FLAGS_CSUM_ENABLE	UINT32_C(0x4)
	/*
	 * Set this bit is '1' to disable the SPD datapath checksum
	 * feature.
	 */
	#define HWRM_FUNC_SPD_CFG_INPUT_FLAGS_CSUM_DISABLE	UINT32_C(0x8)
	/*
	 * Set this bit is '1' to enable the SPD datapath debug
	 * feature.
	 */
	#define HWRM_FUNC_SPD_CFG_INPUT_FLAGS_DBG_ENABLE	UINT32_C(0x10)
	/*
	 * Set this bit is '1' to disable the SPD datapath debug
	 * feature.
	 */
	#define HWRM_FUNC_SPD_CFG_INPUT_FLAGS_DBG_DISABLE	UINT32_C(0x20)
	uint32_t	enables;
	/*
	 * This bit must be '1' for the ethertype field to be
	 * configured.
	 */
	#define HWRM_FUNC_SPD_CFG_INPUT_ENABLES_ETHERTYPE		UINT32_C(0x1)
	/*
	 * This bit must be '1' for the hash_mode_flags field to be
	 * configured.
	 */
	#define HWRM_FUNC_SPD_CFG_INPUT_ENABLES_HASH_MODE_FLAGS	UINT32_C(0x2)
	/*
	 * This bit must be '1' for the hash_type field to be
	 * configured.
	 */
	#define HWRM_FUNC_SPD_CFG_INPUT_ENABLES_HASH_TYPE		UINT32_C(0x4)
	/*
	 * This bit must be '1' for the ring_tbl_addr field to be
	 * configured.
	 */
	#define HWRM_FUNC_SPD_CFG_INPUT_ENABLES_RING_TBL_ADDR	UINT32_C(0x8)
	/*
	 * This bit must be '1' for the hash_key_tbl_addr field to be
	 * configured.
	 */
	#define HWRM_FUNC_SPD_CFG_INPUT_ENABLES_HASH_KEY_TBL_ADDR	UINT32_C(0x10)
	/*
	 * Ethertype value used in the encapsulated SPD packet header.
	 * The user must chooose a value that is not conflicting with
	 * publicly defined ethertype values. By default, the ethertype
	 * value of 0xffff is used if there is no user specified value.
	 */
	uint16_t	ethertype;
	/* Flags to specify different RSS hash modes. */
	uint8_t	hash_mode_flags;
	/*
	 * When this bit is '1', it indicates using current RSS
	 * hash mode setting configured in the device.
	 */
	#define HWRM_FUNC_SPD_CFG_INPUT_HASH_MODE_FLAGS_DEFAULT	UINT32_C(0x1)
	/*
	 * When this bit is '1', it indicates requesting support of
	 * RSS hashing over innermost 4 tuples {l3.src, l3.dest,
	 * l4.src, l4.dest} for tunnel packets. For none-tunnel
	 * packets, the RSS hash is computed over the normal
	 * src/dest l3 and src/dest l4 headers.
	 */
	#define HWRM_FUNC_SPD_CFG_INPUT_HASH_MODE_FLAGS_INNERMOST_4	UINT32_C(0x2)
	/*
	 * When this bit is '1', it indicates requesting support of
	 * RSS hashing over innermost 2 tuples {l3.src, l3.dest} for
	 * tunnel packets. For none-tunnel packets, the RSS hash is
	 * computed over the normal src/dest l3 headers.
	 */
	#define HWRM_FUNC_SPD_CFG_INPUT_HASH_MODE_FLAGS_INNERMOST_2	UINT32_C(0x4)
	/*
	 * When this bit is '1', it indicates requesting support of
	 * RSS hashing over outermost 4 tuples {t_l3.src, t_l3.dest,
	 * t_l4.src, t_l4.dest} for tunnel packets. For none-tunnel
	 * packets, the RSS hash is computed over the normal
	 * src/dest l3 and src/dest l4 headers.
	 */
	#define HWRM_FUNC_SPD_CFG_INPUT_HASH_MODE_FLAGS_OUTERMOST_4	UINT32_C(0x8)
	/*
	 * When this bit is '1', it indicates requesting support of
	 * RSS hashing over outermost 2 tuples {t_l3.src, t_l3.dest} for
	 * tunnel packets. For none-tunnel packets, the RSS hash is
	 * computed over the normal src/dest l3 headers.
	 */
	#define HWRM_FUNC_SPD_CFG_INPUT_HASH_MODE_FLAGS_OUTERMOST_2	UINT32_C(0x10)
	uint8_t	unused_1;
	uint32_t	hash_type;
	/*
	 * When this bit is '1', the RSS hash shall be computed
	 * over source and destination IPv4 addresses of IPv4
	 * packets.
	 */
	#define HWRM_FUNC_SPD_CFG_INPUT_HASH_TYPE_IPV4	UINT32_C(0x1)
	/*
	 * When this bit is '1', the RSS hash shall be computed
	 * over source/destination IPv4 addresses and
	 * source/destination ports of TCP/IPv4 packets.
	 */
	#define HWRM_FUNC_SPD_CFG_INPUT_HASH_TYPE_TCP_IPV4	UINT32_C(0x2)
	/*
	 * When this bit is '1', the RSS hash shall be computed
	 * over source/destination IPv4 addresses and
	 * source/destination ports of UDP/IPv4 packets.
	 */
	#define HWRM_FUNC_SPD_CFG_INPUT_HASH_TYPE_UDP_IPV4	UINT32_C(0x4)
	/*
	 * When this bit is '1', the RSS hash shall be computed
	 * over source and destination IPv4 addresses of IPv6
	 * packets.
	 */
	#define HWRM_FUNC_SPD_CFG_INPUT_HASH_TYPE_IPV6	UINT32_C(0x8)
	/*
	 * When this bit is '1', the RSS hash shall be computed
	 * over source/destination IPv6 addresses and
	 * source/destination ports of TCP/IPv6 packets.
	 */
	#define HWRM_FUNC_SPD_CFG_INPUT_HASH_TYPE_TCP_IPV6	UINT32_C(0x10)
	/*
	 * When this bit is '1', the RSS hash shall be computed
	 * over source/destination IPv6 addresses and
	 * source/destination ports of UDP/IPv6 packets.
	 */
	#define HWRM_FUNC_SPD_CFG_INPUT_HASH_TYPE_UDP_IPV6	UINT32_C(0x20)
	/* This is the address for rss ring group table */
	uint64_t	ring_grp_tbl_addr;
	/* This is the address for rss hash key table */
	uint64_t	hash_key_tbl_addr;
} hwrm_func_spd_cfg_input_t, *phwrm_func_spd_cfg_input_t;

/* hwrm_func_spd_cfg_output (size:128b/16B) */

typedef struct hwrm_func_spd_cfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_func_spd_cfg_output_t, *phwrm_func_spd_cfg_output_t;

/**********************
 * hwrm_func_spd_qcfg *
 **********************/


/* hwrm_func_spd_qcfg_input (size:128b/16B) */

typedef struct hwrm_func_spd_qcfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
} hwrm_func_spd_qcfg_input_t, *phwrm_func_spd_qcfg_input_t;

/* hwrm_func_spd_qcfg_output (size:512b/64B) */

typedef struct hwrm_func_spd_qcfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint32_t	flags;
	/*
	 * The SPD datapath forwarding is currently enabled when this
	 * flag is set to '1'.
	 */
	#define HWRM_FUNC_SPD_QCFG_OUTPUT_FLAGS_FWD_ENABLED	UINT32_C(0x1)
	/*
	 * The SPD datapath checksum feature is currently enabled when
	 * this flag is set to '1'.
	 */
	#define HWRM_FUNC_SPD_QCFG_OUTPUT_FLAGS_CSUM_ENABLED	UINT32_C(0x2)
	/*
	 * The SPD datapath debug feature is currently enabled when
	 * this flag is set to '1'.
	 */
	#define HWRM_FUNC_SPD_QCFG_OUTPUT_FLAGS_DBG_ENABLED	UINT32_C(0x4)
	uint32_t	hash_type;
	/*
	 * When this bit is '1', the RSS hash shall be computed
	 * over source and destination IPv4 addresses of IPv4
	 * packets.
	 */
	#define HWRM_FUNC_SPD_QCFG_OUTPUT_HASH_TYPE_IPV4	UINT32_C(0x1)
	/*
	 * When this bit is '1', the RSS hash shall be computed
	 * over source/destination IPv4 addresses and
	 * source/destination ports of TCP/IPv4 packets.
	 */
	#define HWRM_FUNC_SPD_QCFG_OUTPUT_HASH_TYPE_TCP_IPV4	UINT32_C(0x2)
	/*
	 * When this bit is '1', the RSS hash shall be computed
	 * over source/destination IPv4 addresses and
	 * source/destination ports of UDP/IPv4 packets.
	 */
	#define HWRM_FUNC_SPD_QCFG_OUTPUT_HASH_TYPE_UDP_IPV4	UINT32_C(0x4)
	/*
	 * When this bit is '1', the RSS hash shall be computed
	 * over source and destination IPv4 addresses of IPv6
	 * packets.
	 */
	#define HWRM_FUNC_SPD_QCFG_OUTPUT_HASH_TYPE_IPV6	UINT32_C(0x8)
	/*
	 * When this bit is '1', the RSS hash shall be computed
	 * over source/destination IPv6 addresses and
	 * source/destination ports of TCP/IPv6 packets.
	 */
	#define HWRM_FUNC_SPD_QCFG_OUTPUT_HASH_TYPE_TCP_IPV6	UINT32_C(0x10)
	/*
	 * When this bit is '1', the RSS hash shall be computed
	 * over source/destination IPv6 addresses and
	 * source/destination ports of UDP/IPv6 packets.
	 */
	#define HWRM_FUNC_SPD_QCFG_OUTPUT_HASH_TYPE_UDP_IPV6	UINT32_C(0x20)
	/* This is the value of rss hash key */
	uint32_t	hash_key[10];
	/* Flags to specify different RSS hash modes. */
	uint8_t	hash_mode_flags;
	/*
	 * When this bit is '1', it indicates using current RSS
	 * hash mode setting configured in the device.
	 */
	#define HWRM_FUNC_SPD_QCFG_OUTPUT_HASH_MODE_FLAGS_DEFAULT	UINT32_C(0x1)
	/*
	 * When this bit is '1', it indicates requesting support of
	 * RSS hashing over innermost 4 tuples {l3.src, l3.dest,
	 * l4.src, l4.dest} for tunnel packets. For none-tunnel
	 * packets, the RSS hash is computed over the normal
	 * src/dest l3 and src/dest l4 headers.
	 */
	#define HWRM_FUNC_SPD_QCFG_OUTPUT_HASH_MODE_FLAGS_INNERMOST_4	UINT32_C(0x2)
	/*
	 * When this bit is '1', it indicates requesting support of
	 * RSS hashing over innermost 2 tuples {l3.src, l3.dest} for
	 * tunnel packets. For none-tunnel packets, the RSS hash is
	 * computed over the normal src/dest l3 headers.
	 */
	#define HWRM_FUNC_SPD_QCFG_OUTPUT_HASH_MODE_FLAGS_INNERMOST_2	UINT32_C(0x4)
	/*
	 * When this bit is '1', it indicates requesting support of
	 * RSS hashing over outermost 4 tuples {t_l3.src, t_l3.dest,
	 * t_l4.src, t_l4.dest} for tunnel packets. For none-tunnel
	 * packets, the RSS hash is computed over the normal
	 * src/dest l3 and src/dest l4 headers.
	 */
	#define HWRM_FUNC_SPD_QCFG_OUTPUT_HASH_MODE_FLAGS_OUTERMOST_4	UINT32_C(0x8)
	/*
	 * When this bit is '1', it indicates requesting support of
	 * RSS hashing over outermost 2 tuples {t_l3.src, t_l3.dest} for
	 * tunnel packets. For none-tunnel packets, the RSS hash is
	 * computed over the normal src/dest l3 headers.
	 */
	#define HWRM_FUNC_SPD_QCFG_OUTPUT_HASH_MODE_FLAGS_OUTERMOST_2	UINT32_C(0x10)
	uint8_t	unused_1;
	/*
	 * Ethertype value used in the encapsulated SPD packet header.
	 * The user must chooose a value that is not conflicting with
	 * publicly defined ethertype values. By default, the ethertype
	 * value of 0xffff is used if there is no user specified value.
	 */
	uint16_t	ethertype;
	uint8_t	unused_2[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_func_spd_qcfg_output_t, *phwrm_func_spd_qcfg_output_t;

/*********************
 * hwrm_port_phy_cfg *
 *********************/


/* hwrm_port_phy_cfg_input (size:448b/56B) */

typedef struct hwrm_port_phy_cfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	flags;
	/*
	 * When this bit is set to '1', the PHY for the port shall
	 * be reset.
	 *
	 * # If this bit is set to 1, then the HWRM shall reset the
	 * PHY after applying PHY configuration changes specified
	 * in this command.
	 * # In order to guarantee that PHY configuration changes
	 * specified in this command take effect, the HWRM
	 * client should set this flag to 1.
	 * # If this bit is not set to 1, then the HWRM may reset
	 * the PHY depending on the current PHY configuration and
	 * settings specified in this command.
	 */
	#define HWRM_PORT_PHY_CFG_INPUT_FLAGS_RESET_PHY		UINT32_C(0x1)
	/* deprecated bit.  Do not use!!! */
	#define HWRM_PORT_PHY_CFG_INPUT_FLAGS_DEPRECATED		UINT32_C(0x2)
	/*
	 * When this bit is set to '1', and the force_pam4_link_speed
	 * bit in the 'enables' field is '0', the link shall be forced
	 * to the force_link_speed value.
	 *
	 * When this bit is set to '1', and the force_pam4_link_speed
	 * bit in the 'enables' field is '1', the link shall be forced
	 * to the force_pam4_link_speed value.
	 *
	 * When this bit is set to '1', the HWRM client should
	 * not enable any of the auto negotiation related
	 * fields represented by auto_XXX fields in this command.
	 * When this bit is set to '1' and the HWRM client has
	 * enabled a auto_XXX field in this command, then the
	 * HWRM shall ignore the enabled auto_XXX field.
	 *
	 * When this bit is set to zero, the link
	 * shall be allowed to autoneg.
	 */
	#define HWRM_PORT_PHY_CFG_INPUT_FLAGS_FORCE			UINT32_C(0x4)
	/*
	 * When this bit is set to '1', the auto-negotiation process
	 * shall be restarted on the link.
	 */
	#define HWRM_PORT_PHY_CFG_INPUT_FLAGS_RESTART_AUTONEG		UINT32_C(0x8)
	/*
	 * When this bit is set to '1', Energy Efficient Ethernet
	 * (EEE) is requested to be enabled on this link.
	 * If EEE is not supported on this port, then this flag
	 * shall be ignored by the HWRM.
	 */
	#define HWRM_PORT_PHY_CFG_INPUT_FLAGS_EEE_ENABLE		UINT32_C(0x10)
	/*
	 * When this bit is set to '1', Energy Efficient Ethernet
	 * (EEE) is requested to be disabled on this link.
	 * If EEE is not supported on this port, then this flag
	 * shall be ignored by the HWRM.
	 */
	#define HWRM_PORT_PHY_CFG_INPUT_FLAGS_EEE_DISABLE		UINT32_C(0x20)
	/*
	 * When this bit is set to '1' and EEE is enabled on this
	 * link, then TX LPI is requested to be enabled on the link.
	 * If EEE is not supported on this port, then this flag
	 * shall be ignored by the HWRM.
	 * If EEE is disabled on this port, then this flag shall be
	 * ignored by the HWRM.
	 */
	#define HWRM_PORT_PHY_CFG_INPUT_FLAGS_EEE_TX_LPI_ENABLE	UINT32_C(0x40)
	/*
	 * When this bit is set to '1' and EEE is enabled on this
	 * link, then TX LPI is requested to be disabled on the link.
	 * If EEE is not supported on this port, then this flag
	 * shall be ignored by the HWRM.
	 * If EEE is disabled on this port, then this flag shall be
	 * ignored by the HWRM.
	 */
	#define HWRM_PORT_PHY_CFG_INPUT_FLAGS_EEE_TX_LPI_DISABLE	UINT32_C(0x80)
	/*
	 * When set to 1, then the HWRM shall enable FEC autonegotitation
	 * on this port if supported.  When enabled, at least one of the
	 * FEC modes must be advertised by enabling the fec_clause_74_enable,
	 * fec_clause_91_enable, fec_rs544_1xn_enable, fec_rs544_ieee_enable,
	 * fec_rs272_1xn_enable, or fec_rs272_ieee_enable flag.  If none
	 * of the FEC mode is currently enabled, the HWRM shall choose
	 * a default advertisement setting.
	 * The default advertisement setting can be queried by calling
	 * hwrm_port_phy_qcfg.  Note that the link speed must be
	 * in autonegotiation mode for FEC autonegotiation to take effect.
	 * When set to 0, then this flag shall be ignored.
	 * If FEC autonegotiation is not supported, then the HWRM shall ignore this
	 * flag.
	 */
	#define HWRM_PORT_PHY_CFG_INPUT_FLAGS_FEC_AUTONEG_ENABLE	UINT32_C(0x100)
	/*
	 * When set to 1, then the HWRM shall disable FEC autonegotiation
	 * on this port and use forced FEC mode.  In forced FEC mode, one
	 * or more FEC forced settings under the same clause can be set.
	 * When set to 0, then this flag shall be ignored.
	 * If FEC autonegotiation is not supported, then the HWRM shall ignore this
	 * flag.
	 */
	#define HWRM_PORT_PHY_CFG_INPUT_FLAGS_FEC_AUTONEG_DISABLE	UINT32_C(0x200)
	/*
	 * When set to 1, then the HWRM shall enable FEC CLAUSE 74 (Fire Code)
	 * on this port if supported, by advertising FEC CLAUSE 74 if
	 * FEC autonegotiation is enabled or force enabled otherwise.
	 * When set to 0, then this flag shall be ignored.
	 * If FEC CLAUSE 74 is not supported, then the HWRM shall ignore this
	 * flag.
	 */
	#define HWRM_PORT_PHY_CFG_INPUT_FLAGS_FEC_CLAUSE74_ENABLE	UINT32_C(0x400)
	/*
	 * When set to 1, then the HWRM shall disable FEC CLAUSE 74 (Fire Code)
	 * on this port if supported, by not advertising FEC CLAUSE 74 if
	 * FEC autonegotiation is enabled or force disabled otherwise.
	 * When set to 0, then this flag shall be ignored.
	 * If FEC CLAUSE 74 is not supported, then the HWRM shall ignore this
	 * flag.
	 */
	#define HWRM_PORT_PHY_CFG_INPUT_FLAGS_FEC_CLAUSE74_DISABLE	UINT32_C(0x800)
	/*
	 * When set to 1, then the HWRM shall enable FEC CLAUSE 91
	 * (Reed Solomon RS(528,514) for NRZ) on this port if supported,
	 * by advertising FEC RS(528,514) if FEC autonegotiation is enabled
	 * or force enabled otherwise.  In forced FEC mode, this flag
	 * will only take effect if the speed is NRZ.  Additional
	 * RS544 or RS272 flags (also under clause 91) may be set for PAM4
	 * in forced FEC mode.
	 * When set to 0, then this flag shall be ignored.
	 * If FEC RS(528,514) is not supported, then the HWRM shall ignore
	 * this flag.
	 */
	#define HWRM_PORT_PHY_CFG_INPUT_FLAGS_FEC_CLAUSE91_ENABLE	UINT32_C(0x1000)
	/*
	 * When set to 1, then the HWRM shall disable FEC CLAUSE 91
	 * (Reed Solomon RS(528,514) for NRZ) on this port if supported, by
	 * not advertising RS(528,514) if FEC autonegotiation is enabled or
	 * force disabled otherwise.  When set to 0, then this flag shall be
	 * ignored.  If FEC RS(528,514) is not supported, then the HWRM
	 * shall ignore this flag.
	 */
	#define HWRM_PORT_PHY_CFG_INPUT_FLAGS_FEC_CLAUSE91_DISABLE	UINT32_C(0x2000)
	/*
	 * When this bit is set to '1', the link shall be forced to
	 * be taken down.
	 *
	 * # When this bit is set to '1", all other
	 * command input settings related to the link speed shall
	 * be ignored.
	 * Once the link state is forced down, it can be
	 * explicitly cleared from that state by setting this flag
	 * to '0'.
	 * # If this flag is set to '0', then the link shall be
	 * cleared from forced down state if the link is in forced
	 * down state.
	 * There may be conditions (e.g. out-of-band or sideband
	 * configuration changes for the link) outside the scope
	 * of the HWRM implementation that may clear forced down
	 * link state.
	 */
	#define HWRM_PORT_PHY_CFG_INPUT_FLAGS_FORCE_LINK_DWN		UINT32_C(0x4000)
	/*
	 * When set to 1, then the HWRM shall enable FEC RS544_1XN
	 * on this port if supported, by advertising FEC RS544_1XN if
	 * FEC autonegotiation is enabled or force enabled otherwise.
	 * In forced mode, this flag will only take effect if the speed is
	 * PAM4.  If this flag and fec_rs544_ieee_enable are set, the
	 * HWRM shall choose one of the RS544 modes.
	 * When set to 0, then this flag shall be ignored.
	 * If FEC RS544_1XN is not supported, then the HWRM shall ignore this
	 * flag.
	 */
	#define HWRM_PORT_PHY_CFG_INPUT_FLAGS_FEC_RS544_1XN_ENABLE	UINT32_C(0x8000)
	/*
	 * When set to 1, then the HWRM shall disable FEC RS544_1XN
	 * on this port if supported, by not advertising FEC RS544_1XN if
	 * FEC autonegotiation is enabled or force disabled otherwise.
	 * When set to 0, then this flag shall be ignored.
	 * If FEC RS544_1XN  is not supported, then the HWRM shall ignore this
	 * flag.
	 */
	#define HWRM_PORT_PHY_CFG_INPUT_FLAGS_FEC_RS544_1XN_DISABLE	UINT32_C(0x10000)
	/*
	 * When set to 1, then the HWRM shall enable FEC RS(544,514)
	 * on this port if supported, by advertising FEC RS(544,514) if
	 * FEC autonegotiation is enabled or force enabled otherwise.
	 * In forced mode, this flag will only take effect if the speed is
	 * PAM4.  If this flag and fec_rs544_1xn_enable are set, the
	 * HWRM shall choose one of the RS544 modes.
	 * When set to 0, then this flag shall be ignored.
	 * If FEC RS(544,514) is not supported, then the HWRM shall ignore
	 * this flag.
	 */
	#define HWRM_PORT_PHY_CFG_INPUT_FLAGS_FEC_RS544_IEEE_ENABLE	UINT32_C(0x20000)
	/*
	 * When set to 1, then the HWRM shall disable FEC RS(544,514)
	 * on this port if supported, by not advertising FEC RS(544,514) if
	 * FEC autonegotiation is enabled or force disabled otherwise.
	 * When set to 0, then this flag shall be ignored.
	 * If FEC RS(544,514) is not supported, then the HWRM shall ignore
	 * this flag.
	 */
	#define HWRM_PORT_PHY_CFG_INPUT_FLAGS_FEC_RS544_IEEE_DISABLE	UINT32_C(0x40000)
	/*
	 * When set to 1, then the HWRM shall enable FEC RS272_1XN
	 * on this port if supported, by advertising FEC RS272_1XN if
	 * FEC autonegotiation is enabled or force enabled otherwise.
	 * In forced mode, this flag will only take effect if the speed is
	 * PAM4.  If this flag and fec_rs272_ieee_enable are set, the
	 * HWRM shall choose one of the RS272 modes.  Note that RS272
	 * and RS544 modes cannot be set at the same time in forced FEC mode.
	 * When set to 0, then this flag shall be ignored.
	 * If FEC RS272_1XN is not supported, then the HWRM shall ignore this
	 * flag.
	 */
	#define HWRM_PORT_PHY_CFG_INPUT_FLAGS_FEC_RS272_1XN_ENABLE	UINT32_C(0x80000)
	/*
	 * When set to 1, then the HWRM shall disable FEC RS272_1XN
	 * on this port if supported, by not advertising FEC RS272_1XN if
	 * FEC autonegotiation is enabled or force disabled otherwise.
	 * When set to 0, then this flag shall be ignored.
	 * If FEC RS272_1XN is not supported, then the HWRM shall ignore
	 * this flag.
	 */
	#define HWRM_PORT_PHY_CFG_INPUT_FLAGS_FEC_RS272_1XN_DISABLE	UINT32_C(0x100000)
	/*
	 * When set to 1, then the HWRM shall enable FEC RS(272,257)
	 * on this port if supported, by advertising FEC RS(272,257) if
	 * FEC autonegotiation is enabled or force enabled otherwise.
	 * In forced mode, this flag will only take effect if the speed is
	 * PAM4.  If this flag and fec_rs272_1xn_enable are set, the
	 * HWRM shall choose one of the RS272 modes.  Note that RS272
	 * and RS544 modes cannot be set at the same time in forced FEC mode.
	 * When set to 0, then this flag shall be ignored.
	 * If FEC RS(272,257) is not supported, then the HWRM shall ignore
	 * this flag.
	 */
	#define HWRM_PORT_PHY_CFG_INPUT_FLAGS_FEC_RS272_IEEE_ENABLE	UINT32_C(0x200000)
	/*
	 * When set to 1, then the HWRM shall disable FEC RS(272,257)
	 * on this port if supported, by not advertising FEC RS(272,257) if
	 * FEC autonegotiation is enabled or force disabled otherwise.
	 * When set to 0, then this flag shall be ignored.
	 * If FEC RS(272,257) is not supported, then the HWRM shall ignore
	 * this flag.
	 */
	#define HWRM_PORT_PHY_CFG_INPUT_FLAGS_FEC_RS272_IEEE_DISABLE	UINT32_C(0x400000)
	uint32_t	enables;
	/*
	 * This bit must be '1' for the auto_mode field to be
	 * configured.
	 */
	#define HWRM_PORT_PHY_CFG_INPUT_ENABLES_AUTO_MODE			UINT32_C(0x1)
	/*
	 * This bit must be '1' for the auto_duplex field to be
	 * configured.
	 */
	#define HWRM_PORT_PHY_CFG_INPUT_ENABLES_AUTO_DUPLEX		UINT32_C(0x2)
	/*
	 * This bit must be '1' for the auto_pause field to be
	 * configured.
	 */
	#define HWRM_PORT_PHY_CFG_INPUT_ENABLES_AUTO_PAUSE			UINT32_C(0x4)
	/*
	 * This bit must be '1' for the auto_link_speed field to be
	 * configured.
	 */
	#define HWRM_PORT_PHY_CFG_INPUT_ENABLES_AUTO_LINK_SPEED		UINT32_C(0x8)
	/*
	 * This bit must be '1' for the auto_link_speed_mask field to be
	 * configured.
	 */
	#define HWRM_PORT_PHY_CFG_INPUT_ENABLES_AUTO_LINK_SPEED_MASK	UINT32_C(0x10)
	/*
	 * This bit must be '1' for the wirespeed field to be
	 * configured.
	 */
	#define HWRM_PORT_PHY_CFG_INPUT_ENABLES_WIRESPEED			UINT32_C(0x20)
	/*
	 * This bit must be '1' for the lpbk field to be
	 * configured.
	 */
	#define HWRM_PORT_PHY_CFG_INPUT_ENABLES_LPBK			UINT32_C(0x40)
	/*
	 * This bit must be '1' for the preemphasis field to be
	 * configured.
	 */
	#define HWRM_PORT_PHY_CFG_INPUT_ENABLES_PREEMPHASIS		UINT32_C(0x80)
	/*
	 * This bit must be '1' for the force_pause field to be
	 * configured.
	 */
	#define HWRM_PORT_PHY_CFG_INPUT_ENABLES_FORCE_PAUSE		UINT32_C(0x100)
	/*
	 * This bit must be '1' for the eee_link_speed_mask field to be
	 * configured.
	 */
	#define HWRM_PORT_PHY_CFG_INPUT_ENABLES_EEE_LINK_SPEED_MASK	UINT32_C(0x200)
	/*
	 * This bit must be '1' for the tx_lpi_timer field to be
	 * configured.
	 */
	#define HWRM_PORT_PHY_CFG_INPUT_ENABLES_TX_LPI_TIMER		UINT32_C(0x400)
	/*
	 * This bit must be '1' for the force_pam4_link_speed field to be
	 * configured.
	 */
	#define HWRM_PORT_PHY_CFG_INPUT_ENABLES_FORCE_PAM4_LINK_SPEED	UINT32_C(0x800)
	/*
	 * This bit must be '1' for the auto_pam4_link_speed_mask field to
	 * be configured.
	 */
	#define HWRM_PORT_PHY_CFG_INPUT_ENABLES_AUTO_PAM4_LINK_SPEED_MASK	UINT32_C(0x1000)
	/* Port ID of port that is to be configured. */
	uint16_t	port_id;
	/*
	 * This is the speed that will be used if the force
	 * bit is '1'.  If unsupported speed is selected, an error
	 * will be generated.
	 */
	uint16_t	force_link_speed;
	/* 100Mb link speed */
	#define HWRM_PORT_PHY_CFG_INPUT_FORCE_LINK_SPEED_100MB UINT32_C(0x1)
	/* 1Gb link speed */
	#define HWRM_PORT_PHY_CFG_INPUT_FORCE_LINK_SPEED_1GB   UINT32_C(0xa)
	/* 2Gb link speed */
	#define HWRM_PORT_PHY_CFG_INPUT_FORCE_LINK_SPEED_2GB   UINT32_C(0x14)
	/* 25Gb link speed */
	#define HWRM_PORT_PHY_CFG_INPUT_FORCE_LINK_SPEED_2_5GB UINT32_C(0x19)
	/* 10Gb link speed */
	#define HWRM_PORT_PHY_CFG_INPUT_FORCE_LINK_SPEED_10GB  UINT32_C(0x64)
	/* 20Mb link speed */
	#define HWRM_PORT_PHY_CFG_INPUT_FORCE_LINK_SPEED_20GB  UINT32_C(0xc8)
	/* 25Gb link speed */
	#define HWRM_PORT_PHY_CFG_INPUT_FORCE_LINK_SPEED_25GB  UINT32_C(0xfa)
	/* 40Gb link speed */
	#define HWRM_PORT_PHY_CFG_INPUT_FORCE_LINK_SPEED_40GB  UINT32_C(0x190)
	/* 50Gb link speed */
	#define HWRM_PORT_PHY_CFG_INPUT_FORCE_LINK_SPEED_50GB  UINT32_C(0x1f4)
	/* 100Gb link speed */
	#define HWRM_PORT_PHY_CFG_INPUT_FORCE_LINK_SPEED_100GB UINT32_C(0x3e8)
	/* 10Mb link speed */
	#define HWRM_PORT_PHY_CFG_INPUT_FORCE_LINK_SPEED_10MB  UINT32_C(0xffff)
	#define HWRM_PORT_PHY_CFG_INPUT_FORCE_LINK_SPEED_LAST HWRM_PORT_PHY_CFG_INPUT_FORCE_LINK_SPEED_10MB
	/*
	 * This value is used to identify what autoneg mode is
	 * used when the link speed is not being forced.
	 */
	uint8_t	auto_mode;
	/* Disable autoneg or autoneg disabled. No speeds are selected. */
	#define HWRM_PORT_PHY_CFG_INPUT_AUTO_MODE_NONE	UINT32_C(0x0)
	/* Select all possible speeds for autoneg mode. */
	#define HWRM_PORT_PHY_CFG_INPUT_AUTO_MODE_ALL_SPEEDS   UINT32_C(0x1)
	/*
	 * Select only the auto_link_speed speed for autoneg mode. This mode has
	 * been DEPRECATED. An HWRM client should not use this mode.
	 */
	#define HWRM_PORT_PHY_CFG_INPUT_AUTO_MODE_ONE_SPEED	UINT32_C(0x2)
	/*
	 * Select the auto_link_speed or any speed below that speed for autoneg.
	 * This mode has been DEPRECATED. An HWRM client should not use this mode.
	 */
	#define HWRM_PORT_PHY_CFG_INPUT_AUTO_MODE_ONE_OR_BELOW UINT32_C(0x3)
	/*
	 * Select the speeds based on the corresponding link speed mask values
	 * that are provided. The included speeds are specified in the
	 * auto_link_speed and auto_pam4_link_speed fields.
	 */
	#define HWRM_PORT_PHY_CFG_INPUT_AUTO_MODE_SPEED_MASK   UINT32_C(0x4)
	#define HWRM_PORT_PHY_CFG_INPUT_AUTO_MODE_LAST	HWRM_PORT_PHY_CFG_INPUT_AUTO_MODE_SPEED_MASK
	/*
	 * This is the duplex setting that will be used if the autoneg_mode
	 * is "one_speed" or "one_or_below".
	 */
	uint8_t	auto_duplex;
	/* Half Duplex will be requested. */
	#define HWRM_PORT_PHY_CFG_INPUT_AUTO_DUPLEX_HALF UINT32_C(0x0)
	/* Full duplex will be requested. */
	#define HWRM_PORT_PHY_CFG_INPUT_AUTO_DUPLEX_FULL UINT32_C(0x1)
	/* Both Half and Full dupex will be requested. */
	#define HWRM_PORT_PHY_CFG_INPUT_AUTO_DUPLEX_BOTH UINT32_C(0x2)
	#define HWRM_PORT_PHY_CFG_INPUT_AUTO_DUPLEX_LAST HWRM_PORT_PHY_CFG_INPUT_AUTO_DUPLEX_BOTH
	/*
	 * This value is used to configure the pause that will be
	 * used for autonegotiation.
	 * Add text on the usage of auto_pause and force_pause.
	 */
	uint8_t	auto_pause;
	/*
	 * When this bit is '1', Generation of tx pause messages
	 * has been requested. Disabled otherwise.
	 */
	#define HWRM_PORT_PHY_CFG_INPUT_AUTO_PAUSE_TX		UINT32_C(0x1)
	/*
	 * When this bit is '1', Reception of rx pause messages
	 * has been requested. Disabled otherwise.
	 */
	#define HWRM_PORT_PHY_CFG_INPUT_AUTO_PAUSE_RX		UINT32_C(0x2)
	/*
	 * When set to 1, the advertisement of pause is enabled.
	 *
	 * # When the auto_mode is not set to none and this flag is
	 * set to 1, then the auto_pause bits on this port are being
	 * advertised and autoneg pause results are being interpreted.
	 * # When the auto_mode is not set to none and this
	 * flag is set to 0, the pause is forced as indicated in
	 * force_pause, and also advertised as auto_pause bits, but
	 * the autoneg results are not interpreted since the pause
	 * configuration is being forced.
	 * # When the auto_mode is set to none and this flag is set to
	 * 1, auto_pause bits should be ignored and should be set to 0.
	 */
	#define HWRM_PORT_PHY_CFG_INPUT_AUTO_PAUSE_AUTONEG_PAUSE	UINT32_C(0x4)
	uint8_t	unused_0;
	/*
	 * This is the speed that will be used if the autoneg_mode
	 * is "one_speed" or "one_or_below".  If an unsupported speed
	 * is selected, an error will be generated.
	 */
	uint16_t	auto_link_speed;
	/* 100Mb link speed */
	#define HWRM_PORT_PHY_CFG_INPUT_AUTO_LINK_SPEED_100MB UINT32_C(0x1)
	/* 1Gb link speed */
	#define HWRM_PORT_PHY_CFG_INPUT_AUTO_LINK_SPEED_1GB   UINT32_C(0xa)
	/* 2Gb link speed */
	#define HWRM_PORT_PHY_CFG_INPUT_AUTO_LINK_SPEED_2GB   UINT32_C(0x14)
	/* 25Gb link speed */
	#define HWRM_PORT_PHY_CFG_INPUT_AUTO_LINK_SPEED_2_5GB UINT32_C(0x19)
	/* 10Gb link speed */
	#define HWRM_PORT_PHY_CFG_INPUT_AUTO_LINK_SPEED_10GB  UINT32_C(0x64)
	/* 20Mb link speed */
	#define HWRM_PORT_PHY_CFG_INPUT_AUTO_LINK_SPEED_20GB  UINT32_C(0xc8)
	/* 25Gb link speed */
	#define HWRM_PORT_PHY_CFG_INPUT_AUTO_LINK_SPEED_25GB  UINT32_C(0xfa)
	/* 40Gb link speed */
	#define HWRM_PORT_PHY_CFG_INPUT_AUTO_LINK_SPEED_40GB  UINT32_C(0x190)
	/* 50Gb link speed */
	#define HWRM_PORT_PHY_CFG_INPUT_AUTO_LINK_SPEED_50GB  UINT32_C(0x1f4)
	/* 100Gb link speed */
	#define HWRM_PORT_PHY_CFG_INPUT_AUTO_LINK_SPEED_100GB UINT32_C(0x3e8)
	/* 10Mb link speed */
	#define HWRM_PORT_PHY_CFG_INPUT_AUTO_LINK_SPEED_10MB  UINT32_C(0xffff)
	#define HWRM_PORT_PHY_CFG_INPUT_AUTO_LINK_SPEED_LAST HWRM_PORT_PHY_CFG_INPUT_AUTO_LINK_SPEED_10MB
	/*
	 * This is a mask of link speeds that will be used if
	 * autoneg_mode is "mask".  If unsupported speed is enabled
	 * an error will be generated.
	 */
	uint16_t	auto_link_speed_mask;
	/* 100Mb link speed (Half-duplex) */
	#define HWRM_PORT_PHY_CFG_INPUT_AUTO_LINK_SPEED_MASK_100MBHD	UINT32_C(0x1)
	/* 100Mb link speed (Full-duplex) */
	#define HWRM_PORT_PHY_CFG_INPUT_AUTO_LINK_SPEED_MASK_100MB	UINT32_C(0x2)
	/* 1Gb link speed (Half-duplex) */
	#define HWRM_PORT_PHY_CFG_INPUT_AUTO_LINK_SPEED_MASK_1GBHD	UINT32_C(0x4)
	/* 1Gb link speed (Full-duplex) */
	#define HWRM_PORT_PHY_CFG_INPUT_AUTO_LINK_SPEED_MASK_1GB	UINT32_C(0x8)
	/* 2Gb link speed */
	#define HWRM_PORT_PHY_CFG_INPUT_AUTO_LINK_SPEED_MASK_2GB	UINT32_C(0x10)
	/* 25Gb link speed */
	#define HWRM_PORT_PHY_CFG_INPUT_AUTO_LINK_SPEED_MASK_2_5GB	UINT32_C(0x20)
	/* 10Gb link speed */
	#define HWRM_PORT_PHY_CFG_INPUT_AUTO_LINK_SPEED_MASK_10GB	UINT32_C(0x40)
	/* 20Gb link speed */
	#define HWRM_PORT_PHY_CFG_INPUT_AUTO_LINK_SPEED_MASK_20GB	UINT32_C(0x80)
	/* 25Gb link speed */
	#define HWRM_PORT_PHY_CFG_INPUT_AUTO_LINK_SPEED_MASK_25GB	UINT32_C(0x100)
	/* 40Gb link speed */
	#define HWRM_PORT_PHY_CFG_INPUT_AUTO_LINK_SPEED_MASK_40GB	UINT32_C(0x200)
	/* 50Gb link speed */
	#define HWRM_PORT_PHY_CFG_INPUT_AUTO_LINK_SPEED_MASK_50GB	UINT32_C(0x400)
	/* 100Gb link speed */
	#define HWRM_PORT_PHY_CFG_INPUT_AUTO_LINK_SPEED_MASK_100GB	UINT32_C(0x800)
	/* 10Mb link speed (Half-duplex) */
	#define HWRM_PORT_PHY_CFG_INPUT_AUTO_LINK_SPEED_MASK_10MBHD	UINT32_C(0x1000)
	/* 10Mb link speed (Full-duplex) */
	#define HWRM_PORT_PHY_CFG_INPUT_AUTO_LINK_SPEED_MASK_10MB	UINT32_C(0x2000)
	/* This value controls the wirespeed feature. */
	uint8_t	wirespeed;
	/* Wirespeed feature is disabled. */
	#define HWRM_PORT_PHY_CFG_INPUT_WIRESPEED_OFF UINT32_C(0x0)
	/* Wirespeed feature is enabled. */
	#define HWRM_PORT_PHY_CFG_INPUT_WIRESPEED_ON  UINT32_C(0x1)
	#define HWRM_PORT_PHY_CFG_INPUT_WIRESPEED_LAST HWRM_PORT_PHY_CFG_INPUT_WIRESPEED_ON
	/* This value controls the loopback setting for the PHY. */
	uint8_t	lpbk;
	/* No loopback is selected.  Normal operation. */
	#define HWRM_PORT_PHY_CFG_INPUT_LPBK_NONE	UINT32_C(0x0)
	/*
	 * The HW will be configured with local loopback such that
	 * host data is sent back to the host without modification.
	 */
	#define HWRM_PORT_PHY_CFG_INPUT_LPBK_LOCAL	UINT32_C(0x1)
	/*
	 * The HW will be configured with remote loopback such that
	 * port logic will send packets back out the transmitter that
	 * are received.
	 */
	#define HWRM_PORT_PHY_CFG_INPUT_LPBK_REMOTE   UINT32_C(0x2)
	/*
	 * The HW will be configured with external loopback such that
	 * host data is sent on the transmitter and based on the external
	 * loopback connection the data will be received without modification.
	 */
	#define HWRM_PORT_PHY_CFG_INPUT_LPBK_EXTERNAL UINT32_C(0x3)
	#define HWRM_PORT_PHY_CFG_INPUT_LPBK_LAST	HWRM_PORT_PHY_CFG_INPUT_LPBK_EXTERNAL
	/*
	 * This value is used to configure the pause that will be
	 * used for force mode.
	 */
	uint8_t	force_pause;
	/*
	 * When this bit is '1', Generation of tx pause messages
	 * is supported. Disabled otherwise.
	 */
	#define HWRM_PORT_PHY_CFG_INPUT_FORCE_PAUSE_TX	UINT32_C(0x1)
	/*
	 * When this bit is '1', Reception of rx pause messages
	 * is supported. Disabled otherwise.
	 */
	#define HWRM_PORT_PHY_CFG_INPUT_FORCE_PAUSE_RX	UINT32_C(0x2)
	uint8_t	unused_1;
	/*
	 * This value controls the pre-emphasis to be used for the
	 * link.  Driver should not set this value (use
	 * enable.preemphasis = 0) unless driver is sure of setting.
	 * Normally HWRM FW will determine proper pre-emphasis.
	 */
	uint32_t	preemphasis;
	/*
	 * Setting for link speed mask that is used to
	 * advertise speeds during autonegotiation when EEE is enabled.
	 * This field is valid only when EEE is enabled.
	 * The speeds specified in this field shall be a subset of
	 * speeds specified in auto_link_speed_mask.
	 * If EEE is enabled,then at least one speed shall be provided
	 * in this mask.
	 */
	uint16_t	eee_link_speed_mask;
	/* Reserved */
	#define HWRM_PORT_PHY_CFG_INPUT_EEE_LINK_SPEED_MASK_RSVD1	UINT32_C(0x1)
	/* 100Mb link speed (Full-duplex) */
	#define HWRM_PORT_PHY_CFG_INPUT_EEE_LINK_SPEED_MASK_100MB	UINT32_C(0x2)
	/* Reserved */
	#define HWRM_PORT_PHY_CFG_INPUT_EEE_LINK_SPEED_MASK_RSVD2	UINT32_C(0x4)
	/* 1Gb link speed (Full-duplex) */
	#define HWRM_PORT_PHY_CFG_INPUT_EEE_LINK_SPEED_MASK_1GB	UINT32_C(0x8)
	/* Reserved */
	#define HWRM_PORT_PHY_CFG_INPUT_EEE_LINK_SPEED_MASK_RSVD3	UINT32_C(0x10)
	/* Reserved */
	#define HWRM_PORT_PHY_CFG_INPUT_EEE_LINK_SPEED_MASK_RSVD4	UINT32_C(0x20)
	/* 10Gb link speed */
	#define HWRM_PORT_PHY_CFG_INPUT_EEE_LINK_SPEED_MASK_10GB	UINT32_C(0x40)
	/*
	 * This is the speed that will be used if the force and force_pam4
	 * bits are '1'.  If unsupported speed is selected, an error
	 * will be generated.
	 */
	uint16_t	force_pam4_link_speed;
	/* 50Gb link speed */
	#define HWRM_PORT_PHY_CFG_INPUT_FORCE_PAM4_LINK_SPEED_50GB  UINT32_C(0x1f4)
	/* 100Gb link speed */
	#define HWRM_PORT_PHY_CFG_INPUT_FORCE_PAM4_LINK_SPEED_100GB UINT32_C(0x3e8)
	/* 200Gb link speed */
	#define HWRM_PORT_PHY_CFG_INPUT_FORCE_PAM4_LINK_SPEED_200GB UINT32_C(0x7d0)
	#define HWRM_PORT_PHY_CFG_INPUT_FORCE_PAM4_LINK_SPEED_LAST HWRM_PORT_PHY_CFG_INPUT_FORCE_PAM4_LINK_SPEED_200GB
	/*
	 * Requested setting of TX LPI timer in microseconds.
	 * This field is valid only when EEE is enabled and TX LPI is
	 * enabled.
	 */
	uint32_t	tx_lpi_timer;
	#define HWRM_PORT_PHY_CFG_INPUT_TX_LPI_TIMER_MASK UINT32_C(0xffffff)
	#define HWRM_PORT_PHY_CFG_INPUT_TX_LPI_TIMER_SFT 0
	/* This field specifies which PAM4 speeds are enabled for auto mode. */
	uint16_t	auto_link_pam4_speed_mask;
	#define HWRM_PORT_PHY_CFG_INPUT_AUTO_LINK_PAM4_SPEED_MASK_50G	UINT32_C(0x1)
	#define HWRM_PORT_PHY_CFG_INPUT_AUTO_LINK_PAM4_SPEED_MASK_100G	UINT32_C(0x2)
	#define HWRM_PORT_PHY_CFG_INPUT_AUTO_LINK_PAM4_SPEED_MASK_200G	UINT32_C(0x4)
	uint8_t	unused_2[2];
} hwrm_port_phy_cfg_input_t, *phwrm_port_phy_cfg_input_t;

/* hwrm_port_phy_cfg_output (size:128b/16B) */

typedef struct hwrm_port_phy_cfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_port_phy_cfg_output_t, *phwrm_port_phy_cfg_output_t;

/* hwrm_port_phy_cfg_cmd_err (size:64b/8B) */

typedef struct hwrm_port_phy_cfg_cmd_err {
	/*
	 * command specific error codes that goes to
	 * the cmd_err field in Common HWRM Error Response.
	 */
	uint8_t	code;
	/* Unknown error */
	#define HWRM_PORT_PHY_CFG_CMD_ERR_CODE_UNKNOWN	UINT32_C(0x0)
	/* Unable to complete operation due to invalid speed */
	#define HWRM_PORT_PHY_CFG_CMD_ERR_CODE_ILLEGAL_SPEED UINT32_C(0x1)
	/*
	 * retry the command since the phy is not ready.
	 * retry count is returned in opaque_0.
	 * This is only valid for the first command and
	 * this value will not change for successive calls.
	 * but if a 0 is returned at any time then this should
	 * be treated as an un recoverable failure,
	 *
	 * retry interval in milli seconds is returned in opaque_1.
	 * This specifies the time that user should wait before
	 * issuing the next port_phy_cfg command.
	 */
	#define HWRM_PORT_PHY_CFG_CMD_ERR_CODE_RETRY	UINT32_C(0x2)
	#define HWRM_PORT_PHY_CFG_CMD_ERR_CODE_LAST	HWRM_PORT_PHY_CFG_CMD_ERR_CODE_RETRY
	uint8_t	unused_0[7];
} hwrm_port_phy_cfg_cmd_err_t, *phwrm_port_phy_cfg_cmd_err_t;

/**********************
 * hwrm_port_phy_qcfg *
 **********************/


/* hwrm_port_phy_qcfg_input (size:192b/24B) */

typedef struct hwrm_port_phy_qcfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Port ID of port that is to be queried. */
	uint16_t	port_id;
	uint8_t	unused_0[6];
} hwrm_port_phy_qcfg_input_t, *phwrm_port_phy_qcfg_input_t;

/* hwrm_port_phy_qcfg_output (size:768b/96B) */

typedef struct hwrm_port_phy_qcfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* This value indicates the current link status. */
	uint8_t	link;
	/* There is no link or cable detected. */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LINK_NO_LINK UINT32_C(0x0)
	/* There is no link, but a cable has been detected. */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LINK_SIGNAL  UINT32_C(0x1)
	/* There is a link. */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LINK_LINK	UINT32_C(0x2)
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LINK_LAST   HWRM_PORT_PHY_QCFG_OUTPUT_LINK_LINK
	uint8_t	active_fec_signal_mode;
	/*
	 * This value indicates the current link signaling mode of the
	 * connection.
	 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_SIGNAL_MODE_MASK		UINT32_C(0xf)
	#define HWRM_PORT_PHY_QCFG_OUTPUT_SIGNAL_MODE_SFT		0
	/* NRZ signaling */
		#define HWRM_PORT_PHY_QCFG_OUTPUT_SIGNAL_MODE_NRZ		UINT32_C(0x0)
	/* PAM4 signaling */
		#define HWRM_PORT_PHY_QCFG_OUTPUT_SIGNAL_MODE_PAM4		UINT32_C(0x1)
		#define HWRM_PORT_PHY_QCFG_OUTPUT_SIGNAL_MODE_LAST		HWRM_PORT_PHY_QCFG_OUTPUT_SIGNAL_MODE_PAM4
	/* This value indicates the current active FEC mode. */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_ACTIVE_FEC_MASK		UINT32_C(0xf0)
	#define HWRM_PORT_PHY_QCFG_OUTPUT_ACTIVE_FEC_SFT		4
	/* No active FEC */
		#define HWRM_PORT_PHY_QCFG_OUTPUT_ACTIVE_FEC_FEC_NONE_ACTIVE	(UINT32_C(0x0) << 4)
	/* FEC CLAUSE 74 (Fire Code) active, autonegotiated or forced. */
		#define HWRM_PORT_PHY_QCFG_OUTPUT_ACTIVE_FEC_FEC_CLAUSE74_ACTIVE	(UINT32_C(0x1) << 4)
	/* FEC CLAUSE 91 RS(528,514) active, autonegoatiated or forced. */
		#define HWRM_PORT_PHY_QCFG_OUTPUT_ACTIVE_FEC_FEC_CLAUSE91_ACTIVE	(UINT32_C(0x2) << 4)
	/* FEC RS544_1XN active, autonegoatiated or forced. */
		#define HWRM_PORT_PHY_QCFG_OUTPUT_ACTIVE_FEC_FEC_RS544_1XN_ACTIVE   (UINT32_C(0x3) << 4)
	/* FEC RS(544,528) active, autonegoatiated or forced. */
		#define HWRM_PORT_PHY_QCFG_OUTPUT_ACTIVE_FEC_FEC_RS544_IEEE_ACTIVE  (UINT32_C(0x4) << 4)
	/* FEC RS272_1XN active, autonegotiated or forced. */
		#define HWRM_PORT_PHY_QCFG_OUTPUT_ACTIVE_FEC_FEC_RS272_1XN_ACTIVE   (UINT32_C(0x5) << 4)
	/* FEC RS(272,257) active, autonegoatiated or forced. */
		#define HWRM_PORT_PHY_QCFG_OUTPUT_ACTIVE_FEC_FEC_RS272_IEEE_ACTIVE  (UINT32_C(0x6) << 4)
		#define HWRM_PORT_PHY_QCFG_OUTPUT_ACTIVE_FEC_LAST		HWRM_PORT_PHY_QCFG_OUTPUT_ACTIVE_FEC_FEC_RS272_IEEE_ACTIVE
	/*
	 * This value indicates the current link speed of the connection.
	 * The signal_mode field indicates if the link is using
	 * NRZ or PAM4 signaling.
	 */
	uint16_t	link_speed;
	/* 100Mb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LINK_SPEED_100MB UINT32_C(0x1)
	/* 1Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LINK_SPEED_1GB   UINT32_C(0xa)
	/* 2Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LINK_SPEED_2GB   UINT32_C(0x14)
	/* 25Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LINK_SPEED_2_5GB UINT32_C(0x19)
	/* 10Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LINK_SPEED_10GB  UINT32_C(0x64)
	/* 20Mb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LINK_SPEED_20GB  UINT32_C(0xc8)
	/* 25Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LINK_SPEED_25GB  UINT32_C(0xfa)
	/* 40Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LINK_SPEED_40GB  UINT32_C(0x190)
	/* 50Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LINK_SPEED_50GB  UINT32_C(0x1f4)
	/* 100Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LINK_SPEED_100GB UINT32_C(0x3e8)
	/* 200Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LINK_SPEED_200GB UINT32_C(0x7d0)
	/* 10Mb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LINK_SPEED_10MB  UINT32_C(0xffff)
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LINK_SPEED_LAST HWRM_PORT_PHY_QCFG_OUTPUT_LINK_SPEED_10MB
	/*
	 * This value is indicates the duplex of the current
	 * configuration.
	 */
	uint8_t	duplex_cfg;
	/* Half Duplex connection. */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_DUPLEX_CFG_HALF UINT32_C(0x0)
	/* Full duplex connection. */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_DUPLEX_CFG_FULL UINT32_C(0x1)
	#define HWRM_PORT_PHY_QCFG_OUTPUT_DUPLEX_CFG_LAST HWRM_PORT_PHY_QCFG_OUTPUT_DUPLEX_CFG_FULL
	/*
	 * This value is used to indicate the current
	 * pause configuration. When autoneg is enabled, this value
	 * represents the autoneg results of pause configuration.
	 */
	uint8_t	pause;
	/*
	 * When this bit is '1', Generation of tx pause messages
	 * is supported. Disabled otherwise.
	 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_PAUSE_TX	UINT32_C(0x1)
	/*
	 * When this bit is '1', Reception of rx pause messages
	 * is supported. Disabled otherwise.
	 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_PAUSE_RX	UINT32_C(0x2)
	/*
	 * The supported speeds for the port. This is a bit mask.
	 * For each speed that is supported, the corresponding
	 * bit will be set to '1'.
	 */
	uint16_t	support_speeds;
	/* 100Mb link speed (Half-duplex) */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_SUPPORT_SPEEDS_100MBHD	UINT32_C(0x1)
	/* 100Mb link speed (Full-duplex) */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_SUPPORT_SPEEDS_100MB	UINT32_C(0x2)
	/* 1Gb link speed (Half-duplex) */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_SUPPORT_SPEEDS_1GBHD	UINT32_C(0x4)
	/* 1Gb link speed (Full-duplex) */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_SUPPORT_SPEEDS_1GB	UINT32_C(0x8)
	/* 2Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_SUPPORT_SPEEDS_2GB	UINT32_C(0x10)
	/* 25Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_SUPPORT_SPEEDS_2_5GB	UINT32_C(0x20)
	/* 10Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_SUPPORT_SPEEDS_10GB	UINT32_C(0x40)
	/* 20Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_SUPPORT_SPEEDS_20GB	UINT32_C(0x80)
	/* 25Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_SUPPORT_SPEEDS_25GB	UINT32_C(0x100)
	/* 40Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_SUPPORT_SPEEDS_40GB	UINT32_C(0x200)
	/* 50Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_SUPPORT_SPEEDS_50GB	UINT32_C(0x400)
	/* 100Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_SUPPORT_SPEEDS_100GB	UINT32_C(0x800)
	/* 10Mb link speed (Half-duplex) */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_SUPPORT_SPEEDS_10MBHD	UINT32_C(0x1000)
	/* 10Mb link speed (Full-duplex) */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_SUPPORT_SPEEDS_10MB	UINT32_C(0x2000)
	/*
	 * Current setting of forced link speed.
	 * When the link speed is not being forced, this
	 * value shall be set to 0.
	 */
	uint16_t	force_link_speed;
	/* 100Mb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_FORCE_LINK_SPEED_100MB UINT32_C(0x1)
	/* 1Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_FORCE_LINK_SPEED_1GB   UINT32_C(0xa)
	/* 2Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_FORCE_LINK_SPEED_2GB   UINT32_C(0x14)
	/* 25Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_FORCE_LINK_SPEED_2_5GB UINT32_C(0x19)
	/* 10Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_FORCE_LINK_SPEED_10GB  UINT32_C(0x64)
	/* 20Mb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_FORCE_LINK_SPEED_20GB  UINT32_C(0xc8)
	/* 25Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_FORCE_LINK_SPEED_25GB  UINT32_C(0xfa)
	/* 40Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_FORCE_LINK_SPEED_40GB  UINT32_C(0x190)
	/* 50Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_FORCE_LINK_SPEED_50GB  UINT32_C(0x1f4)
	/* 100Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_FORCE_LINK_SPEED_100GB UINT32_C(0x3e8)
	/* 10Mb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_FORCE_LINK_SPEED_10MB  UINT32_C(0xffff)
	#define HWRM_PORT_PHY_QCFG_OUTPUT_FORCE_LINK_SPEED_LAST HWRM_PORT_PHY_QCFG_OUTPUT_FORCE_LINK_SPEED_10MB
	/* Current setting of auto negotiation mode. */
	uint8_t	auto_mode;
	/* Disable autoneg or autoneg disabled. No speeds are selected. */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_MODE_NONE	UINT32_C(0x0)
	/* Select all possible speeds for autoneg mode. */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_MODE_ALL_SPEEDS   UINT32_C(0x1)
	/*
	 * Select only the auto_link_speed speed for autoneg mode. This mode has
	 * been DEPRECATED. An HWRM client should not use this mode.
	 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_MODE_ONE_SPEED	UINT32_C(0x2)
	/*
	 * Select the auto_link_speed or any speed below that speed for autoneg.
	 * This mode has been DEPRECATED. An HWRM client should not use this mode.
	 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_MODE_ONE_OR_BELOW UINT32_C(0x3)
	/*
	 * Select the speeds based on the corresponding link speed mask value
	 * that is provided.
	 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_MODE_SPEED_MASK   UINT32_C(0x4)
	#define HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_MODE_LAST	HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_MODE_SPEED_MASK
	/*
	 * Current setting of pause autonegotiation.
	 * Move autoneg_pause flag here.
	 */
	uint8_t	auto_pause;
	/*
	 * When this bit is '1', Generation of tx pause messages
	 * has been requested. Disabled otherwise.
	 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_PAUSE_TX		UINT32_C(0x1)
	/*
	 * When this bit is '1', Reception of rx pause messages
	 * has been requested. Disabled otherwise.
	 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_PAUSE_RX		UINT32_C(0x2)
	/*
	 * When set to 1, the advertisement of pause is enabled.
	 *
	 * # When the auto_mode is not set to none and this flag is
	 * set to 1, then the auto_pause bits on this port are being
	 * advertised and autoneg pause results are being interpreted.
	 * # When the auto_mode is not set to none and this
	 * flag is set to 0, the pause is forced as indicated in
	 * force_pause, and also advertised as auto_pause bits, but
	 * the autoneg results are not interpreted since the pause
	 * configuration is being forced.
	 * # When the auto_mode is set to none and this flag is set to
	 * 1, auto_pause bits should be ignored and should be set to 0.
	 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_PAUSE_AUTONEG_PAUSE	UINT32_C(0x4)
	/*
	 * Current setting for auto_link_speed. This field is only
	 * valid when auto_mode is set to "one_speed" or "one_or_below".
	 */
	uint16_t	auto_link_speed;
	/* 100Mb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_LINK_SPEED_100MB UINT32_C(0x1)
	/* 1Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_LINK_SPEED_1GB   UINT32_C(0xa)
	/* 2Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_LINK_SPEED_2GB   UINT32_C(0x14)
	/* 25Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_LINK_SPEED_2_5GB UINT32_C(0x19)
	/* 10Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_LINK_SPEED_10GB  UINT32_C(0x64)
	/* 20Mb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_LINK_SPEED_20GB  UINT32_C(0xc8)
	/* 25Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_LINK_SPEED_25GB  UINT32_C(0xfa)
	/* 40Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_LINK_SPEED_40GB  UINT32_C(0x190)
	/* 50Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_LINK_SPEED_50GB  UINT32_C(0x1f4)
	/* 100Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_LINK_SPEED_100GB UINT32_C(0x3e8)
	/* 10Mb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_LINK_SPEED_10MB  UINT32_C(0xffff)
	#define HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_LINK_SPEED_LAST HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_LINK_SPEED_10MB
	/*
	 * Current setting for auto_link_speed_mask that is used to
	 * advertise speeds during autonegotiation.
	 * This field is only valid when auto_mode is set to "mask".
	 * The speeds specified in this field shall be a subset of
	 * supported speeds on this port.
	 */
	uint16_t	auto_link_speed_mask;
	/* 100Mb link speed (Half-duplex) */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_LINK_SPEED_MASK_100MBHD	UINT32_C(0x1)
	/* 100Mb link speed (Full-duplex) */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_LINK_SPEED_MASK_100MB	UINT32_C(0x2)
	/* 1Gb link speed (Half-duplex) */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_LINK_SPEED_MASK_1GBHD	UINT32_C(0x4)
	/* 1Gb link speed (Full-duplex) */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_LINK_SPEED_MASK_1GB	UINT32_C(0x8)
	/* 2Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_LINK_SPEED_MASK_2GB	UINT32_C(0x10)
	/* 25Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_LINK_SPEED_MASK_2_5GB	UINT32_C(0x20)
	/* 10Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_LINK_SPEED_MASK_10GB	UINT32_C(0x40)
	/* 20Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_LINK_SPEED_MASK_20GB	UINT32_C(0x80)
	/* 25Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_LINK_SPEED_MASK_25GB	UINT32_C(0x100)
	/* 40Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_LINK_SPEED_MASK_40GB	UINT32_C(0x200)
	/* 50Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_LINK_SPEED_MASK_50GB	UINT32_C(0x400)
	/* 100Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_LINK_SPEED_MASK_100GB	UINT32_C(0x800)
	/* 10Mb link speed (Half-duplex) */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_LINK_SPEED_MASK_10MBHD	UINT32_C(0x1000)
	/* 10Mb link speed (Full-duplex) */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_LINK_SPEED_MASK_10MB	UINT32_C(0x2000)
	/* Current setting for wirespeed. */
	uint8_t	wirespeed;
	/* Wirespeed feature is disabled. */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_WIRESPEED_OFF UINT32_C(0x0)
	/* Wirespeed feature is enabled. */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_WIRESPEED_ON  UINT32_C(0x1)
	#define HWRM_PORT_PHY_QCFG_OUTPUT_WIRESPEED_LAST HWRM_PORT_PHY_QCFG_OUTPUT_WIRESPEED_ON
	/* Current setting for loopback. */
	uint8_t	lpbk;
	/* No loopback is selected.  Normal operation. */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LPBK_NONE	UINT32_C(0x0)
	/*
	 * The HW will be configured with local loopback such that
	 * host data is sent back to the host without modification.
	 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LPBK_LOCAL	UINT32_C(0x1)
	/*
	 * The HW will be configured with remote loopback such that
	 * port logic will send packets back out the transmitter that
	 * are received.
	 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LPBK_REMOTE   UINT32_C(0x2)
	/*
	 * The HW will be configured with external loopback such that
	 * host data is sent on the transmitter and based on the external
	 * loopback connection the data will be received without modification.
	 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LPBK_EXTERNAL UINT32_C(0x3)
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LPBK_LAST	HWRM_PORT_PHY_QCFG_OUTPUT_LPBK_EXTERNAL
	/*
	 * Current setting of forced pause.
	 * When the pause configuration is not being forced, then
	 * this value shall be set to 0.
	 */
	uint8_t	force_pause;
	/*
	 * When this bit is '1', Generation of tx pause messages
	 * is supported. Disabled otherwise.
	 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_FORCE_PAUSE_TX	UINT32_C(0x1)
	/*
	 * When this bit is '1', Reception of rx pause messages
	 * is supported. Disabled otherwise.
	 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_FORCE_PAUSE_RX	UINT32_C(0x2)
	/*
	 * This value indicates the current status of the optics module on
	 * this port.
	 */
	uint8_t	module_status;
	/* Module is inserted and accepted */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_MODULE_STATUS_NONE	UINT32_C(0x0)
	/* Module is rejected and transmit side Laser is disabled. */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_MODULE_STATUS_DISABLETX	UINT32_C(0x1)
	/* Module mismatch warning. */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_MODULE_STATUS_WARNINGMSG	UINT32_C(0x2)
	/* Module is rejected and powered down. */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_MODULE_STATUS_PWRDOWN	UINT32_C(0x3)
	/* Module is not inserted. */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_MODULE_STATUS_NOTINSERTED   UINT32_C(0x4)
	/* Module is powered down because of over current fault. */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_MODULE_STATUS_CURRENTFAULT  UINT32_C(0x5)
	/* Module status is not applicable. */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_MODULE_STATUS_NOTAPPLICABLE UINT32_C(0xff)
	#define HWRM_PORT_PHY_QCFG_OUTPUT_MODULE_STATUS_LAST	HWRM_PORT_PHY_QCFG_OUTPUT_MODULE_STATUS_NOTAPPLICABLE
	/* Current setting for preemphasis. */
	uint32_t	preemphasis;
	/* This field represents the major version of the PHY. */
	uint8_t	phy_maj;
	/* This field represents the minor version of the PHY. */
	uint8_t	phy_min;
	/* This field represents the build version of the PHY. */
	uint8_t	phy_bld;
	/* This value represents a PHY type. */
	uint8_t	phy_type;
	/* Unknown */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_UNKNOWN	UINT32_C(0x0)
	/* BASE-CR */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_BASECR	UINT32_C(0x1)
	/* BASE-KR4 (Deprecated) */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_BASEKR4	UINT32_C(0x2)
	/* BASE-LR */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_BASELR	UINT32_C(0x3)
	/* BASE-SR */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_BASESR	UINT32_C(0x4)
	/* BASE-KR2 (Deprecated) */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_BASEKR2	UINT32_C(0x5)
	/* BASE-KX */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_BASEKX	UINT32_C(0x6)
	/* BASE-KR */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_BASEKR	UINT32_C(0x7)
	/* BASE-T */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_BASET		UINT32_C(0x8)
	/* EEE capable BASE-T */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_BASETE	UINT32_C(0x9)
	/* SGMII connected external PHY */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_SGMIIEXTPHY	UINT32_C(0xa)
	/* 25G_BASECR_CA_L */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_25G_BASECR_CA_L  UINT32_C(0xb)
	/* 25G_BASECR_CA_S */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_25G_BASECR_CA_S  UINT32_C(0xc)
	/* 25G_BASECR_CA_N */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_25G_BASECR_CA_N  UINT32_C(0xd)
	/* 25G_BASESR */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_25G_BASESR	UINT32_C(0xe)
	/* 100G_BASECR4 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_100G_BASECR4	UINT32_C(0xf)
	/* 100G_BASESR4 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_100G_BASESR4	UINT32_C(0x10)
	/* 100G_BASELR4 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_100G_BASELR4	UINT32_C(0x11)
	/* 100G_BASEER4 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_100G_BASEER4	UINT32_C(0x12)
	/* 100G_BASESR10 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_100G_BASESR10	UINT32_C(0x13)
	/* 40G_BASECR4 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_40G_BASECR4	UINT32_C(0x14)
	/* 40G_BASESR4 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_40G_BASESR4	UINT32_C(0x15)
	/* 40G_BASELR4 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_40G_BASELR4	UINT32_C(0x16)
	/* 40G_BASEER4 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_40G_BASEER4	UINT32_C(0x17)
	/* 40G_ACTIVE_CABLE */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_40G_ACTIVE_CABLE UINT32_C(0x18)
	/* 1G_baseT */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_1G_BASET	UINT32_C(0x19)
	/* 1G_baseSX */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_1G_BASESX	UINT32_C(0x1a)
	/* 1G_baseCX */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_1G_BASECX	UINT32_C(0x1b)
	/* 100G_BASECR4 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_200G_BASECR4	UINT32_C(0x1c)
	/* 100G_BASESR4 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_200G_BASESR4	UINT32_C(0x1d)
	/* 100G_BASELR4 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_200G_BASELR4	UINT32_C(0x1e)
	/* 100G_BASEER4 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_200G_BASEER4	UINT32_C(0x1f)
	#define HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_LAST		HWRM_PORT_PHY_QCFG_OUTPUT_PHY_TYPE_200G_BASEER4
	/* This value represents a media type. */
	uint8_t	media_type;
	/* Unknown */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_MEDIA_TYPE_UNKNOWN UINT32_C(0x0)
	/* Twisted Pair */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_MEDIA_TYPE_TP	UINT32_C(0x1)
	/* Direct Attached Copper */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_MEDIA_TYPE_DAC	UINT32_C(0x2)
	/* Fiber */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_MEDIA_TYPE_FIBRE   UINT32_C(0x3)
	#define HWRM_PORT_PHY_QCFG_OUTPUT_MEDIA_TYPE_LAST   HWRM_PORT_PHY_QCFG_OUTPUT_MEDIA_TYPE_FIBRE
	/* This value represents a transceiver type. */
	uint8_t	xcvr_pkg_type;
	/* PHY and MAC are in the same package */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_XCVR_PKG_TYPE_XCVR_INTERNAL UINT32_C(0x1)
	/* PHY and MAC are in different packages */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_XCVR_PKG_TYPE_XCVR_EXTERNAL UINT32_C(0x2)
	#define HWRM_PORT_PHY_QCFG_OUTPUT_XCVR_PKG_TYPE_LAST	HWRM_PORT_PHY_QCFG_OUTPUT_XCVR_PKG_TYPE_XCVR_EXTERNAL
	uint8_t	eee_config_phy_addr;
	/* This field represents PHY address. */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_PHY_ADDR_MASK		UINT32_C(0x1f)
	#define HWRM_PORT_PHY_QCFG_OUTPUT_PHY_ADDR_SFT		0
	/*
	 * This field represents flags related to EEE configuration.
	 * These EEE configuration flags are valid only when the
	 * auto_mode is not set to none (in other words autonegotiation
	 * is enabled).
	 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_EEE_CONFIG_MASK		UINT32_C(0xe0)
	#define HWRM_PORT_PHY_QCFG_OUTPUT_EEE_CONFIG_SFT		5
	/*
	 * When set to 1, Energy Efficient Ethernet (EEE) mode is enabled.
	 * Speeds for autoneg with EEE mode enabled
	 * are based on eee_link_speed_mask.
	 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_EEE_CONFIG_EEE_ENABLED	UINT32_C(0x20)
	/*
	 * This flag is valid only when eee_enabled is set to 1.
	 *
	 * # If eee_enabled is set to 0, then EEE mode is disabled
	 * and this flag shall be ignored.
	 * # If eee_enabled is set to 1 and this flag is set to 1,
	 * then Energy Efficient Ethernet (EEE) mode is enabled
	 * and in use.
	 * # If eee_enabled is set to 1 and this flag is set to 0,
	 * then Energy Efficient Ethernet (EEE) mode is enabled
	 * but is currently not in use.
	 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_EEE_CONFIG_EEE_ACTIVE	UINT32_C(0x40)
	/*
	 * This flag is valid only when eee_enabled is set to 1.
	 *
	 * # If eee_enabled is set to 0, then EEE mode is disabled
	 * and this flag shall be ignored.
	 * # If eee_enabled is set to 1 and this flag is set to 1,
	 * then Energy Efficient Ethernet (EEE) mode is enabled
	 * and TX LPI is enabled.
	 * # If eee_enabled is set to 1 and this flag is set to 0,
	 * then Energy Efficient Ethernet (EEE) mode is enabled
	 * but TX LPI is disabled.
	 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_EEE_CONFIG_EEE_TX_LPI	UINT32_C(0x80)
	/*
	 * When set to 1, the parallel detection is used to determine
	 * the speed of the link partner.
	 *
	 * Parallel detection is used when a autonegotiation capable
	 * device is connected to a link parter that is not capable
	 * of autonegotiation.
	 */
	uint8_t	parallel_detect;
	/*
	 * When set to 1, the parallel detection is used to determine
	 * the speed of the link partner.
	 *
	 * Parallel detection is used when a autonegotiation capable
	 * device is connected to a link parter that is not capable
	 * of autonegotiation.
	 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_PARALLEL_DETECT	UINT32_C(0x1)
	/*
	 * The advertised speeds for the port by the link partner.
	 * Each advertised speed will be set to '1'.
	 */
	uint16_t	link_partner_adv_speeds;
	/* 100Mb link speed (Half-duplex) */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LINK_PARTNER_ADV_SPEEDS_100MBHD	UINT32_C(0x1)
	/* 100Mb link speed (Full-duplex) */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LINK_PARTNER_ADV_SPEEDS_100MB	UINT32_C(0x2)
	/* 1Gb link speed (Half-duplex) */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LINK_PARTNER_ADV_SPEEDS_1GBHD	UINT32_C(0x4)
	/* 1Gb link speed (Full-duplex) */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LINK_PARTNER_ADV_SPEEDS_1GB	UINT32_C(0x8)
	/* 2Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LINK_PARTNER_ADV_SPEEDS_2GB	UINT32_C(0x10)
	/* 25Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LINK_PARTNER_ADV_SPEEDS_2_5GB	UINT32_C(0x20)
	/* 10Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LINK_PARTNER_ADV_SPEEDS_10GB	UINT32_C(0x40)
	/* 20Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LINK_PARTNER_ADV_SPEEDS_20GB	UINT32_C(0x80)
	/* 25Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LINK_PARTNER_ADV_SPEEDS_25GB	UINT32_C(0x100)
	/* 40Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LINK_PARTNER_ADV_SPEEDS_40GB	UINT32_C(0x200)
	/* 50Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LINK_PARTNER_ADV_SPEEDS_50GB	UINT32_C(0x400)
	/* 100Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LINK_PARTNER_ADV_SPEEDS_100GB	UINT32_C(0x800)
	/* 10Mb link speed (Half-duplex) */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LINK_PARTNER_ADV_SPEEDS_10MBHD	UINT32_C(0x1000)
	/* 10Mb link speed (Full-duplex) */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LINK_PARTNER_ADV_SPEEDS_10MB	UINT32_C(0x2000)
	/*
	 * The advertised autoneg for the port by the link partner.
	 * This field is deprecated and should be set to 0.
	 */
	uint8_t	link_partner_adv_auto_mode;
	/* Disable autoneg or autoneg disabled. No speeds are selected. */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LINK_PARTNER_ADV_AUTO_MODE_NONE	UINT32_C(0x0)
	/* Select all possible speeds for autoneg mode. */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LINK_PARTNER_ADV_AUTO_MODE_ALL_SPEEDS   UINT32_C(0x1)
	/*
	 * Select only the auto_link_speed speed for autoneg mode. This mode has
	 * been DEPRECATED. An HWRM client should not use this mode.
	 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LINK_PARTNER_ADV_AUTO_MODE_ONE_SPEED	UINT32_C(0x2)
	/*
	 * Select the auto_link_speed or any speed below that speed for autoneg.
	 * This mode has been DEPRECATED. An HWRM client should not use this mode.
	 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LINK_PARTNER_ADV_AUTO_MODE_ONE_OR_BELOW UINT32_C(0x3)
	/*
	 * Select the speeds based on the corresponding link speed mask value
	 * that is provided.
	 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LINK_PARTNER_ADV_AUTO_MODE_SPEED_MASK   UINT32_C(0x4)
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LINK_PARTNER_ADV_AUTO_MODE_LAST	HWRM_PORT_PHY_QCFG_OUTPUT_LINK_PARTNER_ADV_AUTO_MODE_SPEED_MASK
	/* The advertised pause settings on the port by the link partner. */
	uint8_t	link_partner_adv_pause;
	/*
	 * When this bit is '1', Generation of tx pause messages
	 * is supported. Disabled otherwise.
	 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LINK_PARTNER_ADV_PAUSE_TX	UINT32_C(0x1)
	/*
	 * When this bit is '1', Reception of rx pause messages
	 * is supported. Disabled otherwise.
	 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LINK_PARTNER_ADV_PAUSE_RX	UINT32_C(0x2)
	/*
	 * Current setting for link speed mask that is used to
	 * advertise speeds during autonegotiation when EEE is enabled.
	 * This field is valid only when eee_enabled flags is set to 1.
	 * The speeds specified in this field shall be a subset of
	 * speeds specified in auto_link_speed_mask.
	 */
	uint16_t	adv_eee_link_speed_mask;
	/* Reserved */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_ADV_EEE_LINK_SPEED_MASK_RSVD1	UINT32_C(0x1)
	/* 100Mb link speed (Full-duplex) */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_ADV_EEE_LINK_SPEED_MASK_100MB	UINT32_C(0x2)
	/* Reserved */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_ADV_EEE_LINK_SPEED_MASK_RSVD2	UINT32_C(0x4)
	/* 1Gb link speed (Full-duplex) */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_ADV_EEE_LINK_SPEED_MASK_1GB	UINT32_C(0x8)
	/* Reserved */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_ADV_EEE_LINK_SPEED_MASK_RSVD3	UINT32_C(0x10)
	/* Reserved */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_ADV_EEE_LINK_SPEED_MASK_RSVD4	UINT32_C(0x20)
	/* 10Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_ADV_EEE_LINK_SPEED_MASK_10GB	UINT32_C(0x40)
	/*
	 * Current setting for link speed mask that is advertised by
	 * the link partner when EEE is enabled.
	 * This field is valid only when eee_enabled flags is set to 1.
	 */
	uint16_t	link_partner_adv_eee_link_speed_mask;
	/* Reserved */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LINK_PARTNER_ADV_EEE_LINK_SPEED_MASK_RSVD1	UINT32_C(0x1)
	/* 100Mb link speed (Full-duplex) */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LINK_PARTNER_ADV_EEE_LINK_SPEED_MASK_100MB	UINT32_C(0x2)
	/* Reserved */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LINK_PARTNER_ADV_EEE_LINK_SPEED_MASK_RSVD2	UINT32_C(0x4)
	/* 1Gb link speed (Full-duplex) */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LINK_PARTNER_ADV_EEE_LINK_SPEED_MASK_1GB	UINT32_C(0x8)
	/* Reserved */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LINK_PARTNER_ADV_EEE_LINK_SPEED_MASK_RSVD3	UINT32_C(0x10)
	/* Reserved */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LINK_PARTNER_ADV_EEE_LINK_SPEED_MASK_RSVD4	UINT32_C(0x20)
	/* 10Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LINK_PARTNER_ADV_EEE_LINK_SPEED_MASK_10GB	UINT32_C(0x40)
	uint32_t	xcvr_identifier_type_tx_lpi_timer;
	/*
	 * Current setting of TX LPI timer in microseconds.
	 * This field is valid only when_eee_enabled flag is set to 1
	 * and tx_lpi_enabled is set to 1.
	 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_TX_LPI_TIMER_MASK		UINT32_C(0xffffff)
	#define HWRM_PORT_PHY_QCFG_OUTPUT_TX_LPI_TIMER_SFT		0
	/* This value represents transceiver identifier type. */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_XCVR_IDENTIFIER_TYPE_MASK	UINT32_C(0xff000000)
	#define HWRM_PORT_PHY_QCFG_OUTPUT_XCVR_IDENTIFIER_TYPE_SFT	24
	/* Unknown */
		#define HWRM_PORT_PHY_QCFG_OUTPUT_XCVR_IDENTIFIER_TYPE_UNKNOWN   (UINT32_C(0x0) << 24)
	/* SFP/SFP+/SFP28 */
		#define HWRM_PORT_PHY_QCFG_OUTPUT_XCVR_IDENTIFIER_TYPE_SFP	(UINT32_C(0x3) << 24)
	/* QSFP+ */
		#define HWRM_PORT_PHY_QCFG_OUTPUT_XCVR_IDENTIFIER_TYPE_QSFP	(UINT32_C(0xc) << 24)
	/* QSFP+ */
		#define HWRM_PORT_PHY_QCFG_OUTPUT_XCVR_IDENTIFIER_TYPE_QSFPPLUS  (UINT32_C(0xd) << 24)
	/* QSFP28 */
		#define HWRM_PORT_PHY_QCFG_OUTPUT_XCVR_IDENTIFIER_TYPE_QSFP28	(UINT32_C(0x11) << 24)
		#define HWRM_PORT_PHY_QCFG_OUTPUT_XCVR_IDENTIFIER_TYPE_LAST	HWRM_PORT_PHY_QCFG_OUTPUT_XCVR_IDENTIFIER_TYPE_QSFP28
	/*
	 * This value represents the current configuration of
	 * Forward Error Correction (FEC) on the port.
	 */
	uint16_t	fec_cfg;
	/*
	 * When set to 1, then FEC is not supported on this port. If this flag
	 * is set to 1, then all other FEC configuration flags shall be ignored.
	 * When set to 0, then FEC is supported as indicated by other
	 * configuration flags.
	 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_FEC_CFG_FEC_NONE_SUPPORTED	UINT32_C(0x1)
	/*
	 * When set to 1, then FEC autonegotiation is supported on this port.
	 * When set to 0, then FEC autonegotiation is not supported on this port.
	 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_FEC_CFG_FEC_AUTONEG_SUPPORTED	UINT32_C(0x2)
	/*
	 * When set to 1, then FEC autonegotiation is enabled on this port.
	 * When set to 0, then FEC autonegotiation is disabled if supported.
	 * This flag should be ignored if FEC autonegotiation is not supported on this port.
	 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_FEC_CFG_FEC_AUTONEG_ENABLED	UINT32_C(0x4)
	/*
	 * When set to 1, then FEC CLAUSE 74 (Fire Code) is supported on this port.
	 * When set to 0, then FEC CLAUSE 74 (Fire Code) is not supported on this port.
	 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_FEC_CFG_FEC_CLAUSE74_SUPPORTED	UINT32_C(0x8)
	/*
	 * When set to 1, then FEC CLAUSE 74 (Fire Code) is enabled on this
	 * port. This means that FEC CLAUSE 74 is either advertised if
	 * FEC autonegotiation is enabled or FEC CLAUSE 74 is force enabled.
	 * When set to 0, then FEC CLAUSE 74 (Fire Code) is disabled if supported.
	 * This flag should be ignored if FEC CLAUSE 74 is not supported on this port.
	 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_FEC_CFG_FEC_CLAUSE74_ENABLED	UINT32_C(0x10)
	/*
	 * When set to 1, then FEC CLAUSE 91 (Reed Solomon RS(528,514) for
	 * NRZ) is supported on this port.
	 * When set to 0, then FEC RS(528,418) is not supported on this port.
	 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_FEC_CFG_FEC_CLAUSE91_SUPPORTED	UINT32_C(0x20)
	/*
	 * When set to 1, then FEC CLAUSE 91 (Reed Solomon RS(528,514) for
	 * NRZ) is enabled on this port. This means that FEC RS(528,514) is
	 * either advertised if FEC autonegotiation is enabled or FEC
	 * RS(528,514) is force enabled.  When set to 0, then FEC RS(528,514)
	 * is disabled if supported.
	 * This flag should be ignored if FEC CLAUSE 91 is not supported on this port.
	 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_FEC_CFG_FEC_CLAUSE91_ENABLED	UINT32_C(0x40)
	/*
	 * When set to 1, then FEC RS544_1XN is supported on this port.
	 * When set to 0, then FEC RS544_1XN is not supported on this port.
	 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_FEC_CFG_FEC_RS544_1XN_SUPPORTED	UINT32_C(0x80)
	/*
	 * When set to 1, then RS544_1XN is enabled on this
	 * port. This means that FEC RS544_1XN is either advertised if
	 * FEC autonegotiation is enabled or FEC RS544_1XN is force enabled.
	 * When set to 0, then FEC RS544_1XN is disabled if supported.
	 * This flag should be ignored if FEC RS544_1XN is not supported on this port.
	 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_FEC_CFG_FEC_RS544_1XN_ENABLED	UINT32_C(0x100)
	/*
	 * When set to 1, then FEC RS(544,514) is supported on this port.
	 * When set to 0, then FEC RS(544,514) is not supported on this port.
	 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_FEC_CFG_FEC_RS544_IEEE_SUPPORTED	UINT32_C(0x200)
	/*
	 * When set to 1, then RS(544,514) is enabled on this
	 * port. This means that FEC RS(544,514) is either advertised if
	 * FEC autonegotiation is enabled or FEC RS(544,514) is force
	 * enabled.  When set to 0, then FEC RS(544,514) is disabled if supported.
	 * This flag should be ignored if FEC RS(544,514) is not supported on this port.
	 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_FEC_CFG_FEC_RS544_IEEE_ENABLED	UINT32_C(0x400)
	/*
	 * When set to 1, then FEC RS272_1XN is supported on this port.
	 * When set to 0, then FEC RS272_1XN is not supported on this port.
	 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_FEC_CFG_FEC_RS272_1XN_SUPPORTED	UINT32_C(0x800)
	/*
	 * When set to 1, then RS272_1XN is enabled on this
	 * port. This means that FEC RS272_1XN is either advertised if
	 * FEC autonegotiation is enabled or FEC RS272_1XN is force
	 * enabled.  When set to 0, then FEC RS272_1XN is disabled if supported.
	 * This flag should be ignored if FEC RS272_1XN is not supported on this port.
	 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_FEC_CFG_FEC_RS272_1XN_ENABLED	UINT32_C(0x1000)
	/*
	 * When set to 1, then FEC RS(272,514) is supported on this port.
	 * When set to 0, then FEC RS(272,514) is not supported on this port.
	 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_FEC_CFG_FEC_RS272_IEEE_SUPPORTED	UINT32_C(0x2000)
	/*
	 * When set to 1, then RS(272,257) is enabled on this
	 * port. This means that FEC RS(272,257) is either advertised if
	 * FEC autonegotiation is enabled or FEC RS(272,257) is force
	 * enabled.  When set to 0, then FEC RS(272,257) is disabled if supported.
	 * This flag should be ignored if FEC RS(272,257) is not supported on this port.
	 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_FEC_CFG_FEC_RS272_IEEE_ENABLED	UINT32_C(0x4000)
	/*
	 * This value is indicates the duplex of the current
	 * connection state.
	 */
	uint8_t	duplex_state;
	/* Half Duplex connection. */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_DUPLEX_STATE_HALF UINT32_C(0x0)
	/* Full duplex connection. */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_DUPLEX_STATE_FULL UINT32_C(0x1)
	#define HWRM_PORT_PHY_QCFG_OUTPUT_DUPLEX_STATE_LAST HWRM_PORT_PHY_QCFG_OUTPUT_DUPLEX_STATE_FULL
	/* Option flags fields. */
	uint8_t	option_flags;
	/* When this bit is '1', Media auto detect is enabled. */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_OPTION_FLAGS_MEDIA_AUTO_DETECT	UINT32_C(0x1)
	/*
	 * When this bit is '1', active_fec_signal_mode can be
	 * trusted.
	 */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_OPTION_FLAGS_SIGNAL_MODE_KNOWN	UINT32_C(0x2)
	/*
	 * Up to 16 bytes of null padded ASCII string representing
	 * PHY vendor.
	 * If the string is set to null, then the vendor name is not
	 * available.
	 */
	char	phy_vendor_name[16];
	/*
	 * Up to 16 bytes of null padded ASCII string that
	 * identifies vendor specific part number of the PHY.
	 * If the string is set to null, then the vendor specific
	 * part number is not available.
	 */
	char	phy_vendor_partnumber[16];
	/*
	 * The supported PAM4 speeds for the port. This is a bit mask.
	 * For each speed that is supported, the corresponding
	 * bit will be set to '1'.
	 */
	uint16_t	support_pam4_speeds;
	#define HWRM_PORT_PHY_QCFG_OUTPUT_SUPPORT_PAM4_SPEEDS_50G	UINT32_C(0x1)
	#define HWRM_PORT_PHY_QCFG_OUTPUT_SUPPORT_PAM4_SPEEDS_100G	UINT32_C(0x2)
	#define HWRM_PORT_PHY_QCFG_OUTPUT_SUPPORT_PAM4_SPEEDS_200G	UINT32_C(0x4)
	/*
	 * Current setting of forced PAM4 link speed.
	 * When the link speed is not being forced, this
	 * value shall be set to 0.
	 */
	uint16_t	force_pam4_link_speed;
	/* 50Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_FORCE_PAM4_LINK_SPEED_50GB  UINT32_C(0x1f4)
	/* 100Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_FORCE_PAM4_LINK_SPEED_100GB UINT32_C(0x3e8)
	/* 200Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_FORCE_PAM4_LINK_SPEED_200GB UINT32_C(0x7d0)
	#define HWRM_PORT_PHY_QCFG_OUTPUT_FORCE_PAM4_LINK_SPEED_LAST HWRM_PORT_PHY_QCFG_OUTPUT_FORCE_PAM4_LINK_SPEED_200GB
	/*
	 * Current setting for auto_pam4_link_speed_mask that is used to
	 * advertise speeds during autonegotiation.
	 * This field is only valid when auto_mode is set to "mask".
	 * The speeds specified in this field shall be a subset of
	 * supported speeds on this port.
	 */
	uint16_t	auto_pam4_link_speed_mask;
	#define HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_PAM4_LINK_SPEED_MASK_50G	UINT32_C(0x1)
	#define HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_PAM4_LINK_SPEED_MASK_100G	UINT32_C(0x2)
	#define HWRM_PORT_PHY_QCFG_OUTPUT_AUTO_PAM4_LINK_SPEED_MASK_200G	UINT32_C(0x4)
	/*
	 * The advertised PAM4 speeds for the port by the link partner.
	 * Each advertised speed will be set to '1'.
	 */
	uint8_t	link_partner_pam4_adv_speeds;
	/* 50Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LINK_PARTNER_PAM4_ADV_SPEEDS_50GB	UINT32_C(0x1)
	/* 100Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LINK_PARTNER_PAM4_ADV_SPEEDS_100GB	UINT32_C(0x2)
	/* 200Gb link speed */
	#define HWRM_PORT_PHY_QCFG_OUTPUT_LINK_PARTNER_PAM4_ADV_SPEEDS_200GB	UINT32_C(0x4)
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_port_phy_qcfg_output_t, *phwrm_port_phy_qcfg_output_t;

/*********************
 * hwrm_port_mac_cfg *
 *********************/


/* hwrm_port_mac_cfg_input (size:384b/48B) */

typedef struct hwrm_port_mac_cfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * In this field, there are a number of CoS mappings related flags
	 * that are used to configure CoS mappings and their corresponding
	 * priorities in the hardware.
	 * For the priorities of CoS mappings, the HWRM uses the following
	 * priority order (high to low) by default:
	 * # vlan pri
	 * # ip_dscp
	 * # tunnel_vlan_pri
	 * # default cos
	 *
	 * A subset of CoS mappings can be enabled.
	 * If a priority is not specified for an enabled CoS mapping, the
	 * priority will be assigned in the above order for the enabled CoS
	 * mappings. For example, if vlan_pri and ip_dscp CoS mappings are
	 * enabled and their priorities are not specified, the following
	 * priority order (high to low) will be used by the HWRM:
	 * # vlan_pri
	 * # ip_dscp
	 * # default cos
	 *
	 * vlan_pri CoS mapping together with default CoS with lower priority
	 * are enabled by default by the HWRM.
	 */
	uint32_t	flags;
	/*
	 * When this bit is '1', this command will configure
	 * the MAC to match the current link state of the PHY.
	 * If the link is not established on the PHY, then this
	 * bit has no effect.
	 */
	#define HWRM_PORT_MAC_CFG_INPUT_FLAGS_MATCH_LINK			UINT32_C(0x1)
	/*
	 * When this bit is set to '1', the inner VLAN PRI to CoS mapping
	 * is requested to be enabled.
	 */
	#define HWRM_PORT_MAC_CFG_INPUT_FLAGS_VLAN_PRI2COS_ENABLE	UINT32_C(0x2)
	/*
	 * When this bit is set to '1', tunnel VLAN PRI field to
	 * CoS mapping is requested to be enabled.
	 */
	#define HWRM_PORT_MAC_CFG_INPUT_FLAGS_TUNNEL_PRI2COS_ENABLE	UINT32_C(0x4)
	/*
	 * When this bit is set to '1', the IP DSCP to CoS mapping is
	 * requested to be enabled.
	 */
	#define HWRM_PORT_MAC_CFG_INPUT_FLAGS_IP_DSCP2COS_ENABLE		UINT32_C(0x8)
	/*
	 * When this bit is '1', the HWRM is requested to
	 * enable timestamp capture capability on the receive side
	 * of this port.
	 */
	#define HWRM_PORT_MAC_CFG_INPUT_FLAGS_PTP_RX_TS_CAPTURE_ENABLE	UINT32_C(0x10)
	/*
	 * When this bit is '1', the HWRM is requested to
	 * disable timestamp capture capability on the receive side
	 * of this port.
	 */
	#define HWRM_PORT_MAC_CFG_INPUT_FLAGS_PTP_RX_TS_CAPTURE_DISABLE	UINT32_C(0x20)
	/*
	 * When this bit is '1', the HWRM is requested to
	 * enable timestamp capture capability on the transmit side
	 * of this port.
	 */
	#define HWRM_PORT_MAC_CFG_INPUT_FLAGS_PTP_TX_TS_CAPTURE_ENABLE	UINT32_C(0x40)
	/*
	 * When this bit is '1', the HWRM is requested to
	 * disable timestamp capture capability on the transmit side
	 * of this port.
	 */
	#define HWRM_PORT_MAC_CFG_INPUT_FLAGS_PTP_TX_TS_CAPTURE_DISABLE	UINT32_C(0x80)
	/*
	 * When this bit is '1', the Out-Of-Box WoL is requested to
	 * be enabled on this port.
	 */
	#define HWRM_PORT_MAC_CFG_INPUT_FLAGS_OOB_WOL_ENABLE		UINT32_C(0x100)
	/*
	 * When this bit is '1', the Out-Of-Box WoL is requested to
	 * be disabled on this port.
	 */
	#define HWRM_PORT_MAC_CFG_INPUT_FLAGS_OOB_WOL_DISABLE		UINT32_C(0x200)
	/*
	 * When this bit is set to '1', the inner VLAN PRI to CoS mapping
	 * is requested to be disabled.
	 */
	#define HWRM_PORT_MAC_CFG_INPUT_FLAGS_VLAN_PRI2COS_DISABLE	UINT32_C(0x400)
	/*
	 * When this bit is set to '1', tunnel VLAN PRI field to
	 * CoS mapping is requested to be disabled.
	 */
	#define HWRM_PORT_MAC_CFG_INPUT_FLAGS_TUNNEL_PRI2COS_DISABLE	UINT32_C(0x800)
	/*
	 * When this bit is set to '1', the IP DSCP to CoS mapping is
	 * requested to be disabled.
	 */
	#define HWRM_PORT_MAC_CFG_INPUT_FLAGS_IP_DSCP2COS_DISABLE	UINT32_C(0x1000)
	/*
	 * When this bit is set to '1', and the ptp_tx_ts_capture_enable
	 * bit is set, then the device uses one step Tx timestamping.
	 * This bit is temporary and used for experimental purposes.
	 */
	#define HWRM_PORT_MAC_CFG_INPUT_FLAGS_PTP_ONE_STEP_TX_TS		UINT32_C(0x2000)
	uint32_t	enables;
	/*
	 * This bit must be '1' for the ipg field to be
	 * configured.
	 */
	#define HWRM_PORT_MAC_CFG_INPUT_ENABLES_IPG				UINT32_C(0x1)
	/*
	 * This bit must be '1' for the lpbk field to be
	 * configured.
	 */
	#define HWRM_PORT_MAC_CFG_INPUT_ENABLES_LPBK			UINT32_C(0x2)
	/*
	 * This bit must be '1' for the vlan_pri2cos_map_pri field to be
	 * configured.
	 */
	#define HWRM_PORT_MAC_CFG_INPUT_ENABLES_VLAN_PRI2COS_MAP_PRI	UINT32_C(0x4)
	/*
	 * This bit must be '1' for the tunnel_pri2cos_map_pri field to be
	 * configured.
	 */
	#define HWRM_PORT_MAC_CFG_INPUT_ENABLES_TUNNEL_PRI2COS_MAP_PRI	UINT32_C(0x10)
	/*
	 * This bit must be '1' for the dscp2cos_map_pri field to be
	 * configured.
	 */
	#define HWRM_PORT_MAC_CFG_INPUT_ENABLES_DSCP2COS_MAP_PRI		UINT32_C(0x20)
	/*
	 * This bit must be '1' for the rx_ts_capture_ptp_msg_type field to be
	 * configured.
	 */
	#define HWRM_PORT_MAC_CFG_INPUT_ENABLES_RX_TS_CAPTURE_PTP_MSG_TYPE	UINT32_C(0x40)
	/*
	 * This bit must be '1' for the tx_ts_capture_ptp_msg_type field to be
	 * configured.
	 */
	#define HWRM_PORT_MAC_CFG_INPUT_ENABLES_TX_TS_CAPTURE_PTP_MSG_TYPE	UINT32_C(0x80)
	/*
	 * This bit must be '1' for the cos_field_cfg field to be
	 * configured.
	 */
	#define HWRM_PORT_MAC_CFG_INPUT_ENABLES_COS_FIELD_CFG		UINT32_C(0x100)
	/*
	 * This bit must be '1' for the ptp_freq_adj_ppb field to be
	 * configured.
	 */
	#define HWRM_PORT_MAC_CFG_INPUT_ENABLES_PTP_FREQ_ADJ_PPB		UINT32_C(0x200)
	/* Port ID of port that is to be configured. */
	uint16_t	port_id;
	/*
	 * This value is used to configure the minimum IPG that will
	 * be sent between packets by this port.
	 */
	uint8_t	ipg;
	/* This value controls the loopback setting for the MAC. */
	uint8_t	lpbk;
	/* No loopback is selected.  Normal operation. */
	#define HWRM_PORT_MAC_CFG_INPUT_LPBK_NONE   UINT32_C(0x0)
	/*
	 * The HW will be configured with local loopback such that
	 * host data is sent back to the host without modification.
	 */
	#define HWRM_PORT_MAC_CFG_INPUT_LPBK_LOCAL  UINT32_C(0x1)
	/*
	 * The HW will be configured with remote loopback such that
	 * port logic will send packets back out the transmitter that
	 * are received.
	 */
	#define HWRM_PORT_MAC_CFG_INPUT_LPBK_REMOTE UINT32_C(0x2)
	#define HWRM_PORT_MAC_CFG_INPUT_LPBK_LAST  HWRM_PORT_MAC_CFG_INPUT_LPBK_REMOTE
	/*
	 * This value controls the priority setting of VLAN PRI to CoS
	 * mapping based on VLAN Tags of inner packet headers of
	 * tunneled packets or packet headers of non-tunneled packets.
	 *
	 * # Each XXX_pri variable shall have a unique priority value
	 * when it is being specified.
	 * # When comparing priorities of mappings, higher value
	 * indicates higher priority.
	 * For example, a value of 0-3 is returned where 0 is being
	 * the lowest priority and 3 is being the highest priority.
	 */
	uint8_t	vlan_pri2cos_map_pri;
	/* Reserved field. */
	uint8_t	reserved1;
	/*
	 * This value controls the priority setting of VLAN PRI to CoS
	 * mapping based on VLAN Tags of tunneled header.
	 * This mapping only applies when tunneled headers
	 * are present.
	 *
	 * # Each XXX_pri variable shall have a unique priority value
	 * when it is being specified.
	 * # When comparing priorities of mappings, higher value
	 * indicates higher priority.
	 * For example, a value of 0-3 is returned where 0 is being
	 * the lowest priority and 3 is being the highest priority.
	 */
	uint8_t	tunnel_pri2cos_map_pri;
	/*
	 * This value controls the priority setting of IP DSCP to CoS
	 * mapping based on inner IP header of tunneled packets or
	 * IP header of non-tunneled packets.
	 *
	 * # Each XXX_pri variable shall have a unique priority value
	 * when it is being specified.
	 * # When comparing priorities of mappings, higher value
	 * indicates higher priority.
	 * For example, a value of 0-3 is returned where 0 is being
	 * the lowest priority and 3 is being the highest priority.
	 */
	uint8_t	dscp2pri_map_pri;
	/*
	 * This is a 16-bit bit mask that is used to request a
	 * specific configuration of time stamp capture of PTP messages
	 * on the receive side of this port.
	 * This field shall be ignored if the ptp_rx_ts_capture_enable
	 * flag is not set in this command.
	 * Otherwise, if bit 'i' is set, then the HWRM is being
	 * requested to configure the receive side of the port to
	 * capture the time stamp of every received PTP message
	 * with messageType field value set to i.
	 */
	uint16_t	rx_ts_capture_ptp_msg_type;
	/*
	 * This is a 16-bit bit mask that is used to request a
	 * specific configuration of time stamp capture of PTP messages
	 * on the transmit side of this port.
	 * This field shall be ignored if the ptp_tx_ts_capture_enable
	 * flag is not set in this command.
	 * Otherwise, if bit 'i' is set, then the HWRM is being
	 * requested to configure the transmit side of the port to
	 * capture the time stamp of every transmitted PTP message
	 * with messageType field value set to i.
	 */
	uint16_t	tx_ts_capture_ptp_msg_type;
	/* Configuration of CoS fields. */
	uint8_t	cos_field_cfg;
	/* Reserved */
	#define HWRM_PORT_MAC_CFG_INPUT_COS_FIELD_CFG_RSVD1			UINT32_C(0x1)
	/*
	 * This field is used to specify selection of VLAN PRI value
	 * based on whether one or two VLAN Tags are present in
	 * the inner packet headers of tunneled packets or
	 * non-tunneled packets.
	 * This field is valid only if inner VLAN PRI to CoS mapping
	 * is enabled.
	 * If VLAN PRI to CoS mapping is not enabled, then this
	 * field shall be ignored.
	 */
	#define HWRM_PORT_MAC_CFG_INPUT_COS_FIELD_CFG_VLAN_PRI_SEL_MASK	UINT32_C(0x6)
	#define HWRM_PORT_MAC_CFG_INPUT_COS_FIELD_CFG_VLAN_PRI_SEL_SFT	1
	/*
	 * Select inner VLAN PRI when 1 or 2 VLAN Tags are
	 * present in the inner packet headers
	 */
		#define HWRM_PORT_MAC_CFG_INPUT_COS_FIELD_CFG_VLAN_PRI_SEL_INNERMOST	(UINT32_C(0x0) << 1)
	/*
	 * Select outer VLAN Tag PRI when 2 VLAN Tags are
	 * present in the inner packet headers.
	 * No VLAN PRI shall be selected for this configuration
	 * if only one VLAN Tag is present in the inner
	 * packet headers.
	 */
		#define HWRM_PORT_MAC_CFG_INPUT_COS_FIELD_CFG_VLAN_PRI_SEL_OUTER	(UINT32_C(0x1) << 1)
	/*
	 * Select outermost VLAN PRI when 1 or 2 VLAN Tags
	 * are present in the inner packet headers
	 */
		#define HWRM_PORT_MAC_CFG_INPUT_COS_FIELD_CFG_VLAN_PRI_SEL_OUTERMOST	(UINT32_C(0x2) << 1)
	/* Unspecified */
		#define HWRM_PORT_MAC_CFG_INPUT_COS_FIELD_CFG_VLAN_PRI_SEL_UNSPECIFIED	(UINT32_C(0x3) << 1)
		#define HWRM_PORT_MAC_CFG_INPUT_COS_FIELD_CFG_VLAN_PRI_SEL_LAST	HWRM_PORT_MAC_CFG_INPUT_COS_FIELD_CFG_VLAN_PRI_SEL_UNSPECIFIED
	/*
	 * This field is used to specify selection of tunnel VLAN
	 * PRI value based on whether one or two VLAN Tags are
	 * present in tunnel headers.
	 * This field is valid only if tunnel VLAN PRI to CoS mapping
	 * is enabled.
	 * If tunnel VLAN PRI to CoS mapping is not enabled, then this
	 * field shall be ignored.
	 */
	#define HWRM_PORT_MAC_CFG_INPUT_COS_FIELD_CFG_T_VLAN_PRI_SEL_MASK	UINT32_C(0x18)
	#define HWRM_PORT_MAC_CFG_INPUT_COS_FIELD_CFG_T_VLAN_PRI_SEL_SFT	3
	/*
	 * Select inner VLAN PRI when 1 or 2 VLAN Tags are
	 * present in the tunnel packet headers
	 */
		#define HWRM_PORT_MAC_CFG_INPUT_COS_FIELD_CFG_T_VLAN_PRI_SEL_INNERMOST	(UINT32_C(0x0) << 3)
	/*
	 * Select outer VLAN Tag PRI when 2 VLAN Tags are
	 * present in the tunnel packet headers.
	 * No tunnel VLAN PRI shall be selected for this
	 * configuration if only one VLAN Tag is present in
	 * the tunnel packet headers.
	 */
		#define HWRM_PORT_MAC_CFG_INPUT_COS_FIELD_CFG_T_VLAN_PRI_SEL_OUTER	(UINT32_C(0x1) << 3)
	/*
	 * Select outermost VLAN PRI when 1 or 2 VLAN Tags
	 * are present in the tunnel packet headers
	 */
		#define HWRM_PORT_MAC_CFG_INPUT_COS_FIELD_CFG_T_VLAN_PRI_SEL_OUTERMOST	(UINT32_C(0x2) << 3)
	/* Unspecified */
		#define HWRM_PORT_MAC_CFG_INPUT_COS_FIELD_CFG_T_VLAN_PRI_SEL_UNSPECIFIED  (UINT32_C(0x3) << 3)
		#define HWRM_PORT_MAC_CFG_INPUT_COS_FIELD_CFG_T_VLAN_PRI_SEL_LAST	HWRM_PORT_MAC_CFG_INPUT_COS_FIELD_CFG_T_VLAN_PRI_SEL_UNSPECIFIED
	/*
	 * This field shall be used to provide default CoS value
	 * that has been configured on this port.
	 * This field is valid only if default CoS mapping
	 * is enabled.
	 * If default CoS mapping is not enabled, then this
	 * field shall be ignored.
	 */
	#define HWRM_PORT_MAC_CFG_INPUT_COS_FIELD_CFG_DEFAULT_COS_MASK	UINT32_C(0xe0)
	#define HWRM_PORT_MAC_CFG_INPUT_COS_FIELD_CFG_DEFAULT_COS_SFT	5
	uint8_t	unused_0[3];
	/*
	 * This signed field specifies by how much to adjust the frequency
	 * of sync timer updates (measured in parts per billion).
	 */
	int32_t	ptp_freq_adj_ppb;
	uint8_t	unused_1[4];
} hwrm_port_mac_cfg_input_t, *phwrm_port_mac_cfg_input_t;

/* hwrm_port_mac_cfg_output (size:128b/16B) */

typedef struct hwrm_port_mac_cfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * This is the configured maximum length of Ethernet packet
	 * payload that is allowed to be received on the port.
	 * This value does not include the number of bytes used by
	 * Ethernet header and trailer (CRC).
	 */
	uint16_t	mru;
	/*
	 * This is the configured maximum length of Ethernet packet
	 * payload that is allowed to be transmitted on the port.
	 * This value does not include the number of bytes used by
	 * Ethernet header and trailer (CRC).
	 */
	uint16_t	mtu;
	/* Current configuration of the IPG value. */
	uint8_t	ipg;
	/* Current value of the loopback value. */
	uint8_t	lpbk;
	/* No loopback is selected.  Normal operation. */
	#define HWRM_PORT_MAC_CFG_OUTPUT_LPBK_NONE   UINT32_C(0x0)
	/*
	 * The HW will be configured with local loopback such that
	 * host data is sent back to the host without modification.
	 */
	#define HWRM_PORT_MAC_CFG_OUTPUT_LPBK_LOCAL  UINT32_C(0x1)
	/*
	 * The HW will be configured with remote loopback such that
	 * port logic will send packets back out the transmitter that
	 * are received.
	 */
	#define HWRM_PORT_MAC_CFG_OUTPUT_LPBK_REMOTE UINT32_C(0x2)
	#define HWRM_PORT_MAC_CFG_OUTPUT_LPBK_LAST  HWRM_PORT_MAC_CFG_OUTPUT_LPBK_REMOTE
	uint8_t	unused_0;
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_port_mac_cfg_output_t, *phwrm_port_mac_cfg_output_t;

/**********************
 * hwrm_port_mac_qcfg *
 **********************/


/* hwrm_port_mac_qcfg_input (size:192b/24B) */

typedef struct hwrm_port_mac_qcfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Port ID of port that is to be configured. */
	uint16_t	port_id;
	uint8_t	unused_0[6];
} hwrm_port_mac_qcfg_input_t, *phwrm_port_mac_qcfg_input_t;

/* hwrm_port_mac_qcfg_output (size:256b/32B) */

typedef struct hwrm_port_mac_qcfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * This is the configured maximum length of Ethernet packet
	 * payload that is allowed to be received on the port.
	 * This value does not include the number of bytes used by the
	 * Ethernet header and trailer (CRC).
	 */
	uint16_t	mru;
	/*
	 * This is the configured maximum length of Ethernet packet
	 * payload that is allowed to be transmitted on the port.
	 * This value does not include the number of bytes used by the
	 * Ethernet header and trailer (CRC).
	 */
	uint16_t	mtu;
	/*
	 * The minimum IPG that will
	 * be sent between packets by this port.
	 */
	uint8_t	ipg;
	/* The loopback setting for the MAC. */
	uint8_t	lpbk;
	/* No loopback is selected.  Normal operation. */
	#define HWRM_PORT_MAC_QCFG_OUTPUT_LPBK_NONE   UINT32_C(0x0)
	/*
	 * The HW will be configured with local loopback such that
	 * host data is sent back to the host without modification.
	 */
	#define HWRM_PORT_MAC_QCFG_OUTPUT_LPBK_LOCAL  UINT32_C(0x1)
	/*
	 * The HW will be configured with remote loopback such that
	 * port logic will send packets back out the transmitter that
	 * are received.
	 */
	#define HWRM_PORT_MAC_QCFG_OUTPUT_LPBK_REMOTE UINT32_C(0x2)
	#define HWRM_PORT_MAC_QCFG_OUTPUT_LPBK_LAST  HWRM_PORT_MAC_QCFG_OUTPUT_LPBK_REMOTE
	/*
	 * Priority setting for VLAN PRI to CoS mapping.
	 * # Each XXX_pri variable shall have a unique priority value
	 * when it is being used.
	 * # When comparing priorities of mappings, higher value
	 * indicates higher priority.
	 * For example, a value of 0-3 is returned where 0 is being
	 * the lowest priority and 3 is being the highest priority.
	 * # If the correspoding CoS mapping is not enabled, then this
	 * field should be ignored.
	 * # This value indicates the normalized priority value retained
	 * in the HWRM.
	 */
	uint8_t	vlan_pri2cos_map_pri;
	/*
	 * In this field, a number of CoS mappings related flags
	 * are used to indicate configured CoS mappings.
	 */
	uint8_t	flags;
	/*
	 * When this bit is set to '1', the inner VLAN PRI to CoS mapping
	 * is enabled.
	 */
	#define HWRM_PORT_MAC_QCFG_OUTPUT_FLAGS_VLAN_PRI2COS_ENABLE	UINT32_C(0x1)
	/*
	 * When this bit is set to '1', tunnel VLAN PRI field to
	 * CoS mapping is enabled.
	 */
	#define HWRM_PORT_MAC_QCFG_OUTPUT_FLAGS_TUNNEL_PRI2COS_ENABLE	UINT32_C(0x2)
	/*
	 * When this bit is set to '1', the IP DSCP to CoS mapping is
	 * enabled.
	 */
	#define HWRM_PORT_MAC_QCFG_OUTPUT_FLAGS_IP_DSCP2COS_ENABLE	UINT32_C(0x4)
	/*
	 * When this bit is '1', the Out-Of-Box WoL is enabled on this
	 * port.
	 */
	#define HWRM_PORT_MAC_QCFG_OUTPUT_FLAGS_OOB_WOL_ENABLE		UINT32_C(0x8)
	/* When this bit is '1', PTP is enabled for RX on this port. */
	#define HWRM_PORT_MAC_QCFG_OUTPUT_FLAGS_PTP_RX_TS_CAPTURE_ENABLE	UINT32_C(0x10)
	/* When this bit is '1', PTP is enabled for TX on this port. */
	#define HWRM_PORT_MAC_QCFG_OUTPUT_FLAGS_PTP_TX_TS_CAPTURE_ENABLE	UINT32_C(0x20)
	/*
	 * Priority setting for tunnel VLAN PRI to CoS mapping.
	 * # Each XXX_pri variable shall have a unique priority value
	 * when it is being used.
	 * # When comparing priorities of mappings, higher value
	 * indicates higher priority.
	 * For example, a value of 0-3 is returned where 0 is being
	 * the lowest priority and 3 is being the highest priority.
	 * # If the correspoding CoS mapping is not enabled, then this
	 * field should be ignored.
	 * # This value indicates the normalized priority value retained
	 * in the HWRM.
	 */
	uint8_t	tunnel_pri2cos_map_pri;
	/*
	 * Priority setting for DSCP to PRI mapping.
	 * # Each XXX_pri variable shall have a unique priority value
	 * when it is being used.
	 * # When comparing priorities of mappings, higher value
	 * indicates higher priority.
	 * For example, a value of 0-3 is returned where 0 is being
	 * the lowest priority and 3 is being the highest priority.
	 * # If the correspoding CoS mapping is not enabled, then this
	 * field should be ignored.
	 * # This value indicates the normalized priority value retained
	 * in the HWRM.
	 */
	uint8_t	dscp2pri_map_pri;
	/*
	 * This is a 16-bit bit mask that represents the
	 * current configuration of time stamp capture of PTP messages
	 * on the receive side of this port.
	 * If bit 'i' is set, then the receive side of the port
	 * is configured to capture the time stamp of every
	 * received PTP message with messageType field value set
	 * to i.
	 * If all bits are set to 0 (i.e. field value set 0),
	 * then the receive side of the port is not configured
	 * to capture timestamp for PTP messages.
	 * If all bits are set to 1, then the receive side of the
	 * port is configured to capture timestamp for all PTP
	 * messages.
	 */
	uint16_t	rx_ts_capture_ptp_msg_type;
	/*
	 * This is a 16-bit bit mask that represents the
	 * current configuration of time stamp capture of PTP messages
	 * on the transmit side of this port.
	 * If bit 'i' is set, then the transmit side of the port
	 * is configured to capture the time stamp of every
	 * received PTP message with messageType field value set
	 * to i.
	 * If all bits are set to 0 (i.e. field value set 0),
	 * then the transmit side of the port is not configured
	 * to capture timestamp for PTP messages.
	 * If all bits are set to 1, then the transmit side of the
	 * port is configured to capture timestamp for all PTP
	 * messages.
	 */
	uint16_t	tx_ts_capture_ptp_msg_type;
	/* Configuration of CoS fields. */
	uint8_t	cos_field_cfg;
	/* Reserved */
	#define HWRM_PORT_MAC_QCFG_OUTPUT_COS_FIELD_CFG_RSVD			UINT32_C(0x1)
	/*
	 * This field is used for selecting VLAN PRI value
	 * based on whether one or two VLAN Tags are present in
	 * the inner packet headers of tunneled packets or
	 * non-tunneled packets.
	 */
	#define HWRM_PORT_MAC_QCFG_OUTPUT_COS_FIELD_CFG_VLAN_PRI_SEL_MASK	UINT32_C(0x6)
	#define HWRM_PORT_MAC_QCFG_OUTPUT_COS_FIELD_CFG_VLAN_PRI_SEL_SFT	1
	/*
	 * Select inner VLAN PRI when 1 or 2 VLAN Tags are
	 * present in the inner packet headers
	 */
		#define HWRM_PORT_MAC_QCFG_OUTPUT_COS_FIELD_CFG_VLAN_PRI_SEL_INNERMOST	(UINT32_C(0x0) << 1)
	/*
	 * Select outer VLAN Tag PRI when 2 VLAN Tags are
	 * present in the inner packet headers.
	 * No VLAN PRI is selected for this configuration
	 * if only one VLAN Tag is present in the inner
	 * packet headers.
	 */
		#define HWRM_PORT_MAC_QCFG_OUTPUT_COS_FIELD_CFG_VLAN_PRI_SEL_OUTER	(UINT32_C(0x1) << 1)
	/*
	 * Select outermost VLAN PRI when 1 or 2 VLAN Tags
	 * are present in the inner packet headers
	 */
		#define HWRM_PORT_MAC_QCFG_OUTPUT_COS_FIELD_CFG_VLAN_PRI_SEL_OUTERMOST	(UINT32_C(0x2) << 1)
	/* Unspecified */
		#define HWRM_PORT_MAC_QCFG_OUTPUT_COS_FIELD_CFG_VLAN_PRI_SEL_UNSPECIFIED	(UINT32_C(0x3) << 1)
		#define HWRM_PORT_MAC_QCFG_OUTPUT_COS_FIELD_CFG_VLAN_PRI_SEL_LAST	HWRM_PORT_MAC_QCFG_OUTPUT_COS_FIELD_CFG_VLAN_PRI_SEL_UNSPECIFIED
	/*
	 * This field is used for selecting tunnel VLAN PRI value
	 * based on whether one or two VLAN Tags are present in
	 * the tunnel headers of tunneled packets. This selection
	 * does not apply to non-tunneled packets.
	 */
	#define HWRM_PORT_MAC_QCFG_OUTPUT_COS_FIELD_CFG_T_VLAN_PRI_SEL_MASK	UINT32_C(0x18)
	#define HWRM_PORT_MAC_QCFG_OUTPUT_COS_FIELD_CFG_T_VLAN_PRI_SEL_SFT	3
	/*
	 * Select inner VLAN PRI when 1 or 2 VLAN Tags are
	 * present in the tunnel packet headers
	 */
		#define HWRM_PORT_MAC_QCFG_OUTPUT_COS_FIELD_CFG_T_VLAN_PRI_SEL_INNERMOST	(UINT32_C(0x0) << 3)
	/*
	 * Select outer VLAN Tag PRI when 2 VLAN Tags are
	 * present in the tunnel packet headers.
	 * No VLAN PRI is selected for this configuration
	 * if only one VLAN Tag is present in the tunnel
	 * packet headers.
	 */
		#define HWRM_PORT_MAC_QCFG_OUTPUT_COS_FIELD_CFG_T_VLAN_PRI_SEL_OUTER	(UINT32_C(0x1) << 3)
	/*
	 * Select outermost VLAN PRI when 1 or 2 VLAN Tags
	 * are present in the tunnel packet headers
	 */
		#define HWRM_PORT_MAC_QCFG_OUTPUT_COS_FIELD_CFG_T_VLAN_PRI_SEL_OUTERMOST	(UINT32_C(0x2) << 3)
	/* Unspecified */
		#define HWRM_PORT_MAC_QCFG_OUTPUT_COS_FIELD_CFG_T_VLAN_PRI_SEL_UNSPECIFIED  (UINT32_C(0x3) << 3)
		#define HWRM_PORT_MAC_QCFG_OUTPUT_COS_FIELD_CFG_T_VLAN_PRI_SEL_LAST	HWRM_PORT_MAC_QCFG_OUTPUT_COS_FIELD_CFG_T_VLAN_PRI_SEL_UNSPECIFIED
	/*
	 * This field is used to provide default CoS value that
	 * has been configured on this port.
	 */
	#define HWRM_PORT_MAC_QCFG_OUTPUT_COS_FIELD_CFG_DEFAULT_COS_MASK	UINT32_C(0xe0)
	#define HWRM_PORT_MAC_QCFG_OUTPUT_COS_FIELD_CFG_DEFAULT_COS_SFT	5
	uint8_t	unused_1;
	uint16_t	port_svif_info;
	/*
	 * This field specifies the source virtual interface of the port being
	 * queried. Drivers can use this to program port svif field in the
	 * L2 context table
	 */
	#define HWRM_PORT_MAC_QCFG_OUTPUT_PORT_SVIF_INFO_PORT_SVIF_MASK	UINT32_C(0x7fff)
	#define HWRM_PORT_MAC_QCFG_OUTPUT_PORT_SVIF_INFO_PORT_SVIF_SFT	0
	/* This field specifies whether port_svif is valid or not */
	#define HWRM_PORT_MAC_QCFG_OUTPUT_PORT_SVIF_INFO_PORT_SVIF_VALID	UINT32_C(0x8000)
	uint8_t	unused_2[5];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_port_mac_qcfg_output_t, *phwrm_port_mac_qcfg_output_t;

/**************************
 * hwrm_port_mac_ptp_qcfg *
 **************************/


/* hwrm_port_mac_ptp_qcfg_input (size:192b/24B) */

typedef struct hwrm_port_mac_ptp_qcfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Port ID of port that is being queried. */
	uint16_t	port_id;
	uint8_t	unused_0[6];
} hwrm_port_mac_ptp_qcfg_input_t, *phwrm_port_mac_ptp_qcfg_input_t;

/* hwrm_port_mac_ptp_qcfg_output (size:640b/80B) */

typedef struct hwrm_port_mac_ptp_qcfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * In this field, a number of PTP related flags
	 * are used to indicate configured PTP capabilities.
	 */
	uint8_t	flags;
	/*
	 * When this bit is set to '1', the PTP related registers are
	 * directly accessible by the host.
	 */
	#define HWRM_PORT_MAC_PTP_QCFG_OUTPUT_FLAGS_DIRECT_ACCESS	UINT32_C(0x1)
	/*
	 * When this bit is set to '1', the device supports one-step
	 * Tx timestamping.
	 */
	#define HWRM_PORT_MAC_PTP_QCFG_OUTPUT_FLAGS_ONE_STEP_TX_TS	UINT32_C(0x4)
	/*
	 * When this bit is set to '1', the PTP information is accessible
	 * via HWRM commands.
	 */
	#define HWRM_PORT_MAC_PTP_QCFG_OUTPUT_FLAGS_HWRM_ACCESS	UINT32_C(0x8)
	uint8_t	unused_0[3];
	/* Offset of the PTP register for the lower 32 bits of timestamp for RX. */
	uint32_t	rx_ts_reg_off_lower;
	/* Offset of the PTP register for the upper 32 bits of timestamp for RX. */
	uint32_t	rx_ts_reg_off_upper;
	/* Offset of the PTP register for the sequence ID for RX. */
	uint32_t	rx_ts_reg_off_seq_id;
	/* Offset of the first PTP source ID for RX. */
	uint32_t	rx_ts_reg_off_src_id_0;
	/* Offset of the second PTP source ID for RX. */
	uint32_t	rx_ts_reg_off_src_id_1;
	/* Offset of the third PTP source ID for RX. */
	uint32_t	rx_ts_reg_off_src_id_2;
	/* Offset of the domain ID for RX. */
	uint32_t	rx_ts_reg_off_domain_id;
	/* Offset of the PTP FIFO register for RX. */
	uint32_t	rx_ts_reg_off_fifo;
	/* Offset of the PTP advance FIFO register for RX. */
	uint32_t	rx_ts_reg_off_fifo_adv;
	/* PTP timestamp granularity for RX. */
	uint32_t	rx_ts_reg_off_granularity;
	/* Offset of the PTP register for the lower 32 bits of timestamp for TX. */
	uint32_t	tx_ts_reg_off_lower;
	/* Offset of the PTP register for the upper 32 bits of timestamp for TX. */
	uint32_t	tx_ts_reg_off_upper;
	/* Offset of the PTP register for the sequence ID for TX. */
	uint32_t	tx_ts_reg_off_seq_id;
	/* Offset of the PTP FIFO register for TX. */
	uint32_t	tx_ts_reg_off_fifo;
	/* PTP timestamp granularity for TX. */
	uint32_t	tx_ts_reg_off_granularity;
	uint8_t	unused_1[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_port_mac_ptp_qcfg_output_t, *phwrm_port_mac_ptp_qcfg_output_t;

/* Port Tx Statistics Format */
/* tx_port_stats (size:3264b/408B) */

typedef struct tx_port_stats {
	/* Total Number of 64 Bytes frames transmitted */
	uint64_t	tx_64b_frames;
	/* Total Number of 65-127 Bytes frames transmitted */
	uint64_t	tx_65b_127b_frames;
	/* Total Number of 128-255 Bytes frames transmitted */
	uint64_t	tx_128b_255b_frames;
	/* Total Number of 256-511 Bytes frames transmitted */
	uint64_t	tx_256b_511b_frames;
	/* Total Number of 512-1023 Bytes frames transmitted */
	uint64_t	tx_512b_1023b_frames;
	/* Total Number of 1024-1518 Bytes frames transmitted */
	uint64_t	tx_1024b_1518b_frames;
	/*
	 * Total Number of each good VLAN (exludes FCS errors)
	 * frame transmitted which is 1519 to 1522 bytes in length
	 * inclusive (excluding framing bits but including FCS bytes).
	 */
	uint64_t	tx_good_vlan_frames;
	/* Total Number of 1519-2047 Bytes frames transmitted */
	uint64_t	tx_1519b_2047b_frames;
	/* Total Number of 2048-4095 Bytes frames transmitted */
	uint64_t	tx_2048b_4095b_frames;
	/* Total Number of 4096-9216 Bytes frames transmitted */
	uint64_t	tx_4096b_9216b_frames;
	/* Total Number of 9217-16383 Bytes frames transmitted */
	uint64_t	tx_9217b_16383b_frames;
	/* Total Number of good frames transmitted */
	uint64_t	tx_good_frames;
	/* Total Number of frames transmitted */
	uint64_t	tx_total_frames;
	/* Total number of unicast frames transmitted */
	uint64_t	tx_ucast_frames;
	/* Total number of multicast frames transmitted */
	uint64_t	tx_mcast_frames;
	/* Total number of broadcast frames transmitted */
	uint64_t	tx_bcast_frames;
	/* Total number of PAUSE control frames transmitted */
	uint64_t	tx_pause_frames;
	/*
	 * Total number of PFC/per-priority PAUSE
	 * control frames transmitted
	 */
	uint64_t	tx_pfc_frames;
	/* Total number of jabber frames transmitted */
	uint64_t	tx_jabber_frames;
	/* Total number of frames transmitted with FCS error */
	uint64_t	tx_fcs_err_frames;
	/* Total number of control frames transmitted */
	uint64_t	tx_control_frames;
	/* Total number of over-sized frames transmitted */
	uint64_t	tx_oversz_frames;
	/* Total number of frames with single deferral */
	uint64_t	tx_single_dfrl_frames;
	/* Total number of frames with multiple deferrals */
	uint64_t	tx_multi_dfrl_frames;
	/* Total number of frames with single collision */
	uint64_t	tx_single_coll_frames;
	/* Total number of frames with multiple collisions */
	uint64_t	tx_multi_coll_frames;
	/* Total number of frames with late collisions */
	uint64_t	tx_late_coll_frames;
	/* Total number of frames with excessive collisions */
	uint64_t	tx_excessive_coll_frames;
	/* Total number of fragmented frames transmitted */
	uint64_t	tx_frag_frames;
	/* Total number of transmit errors */
	uint64_t	tx_err;
	/* Total number of single VLAN tagged frames transmitted */
	uint64_t	tx_tagged_frames;
	/* Total number of double VLAN tagged frames transmitted */
	uint64_t	tx_dbl_tagged_frames;
	/* Total number of runt frames transmitted */
	uint64_t	tx_runt_frames;
	/* Total number of TX FIFO under runs */
	uint64_t	tx_fifo_underruns;
	/*
	 * Total number of PFC frames with PFC enabled bit for
	 * Pri 0 transmitted
	 */
	uint64_t	tx_pfc_ena_frames_pri0;
	/*
	 * Total number of PFC frames with PFC enabled bit for
	 * Pri 1 transmitted
	 */
	uint64_t	tx_pfc_ena_frames_pri1;
	/*
	 * Total number of PFC frames with PFC enabled bit for
	 * Pri 2 transmitted
	 */
	uint64_t	tx_pfc_ena_frames_pri2;
	/*
	 * Total number of PFC frames with PFC enabled bit for
	 * Pri 3 transmitted
	 */
	uint64_t	tx_pfc_ena_frames_pri3;
	/*
	 * Total number of PFC frames with PFC enabled bit for
	 * Pri 4 transmitted
	 */
	uint64_t	tx_pfc_ena_frames_pri4;
	/*
	 * Total number of PFC frames with PFC enabled bit for
	 * Pri 5 transmitted
	 */
	uint64_t	tx_pfc_ena_frames_pri5;
	/*
	 * Total number of PFC frames with PFC enabled bit for
	 * Pri 6 transmitted
	 */
	uint64_t	tx_pfc_ena_frames_pri6;
	/*
	 * Total number of PFC frames with PFC enabled bit for
	 * Pri 7 transmitted
	 */
	uint64_t	tx_pfc_ena_frames_pri7;
	/* Total number of EEE LPI Events on TX */
	uint64_t	tx_eee_lpi_events;
	/* EEE LPI Duration Counter on TX */
	uint64_t	tx_eee_lpi_duration;
	/*
	 * Total number of Link Level Flow Control (LLFC) messages
	 * transmitted
	 */
	uint64_t	tx_llfc_logical_msgs;
	/* Total number of HCFC messages transmitted */
	uint64_t	tx_hcfc_msgs;
	/* Total number of TX collisions */
	uint64_t	tx_total_collisions;
	/* Total number of transmitted bytes */
	uint64_t	tx_bytes;
	/* Total number of end-to-end HOL frames */
	uint64_t	tx_xthol_frames;
	/* Total Tx Drops per Port reported by STATS block */
	uint64_t	tx_stat_discard;
	/* Total Tx Error Drops per Port reported by STATS block */
	uint64_t	tx_stat_error;
} tx_port_stats_t, *ptx_port_stats_t;

/* Port Rx Statistics Format */
/* rx_port_stats (size:4224b/528B) */

typedef struct rx_port_stats {
	/* Total Number of 64 Bytes frames received */
	uint64_t	rx_64b_frames;
	/* Total Number of 65-127 Bytes frames received */
	uint64_t	rx_65b_127b_frames;
	/* Total Number of 128-255 Bytes frames received */
	uint64_t	rx_128b_255b_frames;
	/* Total Number of 256-511 Bytes frames received */
	uint64_t	rx_256b_511b_frames;
	/* Total Number of 512-1023 Bytes frames received */
	uint64_t	rx_512b_1023b_frames;
	/* Total Number of 1024-1518 Bytes frames received */
	uint64_t	rx_1024b_1518b_frames;
	/*
	 * Total Number of each good VLAN (exludes FCS errors)
	 * frame received which is 1519 to 1522 bytes in length
	 * inclusive (excluding framing bits but including FCS bytes).
	 */
	uint64_t	rx_good_vlan_frames;
	/* Total Number of 1519-2047 Bytes frames received */
	uint64_t	rx_1519b_2047b_frames;
	/* Total Number of 2048-4095 Bytes frames received */
	uint64_t	rx_2048b_4095b_frames;
	/* Total Number of 4096-9216 Bytes frames received */
	uint64_t	rx_4096b_9216b_frames;
	/* Total Number of 9217-16383 Bytes frames received */
	uint64_t	rx_9217b_16383b_frames;
	/* Total number of frames received */
	uint64_t	rx_total_frames;
	/* Total number of unicast frames received */
	uint64_t	rx_ucast_frames;
	/* Total number of multicast frames received */
	uint64_t	rx_mcast_frames;
	/* Total number of broadcast frames received */
	uint64_t	rx_bcast_frames;
	/* Total number of received frames with FCS error */
	uint64_t	rx_fcs_err_frames;
	/* Total number of control frames received */
	uint64_t	rx_ctrl_frames;
	/* Total number of PAUSE frames received */
	uint64_t	rx_pause_frames;
	/* Total number of PFC frames received */
	uint64_t	rx_pfc_frames;
	/*
	 * Total number of frames received with an unsupported
	 * opcode
	 */
	uint64_t	rx_unsupported_opcode_frames;
	/*
	 * Total number of frames received with an unsupported
	 * DA for pause and PFC
	 */
	uint64_t	rx_unsupported_da_pausepfc_frames;
	/* Total number of frames received with an unsupported SA */
	uint64_t	rx_wrong_sa_frames;
	/* Total number of received packets with alignment error */
	uint64_t	rx_align_err_frames;
	/* Total number of received frames with out-of-range length */
	uint64_t	rx_oor_len_frames;
	/* Total number of received frames with error termination */
	uint64_t	rx_code_err_frames;
	/*
	 * Total number of received frames with a false carrier is
	 * detected during idle, as defined by RX_ER samples active
	 * and RXD is 0xE. The event is reported along with the
	 * statistics generated on the next received frame. Only
	 * one false carrier condition can be detected and logged
	 * between frames.
	 *
	 * Carrier event, valid for 10M/100M speed modes only.
	 */
	uint64_t	rx_false_carrier_frames;
	/* Total number of over-sized frames received */
	uint64_t	rx_ovrsz_frames;
	/* Total number of jabber packets received */
	uint64_t	rx_jbr_frames;
	/* Total number of received frames with MTU error */
	uint64_t	rx_mtu_err_frames;
	/* Total number of received frames with CRC match */
	uint64_t	rx_match_crc_frames;
	/* Total number of frames received promiscuously */
	uint64_t	rx_promiscuous_frames;
	/*
	 * Total number of received frames with one or two VLAN
	 * tags
	 */
	uint64_t	rx_tagged_frames;
	/* Total number of received frames with two VLAN tags */
	uint64_t	rx_double_tagged_frames;
	/* Total number of truncated frames received */
	uint64_t	rx_trunc_frames;
	/* Total number of good frames (without errors) received */
	uint64_t	rx_good_frames;
	/*
	 * Total number of received PFC frames with transition from
	 * XON to XOFF on Pri 0
	 */
	uint64_t	rx_pfc_xon2xoff_frames_pri0;
	/*
	 * Total number of received PFC frames with transition from
	 * XON to XOFF on Pri 1
	 */
	uint64_t	rx_pfc_xon2xoff_frames_pri1;
	/*
	 * Total number of received PFC frames with transition from
	 * XON to XOFF on Pri 2
	 */
	uint64_t	rx_pfc_xon2xoff_frames_pri2;
	/*
	 * Total number of received PFC frames with transition from
	 * XON to XOFF on Pri 3
	 */
	uint64_t	rx_pfc_xon2xoff_frames_pri3;
	/*
	 * Total number of received PFC frames with transition from
	 * XON to XOFF on Pri 4
	 */
	uint64_t	rx_pfc_xon2xoff_frames_pri4;
	/*
	 * Total number of received PFC frames with transition from
	 * XON to XOFF on Pri 5
	 */
	uint64_t	rx_pfc_xon2xoff_frames_pri5;
	/*
	 * Total number of received PFC frames with transition from
	 * XON to XOFF on Pri 6
	 */
	uint64_t	rx_pfc_xon2xoff_frames_pri6;
	/*
	 * Total number of received PFC frames with transition from
	 * XON to XOFF on Pri 7
	 */
	uint64_t	rx_pfc_xon2xoff_frames_pri7;
	/*
	 * Total number of received PFC frames with PFC enabled
	 * bit for Pri 0
	 */
	uint64_t	rx_pfc_ena_frames_pri0;
	/*
	 * Total number of received PFC frames with PFC enabled
	 * bit for Pri 1
	 */
	uint64_t	rx_pfc_ena_frames_pri1;
	/*
	 * Total number of received PFC frames with PFC enabled
	 * bit for Pri 2
	 */
	uint64_t	rx_pfc_ena_frames_pri2;
	/*
	 * Total number of received PFC frames with PFC enabled
	 * bit for Pri 3
	 */
	uint64_t	rx_pfc_ena_frames_pri3;
	/*
	 * Total number of received PFC frames with PFC enabled
	 * bit for Pri 4
	 */
	uint64_t	rx_pfc_ena_frames_pri4;
	/*
	 * Total number of received PFC frames with PFC enabled
	 * bit for Pri 5
	 */
	uint64_t	rx_pfc_ena_frames_pri5;
	/*
	 * Total number of received PFC frames with PFC enabled
	 * bit for Pri 6
	 */
	uint64_t	rx_pfc_ena_frames_pri6;
	/*
	 * Total number of received PFC frames with PFC enabled
	 * bit for Pri 7
	 */
	uint64_t	rx_pfc_ena_frames_pri7;
	/* Total Number of frames received with SCH CRC error */
	uint64_t	rx_sch_crc_err_frames;
	/* Total Number of under-sized frames received */
	uint64_t	rx_undrsz_frames;
	/* Total Number of fragmented frames received */
	uint64_t	rx_frag_frames;
	/* Total number of RX EEE LPI Events */
	uint64_t	rx_eee_lpi_events;
	/* EEE LPI Duration Counter on RX */
	uint64_t	rx_eee_lpi_duration;
	/*
	 * Total number of physical type Link Level Flow Control
	 * (LLFC) messages received
	 */
	uint64_t	rx_llfc_physical_msgs;
	/*
	 * Total number of logical type Link Level Flow Control
	 * (LLFC) messages received
	 */
	uint64_t	rx_llfc_logical_msgs;
	/*
	 * Total number of logical type Link Level Flow Control
	 * (LLFC) messages received with CRC error
	 */
	uint64_t	rx_llfc_msgs_with_crc_err;
	/* Total number of HCFC messages received */
	uint64_t	rx_hcfc_msgs;
	/* Total number of HCFC messages received with CRC error */
	uint64_t	rx_hcfc_msgs_with_crc_err;
	/* Total number of received bytes */
	uint64_t	rx_bytes;
	/* Total number of bytes received in runt frames */
	uint64_t	rx_runt_bytes;
	/* Total number of runt frames received */
	uint64_t	rx_runt_frames;
	/* Total Rx Discards per Port reported by STATS block */
	uint64_t	rx_stat_discard;
	uint64_t	rx_stat_err;
} rx_port_stats_t, *prx_port_stats_t;

/********************
 * hwrm_port_qstats *
 ********************/


/* hwrm_port_qstats_input (size:320b/40B) */

typedef struct hwrm_port_qstats_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Port ID of port that is being queried. */
	uint16_t	port_id;
	uint8_t	flags;
	/* This value is not used to avoid backward compatibility issues. */
	#define HWRM_PORT_QSTATS_INPUT_FLAGS_UNUSED	UINT32_C(0x0)
	/*
	 * This bit is set to 1 when request is for a counter mask,
	 * representing the width of each of the stats counters, rather
	 * than counters themselves.
	 */
	#define HWRM_PORT_QSTATS_INPUT_FLAGS_COUNTER_MASK UINT32_C(0x1)
	#define HWRM_PORT_QSTATS_INPUT_FLAGS_LAST	HWRM_PORT_QSTATS_INPUT_FLAGS_COUNTER_MASK
	uint8_t	unused_0[5];
	/*
	 * This is the host address where
	 * Tx port statistics will be stored
	 */
	uint64_t	tx_stat_host_addr;
	/*
	 * This is the host address where
	 * Rx port statistics will be stored
	 */
	uint64_t	rx_stat_host_addr;
} hwrm_port_qstats_input_t, *phwrm_port_qstats_input_t;

/* hwrm_port_qstats_output (size:128b/16B) */

typedef struct hwrm_port_qstats_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* The size of TX port statistics block in bytes. */
	uint16_t	tx_stat_size;
	/* The size of RX port statistics block in bytes. */
	uint16_t	rx_stat_size;
	uint8_t	unused_0[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_port_qstats_output_t, *phwrm_port_qstats_output_t;

/* Port Tx Statistics extended Format */
/* tx_port_stats_ext (size:2048b/256B) */

typedef struct tx_port_stats_ext {
	/* Total number of tx bytes count on cos queue 0 */
	uint64_t	tx_bytes_cos0;
	/* Total number of tx bytes count on cos queue 1 */
	uint64_t	tx_bytes_cos1;
	/* Total number of tx bytes count on cos queue 2 */
	uint64_t	tx_bytes_cos2;
	/* Total number of tx bytes count on cos queue 3 */
	uint64_t	tx_bytes_cos3;
	/* Total number of tx bytes count on cos queue 4 */
	uint64_t	tx_bytes_cos4;
	/* Total number of tx bytes count on cos queue 5 */
	uint64_t	tx_bytes_cos5;
	/* Total number of tx bytes count on cos queue 6 */
	uint64_t	tx_bytes_cos6;
	/* Total number of tx bytes count on cos queue 7 */
	uint64_t	tx_bytes_cos7;
	/* Total number of tx packets count on cos queue 0 */
	uint64_t	tx_packets_cos0;
	/* Total number of tx packets count on cos queue 1 */
	uint64_t	tx_packets_cos1;
	/* Total number of tx packets count on cos queue 2 */
	uint64_t	tx_packets_cos2;
	/* Total number of tx packets count on cos queue 3 */
	uint64_t	tx_packets_cos3;
	/* Total number of tx packets count on cos queue 4 */
	uint64_t	tx_packets_cos4;
	/* Total number of tx packets count on cos queue 5 */
	uint64_t	tx_packets_cos5;
	/* Total number of tx packets count on cos queue 6 */
	uint64_t	tx_packets_cos6;
	/* Total number of tx packets count on cos queue 7 */
	uint64_t	tx_packets_cos7;
	/* time duration between transmitting a XON -> XOFF and a subsequent XOFF -> XON for priority 0 */
	uint64_t	pfc_pri0_tx_duration_us;
	/* Number of times, a XON -> XOFF and XOFF -> XON transitions occur for priority 0 */
	uint64_t	pfc_pri0_tx_transitions;
	/* time duration between transmitting a XON -> XOFF and a subsequent XOFF -> XON for priority 1 */
	uint64_t	pfc_pri1_tx_duration_us;
	/* Number of times, a XON -> XOFF and XOFF -> XON transitions occur for priority 1 */
	uint64_t	pfc_pri1_tx_transitions;
	/* time duration between transmitting a XON -> XOFF and a subsequent XOFF -> XON for priority 2 */
	uint64_t	pfc_pri2_tx_duration_us;
	/* Number of times, a XON -> XOFF and XOFF -> XON transitions occur for priority 2 */
	uint64_t	pfc_pri2_tx_transitions;
	/* time duration between transmitting a XON -> XOFF and a subsequent XOFF -> XON for priority 3 */
	uint64_t	pfc_pri3_tx_duration_us;
	/* Number of times, a XON -> XOFF and XOFF -> XON transitions occur for priority 3 */
	uint64_t	pfc_pri3_tx_transitions;
	/* time duration between transmitting a XON -> XOFF and a subsequent XOFF -> XON for priority 4 */
	uint64_t	pfc_pri4_tx_duration_us;
	/* Number of times, a XON -> XOFF and XOFF -> XON transitions occur for priority 4 */
	uint64_t	pfc_pri4_tx_transitions;
	/* time duration between transmitting a XON -> XOFF and a subsequent XOFF -> XON for priority 5 */
	uint64_t	pfc_pri5_tx_duration_us;
	/* Number of times, a XON -> XOFF and XOFF -> XON transitions occur for priority 5 */
	uint64_t	pfc_pri5_tx_transitions;
	/* time duration between transmitting a XON -> XOFF and a subsequent XOFF -> XON for priority 6 */
	uint64_t	pfc_pri6_tx_duration_us;
	/* Number of times, a XON -> XOFF and XOFF -> XON transitions occur for priority 6 */
	uint64_t	pfc_pri6_tx_transitions;
	/* time duration between transmitting a XON -> XOFF and a subsequent XOFF -> XON for priority 7 */
	uint64_t	pfc_pri7_tx_duration_us;
	/* Number of times, a XON -> XOFF and XOFF -> XON transitions occur for priority 7 */
	uint64_t	pfc_pri7_tx_transitions;
} tx_port_stats_ext_t, *ptx_port_stats_ext_t;

/* Port Rx Statistics extended Format */
/* rx_port_stats_ext (size:3648b/456B) */

typedef struct rx_port_stats_ext {
	/* Number of times link state changed to down */
	uint64_t	link_down_events;
	/* Number of times the idle rings with pause bit are found */
	uint64_t	continuous_pause_events;
	/* Number of times the active rings pause bit resumed back */
	uint64_t	resume_pause_events;
	/* Number of times, the ROCE cos queue PFC is disabled to avoid pause flood/burst */
	uint64_t	continuous_roce_pause_events;
	/* Number of times, the ROCE cos queue PFC is enabled back */
	uint64_t	resume_roce_pause_events;
	/* Total number of rx bytes count on cos queue 0 */
	uint64_t	rx_bytes_cos0;
	/* Total number of rx bytes count on cos queue 1 */
	uint64_t	rx_bytes_cos1;
	/* Total number of rx bytes count on cos queue 2 */
	uint64_t	rx_bytes_cos2;
	/* Total number of rx bytes count on cos queue 3 */
	uint64_t	rx_bytes_cos3;
	/* Total number of rx bytes count on cos queue 4 */
	uint64_t	rx_bytes_cos4;
	/* Total number of rx bytes count on cos queue 5 */
	uint64_t	rx_bytes_cos5;
	/* Total number of rx bytes count on cos queue 6 */
	uint64_t	rx_bytes_cos6;
	/* Total number of rx bytes count on cos queue 7 */
	uint64_t	rx_bytes_cos7;
	/* Total number of rx packets count on cos queue 0 */
	uint64_t	rx_packets_cos0;
	/* Total number of rx packets count on cos queue 1 */
	uint64_t	rx_packets_cos1;
	/* Total number of rx packets count on cos queue 2 */
	uint64_t	rx_packets_cos2;
	/* Total number of rx packets count on cos queue 3 */
	uint64_t	rx_packets_cos3;
	/* Total number of rx packets count on cos queue 4 */
	uint64_t	rx_packets_cos4;
	/* Total number of rx packets count on cos queue 5 */
	uint64_t	rx_packets_cos5;
	/* Total number of rx packets count on cos queue 6 */
	uint64_t	rx_packets_cos6;
	/* Total number of rx packets count on cos queue 7 */
	uint64_t	rx_packets_cos7;
	/* time duration receiving a XON -> XOFF and a subsequent XOFF -> XON for priority 0 */
	uint64_t	pfc_pri0_rx_duration_us;
	/* Number of times, a XON -> XOFF and XOFF -> XON transitions occur for priority 0 */
	uint64_t	pfc_pri0_rx_transitions;
	/* time duration receiving a XON -> XOFF and a subsequent XOFF -> XON for priority 1 */
	uint64_t	pfc_pri1_rx_duration_us;
	/* Number of times, a XON -> XOFF and XOFF -> XON transitions occur for priority 1 */
	uint64_t	pfc_pri1_rx_transitions;
	/* time duration receiving a XON -> XOFF and a subsequent XOFF -> XON for priority 2 */
	uint64_t	pfc_pri2_rx_duration_us;
	/* Number of times, a XON -> XOFF and XOFF -> XON transitions occur for priority 2 */
	uint64_t	pfc_pri2_rx_transitions;
	/* time duration receiving a XON -> XOFF and a subsequent XOFF -> XON for priority 3 */
	uint64_t	pfc_pri3_rx_duration_us;
	/* Number of times, a XON -> XOFF and XOFF -> XON transitions occur for priority 3 */
	uint64_t	pfc_pri3_rx_transitions;
	/* time duration receiving a XON -> XOFF and a subsequent XOFF -> XON for priority 4 */
	uint64_t	pfc_pri4_rx_duration_us;
	/* Number of times, a XON -> XOFF and XOFF -> XON transitions occur for priority 4 */
	uint64_t	pfc_pri4_rx_transitions;
	/* time duration receiving a XON -> XOFF and a subsequent XOFF -> XON for priority 5 */
	uint64_t	pfc_pri5_rx_duration_us;
	/* Number of times, a XON -> XOFF and XOFF -> XON transitions occur for priority 5 */
	uint64_t	pfc_pri5_rx_transitions;
	/* time duration receiving a XON -> XOFF and a subsequent XOFF -> XON for priority 6 */
	uint64_t	pfc_pri6_rx_duration_us;
	/* Number of times, a XON -> XOFF and XOFF -> XON transitions occur for priority 6 */
	uint64_t	pfc_pri6_rx_transitions;
	/* time duration receiving a XON -> XOFF and a subsequent XOFF -> XON for priority 7 */
	uint64_t	pfc_pri7_rx_duration_us;
	/* Number of times, a XON -> XOFF and XOFF -> XON transitions occur for priority 7 */
	uint64_t	pfc_pri7_rx_transitions;
	/* Total number of received bits */
	uint64_t	rx_bits;
	/* The number of events where the port receive buffer was over 85% full */
	uint64_t	rx_buffer_passed_threshold;
	/*
	 * The number of symbol errors that wasn't corrected by FEC correction
	 * alogirithm
	 */
	uint64_t	rx_pcs_symbol_err;
	/* The number of corrected bits on the port according to active FEC */
	uint64_t	rx_corrected_bits;
	/* Total number of rx discard bytes count on cos queue 0 */
	uint64_t	rx_discard_bytes_cos0;
	/* Total number of rx discard bytes count on cos queue 1 */
	uint64_t	rx_discard_bytes_cos1;
	/* Total number of rx discard bytes count on cos queue 2 */
	uint64_t	rx_discard_bytes_cos2;
	/* Total number of rx discard bytes count on cos queue 3 */
	uint64_t	rx_discard_bytes_cos3;
	/* Total number of rx discard bytes count on cos queue 4 */
	uint64_t	rx_discard_bytes_cos4;
	/* Total number of rx discard bytes count on cos queue 5 */
	uint64_t	rx_discard_bytes_cos5;
	/* Total number of rx discard bytes count on cos queue 6 */
	uint64_t	rx_discard_bytes_cos6;
	/* Total number of rx discard bytes count on cos queue 7 */
	uint64_t	rx_discard_bytes_cos7;
	/* Total number of rx discard packets count on cos queue 0 */
	uint64_t	rx_discard_packets_cos0;
	/* Total number of rx discard packets count on cos queue 1 */
	uint64_t	rx_discard_packets_cos1;
	/* Total number of rx discard packets count on cos queue 2 */
	uint64_t	rx_discard_packets_cos2;
	/* Total number of rx discard packets count on cos queue 3 */
	uint64_t	rx_discard_packets_cos3;
	/* Total number of rx discard packets count on cos queue 4 */
	uint64_t	rx_discard_packets_cos4;
	/* Total number of rx discard packets count on cos queue 5 */
	uint64_t	rx_discard_packets_cos5;
	/* Total number of rx discard packets count on cos queue 6 */
	uint64_t	rx_discard_packets_cos6;
	/* Total number of rx discard packets count on cos queue 7 */
	uint64_t	rx_discard_packets_cos7;
} rx_port_stats_ext_t, *prx_port_stats_ext_t;

/*
 * Port Rx Statistics extended PFC WatchDog Format.
 * StormDetect and StormRevert event determination is based
 * on an integration period and a percentage threshold.
 * StormDetect event - when percentage of XOFF frames received
 * within an integration period exceeds the configured threshold.
 * StormRevert event - when percentage of XON frames received
 * within an integration period exceeds the configured threshold.
 * Actual number of XOFF/XON frames for the events to be triggered
 * depends on both configured integration period and sampling rate.
 * The statistics in this structure represent counts of specified
 * events from the moment the feature (PFC WatchDog) is enabled via
 * hwrm_queue_pfc_enable_cfg call.
 */
/* rx_port_stats_ext_pfc_wd (size:5120b/640B) */

typedef struct rx_port_stats_ext_pfc_wd {
	/*
	 * Total number of PFC WatchDog StormDetect events detected
	 * for Pri 0
	 */
	uint64_t	rx_pfc_watchdog_storms_detected_pri0;
	/*
	 * Total number of PFC WatchDog StormDetect events detected
	 * for Pri 1
	 */
	uint64_t	rx_pfc_watchdog_storms_detected_pri1;
	/*
	 * Total number of PFC WatchDog StormDetect events detected
	 * for Pri 2
	 */
	uint64_t	rx_pfc_watchdog_storms_detected_pri2;
	/*
	 * Total number of PFC WatchDog StormDetect events detected
	 * for Pri 3
	 */
	uint64_t	rx_pfc_watchdog_storms_detected_pri3;
	/*
	 * Total number of PFC WatchDog StormDetect events detected
	 * for Pri 4
	 */
	uint64_t	rx_pfc_watchdog_storms_detected_pri4;
	/*
	 * Total number of PFC WatchDog StormDetect events detected
	 * for Pri 5
	 */
	uint64_t	rx_pfc_watchdog_storms_detected_pri5;
	/*
	 * Total number of PFC WatchDog StormDetect events detected
	 * for Pri 6
	 */
	uint64_t	rx_pfc_watchdog_storms_detected_pri6;
	/*
	 * Total number of PFC WatchDog StormDetect events detected
	 * for Pri 7
	 */
	uint64_t	rx_pfc_watchdog_storms_detected_pri7;
	/*
	 * Total number of PFC WatchDog StormRevert events detected
	 * for Pri 0
	 */
	uint64_t	rx_pfc_watchdog_storms_reverted_pri0;
	/*
	 * Total number of PFC WatchDog StormRevert events detected
	 * for Pri 1
	 */
	uint64_t	rx_pfc_watchdog_storms_reverted_pri1;
	/*
	 * Total number of PFC WatchDog StormRevert events detected
	 * for Pri 2
	 */
	uint64_t	rx_pfc_watchdog_storms_reverted_pri2;
	/*
	 * Total number of PFC WatchDog StormRevert events detected
	 * for Pri 3
	 */
	uint64_t	rx_pfc_watchdog_storms_reverted_pri3;
	/*
	 * Total number of PFC WatchDog StormRevert events detected
	 * for Pri 4
	 */
	uint64_t	rx_pfc_watchdog_storms_reverted_pri4;
	/*
	 * Total number of PFC WatchDog StormRevert events detected
	 * for Pri 5
	 */
	uint64_t	rx_pfc_watchdog_storms_reverted_pri5;
	/*
	 * Total number of PFC WatchDog StormRevert events detected
	 * for Pri 6
	 */
	uint64_t	rx_pfc_watchdog_storms_reverted_pri6;
	/*
	 * Total number of PFC WatchDog StormRevert events detected
	 * for Pri 7
	 */
	uint64_t	rx_pfc_watchdog_storms_reverted_pri7;
	/*
	 * Total number of packets received during PFC watchdog storm
	 * for pri 0
	 */
	uint64_t	rx_pfc_watchdog_storms_rx_packets_pri0;
	/*
	 * Total number of packets received during PFC watchdog storm
	 * for pri 1
	 */
	uint64_t	rx_pfc_watchdog_storms_rx_packets_pri1;
	/*
	 * Total number of packets received during PFC watchdog storm
	 *  for pri 2
	 */
	uint64_t	rx_pfc_watchdog_storms_rx_packets_pri2;
	/*
	 * Total number of packets received during PFC watchdog storm
	 *  for pri 3
	 */
	uint64_t	rx_pfc_watchdog_storms_rx_packets_pri3;
	/*
	 * Total number of packets received during PFC watchdog storm
	 *  for pri 4
	 */
	uint64_t	rx_pfc_watchdog_storms_rx_packets_pri4;
	/*
	 * Total number of packets received during PFC watchdog storm
	 *  for pri 5
	 */
	uint64_t	rx_pfc_watchdog_storms_rx_packets_pri5;
	/*
	 * Total number of packets received during PFC watchdog storm
	 *  for pri 6
	 */
	uint64_t	rx_pfc_watchdog_storms_rx_packets_pri6;
	/*
	 * Total number of packets received during PFC watchdog storm
	 *  for pri 7
	 */
	uint64_t	rx_pfc_watchdog_storms_rx_packets_pri7;
	/*
	 * Total number of bytes received during PFC watchdog storm
	 * for pri 0
	 */
	uint64_t	rx_pfc_watchdog_storms_rx_bytes_pri0;
	/*
	 * Total number of bytes received during PFC watchdog storm
	 * for pri 1
	 */
	uint64_t	rx_pfc_watchdog_storms_rx_bytes_pri1;
	/*
	 * Total number of bytes received during PFC watchdog storm
	 *  for pri 2
	 */
	uint64_t	rx_pfc_watchdog_storms_rx_bytes_pri2;
	/*
	 * Total number of bytes received during PFC watchdog storm
	 *  for pri 3
	 */
	uint64_t	rx_pfc_watchdog_storms_rx_bytes_pri3;
	/*
	 * Total number of bytes received during PFC watchdog storm
	 *  for pri 4
	 */
	uint64_t	rx_pfc_watchdog_storms_rx_bytes_pri4;
	/*
	 * Total number of bytes received during PFC watchdog storm
	 *  for pri 5
	 */
	uint64_t	rx_pfc_watchdog_storms_rx_bytes_pri5;
	/*
	 * Total number of bytes received during PFC watchdog storm
	 *  for pri 6
	 */
	uint64_t	rx_pfc_watchdog_storms_rx_bytes_pri6;
	/*
	 * Total number of bytes received during PFC watchdog storm
	 *  for pri 7
	 */
	uint64_t	rx_pfc_watchdog_storms_rx_bytes_pri7;
	/*
	 * Total number of packets dropped on rx during PFC watchdog storm
	 * for pri 0
	 */
	uint64_t	rx_pfc_watchdog_storms_rx_packets_dropped_pri0;
	/*
	 * Total number of packets dropped on rx during PFC watchdog storm
	 * for pri 1
	 */
	uint64_t	rx_pfc_watchdog_storms_rx_packets_dropped_pri1;
	/*
	 * Total number of packets dropped on rx during PFC watchdog storm
	 *  for pri 2
	 */
	uint64_t	rx_pfc_watchdog_storms_rx_packets_dropped_pri2;
	/*
	 * Total number of packets dropped on rx during PFC watchdog storm
	 *  for pri 3
	 */
	uint64_t	rx_pfc_watchdog_storms_rx_packets_dropped_pri3;
	/*
	 * Total number of packets dropped on rx during PFC watchdog storm
	 *  for pri 4
	 */
	uint64_t	rx_pfc_watchdog_storms_rx_packets_dropped_pri4;
	/*
	 * Total number of packets dropped on rx during PFC watchdog storm
	 *  for pri 5
	 */
	uint64_t	rx_pfc_watchdog_storms_rx_packets_dropped_pri5;
	/*
	 * Total number of packets dropped on rx during PFC watchdog storm
	 *  for pri 6
	 */
	uint64_t	rx_pfc_watchdog_storms_rx_packets_dropped_pri6;
	/*
	 * Total number of packets dropped on rx during PFC watchdog storm
	 *  for pri 7
	 */
	uint64_t	rx_pfc_watchdog_storms_rx_packets_dropped_pri7;
	/*
	 * Total number of bytes dropped on rx during PFC watchdog storm
	 * for pri 0
	 */
	uint64_t	rx_pfc_watchdog_storms_rx_bytes_dropped_pri0;
	/*
	 * Total number of bytes dropped on rx during PFC watchdog storm
	 * for pri 1
	 */
	uint64_t	rx_pfc_watchdog_storms_rx_bytes_dropped_pri1;
	/*
	 * Total number of bytes dropped on rx during PFC watchdog storm
	 *  for pri 2
	 */
	uint64_t	rx_pfc_watchdog_storms_rx_bytes_dropped_pri2;
	/*
	 * Total number of bytes dropped on rx during PFC watchdog storm
	 *  for pri 3
	 */
	uint64_t	rx_pfc_watchdog_storms_rx_bytes_dropped_pri3;
	/*
	 * Total number of bytes dropped on rx during PFC watchdog storm
	 *  for pri 4
	 */
	uint64_t	rx_pfc_watchdog_storms_rx_bytes_dropped_pri4;
	/*
	 * Total number of bytes dropped on rx during PFC watchdog storm
	 *  for pri 5
	 */
	uint64_t	rx_pfc_watchdog_storms_rx_bytes_dropped_pri5;
	/*
	 * Total number of bytes dropped on rx during PFC watchdog storm
	 *  for pri 6
	 */
	uint64_t	rx_pfc_watchdog_storms_rx_bytes_dropped_pri6;
	/*
	 * Total number of bytes dropped on rx during PFC watchdog storm
	 *  for pri 7
	 */
	uint64_t	rx_pfc_watchdog_storms_rx_bytes_dropped_pri7;
	/*
	 * Number of packets received during last PFC watchdog storm
	 * for pri 0
	 */
	uint64_t	rx_pfc_watchdog_last_storm_rx_packets_pri0;
	/*
	 * Number of packets received during last PFC watchdog storm
	 * for pri 1
	 */
	uint64_t	rx_pfc_watchdog_last_storm_rx_packets_pri1;
	/*
	 * Number of packets received during last PFC watchdog storm
	 *  for pri 2
	 */
	uint64_t	rx_pfc_watchdog_last_storm_rx_packets_pri2;
	/*
	 * Number of packets received during last PFC watchdog storm
	 *  for pri 3
	 */
	uint64_t	rx_pfc_watchdog_last_storm_rx_packets_pri3;
	/*
	 * Number of packets received during last PFC watchdog storm
	 *  for pri 4
	 */
	uint64_t	rx_pfc_watchdog_last_storm_rx_packets_pri4;
	/*
	 * Number of packets received during last PFC watchdog storm
	 *  for pri 5
	 */
	uint64_t	rx_pfc_watchdog_last_storm_rx_packets_pri5;
	/*
	 * Number of packets received during last PFC watchdog storm
	 *  for pri 6
	 */
	uint64_t	rx_pfc_watchdog_last_storm_rx_packets_pri6;
	/*
	 * Number of packets received during last PFC watchdog storm
	 *  for pri 7
	 */
	uint64_t	rx_pfc_watchdog_last_storm_rx_packets_pri7;
	/*
	 * Number of bytes received during last PFC watchdog storm
	 * for pri 0
	 */
	uint64_t	rx_pfc_watchdog_last_storm_rx_bytes_pri0;
	/*
	 * Number of bytes received during last PFC watchdog storm
	 * for pri 1
	 */
	uint64_t	rx_pfc_watchdog_last_storm_rx_bytes_pri1;
	/*
	 * Number of bytes received during last PFC watchdog storm
	 *  for pri 2
	 */
	uint64_t	rx_pfc_watchdog_last_storm_rx_bytes_pri2;
	/*
	 * Number of bytes received during last PFC watchdog storm
	 *  for pri 3
	 */
	uint64_t	rx_pfc_watchdog_last_storm_rx_bytes_pri3;
	/*
	 * Number of bytes received during last PFC watchdog storm
	 *  for pri 4
	 */
	uint64_t	rx_pfc_watchdog_last_storm_rx_bytes_pri4;
	/*
	 * Number of bytes received during last PFC watchdog storm
	 *  for pri 5
	 */
	uint64_t	rx_pfc_watchdog_last_storm_rx_bytes_pri5;
	/*
	 * Number of bytes received during last PFC watchdog storm
	 *  for pri 6
	 */
	uint64_t	rx_pfc_watchdog_last_storm_rx_bytes_pri6;
	/*
	 * Number of bytes received during last PFC watchdog storm
	 *  for pri 7
	 */
	uint64_t	rx_pfc_watchdog_last_storm_rx_bytes_pri7;
	/*
	 * Number of packets dropped on rx during last PFC watchdog storm
	 * for pri 0
	 */
	uint64_t	rx_pfc_watchdog_last_storm_rx_packets_dropped_pri0;
	/*
	 * Number of packets dropped on rx during last PFC watchdog storm
	 * for pri 1
	 */
	uint64_t	rx_pfc_watchdog_last_storm_rx_packets_dropped_pri1;
	/*
	 * Number of packets dropped on rx during last PFC watchdog storm
	 *  for pri 2
	 */
	uint64_t	rx_pfc_watchdog_last_storm_rx_packets_dropped_pri2;
	/*
	 * Number of packets dropped on rx during last PFC watchdog storm
	 *  for pri 3
	 */
	uint64_t	rx_pfc_watchdog_last_storm_rx_packets_dropped_pri3;
	/*
	 * Number of packets dropped on rx during last PFC watchdog storm
	 *  for pri 4
	 */
	uint64_t	rx_pfc_watchdog_last_storm_rx_packets_dropped_pri4;
	/*
	 * Number of packets dropped on rx during last PFC watchdog storm
	 *  for pri 5
	 */
	uint64_t	rx_pfc_watchdog_last_storm_rx_packets_dropped_pri5;
	/*
	 * Number of packets dropped on rx during last PFC watchdog storm
	 *  for pri 6
	 */
	uint64_t	rx_pfc_watchdog_last_storm_rx_packets_dropped_pri6;
	/*
	 * Number of packets dropped on rx during last PFC watchdog storm
	 *  for pri 7
	 */
	uint64_t	rx_pfc_watchdog_last_storm_rx_packets_dropped_pri7;
	/*
	 * Total number of bytes dropped on rx during PFC watchdog storm
	 * for pri 0
	 */
	uint64_t	rx_pfc_watchdog_last_storm_rx_bytes_dropped_pri0;
	/*
	 * Number of bytes dropped on rx during last PFC watchdog storm
	 * for pri 1
	 */
	uint64_t	rx_pfc_watchdog_last_storm_rx_bytes_dropped_pri1;
	/*
	 * Number of bytes dropped on rx during last PFC watchdog storm
	 *  for pri 2
	 */
	uint64_t	rx_pfc_watchdog_last_storm_rx_bytes_dropped_pri2;
	/*
	 * Number of bytes dropped on rx during last PFC watchdog storm
	 *  for pri 3
	 */
	uint64_t	rx_pfc_watchdog_last_storm_rx_bytes_dropped_pri3;
	/*
	 * Number of bytes dropped on rx during last PFC watchdog storm
	 *  for pri 4
	 */
	uint64_t	rx_pfc_watchdog_last_storm_rx_bytes_dropped_pri4;
	/*
	 * Number of bytes dropped on rx during last PFC watchdog storm
	 *  for pri 5
	 */
	uint64_t	rx_pfc_watchdog_last_storm_rx_bytes_dropped_pri5;
	/*
	 * Number of bytes dropped on rx during last PFC watchdog storm
	 *  for pri 6
	 */
	uint64_t	rx_pfc_watchdog_last_storm_rx_bytes_dropped_pri6;
	/*
	 * Number of bytes dropped on rx during last PFC watchdog storm
	 *  for pri 7
	 */
	uint64_t	rx_pfc_watchdog_last_storm_rx_bytes_dropped_pri7;
} rx_port_stats_ext_pfc_wd_t, *prx_port_stats_ext_pfc_wd_t;

/************************
 * hwrm_port_qstats_ext *
 ************************/


/* hwrm_port_qstats_ext_input (size:320b/40B) */

typedef struct hwrm_port_qstats_ext_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Port ID of port that is being queried. */
	uint16_t	port_id;
	/*
	 * The size of TX port extended
	 * statistics block in bytes.
	 */
	uint16_t	tx_stat_size;
	/*
	 * The size of RX port extended
	 * statistics block in bytes
	 */
	uint16_t	rx_stat_size;
	uint8_t	flags;
	/* This value is not used to avoid backward compatibility issues. */
	#define HWRM_PORT_QSTATS_EXT_INPUT_FLAGS_UNUSED	UINT32_C(0x0)
	/*
	 * This bit is set to 1 when request is for the counter mask,
	 * representing width of each of the stats counters, rather than
	 * counters themselves.
	 */
	#define HWRM_PORT_QSTATS_EXT_INPUT_FLAGS_COUNTER_MASK UINT32_C(0x1)
	#define HWRM_PORT_QSTATS_EXT_INPUT_FLAGS_LAST	HWRM_PORT_QSTATS_EXT_INPUT_FLAGS_COUNTER_MASK
	uint8_t	unused_0;
	/*
	 * This is the host address where
	 * Tx port statistics will be stored
	 */
	uint64_t	tx_stat_host_addr;
	/*
	 * This is the host address where
	 * Rx port statistics will be stored
	 */
	uint64_t	rx_stat_host_addr;
} hwrm_port_qstats_ext_input_t, *phwrm_port_qstats_ext_input_t;

/* hwrm_port_qstats_ext_output (size:128b/16B) */

typedef struct hwrm_port_qstats_ext_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* The size of TX port statistics block in bytes. */
	uint16_t	tx_stat_size;
	/* The size of RX port statistics block in bytes. */
	uint16_t	rx_stat_size;
	/* Total number of active cos queues available. */
	uint16_t	total_active_cos_queues;
	uint8_t	flags;
	/*
	 * If set to 1, then this field indicates that clear
	 * roce specific counters is supported.
	 */
	#define HWRM_PORT_QSTATS_EXT_OUTPUT_FLAGS_CLEAR_ROCE_COUNTERS_SUPPORTED	UINT32_C(0x1)
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_port_qstats_ext_output_t, *phwrm_port_qstats_ext_output_t;

/*******************************
 * hwrm_port_qstats_ext_pfc_wd *
 *******************************/


/* hwrm_port_qstats_ext_pfc_wd_input (size:256b/32B) */

typedef struct hwrm_port_qstats_ext_pfc_wd_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Port ID of port that is being queried. */
	uint16_t	port_id;
	/*
	 * The size of rx_port_stats_ext_pfc_wd
	 * block in bytes
	 */
	uint16_t	pfc_wd_stat_size;
	uint8_t	unused_0[4];
	/*
	 * This is the host address where
	 * rx_port_stats_ext_pfc_wd will be stored
	 */
	uint64_t	pfc_wd_stat_host_addr;
} hwrm_port_qstats_ext_pfc_wd_input_t, *phwrm_port_qstats_ext_pfc_wd_input_t;

/* hwrm_port_qstats_ext_pfc_wd_output (size:128b/16B) */

typedef struct hwrm_port_qstats_ext_pfc_wd_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * The size of rx_port_stats_ext_pfc_wd
	 * statistics block in bytes.
	 */
	uint16_t	pfc_wd_stat_size;
	uint8_t	flags;
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
	uint8_t	unused_0[4];
} hwrm_port_qstats_ext_pfc_wd_output_t, *phwrm_port_qstats_ext_pfc_wd_output_t;

/*************************
 * hwrm_port_lpbk_qstats *
 *************************/


/* hwrm_port_lpbk_qstats_input (size:128b/16B) */

typedef struct hwrm_port_lpbk_qstats_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
} hwrm_port_lpbk_qstats_input_t, *phwrm_port_lpbk_qstats_input_t;

/* hwrm_port_lpbk_qstats_output (size:768b/96B) */

typedef struct hwrm_port_lpbk_qstats_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Number of transmitted unicast frames */
	uint64_t	lpbk_ucast_frames;
	/* Number of transmitted multicast frames */
	uint64_t	lpbk_mcast_frames;
	/* Number of transmitted broadcast frames */
	uint64_t	lpbk_bcast_frames;
	/* Number of transmitted bytes for unicast traffic */
	uint64_t	lpbk_ucast_bytes;
	/* Number of transmitted bytes for multicast traffic */
	uint64_t	lpbk_mcast_bytes;
	/* Number of transmitted bytes for broadcast traffic */
	uint64_t	lpbk_bcast_bytes;
	/* Total Tx Drops for loopback traffic reported by STATS block */
	uint64_t	tx_stat_discard;
	/* Total Tx Error Drops for loopback traffic reported by STATS block */
	uint64_t	tx_stat_error;
	/* Total Rx Drops for loopback traffic reported by STATS block */
	uint64_t	rx_stat_discard;
	/* Total Rx Error Drops for loopback traffic reported by STATS block */
	uint64_t	rx_stat_error;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_port_lpbk_qstats_output_t, *phwrm_port_lpbk_qstats_output_t;

/************************
 * hwrm_port_ecn_qstats *
 ************************/


/* hwrm_port_ecn_qstats_input (size:256b/32B) */

typedef struct hwrm_port_ecn_qstats_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * Port ID of port that is being queried. Unused if NIC is in
	 * multi-host mode.
	 */
	uint16_t	port_id;
	/*
	 * Size of the DMA buffer the caller has allocated for the firmware to
	 * write into.
	 */
	uint16_t	ecn_stat_buf_size;
	uint8_t	flags;
	/* This value is not used to avoid backward compatibility issues. */
	#define HWRM_PORT_ECN_QSTATS_INPUT_FLAGS_UNUSED	UINT32_C(0x0)
	/*
	 * This bit is set to 1 when request is for a counter mask,
	 * representing the width of each of the stats counters, rather
	 * than counters themselves.
	 */
	#define HWRM_PORT_ECN_QSTATS_INPUT_FLAGS_COUNTER_MASK UINT32_C(0x1)
	#define HWRM_PORT_ECN_QSTATS_INPUT_FLAGS_LAST	HWRM_PORT_ECN_QSTATS_INPUT_FLAGS_COUNTER_MASK
	uint8_t	unused_0[3];
	/*
	 * This is the host address where
	 * ECN port statistics will be stored
	 */
	uint64_t	ecn_stat_host_addr;
} hwrm_port_ecn_qstats_input_t, *phwrm_port_ecn_qstats_input_t;

/* hwrm_port_ecn_qstats_output (size:128b/16B) */

typedef struct hwrm_port_ecn_qstats_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Number of bytes of stats the firmware wrote to the DMA buffer. */
	uint16_t	ecn_stat_buf_size;
	/*
	 * Bitmask that indicates which CoS queues have ECN marking enabled.
	 * Bit i corresponds to CoS queue i.
	 */
	uint8_t	mark_en;
	uint8_t	unused_0[4];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_port_ecn_qstats_output_t, *phwrm_port_ecn_qstats_output_t;

/* ECN mark statistics format */
/* port_stats_ecn (size:512b/64B) */

typedef struct port_stats_ecn {
	/*
	 * Number of packets marked in CoS queue 0.
	 * Or, if the driver requested counter masks, a mask to indicate the size
	 * of the counter.
	 */
	uint64_t	mark_cnt_cos0;
	/*
	 * Number of packets marked in CoS queue 1.
	 * Or, if the driver requested counter masks, a mask to indicate the size
	 * of the counter.
	 */
	uint64_t	mark_cnt_cos1;
	/*
	 * Number of packets marked in CoS queue 2.
	 * Or, if the driver requested counter masks, a mask to indicate the size
	 * of the counter.
	 */
	uint64_t	mark_cnt_cos2;
	/*
	 * Number of packets marked in CoS queue 3.
	 * Or, if the driver requested counter masks, a mask to indicate the size
	 * of the counter.
	 */
	uint64_t	mark_cnt_cos3;
	/*
	 * Number of packets marked in CoS queue 4.
	 * Or, if the driver requested counter masks, a mask to indicate the size
	 * of the counter.
	 */
	uint64_t	mark_cnt_cos4;
	/*
	 * Number of packets marked in CoS queue 5.
	 * Or, if the driver requested counter masks, a mask to indicate the size
	 * of the counter.
	 */
	uint64_t	mark_cnt_cos5;
	/*
	 * Number of packets marked in CoS queue 6.
	 * Or, if the driver requested counter masks, a mask to indicate the size
	 * of the counter.
	 */
	uint64_t	mark_cnt_cos6;
	/*
	 * Number of packets marked in CoS queue 7.
	 * Or, if the driver requested counter masks, a mask to indicate the size
	 * of the counter.
	 */
	uint64_t	mark_cnt_cos7;
} port_stats_ecn_t, *pport_stats_ecn_t;

/***********************
 * hwrm_port_clr_stats *
 ***********************/


/* hwrm_port_clr_stats_input (size:192b/24B) */

typedef struct hwrm_port_clr_stats_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Port ID of port that is being queried. */
	uint16_t	port_id;
	uint8_t	flags;
	/*
	 * If set to 1, then this field indicates clear the following RoCE
	 * specific counters.
	 * RoCE associated TX/RX cos counters
	 * CNP associated TX/RX cos counters
	 * RoCE/CNP specific TX/RX flow counters
	 * Firmware will determine the RoCE/CNP cos queue based on qos profile.
	 * This flag is honored only when RoCE is enabled on that port.
	 */
	#define HWRM_PORT_CLR_STATS_INPUT_FLAGS_ROCE_COUNTERS	UINT32_C(0x1)
	uint8_t	unused_0[5];
} hwrm_port_clr_stats_input_t, *phwrm_port_clr_stats_input_t;

/* hwrm_port_clr_stats_output (size:128b/16B) */

typedef struct hwrm_port_clr_stats_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_port_clr_stats_output_t, *phwrm_port_clr_stats_output_t;

/***********************
 * hwrm_port_phy_qcaps *
 ***********************/


/* hwrm_port_phy_qcaps_input (size:192b/24B) */

typedef struct hwrm_port_phy_qcaps_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Port ID of port that is being queried. */
	uint16_t	port_id;
	uint8_t	unused_0[6];
} hwrm_port_phy_qcaps_input_t, *phwrm_port_phy_qcaps_input_t;

/* hwrm_port_phy_qcaps_output (size:256b/32B) */

typedef struct hwrm_port_phy_qcaps_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* PHY capability flags */
	uint8_t	flags;
	/*
	 * If set to 1, then this field indicates that the
	 * link is capable of supporting EEE.
	 */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_FLAGS_EEE_SUPPORTED			UINT32_C(0x1)
	/*
	 * If set to 1, then this field indicates that the
	 * PHY is capable of supporting external loopback.
	 */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_FLAGS_EXTERNAL_LPBK_SUPPORTED	UINT32_C(0x2)
	/*
	 * If set to 1, then this field indicates that the
	 * PHY is capable of supporting loopback in autoneg mode.
	 */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_FLAGS_AUTONEG_LPBK_SUPPORTED	UINT32_C(0x4)
	/*
	 * Indicates if the configuration of shared PHY settings is supported.
	 * In cases where a physical port is shared by multiple functions
	 * (e.g. NPAR, multihost, etc), the configuration of PHY
	 * settings may not be allowed. Callers to HWRM_PORT_PHY_CFG will
	 * get an HWRM_ERR_CODE_RESOURCE_ACCESS_DENIED error in this case.
	 */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_FLAGS_SHARED_PHY_CFG_SUPPORTED	UINT32_C(0x8)
	/*
	 * If set to 1, it indicates that the port counters and extended
	 * port counters will not reset when the firmware shuts down or
	 * resets the PHY.  These counters will only be reset during power
	 * cycle or by calling HWRM_PORT_CLR_STATS.
	 * If set to 0, the state of the counters is unspecified when
	 * firmware shuts down or resets the PHY.
	 */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_FLAGS_CUMULATIVE_COUNTERS_ON_RESET	UINT32_C(0x10)
	/*
	 * If set to 1, then this field indicates that the
	 * local loopback is not supported on this controller.
	 */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_FLAGS_LOCAL_LPBK_NOT_SUPPORTED	UINT32_C(0x20)
	/*
	 * If set to 1, then this field indicates that the
	 * PHY/Link down policy during PF shutdown is totally
	 * controlled by the firmware. It can shutdown the link
	 * even when there are active VFs associated with the PF.
	 * Host PF driver can send HWRM_PHY_CFG command to bring
	 * down the PHY even when the port is shared between VFs
	 * and PFs.
	 */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_FLAGS_FW_MANAGED_LINK_DOWN		UINT32_C(0x40)
	/*
	 * If set to 1, this field indicates that the FCS may
	 * be disabled for a given packet via the transmit
	 * buffer descriptor.
	 */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_FLAGS_NO_FCS			UINT32_C(0x80)
	/* Number of front panel ports for this device. */
	uint8_t	port_cnt;
	/* Not supported or unknown */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_PORT_CNT_UNKNOWN UINT32_C(0x0)
	/* single port device */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_PORT_CNT_1	UINT32_C(0x1)
	/* 2-port device */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_PORT_CNT_2	UINT32_C(0x2)
	/* 3-port device */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_PORT_CNT_3	UINT32_C(0x3)
	/* 4-port device */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_PORT_CNT_4	UINT32_C(0x4)
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_PORT_CNT_LAST   HWRM_PORT_PHY_QCAPS_OUTPUT_PORT_CNT_4
	/*
	 * This is a bit mask to indicate what speeds are supported
	 * as forced speeds on this link.
	 * For each speed that can be forced on this link, the
	 * corresponding mask bit shall be set to '1'.
	 */
	uint16_t	supported_speeds_force_mode;
	/* 100Mb link speed (Half-duplex) */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS_FORCE_MODE_100MBHD	UINT32_C(0x1)
	/* 100Mb link speed (Full-duplex) */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS_FORCE_MODE_100MB	UINT32_C(0x2)
	/* 1Gb link speed (Half-duplex) */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS_FORCE_MODE_1GBHD	UINT32_C(0x4)
	/* 1Gb link speed (Full-duplex) */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS_FORCE_MODE_1GB	UINT32_C(0x8)
	/* 2Gb link speed */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS_FORCE_MODE_2GB	UINT32_C(0x10)
	/* 25Gb link speed */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS_FORCE_MODE_2_5GB	UINT32_C(0x20)
	/* 10Gb link speed */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS_FORCE_MODE_10GB	UINT32_C(0x40)
	/* 20Gb link speed */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS_FORCE_MODE_20GB	UINT32_C(0x80)
	/* 25Gb link speed */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS_FORCE_MODE_25GB	UINT32_C(0x100)
	/* 40Gb link speed */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS_FORCE_MODE_40GB	UINT32_C(0x200)
	/* 50Gb link speed */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS_FORCE_MODE_50GB	UINT32_C(0x400)
	/* 100Gb link speed */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS_FORCE_MODE_100GB	UINT32_C(0x800)
	/* 10Mb link speed (Half-duplex) */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS_FORCE_MODE_10MBHD	UINT32_C(0x1000)
	/* 10Mb link speed (Full-duplex) */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS_FORCE_MODE_10MB	UINT32_C(0x2000)
	/*
	 * This is a bit mask to indicate what speeds are supported
	 * for autonegotiation on this link.
	 * For each speed that can be autonegotiated on this link, the
	 * corresponding mask bit shall be set to '1'.
	 */
	uint16_t	supported_speeds_auto_mode;
	/* 100Mb link speed (Half-duplex) */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS_AUTO_MODE_100MBHD	UINT32_C(0x1)
	/* 100Mb link speed (Full-duplex) */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS_AUTO_MODE_100MB	UINT32_C(0x2)
	/* 1Gb link speed (Half-duplex) */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS_AUTO_MODE_1GBHD	UINT32_C(0x4)
	/* 1Gb link speed (Full-duplex) */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS_AUTO_MODE_1GB	UINT32_C(0x8)
	/* 2Gb link speed */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS_AUTO_MODE_2GB	UINT32_C(0x10)
	/* 25Gb link speed */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS_AUTO_MODE_2_5GB	UINT32_C(0x20)
	/* 10Gb link speed */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS_AUTO_MODE_10GB	UINT32_C(0x40)
	/* 20Gb link speed */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS_AUTO_MODE_20GB	UINT32_C(0x80)
	/* 25Gb link speed */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS_AUTO_MODE_25GB	UINT32_C(0x100)
	/* 40Gb link speed */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS_AUTO_MODE_40GB	UINT32_C(0x200)
	/* 50Gb link speed */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS_AUTO_MODE_50GB	UINT32_C(0x400)
	/* 100Gb link speed */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS_AUTO_MODE_100GB	UINT32_C(0x800)
	/* 10Mb link speed (Half-duplex) */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS_AUTO_MODE_10MBHD	UINT32_C(0x1000)
	/* 10Mb link speed (Full-duplex) */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS_AUTO_MODE_10MB	UINT32_C(0x2000)
	/*
	 * This is a bit mask to indicate what speeds are supported
	 * for EEE on this link.
	 * For each speed that can be autonegotiated when EEE is enabled
	 * on this link, the corresponding mask bit shall be set to '1'.
	 * This field is only valid when the eee_suppotred is set to '1'.
	 */
	uint16_t	supported_speeds_eee_mode;
	/* Reserved */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS_EEE_MODE_RSVD1	UINT32_C(0x1)
	/* 100Mb link speed (Full-duplex) */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS_EEE_MODE_100MB	UINT32_C(0x2)
	/* Reserved */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS_EEE_MODE_RSVD2	UINT32_C(0x4)
	/* 1Gb link speed (Full-duplex) */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS_EEE_MODE_1GB	UINT32_C(0x8)
	/* Reserved */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS_EEE_MODE_RSVD3	UINT32_C(0x10)
	/* Reserved */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS_EEE_MODE_RSVD4	UINT32_C(0x20)
	/* 10Gb link speed */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_SPEEDS_EEE_MODE_10GB	UINT32_C(0x40)
	uint32_t	tx_lpi_timer_low;
	/*
	 * The lowest value of TX LPI timer that can be set on this link
	 * when EEE is enabled. This value is in microseconds.
	 * This field is valid only when_eee_supported is set to '1'.
	 */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_TX_LPI_TIMER_LOW_MASK UINT32_C(0xffffff)
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_TX_LPI_TIMER_LOW_SFT 0
	/*
	 * Reserved field. The HWRM shall set this field to 0.
	 * An HWRM client shall ignore this field.
	 */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_RSVD2_MASK	UINT32_C(0xff000000)
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_RSVD2_SFT		24
	uint32_t	valid_tx_lpi_timer_high;
	/*
	 * The highest value of TX LPI timer that can be set on this link
	 * when EEE is enabled. This value is in microseconds.
	 * This field is valid only when_eee_supported is set to '1'.
	 */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_TX_LPI_TIMER_HIGH_MASK UINT32_C(0xffffff)
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_TX_LPI_TIMER_HIGH_SFT 0
	/*
	 * Reserved field. The HWRM shall set this field to 0.
	 * An HWRM client shall ignore this field.
	 */
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_RSVD_MASK		UINT32_C(0xff000000)
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_RSVD_SFT		24
	/*
	 * This field is used to advertise which PAM4 speeds are supported
	 * in auto mode.
	 */
	uint16_t	supported_pam4_speeds_auto_mode;
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_PAM4_SPEEDS_AUTO_MODE_50G	UINT32_C(0x1)
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_PAM4_SPEEDS_AUTO_MODE_100G	UINT32_C(0x2)
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_PAM4_SPEEDS_AUTO_MODE_200G	UINT32_C(0x4)
	/*
	 * This field is used to advertise which PAM4 speeds are supported
	 * in forced mode.
	 */
	uint16_t	supported_pam4_speeds_force_mode;
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_PAM4_SPEEDS_FORCE_MODE_50G	UINT32_C(0x1)
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_PAM4_SPEEDS_FORCE_MODE_100G	UINT32_C(0x2)
	#define HWRM_PORT_PHY_QCAPS_OUTPUT_SUPPORTED_PAM4_SPEEDS_FORCE_MODE_200G	UINT32_C(0x4)
	uint8_t	unused_0[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_port_phy_qcaps_output_t, *phwrm_port_phy_qcaps_output_t;

/****************************
 * hwrm_port_phy_mdio_write *
 ****************************/


/* hwrm_port_phy_mdio_write_input (size:320b/40B) */

typedef struct hwrm_port_phy_mdio_write_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Reserved for future use. */
	uint64_t	unused_0;
	/* Port ID of port. */
	uint16_t	port_id;
	/* If phy_address is 0xFF, port_id will be used to derive phy_addr. */
	uint8_t	phy_addr;
	/* 8-bit device address. */
	uint8_t	dev_addr;
	/* 16-bit register address. */
	uint16_t	reg_addr;
	/* 16-bit register data. */
	uint16_t	reg_data;
	/*
	 * When this bit is set to 1 a Clause 45 mdio access is done.
	 * when this bit is set to 0 a Clause 22 mdio access is done.
	 */
	uint8_t	cl45_mdio;
	/*  */
	uint8_t	unused_1[7];
} hwrm_port_phy_mdio_write_input_t, *phwrm_port_phy_mdio_write_input_t;

/* hwrm_port_phy_mdio_write_output (size:128b/16B) */

typedef struct hwrm_port_phy_mdio_write_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_port_phy_mdio_write_output_t, *phwrm_port_phy_mdio_write_output_t;

/***************************
 * hwrm_port_phy_mdio_read *
 ***************************/


/* hwrm_port_phy_mdio_read_input (size:256b/32B) */

typedef struct hwrm_port_phy_mdio_read_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Reserved for future use. */
	uint64_t	unused_0;
	/* Port ID of port. */
	uint16_t	port_id;
	/* If phy_address is 0xFF, port_id will be used to derive phy_addr. */
	uint8_t	phy_addr;
	/* 8-bit device address. */
	uint8_t	dev_addr;
	/* 16-bit register address. */
	uint16_t	reg_addr;
	/*
	 * When this bit is set to 1 a Clause 45 mdio access is done.
	 * when this bit is set to 0 a Clause 22 mdio access is done.
	 */
	uint8_t	cl45_mdio;
	/*  */
	uint8_t	unused_1;
} hwrm_port_phy_mdio_read_input_t, *phwrm_port_phy_mdio_read_input_t;

/* hwrm_port_phy_mdio_read_output (size:128b/16B) */

typedef struct hwrm_port_phy_mdio_read_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* 16-bit register data. */
	uint16_t	reg_data;
	uint8_t	unused_0[5];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_port_phy_mdio_read_output_t, *phwrm_port_phy_mdio_read_output_t;

/*********************
 * hwrm_port_led_cfg *
 *********************/


/* hwrm_port_led_cfg_input (size:512b/64B) */

typedef struct hwrm_port_led_cfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	enables;
	/*
	 * This bit must be '1' for the led0_id field to be
	 * configured.
	 */
	#define HWRM_PORT_LED_CFG_INPUT_ENABLES_LED0_ID		UINT32_C(0x1)
	/*
	 * This bit must be '1' for the led0_state field to be
	 * configured.
	 */
	#define HWRM_PORT_LED_CFG_INPUT_ENABLES_LED0_STATE	UINT32_C(0x2)
	/*
	 * This bit must be '1' for the led0_color field to be
	 * configured.
	 */
	#define HWRM_PORT_LED_CFG_INPUT_ENABLES_LED0_COLOR	UINT32_C(0x4)
	/*
	 * This bit must be '1' for the led0_blink_on field to be
	 * configured.
	 */
	#define HWRM_PORT_LED_CFG_INPUT_ENABLES_LED0_BLINK_ON	UINT32_C(0x8)
	/*
	 * This bit must be '1' for the led0_blink_off field to be
	 * configured.
	 */
	#define HWRM_PORT_LED_CFG_INPUT_ENABLES_LED0_BLINK_OFF	UINT32_C(0x10)
	/*
	 * This bit must be '1' for the led0_group_id field to be
	 * configured.
	 */
	#define HWRM_PORT_LED_CFG_INPUT_ENABLES_LED0_GROUP_ID	UINT32_C(0x20)
	/*
	 * This bit must be '1' for the led1_id field to be
	 * configured.
	 */
	#define HWRM_PORT_LED_CFG_INPUT_ENABLES_LED1_ID		UINT32_C(0x40)
	/*
	 * This bit must be '1' for the led1_state field to be
	 * configured.
	 */
	#define HWRM_PORT_LED_CFG_INPUT_ENABLES_LED1_STATE	UINT32_C(0x80)
	/*
	 * This bit must be '1' for the led1_color field to be
	 * configured.
	 */
	#define HWRM_PORT_LED_CFG_INPUT_ENABLES_LED1_COLOR	UINT32_C(0x100)
	/*
	 * This bit must be '1' for the led1_blink_on field to be
	 * configured.
	 */
	#define HWRM_PORT_LED_CFG_INPUT_ENABLES_LED1_BLINK_ON	UINT32_C(0x200)
	/*
	 * This bit must be '1' for the led1_blink_off field to be
	 * configured.
	 */
	#define HWRM_PORT_LED_CFG_INPUT_ENABLES_LED1_BLINK_OFF	UINT32_C(0x400)
	/*
	 * This bit must be '1' for the led1_group_id field to be
	 * configured.
	 */
	#define HWRM_PORT_LED_CFG_INPUT_ENABLES_LED1_GROUP_ID	UINT32_C(0x800)
	/*
	 * This bit must be '1' for the led2_id field to be
	 * configured.
	 */
	#define HWRM_PORT_LED_CFG_INPUT_ENABLES_LED2_ID		UINT32_C(0x1000)
	/*
	 * This bit must be '1' for the led2_state field to be
	 * configured.
	 */
	#define HWRM_PORT_LED_CFG_INPUT_ENABLES_LED2_STATE	UINT32_C(0x2000)
	/*
	 * This bit must be '1' for the led2_color field to be
	 * configured.
	 */
	#define HWRM_PORT_LED_CFG_INPUT_ENABLES_LED2_COLOR	UINT32_C(0x4000)
	/*
	 * This bit must be '1' for the led2_blink_on field to be
	 * configured.
	 */
	#define HWRM_PORT_LED_CFG_INPUT_ENABLES_LED2_BLINK_ON	UINT32_C(0x8000)
	/*
	 * This bit must be '1' for the led2_blink_off field to be
	 * configured.
	 */
	#define HWRM_PORT_LED_CFG_INPUT_ENABLES_LED2_BLINK_OFF	UINT32_C(0x10000)
	/*
	 * This bit must be '1' for the led2_group_id field to be
	 * configured.
	 */
	#define HWRM_PORT_LED_CFG_INPUT_ENABLES_LED2_GROUP_ID	UINT32_C(0x20000)
	/*
	 * This bit must be '1' for the led3_id field to be
	 * configured.
	 */
	#define HWRM_PORT_LED_CFG_INPUT_ENABLES_LED3_ID		UINT32_C(0x40000)
	/*
	 * This bit must be '1' for the led3_state field to be
	 * configured.
	 */
	#define HWRM_PORT_LED_CFG_INPUT_ENABLES_LED3_STATE	UINT32_C(0x80000)
	/*
	 * This bit must be '1' for the led3_color field to be
	 * configured.
	 */
	#define HWRM_PORT_LED_CFG_INPUT_ENABLES_LED3_COLOR	UINT32_C(0x100000)
	/*
	 * This bit must be '1' for the led3_blink_on field to be
	 * configured.
	 */
	#define HWRM_PORT_LED_CFG_INPUT_ENABLES_LED3_BLINK_ON	UINT32_C(0x200000)
	/*
	 * This bit must be '1' for the led3_blink_off field to be
	 * configured.
	 */
	#define HWRM_PORT_LED_CFG_INPUT_ENABLES_LED3_BLINK_OFF	UINT32_C(0x400000)
	/*
	 * This bit must be '1' for the led3_group_id field to be
	 * configured.
	 */
	#define HWRM_PORT_LED_CFG_INPUT_ENABLES_LED3_GROUP_ID	UINT32_C(0x800000)
	/* Port ID of port whose LEDs are configured. */
	uint16_t	port_id;
	/*
	 * The number of LEDs that are being configured.
	 * Up to 4 LEDs can be configured with this command.
	 */
	uint8_t	num_leds;
	/* Reserved field. */
	uint8_t	rsvd;
	/* An identifier for the LED #0. */
	uint8_t	led0_id;
	/* The requested state of the LED #0. */
	uint8_t	led0_state;
	/* Default state of the LED */
	#define HWRM_PORT_LED_CFG_INPUT_LED0_STATE_DEFAULT  UINT32_C(0x0)
	/* Off */
	#define HWRM_PORT_LED_CFG_INPUT_LED0_STATE_OFF	UINT32_C(0x1)
	/* On */
	#define HWRM_PORT_LED_CFG_INPUT_LED0_STATE_ON	UINT32_C(0x2)
	/* Blink */
	#define HWRM_PORT_LED_CFG_INPUT_LED0_STATE_BLINK	UINT32_C(0x3)
	/* Blink Alternately */
	#define HWRM_PORT_LED_CFG_INPUT_LED0_STATE_BLINKALT UINT32_C(0x4)
	#define HWRM_PORT_LED_CFG_INPUT_LED0_STATE_LAST	HWRM_PORT_LED_CFG_INPUT_LED0_STATE_BLINKALT
	/* The requested color of LED #0. */
	uint8_t	led0_color;
	/* Default */
	#define HWRM_PORT_LED_CFG_INPUT_LED0_COLOR_DEFAULT	UINT32_C(0x0)
	/* Amber */
	#define HWRM_PORT_LED_CFG_INPUT_LED0_COLOR_AMBER	UINT32_C(0x1)
	/* Green */
	#define HWRM_PORT_LED_CFG_INPUT_LED0_COLOR_GREEN	UINT32_C(0x2)
	/* Green or Amber */
	#define HWRM_PORT_LED_CFG_INPUT_LED0_COLOR_GREENAMBER UINT32_C(0x3)
	#define HWRM_PORT_LED_CFG_INPUT_LED0_COLOR_LAST	HWRM_PORT_LED_CFG_INPUT_LED0_COLOR_GREENAMBER
	uint8_t	unused_0;
	/*
	 * If the LED #0 state is "blink" or "blinkalt", then
	 * this field represents the requested time in milliseconds
	 * to keep LED on between cycles.
	 */
	uint16_t	led0_blink_on;
	/*
	 * If the LED #0 state is "blink" or "blinkalt", then
	 * this field represents the requested time in milliseconds
	 * to keep LED off between cycles.
	 */
	uint16_t	led0_blink_off;
	/*
	 * An identifier for the group of LEDs that LED #0 belongs
	 * to.
	 * If set to 0, then the LED #0 shall not be grouped and
	 * shall be treated as an individual resource.
	 * For all other non-zero values of this field, LED #0 shall
	 * be grouped together with the LEDs with the same group ID
	 * value.
	 */
	uint8_t	led0_group_id;
	/* Reserved field. */
	uint8_t	rsvd0;
	/* An identifier for the LED #1. */
	uint8_t	led1_id;
	/* The requested state of the LED #1. */
	uint8_t	led1_state;
	/* Default state of the LED */
	#define HWRM_PORT_LED_CFG_INPUT_LED1_STATE_DEFAULT  UINT32_C(0x0)
	/* Off */
	#define HWRM_PORT_LED_CFG_INPUT_LED1_STATE_OFF	UINT32_C(0x1)
	/* On */
	#define HWRM_PORT_LED_CFG_INPUT_LED1_STATE_ON	UINT32_C(0x2)
	/* Blink */
	#define HWRM_PORT_LED_CFG_INPUT_LED1_STATE_BLINK	UINT32_C(0x3)
	/* Blink Alternately */
	#define HWRM_PORT_LED_CFG_INPUT_LED1_STATE_BLINKALT UINT32_C(0x4)
	#define HWRM_PORT_LED_CFG_INPUT_LED1_STATE_LAST	HWRM_PORT_LED_CFG_INPUT_LED1_STATE_BLINKALT
	/* The requested color of LED #1. */
	uint8_t	led1_color;
	/* Default */
	#define HWRM_PORT_LED_CFG_INPUT_LED1_COLOR_DEFAULT	UINT32_C(0x0)
	/* Amber */
	#define HWRM_PORT_LED_CFG_INPUT_LED1_COLOR_AMBER	UINT32_C(0x1)
	/* Green */
	#define HWRM_PORT_LED_CFG_INPUT_LED1_COLOR_GREEN	UINT32_C(0x2)
	/* Green or Amber */
	#define HWRM_PORT_LED_CFG_INPUT_LED1_COLOR_GREENAMBER UINT32_C(0x3)
	#define HWRM_PORT_LED_CFG_INPUT_LED1_COLOR_LAST	HWRM_PORT_LED_CFG_INPUT_LED1_COLOR_GREENAMBER
	uint8_t	unused_1;
	/*
	 * If the LED #1 state is "blink" or "blinkalt", then
	 * this field represents the requested time in milliseconds
	 * to keep LED on between cycles.
	 */
	uint16_t	led1_blink_on;
	/*
	 * If the LED #1 state is "blink" or "blinkalt", then
	 * this field represents the requested time in milliseconds
	 * to keep LED off between cycles.
	 */
	uint16_t	led1_blink_off;
	/*
	 * An identifier for the group of LEDs that LED #1 belongs
	 * to.
	 * If set to 0, then the LED #1 shall not be grouped and
	 * shall be treated as an individual resource.
	 * For all other non-zero values of this field, LED #1 shall
	 * be grouped together with the LEDs with the same group ID
	 * value.
	 */
	uint8_t	led1_group_id;
	/* Reserved field. */
	uint8_t	rsvd1;
	/* An identifier for the LED #2. */
	uint8_t	led2_id;
	/* The requested state of the LED #2. */
	uint8_t	led2_state;
	/* Default state of the LED */
	#define HWRM_PORT_LED_CFG_INPUT_LED2_STATE_DEFAULT  UINT32_C(0x0)
	/* Off */
	#define HWRM_PORT_LED_CFG_INPUT_LED2_STATE_OFF	UINT32_C(0x1)
	/* On */
	#define HWRM_PORT_LED_CFG_INPUT_LED2_STATE_ON	UINT32_C(0x2)
	/* Blink */
	#define HWRM_PORT_LED_CFG_INPUT_LED2_STATE_BLINK	UINT32_C(0x3)
	/* Blink Alternately */
	#define HWRM_PORT_LED_CFG_INPUT_LED2_STATE_BLINKALT UINT32_C(0x4)
	#define HWRM_PORT_LED_CFG_INPUT_LED2_STATE_LAST	HWRM_PORT_LED_CFG_INPUT_LED2_STATE_BLINKALT
	/* The requested color of LED #2. */
	uint8_t	led2_color;
	/* Default */
	#define HWRM_PORT_LED_CFG_INPUT_LED2_COLOR_DEFAULT	UINT32_C(0x0)
	/* Amber */
	#define HWRM_PORT_LED_CFG_INPUT_LED2_COLOR_AMBER	UINT32_C(0x1)
	/* Green */
	#define HWRM_PORT_LED_CFG_INPUT_LED2_COLOR_GREEN	UINT32_C(0x2)
	/* Green or Amber */
	#define HWRM_PORT_LED_CFG_INPUT_LED2_COLOR_GREENAMBER UINT32_C(0x3)
	#define HWRM_PORT_LED_CFG_INPUT_LED2_COLOR_LAST	HWRM_PORT_LED_CFG_INPUT_LED2_COLOR_GREENAMBER
	uint8_t	unused_2;
	/*
	 * If the LED #2 state is "blink" or "blinkalt", then
	 * this field represents the requested time in milliseconds
	 * to keep LED on between cycles.
	 */
	uint16_t	led2_blink_on;
	/*
	 * If the LED #2 state is "blink" or "blinkalt", then
	 * this field represents the requested time in milliseconds
	 * to keep LED off between cycles.
	 */
	uint16_t	led2_blink_off;
	/*
	 * An identifier for the group of LEDs that LED #2 belongs
	 * to.
	 * If set to 0, then the LED #2 shall not be grouped and
	 * shall be treated as an individual resource.
	 * For all other non-zero values of this field, LED #2 shall
	 * be grouped together with the LEDs with the same group ID
	 * value.
	 */
	uint8_t	led2_group_id;
	/* Reserved field. */
	uint8_t	rsvd2;
	/* An identifier for the LED #3. */
	uint8_t	led3_id;
	/* The requested state of the LED #3. */
	uint8_t	led3_state;
	/* Default state of the LED */
	#define HWRM_PORT_LED_CFG_INPUT_LED3_STATE_DEFAULT  UINT32_C(0x0)
	/* Off */
	#define HWRM_PORT_LED_CFG_INPUT_LED3_STATE_OFF	UINT32_C(0x1)
	/* On */
	#define HWRM_PORT_LED_CFG_INPUT_LED3_STATE_ON	UINT32_C(0x2)
	/* Blink */
	#define HWRM_PORT_LED_CFG_INPUT_LED3_STATE_BLINK	UINT32_C(0x3)
	/* Blink Alternately */
	#define HWRM_PORT_LED_CFG_INPUT_LED3_STATE_BLINKALT UINT32_C(0x4)
	#define HWRM_PORT_LED_CFG_INPUT_LED3_STATE_LAST	HWRM_PORT_LED_CFG_INPUT_LED3_STATE_BLINKALT
	/* The requested color of LED #3. */
	uint8_t	led3_color;
	/* Default */
	#define HWRM_PORT_LED_CFG_INPUT_LED3_COLOR_DEFAULT	UINT32_C(0x0)
	/* Amber */
	#define HWRM_PORT_LED_CFG_INPUT_LED3_COLOR_AMBER	UINT32_C(0x1)
	/* Green */
	#define HWRM_PORT_LED_CFG_INPUT_LED3_COLOR_GREEN	UINT32_C(0x2)
	/* Green or Amber */
	#define HWRM_PORT_LED_CFG_INPUT_LED3_COLOR_GREENAMBER UINT32_C(0x3)
	#define HWRM_PORT_LED_CFG_INPUT_LED3_COLOR_LAST	HWRM_PORT_LED_CFG_INPUT_LED3_COLOR_GREENAMBER
	uint8_t	unused_3;
	/*
	 * If the LED #3 state is "blink" or "blinkalt", then
	 * this field represents the requested time in milliseconds
	 * to keep LED on between cycles.
	 */
	uint16_t	led3_blink_on;
	/*
	 * If the LED #3 state is "blink" or "blinkalt", then
	 * this field represents the requested time in milliseconds
	 * to keep LED off between cycles.
	 */
	uint16_t	led3_blink_off;
	/*
	 * An identifier for the group of LEDs that LED #3 belongs
	 * to.
	 * If set to 0, then the LED #3 shall not be grouped and
	 * shall be treated as an individual resource.
	 * For all other non-zero values of this field, LED #3 shall
	 * be grouped together with the LEDs with the same group ID
	 * value.
	 */
	uint8_t	led3_group_id;
	/* Reserved field. */
	uint8_t	rsvd3;
} hwrm_port_led_cfg_input_t, *phwrm_port_led_cfg_input_t;

/* hwrm_port_led_cfg_output (size:128b/16B) */

typedef struct hwrm_port_led_cfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_port_led_cfg_output_t, *phwrm_port_led_cfg_output_t;

/**********************
 * hwrm_port_led_qcfg *
 **********************/


/* hwrm_port_led_qcfg_input (size:192b/24B) */

typedef struct hwrm_port_led_qcfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Port ID of port whose LED configuration is being queried. */
	uint16_t	port_id;
	uint8_t	unused_0[6];
} hwrm_port_led_qcfg_input_t, *phwrm_port_led_qcfg_input_t;

/* hwrm_port_led_qcfg_output (size:448b/56B) */

typedef struct hwrm_port_led_qcfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * The number of LEDs that are configured on this port.
	 * Up to 4 LEDs can be returned in the response.
	 */
	uint8_t	num_leds;
	/* An identifier for the LED #0. */
	uint8_t	led0_id;
	/* The type of LED #0. */
	uint8_t	led0_type;
	/* Speed LED */
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED0_TYPE_SPEED	UINT32_C(0x0)
	/* Activity LED */
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED0_TYPE_ACTIVITY UINT32_C(0x1)
	/* Invalid */
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED0_TYPE_INVALID  UINT32_C(0xff)
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED0_TYPE_LAST	HWRM_PORT_LED_QCFG_OUTPUT_LED0_TYPE_INVALID
	/* The current state of the LED #0. */
	uint8_t	led0_state;
	/* Default state of the LED */
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED0_STATE_DEFAULT  UINT32_C(0x0)
	/* Off */
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED0_STATE_OFF	UINT32_C(0x1)
	/* On */
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED0_STATE_ON	UINT32_C(0x2)
	/* Blink */
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED0_STATE_BLINK	UINT32_C(0x3)
	/* Blink Alternately */
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED0_STATE_BLINKALT UINT32_C(0x4)
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED0_STATE_LAST	HWRM_PORT_LED_QCFG_OUTPUT_LED0_STATE_BLINKALT
	/* The color of LED #0. */
	uint8_t	led0_color;
	/* Default */
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED0_COLOR_DEFAULT	UINT32_C(0x0)
	/* Amber */
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED0_COLOR_AMBER	UINT32_C(0x1)
	/* Green */
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED0_COLOR_GREEN	UINT32_C(0x2)
	/* Green or Amber */
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED0_COLOR_GREENAMBER UINT32_C(0x3)
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED0_COLOR_LAST	HWRM_PORT_LED_QCFG_OUTPUT_LED0_COLOR_GREENAMBER
	uint8_t	unused_0;
	/*
	 * If the LED #0 state is "blink" or "blinkalt", then
	 * this field represents the requested time in milliseconds
	 * to keep LED on between cycles.
	 */
	uint16_t	led0_blink_on;
	/*
	 * If the LED #0 state is "blink" or "blinkalt", then
	 * this field represents the requested time in milliseconds
	 * to keep LED off between cycles.
	 */
	uint16_t	led0_blink_off;
	/*
	 * An identifier for the group of LEDs that LED #0 belongs
	 * to.
	 * If set to 0, then the LED #0 is not grouped.
	 * For all other non-zero values of this field, LED #0 is
	 * grouped together with the LEDs with the same group ID
	 * value.
	 */
	uint8_t	led0_group_id;
	/* An identifier for the LED #1. */
	uint8_t	led1_id;
	/* The type of LED #1. */
	uint8_t	led1_type;
	/* Speed LED */
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED1_TYPE_SPEED	UINT32_C(0x0)
	/* Activity LED */
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED1_TYPE_ACTIVITY UINT32_C(0x1)
	/* Invalid */
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED1_TYPE_INVALID  UINT32_C(0xff)
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED1_TYPE_LAST	HWRM_PORT_LED_QCFG_OUTPUT_LED1_TYPE_INVALID
	/* The current state of the LED #1. */
	uint8_t	led1_state;
	/* Default state of the LED */
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED1_STATE_DEFAULT  UINT32_C(0x0)
	/* Off */
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED1_STATE_OFF	UINT32_C(0x1)
	/* On */
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED1_STATE_ON	UINT32_C(0x2)
	/* Blink */
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED1_STATE_BLINK	UINT32_C(0x3)
	/* Blink Alternately */
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED1_STATE_BLINKALT UINT32_C(0x4)
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED1_STATE_LAST	HWRM_PORT_LED_QCFG_OUTPUT_LED1_STATE_BLINKALT
	/* The color of LED #1. */
	uint8_t	led1_color;
	/* Default */
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED1_COLOR_DEFAULT	UINT32_C(0x0)
	/* Amber */
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED1_COLOR_AMBER	UINT32_C(0x1)
	/* Green */
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED1_COLOR_GREEN	UINT32_C(0x2)
	/* Green or Amber */
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED1_COLOR_GREENAMBER UINT32_C(0x3)
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED1_COLOR_LAST	HWRM_PORT_LED_QCFG_OUTPUT_LED1_COLOR_GREENAMBER
	uint8_t	unused_1;
	/*
	 * If the LED #1 state is "blink" or "blinkalt", then
	 * this field represents the requested time in milliseconds
	 * to keep LED on between cycles.
	 */
	uint16_t	led1_blink_on;
	/*
	 * If the LED #1 state is "blink" or "blinkalt", then
	 * this field represents the requested time in milliseconds
	 * to keep LED off between cycles.
	 */
	uint16_t	led1_blink_off;
	/*
	 * An identifier for the group of LEDs that LED #1 belongs
	 * to.
	 * If set to 0, then the LED #1 is not grouped.
	 * For all other non-zero values of this field, LED #1 is
	 * grouped together with the LEDs with the same group ID
	 * value.
	 */
	uint8_t	led1_group_id;
	/* An identifier for the LED #2. */
	uint8_t	led2_id;
	/* The type of LED #2. */
	uint8_t	led2_type;
	/* Speed LED */
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED2_TYPE_SPEED	UINT32_C(0x0)
	/* Activity LED */
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED2_TYPE_ACTIVITY UINT32_C(0x1)
	/* Invalid */
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED2_TYPE_INVALID  UINT32_C(0xff)
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED2_TYPE_LAST	HWRM_PORT_LED_QCFG_OUTPUT_LED2_TYPE_INVALID
	/* The current state of the LED #2. */
	uint8_t	led2_state;
	/* Default state of the LED */
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED2_STATE_DEFAULT  UINT32_C(0x0)
	/* Off */
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED2_STATE_OFF	UINT32_C(0x1)
	/* On */
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED2_STATE_ON	UINT32_C(0x2)
	/* Blink */
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED2_STATE_BLINK	UINT32_C(0x3)
	/* Blink Alternately */
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED2_STATE_BLINKALT UINT32_C(0x4)
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED2_STATE_LAST	HWRM_PORT_LED_QCFG_OUTPUT_LED2_STATE_BLINKALT
	/* The color of LED #2. */
	uint8_t	led2_color;
	/* Default */
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED2_COLOR_DEFAULT	UINT32_C(0x0)
	/* Amber */
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED2_COLOR_AMBER	UINT32_C(0x1)
	/* Green */
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED2_COLOR_GREEN	UINT32_C(0x2)
	/* Green or Amber */
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED2_COLOR_GREENAMBER UINT32_C(0x3)
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED2_COLOR_LAST	HWRM_PORT_LED_QCFG_OUTPUT_LED2_COLOR_GREENAMBER
	uint8_t	unused_2;
	/*
	 * If the LED #2 state is "blink" or "blinkalt", then
	 * this field represents the requested time in milliseconds
	 * to keep LED on between cycles.
	 */
	uint16_t	led2_blink_on;
	/*
	 * If the LED #2 state is "blink" or "blinkalt", then
	 * this field represents the requested time in milliseconds
	 * to keep LED off between cycles.
	 */
	uint16_t	led2_blink_off;
	/*
	 * An identifier for the group of LEDs that LED #2 belongs
	 * to.
	 * If set to 0, then the LED #2 is not grouped.
	 * For all other non-zero values of this field, LED #2 is
	 * grouped together with the LEDs with the same group ID
	 * value.
	 */
	uint8_t	led2_group_id;
	/* An identifier for the LED #3. */
	uint8_t	led3_id;
	/* The type of LED #3. */
	uint8_t	led3_type;
	/* Speed LED */
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED3_TYPE_SPEED	UINT32_C(0x0)
	/* Activity LED */
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED3_TYPE_ACTIVITY UINT32_C(0x1)
	/* Invalid */
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED3_TYPE_INVALID  UINT32_C(0xff)
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED3_TYPE_LAST	HWRM_PORT_LED_QCFG_OUTPUT_LED3_TYPE_INVALID
	/* The current state of the LED #3. */
	uint8_t	led3_state;
	/* Default state of the LED */
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED3_STATE_DEFAULT  UINT32_C(0x0)
	/* Off */
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED3_STATE_OFF	UINT32_C(0x1)
	/* On */
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED3_STATE_ON	UINT32_C(0x2)
	/* Blink */
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED3_STATE_BLINK	UINT32_C(0x3)
	/* Blink Alternately */
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED3_STATE_BLINKALT UINT32_C(0x4)
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED3_STATE_LAST	HWRM_PORT_LED_QCFG_OUTPUT_LED3_STATE_BLINKALT
	/* The color of LED #3. */
	uint8_t	led3_color;
	/* Default */
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED3_COLOR_DEFAULT	UINT32_C(0x0)
	/* Amber */
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED3_COLOR_AMBER	UINT32_C(0x1)
	/* Green */
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED3_COLOR_GREEN	UINT32_C(0x2)
	/* Green or Amber */
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED3_COLOR_GREENAMBER UINT32_C(0x3)
	#define HWRM_PORT_LED_QCFG_OUTPUT_LED3_COLOR_LAST	HWRM_PORT_LED_QCFG_OUTPUT_LED3_COLOR_GREENAMBER
	uint8_t	unused_3;
	/*
	 * If the LED #3 state is "blink" or "blinkalt", then
	 * this field represents the requested time in milliseconds
	 * to keep LED on between cycles.
	 */
	uint16_t	led3_blink_on;
	/*
	 * If the LED #3 state is "blink" or "blinkalt", then
	 * this field represents the requested time in milliseconds
	 * to keep LED off between cycles.
	 */
	uint16_t	led3_blink_off;
	/*
	 * An identifier for the group of LEDs that LED #3 belongs
	 * to.
	 * If set to 0, then the LED #3 is not grouped.
	 * For all other non-zero values of this field, LED #3 is
	 * grouped together with the LEDs with the same group ID
	 * value.
	 */
	uint8_t	led3_group_id;
	uint8_t	unused_4[6];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_port_led_qcfg_output_t, *phwrm_port_led_qcfg_output_t;

/***********************
 * hwrm_port_led_qcaps *
 ***********************/


/* hwrm_port_led_qcaps_input (size:192b/24B) */

typedef struct hwrm_port_led_qcaps_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Port ID of port whose LED configuration is being queried. */
	uint16_t	port_id;
	uint8_t	unused_0[6];
} hwrm_port_led_qcaps_input_t, *phwrm_port_led_qcaps_input_t;

/* hwrm_port_led_qcaps_output (size:384b/48B) */

typedef struct hwrm_port_led_qcaps_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * The number of LEDs that are configured on this port.
	 * Up to 4 LEDs can be returned in the response.
	 */
	uint8_t	num_leds;
	/* Reserved for future use. */
	uint8_t	unused[3];
	/* An identifier for the LED #0. */
	uint8_t	led0_id;
	/* The type of LED #0. */
	uint8_t	led0_type;
	/* Speed LED */
	#define HWRM_PORT_LED_QCAPS_OUTPUT_LED0_TYPE_SPEED	UINT32_C(0x0)
	/* Activity LED */
	#define HWRM_PORT_LED_QCAPS_OUTPUT_LED0_TYPE_ACTIVITY UINT32_C(0x1)
	/* Invalid */
	#define HWRM_PORT_LED_QCAPS_OUTPUT_LED0_TYPE_INVALID  UINT32_C(0xff)
	#define HWRM_PORT_LED_QCAPS_OUTPUT_LED0_TYPE_LAST	HWRM_PORT_LED_QCAPS_OUTPUT_LED0_TYPE_INVALID
	/*
	 * An identifier for the group of LEDs that LED #0 belongs
	 * to.
	 * If set to 0, then the LED #0 cannot be grouped.
	 * For all other non-zero values of this field, LED #0 is
	 * grouped together with the LEDs with the same group ID
	 * value.
	 */
	uint8_t	led0_group_id;
	uint8_t	unused_0;
	/* The states supported by LED #0. */
	uint16_t	led0_state_caps;
	/*
	 * If set to 1, this LED is enabled.
	 * If set to 0, this LED is disabled.
	 */
	#define HWRM_PORT_LED_QCAPS_OUTPUT_LED0_STATE_CAPS_ENABLED		UINT32_C(0x1)
	/*
	 * If set to 1, off state is supported on this LED.
	 * If set to 0, off state is not supported on this LED.
	 */
	#define HWRM_PORT_LED_QCAPS_OUTPUT_LED0_STATE_CAPS_OFF_SUPPORTED	UINT32_C(0x2)
	/*
	 * If set to 1, on state is supported on this LED.
	 * If set to 0, on state is not supported on this LED.
	 */
	#define HWRM_PORT_LED_QCAPS_OUTPUT_LED0_STATE_CAPS_ON_SUPPORTED		UINT32_C(0x4)
	/*
	 * If set to 1, blink state is supported on this LED.
	 * If set to 0, blink state is not supported on this LED.
	 */
	#define HWRM_PORT_LED_QCAPS_OUTPUT_LED0_STATE_CAPS_BLINK_SUPPORTED	UINT32_C(0x8)
	/*
	 * If set to 1, blink_alt state is supported on this LED.
	 * If set to 0, blink_alt state is not supported on this LED.
	 */
	#define HWRM_PORT_LED_QCAPS_OUTPUT_LED0_STATE_CAPS_BLINK_ALT_SUPPORTED	UINT32_C(0x10)
	/* The colors supported by LED #0. */
	uint16_t	led0_color_caps;
	/* reserved. */
	#define HWRM_PORT_LED_QCAPS_OUTPUT_LED0_COLOR_CAPS_RSVD		UINT32_C(0x1)
	/*
	 * If set to 1, Amber color is supported on this LED.
	 * If set to 0, Amber color is not supported on this LED.
	 */
	#define HWRM_PORT_LED_QCAPS_OUTPUT_LED0_COLOR_CAPS_AMBER_SUPPORTED	UINT32_C(0x2)
	/*
	 * If set to 1, Green color is supported on this LED.
	 * If set to 0, Green color is not supported on this LED.
	 */
	#define HWRM_PORT_LED_QCAPS_OUTPUT_LED0_COLOR_CAPS_GREEN_SUPPORTED	UINT32_C(0x4)
	/* An identifier for the LED #1. */
	uint8_t	led1_id;
	/* The type of LED #1. */
	uint8_t	led1_type;
	/* Speed LED */
	#define HWRM_PORT_LED_QCAPS_OUTPUT_LED1_TYPE_SPEED	UINT32_C(0x0)
	/* Activity LED */
	#define HWRM_PORT_LED_QCAPS_OUTPUT_LED1_TYPE_ACTIVITY UINT32_C(0x1)
	/* Invalid */
	#define HWRM_PORT_LED_QCAPS_OUTPUT_LED1_TYPE_INVALID  UINT32_C(0xff)
	#define HWRM_PORT_LED_QCAPS_OUTPUT_LED1_TYPE_LAST	HWRM_PORT_LED_QCAPS_OUTPUT_LED1_TYPE_INVALID
	/*
	 * An identifier for the group of LEDs that LED #1 belongs
	 * to.
	 * If set to 0, then the LED #0 cannot be grouped.
	 * For all other non-zero values of this field, LED #0 is
	 * grouped together with the LEDs with the same group ID
	 * value.
	 */
	uint8_t	led1_group_id;
	uint8_t	unused_1;
	/* The states supported by LED #1. */
	uint16_t	led1_state_caps;
	/*
	 * If set to 1, this LED is enabled.
	 * If set to 0, this LED is disabled.
	 */
	#define HWRM_PORT_LED_QCAPS_OUTPUT_LED1_STATE_CAPS_ENABLED		UINT32_C(0x1)
	/*
	 * If set to 1, off state is supported on this LED.
	 * If set to 0, off state is not supported on this LED.
	 */
	#define HWRM_PORT_LED_QCAPS_OUTPUT_LED1_STATE_CAPS_OFF_SUPPORTED	UINT32_C(0x2)
	/*
	 * If set to 1, on state is supported on this LED.
	 * If set to 0, on state is not supported on this LED.
	 */
	#define HWRM_PORT_LED_QCAPS_OUTPUT_LED1_STATE_CAPS_ON_SUPPORTED		UINT32_C(0x4)
	/*
	 * If set to 1, blink state is supported on this LED.
	 * If set to 0, blink state is not supported on this LED.
	 */
	#define HWRM_PORT_LED_QCAPS_OUTPUT_LED1_STATE_CAPS_BLINK_SUPPORTED	UINT32_C(0x8)
	/*
	 * If set to 1, blink_alt state is supported on this LED.
	 * If set to 0, blink_alt state is not supported on this LED.
	 */
	#define HWRM_PORT_LED_QCAPS_OUTPUT_LED1_STATE_CAPS_BLINK_ALT_SUPPORTED	UINT32_C(0x10)
	/* The colors supported by LED #1. */
	uint16_t	led1_color_caps;
	/* reserved. */
	#define HWRM_PORT_LED_QCAPS_OUTPUT_LED1_COLOR_CAPS_RSVD		UINT32_C(0x1)
	/*
	 * If set to 1, Amber color is supported on this LED.
	 * If set to 0, Amber color is not supported on this LED.
	 */
	#define HWRM_PORT_LED_QCAPS_OUTPUT_LED1_COLOR_CAPS_AMBER_SUPPORTED	UINT32_C(0x2)
	/*
	 * If set to 1, Green color is supported on this LED.
	 * If set to 0, Green color is not supported on this LED.
	 */
	#define HWRM_PORT_LED_QCAPS_OUTPUT_LED1_COLOR_CAPS_GREEN_SUPPORTED	UINT32_C(0x4)
	/* An identifier for the LED #2. */
	uint8_t	led2_id;
	/* The type of LED #2. */
	uint8_t	led2_type;
	/* Speed LED */
	#define HWRM_PORT_LED_QCAPS_OUTPUT_LED2_TYPE_SPEED	UINT32_C(0x0)
	/* Activity LED */
	#define HWRM_PORT_LED_QCAPS_OUTPUT_LED2_TYPE_ACTIVITY UINT32_C(0x1)
	/* Invalid */
	#define HWRM_PORT_LED_QCAPS_OUTPUT_LED2_TYPE_INVALID  UINT32_C(0xff)
	#define HWRM_PORT_LED_QCAPS_OUTPUT_LED2_TYPE_LAST	HWRM_PORT_LED_QCAPS_OUTPUT_LED2_TYPE_INVALID
	/*
	 * An identifier for the group of LEDs that LED #0 belongs
	 * to.
	 * If set to 0, then the LED #0 cannot be grouped.
	 * For all other non-zero values of this field, LED #0 is
	 * grouped together with the LEDs with the same group ID
	 * value.
	 */
	uint8_t	led2_group_id;
	uint8_t	unused_2;
	/* The states supported by LED #2. */
	uint16_t	led2_state_caps;
	/*
	 * If set to 1, this LED is enabled.
	 * If set to 0, this LED is disabled.
	 */
	#define HWRM_PORT_LED_QCAPS_OUTPUT_LED2_STATE_CAPS_ENABLED		UINT32_C(0x1)
	/*
	 * If set to 1, off state is supported on this LED.
	 * If set to 0, off state is not supported on this LED.
	 */
	#define HWRM_PORT_LED_QCAPS_OUTPUT_LED2_STATE_CAPS_OFF_SUPPORTED	UINT32_C(0x2)
	/*
	 * If set to 1, on state is supported on this LED.
	 * If set to 0, on state is not supported on this LED.
	 */
	#define HWRM_PORT_LED_QCAPS_OUTPUT_LED2_STATE_CAPS_ON_SUPPORTED		UINT32_C(0x4)
	/*
	 * If set to 1, blink state is supported on this LED.
	 * If set to 0, blink state is not supported on this LED.
	 */
	#define HWRM_PORT_LED_QCAPS_OUTPUT_LED2_STATE_CAPS_BLINK_SUPPORTED	UINT32_C(0x8)
	/*
	 * If set to 1, blink_alt state is supported on this LED.
	 * If set to 0, blink_alt state is not supported on this LED.
	 */
	#define HWRM_PORT_LED_QCAPS_OUTPUT_LED2_STATE_CAPS_BLINK_ALT_SUPPORTED	UINT32_C(0x10)
	/* The colors supported by LED #2. */
	uint16_t	led2_color_caps;
	/* reserved. */
	#define HWRM_PORT_LED_QCAPS_OUTPUT_LED2_COLOR_CAPS_RSVD		UINT32_C(0x1)
	/*
	 * If set to 1, Amber color is supported on this LED.
	 * If set to 0, Amber color is not supported on this LED.
	 */
	#define HWRM_PORT_LED_QCAPS_OUTPUT_LED2_COLOR_CAPS_AMBER_SUPPORTED	UINT32_C(0x2)
	/*
	 * If set to 1, Green color is supported on this LED.
	 * If set to 0, Green color is not supported on this LED.
	 */
	#define HWRM_PORT_LED_QCAPS_OUTPUT_LED2_COLOR_CAPS_GREEN_SUPPORTED	UINT32_C(0x4)
	/* An identifier for the LED #3. */
	uint8_t	led3_id;
	/* The type of LED #3. */
	uint8_t	led3_type;
	/* Speed LED */
	#define HWRM_PORT_LED_QCAPS_OUTPUT_LED3_TYPE_SPEED	UINT32_C(0x0)
	/* Activity LED */
	#define HWRM_PORT_LED_QCAPS_OUTPUT_LED3_TYPE_ACTIVITY UINT32_C(0x1)
	/* Invalid */
	#define HWRM_PORT_LED_QCAPS_OUTPUT_LED3_TYPE_INVALID  UINT32_C(0xff)
	#define HWRM_PORT_LED_QCAPS_OUTPUT_LED3_TYPE_LAST	HWRM_PORT_LED_QCAPS_OUTPUT_LED3_TYPE_INVALID
	/*
	 * An identifier for the group of LEDs that LED #3 belongs
	 * to.
	 * If set to 0, then the LED #0 cannot be grouped.
	 * For all other non-zero values of this field, LED #0 is
	 * grouped together with the LEDs with the same group ID
	 * value.
	 */
	uint8_t	led3_group_id;
	uint8_t	unused_3;
	/* The states supported by LED #3. */
	uint16_t	led3_state_caps;
	/*
	 * If set to 1, this LED is enabled.
	 * If set to 0, this LED is disabled.
	 */
	#define HWRM_PORT_LED_QCAPS_OUTPUT_LED3_STATE_CAPS_ENABLED		UINT32_C(0x1)
	/*
	 * If set to 1, off state is supported on this LED.
	 * If set to 0, off state is not supported on this LED.
	 */
	#define HWRM_PORT_LED_QCAPS_OUTPUT_LED3_STATE_CAPS_OFF_SUPPORTED	UINT32_C(0x2)
	/*
	 * If set to 1, on state is supported on this LED.
	 * If set to 0, on state is not supported on this LED.
	 */
	#define HWRM_PORT_LED_QCAPS_OUTPUT_LED3_STATE_CAPS_ON_SUPPORTED		UINT32_C(0x4)
	/*
	 * If set to 1, blink state is supported on this LED.
	 * If set to 0, blink state is not supported on this LED.
	 */
	#define HWRM_PORT_LED_QCAPS_OUTPUT_LED3_STATE_CAPS_BLINK_SUPPORTED	UINT32_C(0x8)
	/*
	 * If set to 1, blink_alt state is supported on this LED.
	 * If set to 0, blink_alt state is not supported on this LED.
	 */
	#define HWRM_PORT_LED_QCAPS_OUTPUT_LED3_STATE_CAPS_BLINK_ALT_SUPPORTED	UINT32_C(0x10)
	/* The colors supported by LED #3. */
	uint16_t	led3_color_caps;
	/* reserved. */
	#define HWRM_PORT_LED_QCAPS_OUTPUT_LED3_COLOR_CAPS_RSVD		UINT32_C(0x1)
	/*
	 * If set to 1, Amber color is supported on this LED.
	 * If set to 0, Amber color is not supported on this LED.
	 */
	#define HWRM_PORT_LED_QCAPS_OUTPUT_LED3_COLOR_CAPS_AMBER_SUPPORTED	UINT32_C(0x2)
	/*
	 * If set to 1, Green color is supported on this LED.
	 * If set to 0, Green color is not supported on this LED.
	 */
	#define HWRM_PORT_LED_QCAPS_OUTPUT_LED3_COLOR_CAPS_GREEN_SUPPORTED	UINT32_C(0x4)
	uint8_t	unused_4[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_port_led_qcaps_output_t, *phwrm_port_led_qcaps_output_t;

/***********************
 * hwrm_port_prbs_test *
 ***********************/


/* hwrm_port_prbs_test_input (size:384b/48B) */

typedef struct hwrm_port_prbs_test_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Host address data is to DMA'd to. */
	uint64_t	resp_data_addr;
	/*
	 * Size of the buffer pointed to by resp_data_addr. The firmware may
	 * use this entire buffer or less than the entire buffer, but never more.
	 */
	uint16_t	data_len;
	uint16_t	unused_0;
	uint32_t	unused_1;
	/* Port ID of port where PRBS test to be run. */
	uint16_t	port_id;
	/* Polynomial selection for PRBS test. */
	uint16_t	poly;
	/* PRBS7 */
	#define HWRM_PORT_PRBS_TEST_INPUT_POLY_PRBS7   UINT32_C(0x0)
	/* PRBS9 */
	#define HWRM_PORT_PRBS_TEST_INPUT_POLY_PRBS9   UINT32_C(0x1)
	/* PRBS11 */
	#define HWRM_PORT_PRBS_TEST_INPUT_POLY_PRBS11  UINT32_C(0x2)
	/* PRBS15 */
	#define HWRM_PORT_PRBS_TEST_INPUT_POLY_PRBS15  UINT32_C(0x3)
	/* PRBS23 */
	#define HWRM_PORT_PRBS_TEST_INPUT_POLY_PRBS23  UINT32_C(0x4)
	/* PRBS31 */
	#define HWRM_PORT_PRBS_TEST_INPUT_POLY_PRBS31  UINT32_C(0x5)
	/* PRBS58 */
	#define HWRM_PORT_PRBS_TEST_INPUT_POLY_PRBS58  UINT32_C(0x6)
	/* Invalid */
	#define HWRM_PORT_PRBS_TEST_INPUT_POLY_INVALID UINT32_C(0xff)
	#define HWRM_PORT_PRBS_TEST_INPUT_POLY_LAST   HWRM_PORT_PRBS_TEST_INPUT_POLY_INVALID
	/*
	 * Configuration bits for PRBS test.
	 * Use enable bit to start/stop test.
	 * Use tx/rx lane map bits to run test on specific lanes,
	 * if set to 0 test will be run on all lanes.
	 */
	uint16_t	prbs_config;
	/*
	 * Set 0 to stop test currently in progress
	 * Set 1 to start test with configuration provided.
	 */
	#define HWRM_PORT_PRBS_TEST_INPUT_PRBS_CONFIG_START_STOP		UINT32_C(0x1)
	/*
	 * If set to 1, tx_lane_map bitmap should have lane bits set.
	 * If set to 0, test will be run on all lanes for this port.
	 */
	#define HWRM_PORT_PRBS_TEST_INPUT_PRBS_CONFIG_TX_LANE_MAP_VALID	UINT32_C(0x2)
	/*
	 * If set to 1, rx_lane_map bitmap should have lane bits set.
	 * If set to 0, test will be run on all lanes for this port.
	 */
	#define HWRM_PORT_PRBS_TEST_INPUT_PRBS_CONFIG_RX_LANE_MAP_VALID	UINT32_C(0x4)
	/* Duration in seconds to run the PRBS test. */
	uint16_t	timeout;
	/*
	 * If tx_lane_map_valid is set to 1, this field is a bitmap
	 * of tx lanes to run PRBS test. bit0 = lane0,
	 * bit1 = lane1 ..bit31 = lane31
	 */
	uint32_t	tx_lane_map;
	/*
	 * If rx_lane_map_valid is set to 1, this field is a bitmap
	 * of rx lanes to run PRBS test. bit0 = lane0,
	 * bit1 = lane1 ..bit31 = lane31
	 */
	uint32_t	rx_lane_map;
} hwrm_port_prbs_test_input_t, *phwrm_port_prbs_test_input_t;

/* hwrm_port_prbs_test_output (size:128b/16B) */

typedef struct hwrm_port_prbs_test_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Total length of stored data. */
	uint16_t	total_data_len;
	uint16_t	unused_0;
	uint8_t	unused_1[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_port_prbs_test_output_t, *phwrm_port_prbs_test_output_t;

/**********************
 * hwrm_port_dsc_dump *
 **********************/


/* hwrm_port_dsc_dump_input (size:320b/40B) */

typedef struct hwrm_port_dsc_dump_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Host address where response diagnostic data is returned. */
	uint64_t	resp_data_addr;
	/*
	 * Size of the buffer pointed to by resp_data_addr. The firmware
	 * may use this entire buffer or less than the entire buffer, but
	 * never more.
	 */
	uint16_t	data_len;
	uint16_t	unused_0;
	uint32_t	unused_1;
	/* Port ID of port where dsc dump to be collected. */
	uint16_t	port_id;
	/* Diag level specified by the user */
	uint16_t	diag_level;
	/* SRDS_DIAG_LANE */
	#define HWRM_PORT_DSC_DUMP_INPUT_DIAG_LEVEL_SRDS_DIAG_LANE	UINT32_C(0x0)
	/* SRDS_DIAG_CORE */
	#define HWRM_PORT_DSC_DUMP_INPUT_DIAG_LEVEL_SRDS_DIAG_CORE	UINT32_C(0x1)
	/* SRDS_DIAG_EVENT */
	#define HWRM_PORT_DSC_DUMP_INPUT_DIAG_LEVEL_SRDS_DIAG_EVENT	UINT32_C(0x2)
	/* SRDS_DIAG_EYE */
	#define HWRM_PORT_DSC_DUMP_INPUT_DIAG_LEVEL_SRDS_DIAG_EYE	UINT32_C(0x3)
	/* SRDS_DIAG_REG_CORE */
	#define HWRM_PORT_DSC_DUMP_INPUT_DIAG_LEVEL_SRDS_DIAG_REG_CORE   UINT32_C(0x4)
	/* SRDS_DIAG_REG_LANE */
	#define HWRM_PORT_DSC_DUMP_INPUT_DIAG_LEVEL_SRDS_DIAG_REG_LANE   UINT32_C(0x5)
	/* SRDS_DIAG_UC_CORE */
	#define HWRM_PORT_DSC_DUMP_INPUT_DIAG_LEVEL_SRDS_DIAG_UC_CORE	UINT32_C(0x6)
	/* SRDS_DIAG_UC_LANE */
	#define HWRM_PORT_DSC_DUMP_INPUT_DIAG_LEVEL_SRDS_DIAG_UC_LANE	UINT32_C(0x7)
	/* SRDS_DIAG_LANE_DEBUG */
	#define HWRM_PORT_DSC_DUMP_INPUT_DIAG_LEVEL_SRDS_DIAG_LANE_DEBUG UINT32_C(0x8)
	/* SRDS_DIAG_BER_VERT */
	#define HWRM_PORT_DSC_DUMP_INPUT_DIAG_LEVEL_SRDS_DIAG_BER_VERT   UINT32_C(0x9)
	/* SRDS_DIAG_BER_HORZ */
	#define HWRM_PORT_DSC_DUMP_INPUT_DIAG_LEVEL_SRDS_DIAG_BER_HORZ   UINT32_C(0xa)
	/* SRDS_DIAG_EVENT_SAFE */
	#define HWRM_PORT_DSC_DUMP_INPUT_DIAG_LEVEL_SRDS_DIAG_EVENT_SAFE UINT32_C(0xb)
	/* SRDS_DIAG_TIMESTAMP */
	#define HWRM_PORT_DSC_DUMP_INPUT_DIAG_LEVEL_SRDS_DIAG_TIMESTAMP  UINT32_C(0xc)
	#define HWRM_PORT_DSC_DUMP_INPUT_DIAG_LEVEL_LAST		HWRM_PORT_DSC_DUMP_INPUT_DIAG_LEVEL_SRDS_DIAG_TIMESTAMP
	/*
	 * This field is a lane number
	 * on which to collect the dsc dump
	 */
	uint16_t	lane_number;
	/*
	 * Configuration bits.
	 * Use enable bit to start dsc dump or retrieve dump
	 */
	uint16_t	dsc_dump_config;
	/*
	 * Set 0 to retrieve the dsc dump
	 * Set 1 to start the dsc dump
	 */
	#define HWRM_PORT_DSC_DUMP_INPUT_DSC_DUMP_CONFIG_START_RETRIEVE	UINT32_C(0x1)
} hwrm_port_dsc_dump_input_t, *phwrm_port_dsc_dump_input_t;

/* hwrm_port_dsc_dump_output (size:128b/16B) */

typedef struct hwrm_port_dsc_dump_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Total length of stored data. */
	uint16_t	total_data_len;
	uint16_t	unused_0;
	uint8_t	unused_1[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_port_dsc_dump_output_t, *phwrm_port_dsc_dump_output_t;

/******************************
 * hwrm_port_sfp_sideband_cfg *
 ******************************/


/* hwrm_port_sfp_sideband_cfg_input (size:256b/32B) */

typedef struct hwrm_port_sfp_sideband_cfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Port ID of port that is to be queried. */
	uint16_t	port_id;
	uint8_t	unused_0[6];
	/*
	 * This bitfield is used to specify which bits from the 'flags'
	 * fields are being configured by the caller.
	 */
	uint32_t	enables;
	/* This bit must be '1' for rs0 to be configured. */
	#define HWRM_PORT_SFP_SIDEBAND_CFG_INPUT_ENABLES_RS0	UINT32_C(0x1)
	/* This bit must be '1' for rs1 to be configured. */
	#define HWRM_PORT_SFP_SIDEBAND_CFG_INPUT_ENABLES_RS1	UINT32_C(0x2)
	/* This bit must be '1' for tx_disable to be configured. */
	#define HWRM_PORT_SFP_SIDEBAND_CFG_INPUT_ENABLES_TX_DIS	UINT32_C(0x4)
	/*
	 * This bit must be '1' for mod_sel to be configured.
	 * Valid only on QSFP modules
	 */
	#define HWRM_PORT_SFP_SIDEBAND_CFG_INPUT_ENABLES_MOD_SEL	UINT32_C(0x8)
	/* This bit must be '1' for reset_l to be configured. */
	#define HWRM_PORT_SFP_SIDEBAND_CFG_INPUT_ENABLES_RESET_L	UINT32_C(0x10)
	/* This bit must be '1' for lp_mode to be configured. */
	#define HWRM_PORT_SFP_SIDEBAND_CFG_INPUT_ENABLES_LP_MODE	UINT32_C(0x20)
	/* This bit must be '1' for pwr_disable to be configured. */
	#define HWRM_PORT_SFP_SIDEBAND_CFG_INPUT_ENABLES_PWR_DIS	UINT32_C(0x40)
	/*
	 * Only bits that have corresponding bits in the 'enables'
	 * bitfield are processed by the firmware, all other bits
	 * of 'flags' are ignored.
	 */
	uint32_t	flags;
	/*
	 * This bit along with rs1 configures the current speed of the dual
	 * rate module. If these pins are GNDed then the speed can be changed
	 * by driectly writing to EEPROM.
	 */
	#define HWRM_PORT_SFP_SIDEBAND_CFG_INPUT_FLAGS_RS0	UINT32_C(0x1)
	/*
	 * This bit along with rs0 configures the current speed of the dual
	 * rate module. If these pins are GNDed then the speed can be changed
	 * by driectly writing to EEPROM.
	 */
	#define HWRM_PORT_SFP_SIDEBAND_CFG_INPUT_FLAGS_RS1	UINT32_C(0x2)
	/*
	 * When this bit is set to '1', tx_disable is set.
	 * On a 1G BASE-T module, if this bit is set,
	 * module PHY registers will not be accessible.
	 */
	#define HWRM_PORT_SFP_SIDEBAND_CFG_INPUT_FLAGS_TX_DIS	UINT32_C(0x4)
	/*
	 * When this bit is set to '1', this module is selected.
	 * Valid only on QSFP modules
	 */
	#define HWRM_PORT_SFP_SIDEBAND_CFG_INPUT_FLAGS_MOD_SEL	UINT32_C(0x8)
	/*
	 * If reset_l is set to 0, Module will be taken out of reset
	 * and other signals will be set to their requested state once
	 * the module is out of reset.
	 * Valid only on QSFP modules
	 */
	#define HWRM_PORT_SFP_SIDEBAND_CFG_INPUT_FLAGS_RESET_L	UINT32_C(0x10)
	/*
	 * When this bit is set to '1', the module will be configured
	 * in low power mode.
	 * Valid only on QSFP modules
	 */
	#define HWRM_PORT_SFP_SIDEBAND_CFG_INPUT_FLAGS_LP_MODE	UINT32_C(0x20)
	/* When this bit is set to '1', the module will be powered down. */
	#define HWRM_PORT_SFP_SIDEBAND_CFG_INPUT_FLAGS_PWR_DIS	UINT32_C(0x40)
} hwrm_port_sfp_sideband_cfg_input_t, *phwrm_port_sfp_sideband_cfg_input_t;

/* hwrm_port_sfp_sideband_cfg_output (size:128b/16B) */

typedef struct hwrm_port_sfp_sideband_cfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_port_sfp_sideband_cfg_output_t, *phwrm_port_sfp_sideband_cfg_output_t;

/*******************************
 * hwrm_port_sfp_sideband_qcfg *
 *******************************/


/* hwrm_port_sfp_sideband_qcfg_input (size:192b/24B) */

typedef struct hwrm_port_sfp_sideband_qcfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Port ID of port that is to be queried. */
	uint16_t	port_id;
	uint8_t	unused_0[6];
} hwrm_port_sfp_sideband_qcfg_input_t, *phwrm_port_sfp_sideband_qcfg_input_t;

/* hwrm_port_sfp_sideband_qcfg_output (size:192b/24B) */

typedef struct hwrm_port_sfp_sideband_qcfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * Bitmask indicating which sideband signals are valid.
	 * This is based on the board and nvm cfg that is present on the board.
	 */
	uint32_t	supported_mask;
	uint32_t	sideband_signals;
	/* When this bit is set to '1', the Module is absent. */
	#define HWRM_PORT_SFP_SIDEBAND_QCFG_OUTPUT_SIDEBAND_SIGNALS_MOD_ABS	UINT32_C(0x1)
	/*
	 * When this bit is set to '1', there is no valid signal on RX.
	 * This signal is a filtered version of Signal Detect.
	 */
	#define HWRM_PORT_SFP_SIDEBAND_QCFG_OUTPUT_SIDEBAND_SIGNALS_RX_LOS	UINT32_C(0x2)
	/*
	 * This bit along with rs1 indiactes the current speed of the dual
	 * rate module.If these pins are grounded then the speed can be
	 * changed by driectky writing to EEPROM.
	 */
	#define HWRM_PORT_SFP_SIDEBAND_QCFG_OUTPUT_SIDEBAND_SIGNALS_RS0	UINT32_C(0x4)
	/*
	 * This bit along with rs0 indiactes the current speed of the dual
	 * rate module.If these pins are grounded then the speed can be
	 * changed by driectky writing to EEPROM.
	 */
	#define HWRM_PORT_SFP_SIDEBAND_QCFG_OUTPUT_SIDEBAND_SIGNALS_RS1	UINT32_C(0x8)
	/*
	 * When this bit is set to '1', tx_disable is set.
	 * On a 1G BASE-T module, if this bit is set, module PHY
	 * registers will not be accessible.
	 */
	#define HWRM_PORT_SFP_SIDEBAND_QCFG_OUTPUT_SIDEBAND_SIGNALS_TX_DIS	UINT32_C(0x10)
	/* When this bit is set to '1', tx_fault is set. */
	#define HWRM_PORT_SFP_SIDEBAND_QCFG_OUTPUT_SIDEBAND_SIGNALS_TX_FAULT	UINT32_C(0x20)
	/*
	 * When this bit is set to '1', module is selected.
	 * Valid only on QSFP modules
	 */
	#define HWRM_PORT_SFP_SIDEBAND_QCFG_OUTPUT_SIDEBAND_SIGNALS_MOD_SEL	UINT32_C(0x40)
	/*
	 * When this bit is set to '0', the module is held in reset.
	 * if reset_l is set to 1,first module is taken out of reset
	 * and other signals will be set to their requested state.
	 * Valid only on QSFP modules.
	 */
	#define HWRM_PORT_SFP_SIDEBAND_QCFG_OUTPUT_SIDEBAND_SIGNALS_RESET_L	UINT32_C(0x80)
	/*
	 * When this bit is set to '1', the module is in low power mode.
	 * Valid only on QSFP modules
	 */
	#define HWRM_PORT_SFP_SIDEBAND_QCFG_OUTPUT_SIDEBAND_SIGNALS_LP_MODE	UINT32_C(0x100)
	/* When this bit is set to '1', module is in power down state. */
	#define HWRM_PORT_SFP_SIDEBAND_QCFG_OUTPUT_SIDEBAND_SIGNALS_PWR_DIS	UINT32_C(0x200)
	uint8_t	unused[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written. When
	 * writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_port_sfp_sideband_qcfg_output_t, *phwrm_port_sfp_sideband_qcfg_output_t;

/**********************************
 * hwrm_port_phy_mdio_bus_acquire *
 **********************************/


/* hwrm_port_phy_mdio_bus_acquire_input (size:192b/24B) */

typedef struct hwrm_port_phy_mdio_bus_acquire_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Port ID of the port. */
	uint16_t	port_id;
	/*
	 * client_id of the client requesting BUS access.
	 * Any value from 0x10 to 0xFFFF can be used.
	 * Client should make sure that the returned client_id
	 * in response matches the client_id in request.
	 * 0-0xF are reserved for internal use.
	 */
	uint16_t	client_id;
	/*
	 * Timeout in milli seconds, MDIO BUS will be released automatically
	 * after this time, if another mdio acquire command is not received
	 * within the timeout window from the same client.
	 * A 0xFFFF will hold the bus until this bus is released.
	 */
	uint16_t	mdio_bus_timeout;
	uint8_t	unused_0[2];
} hwrm_port_phy_mdio_bus_acquire_input_t, *phwrm_port_phy_mdio_bus_acquire_input_t;

/* hwrm_port_phy_mdio_bus_acquire_output (size:128b/16B) */

typedef struct hwrm_port_phy_mdio_bus_acquire_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint16_t	unused_0;
	/*
	 * client_id of the module holding the BUS.
	 * 0-0xF are reserved for internal use.
	 */
	uint16_t	client_id;
	uint8_t	unused_1[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_port_phy_mdio_bus_acquire_output_t, *phwrm_port_phy_mdio_bus_acquire_output_t;

/**********************************
 * hwrm_port_phy_mdio_bus_release *
 **********************************/


/* hwrm_port_phy_mdio_bus_release_input (size:192b/24B) */

typedef struct hwrm_port_phy_mdio_bus_release_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Port ID of the port. */
	uint16_t	port_id;
	/*
	 * client_id of the client requesting BUS release.
	 * A client should not release any other clients BUS.
	 */
	uint16_t	client_id;
	uint8_t	unused_0[4];
} hwrm_port_phy_mdio_bus_release_input_t, *phwrm_port_phy_mdio_bus_release_input_t;

/* hwrm_port_phy_mdio_bus_release_output (size:128b/16B) */

typedef struct hwrm_port_phy_mdio_bus_release_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint16_t	unused_0;
	/* The BUS is released if client_id matches the client_id in request. */
	uint16_t	clients_id;
	uint8_t	unused_1[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_port_phy_mdio_bus_release_output_t, *phwrm_port_phy_mdio_bus_release_output_t;

/************************
 * hwrm_port_tx_fir_cfg *
 ************************/


/* hwrm_port_tx_fir_cfg_input (size:320b/40B) */

typedef struct hwrm_port_tx_fir_cfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Modulation types of TX FIR: NRZ, PAM4. */
	uint8_t	mod_type;
	/* For NRZ */
	#define HWRM_PORT_TX_FIR_CFG_INPUT_MOD_TYPE_NRZ  UINT32_C(0x0)
	/* For PAM4 */
	#define HWRM_PORT_TX_FIR_CFG_INPUT_MOD_TYPE_PAM4 UINT32_C(0x1)
	#define HWRM_PORT_TX_FIR_CFG_INPUT_MOD_TYPE_LAST HWRM_PORT_TX_FIR_CFG_INPUT_MOD_TYPE_PAM4
	/* The lane mask of the lane TX FIR will be configured. */
	uint8_t	lane_mask;
	uint8_t	unused_0[2];
	/* Value1 of TX FIR, required for NRZ or PAM4. */
	uint32_t	txfir_val_1;
	/* Value2 of TX FIR, required for NRZ or PAM4. */
	uint32_t	txfir_val_2;
	/* Value3 of TX FIR, required for PAM4. */
	uint32_t	txfir_val_3;
	/* Value4 of TX FIR, required for PAM4. */
	uint32_t	txfir_val_4;
	uint8_t	unused_1[4];
} hwrm_port_tx_fir_cfg_input_t, *phwrm_port_tx_fir_cfg_input_t;

/* hwrm_port_tx_fir_cfg_output (size:128b/16B) */

typedef struct hwrm_port_tx_fir_cfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_port_tx_fir_cfg_output_t, *phwrm_port_tx_fir_cfg_output_t;

/*************************
 * hwrm_port_tx_fir_qcfg *
 *************************/


/* hwrm_port_tx_fir_qcfg_input (size:192b/24B) */

typedef struct hwrm_port_tx_fir_qcfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Modulation types of TX FIR: NRZ, PAM4. */
	uint8_t	mod_type;
	/* For NRZ */
	#define HWRM_PORT_TX_FIR_QCFG_INPUT_MOD_TYPE_NRZ  UINT32_C(0x0)
	/* For PAM4 */
	#define HWRM_PORT_TX_FIR_QCFG_INPUT_MOD_TYPE_PAM4 UINT32_C(0x1)
	#define HWRM_PORT_TX_FIR_QCFG_INPUT_MOD_TYPE_LAST HWRM_PORT_TX_FIR_QCFG_INPUT_MOD_TYPE_PAM4
	/* The ID of the lane TX FIR will be queried. */
	uint8_t	lane_id;
	uint8_t	unused[6];
} hwrm_port_tx_fir_qcfg_input_t, *phwrm_port_tx_fir_qcfg_input_t;

/* hwrm_port_tx_fir_qcfg_output (size:256b/32B) */

typedef struct hwrm_port_tx_fir_qcfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Value1 of TX FIR, required for NRZ or PAM4. */
	uint32_t	txfir_val_1;
	/* Value2 of TX FIR, required for NRZ or PAM4. */
	uint32_t	txfir_val_2;
	/* Value3 of TX FIR, required for PAM4. */
	uint32_t	txfir_val_3;
	/* Value4 of TX FIR, required for PAM4. */
	uint32_t	txfir_val_4;
	uint8_t	unused[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_port_tx_fir_qcfg_output_t, *phwrm_port_tx_fir_qcfg_output_t;

/***********************
 * hwrm_queue_qportcfg *
 ***********************/


/* hwrm_queue_qportcfg_input (size:192b/24B) */

typedef struct hwrm_queue_qportcfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	flags;
	/*
	 * Enumeration denoting the RX, TX type of the resource.
	 * This enumeration is used for resources that are similar for both
	 * TX and RX paths of the chip.
	 */
	#define HWRM_QUEUE_QPORTCFG_INPUT_FLAGS_PATH	UINT32_C(0x1)
	/* tx path */
		#define HWRM_QUEUE_QPORTCFG_INPUT_FLAGS_PATH_TX	UINT32_C(0x0)
	/* rx path */
		#define HWRM_QUEUE_QPORTCFG_INPUT_FLAGS_PATH_RX	UINT32_C(0x1)
		#define HWRM_QUEUE_QPORTCFG_INPUT_FLAGS_PATH_LAST HWRM_QUEUE_QPORTCFG_INPUT_FLAGS_PATH_RX
	/*
	 * Port ID of port for which the queue configuration is being
	 * queried. This field is only required when sent by IPC.
	 */
	uint16_t	port_id;
	/*
	 * Drivers will set this capability when it can use
	 * queue_idx_service_profile to map the queues to application.
	 */
	uint8_t	drv_qmap_cap;
	/* disabled */
	#define HWRM_QUEUE_QPORTCFG_INPUT_DRV_QMAP_CAP_DISABLED UINT32_C(0x0)
	/* enabled */
	#define HWRM_QUEUE_QPORTCFG_INPUT_DRV_QMAP_CAP_ENABLED  UINT32_C(0x1)
	#define HWRM_QUEUE_QPORTCFG_INPUT_DRV_QMAP_CAP_LAST	HWRM_QUEUE_QPORTCFG_INPUT_DRV_QMAP_CAP_ENABLED
	uint8_t	unused_0;
} hwrm_queue_qportcfg_input_t, *phwrm_queue_qportcfg_input_t;

/* hwrm_queue_qportcfg_output (size:1344b/168B) */

typedef struct hwrm_queue_qportcfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * The maximum number of queues that can be configured on this
	 * port.
	 * Valid values range from 1 through 8.
	 */
	uint8_t	max_configurable_queues;
	/*
	 * The maximum number of lossless queues that can be configured
	 * on this port.
	 * Valid values range from 0 through 8.
	 */
	uint8_t	max_configurable_lossless_queues;
	/*
	 * Bitmask indicating which queues can be configured by the
	 * hwrm_queue_cfg command.
	 *
	 * Each bit represents a specific queue where bit 0 represents
	 * queue 0 and bit 7 represents queue 7.
	 * # A value of 0 indicates that the queue is not configurable
	 * by the hwrm_queue_cfg command.
	 * # A value of 1 indicates that the queue is configurable.
	 * # A hwrm_queue_cfg command shall return error when trying to
	 * configure a queue not configurable.
	 */
	uint8_t	queue_cfg_allowed;
	/* Information about queue configuration. */
	uint8_t	queue_cfg_info;
	/*
	 * If this flag is set to '1', then the queues are
	 * configured asymmetrically on TX and RX sides.
	 * If this flag is set to '0', then the queues are
	 * configured symmetrically on TX and RX sides. For
	 * symmetric configuration, the queue configuration
	 * including queue ids and service profiles on the
	 * TX side is the same as the corresponding queue
	 * configuration on the RX side.
	 */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_CFG_INFO_ASYM_CFG		UINT32_C(0x1)
	/*
	 * If this flag is set to '1', then service_profile will carry
	 * either lossy/lossless type and the new service_profile_type
	 * field will be used to determine if the queue is for L2/ROCE/CNP.
	 */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_CFG_INFO_USE_PROFILE_TYPE	UINT32_C(0x2)
	/*
	 * Bitmask indicating which queues can be configured by the
	 * hwrm_queue_pfcenable_cfg command.
	 *
	 * Each bit represents a specific priority where bit 0 represents
	 * priority 0 and bit 7 represents priority 7.
	 * # A value of 0 indicates that the priority is not configurable by
	 * the hwrm_queue_pfcenable_cfg command.
	 * # A value of 1 indicates that the priority is configurable.
	 * # A hwrm_queue_pfcenable_cfg command shall return error when
	 * trying to configure a priority that is not configurable.
	 */
	uint8_t	queue_pfcenable_cfg_allowed;
	/*
	 * Bitmask indicating which queues can be configured by the
	 * hwrm_queue_pri2cos_cfg command.
	 *
	 * Each bit represents a specific queue where bit 0 represents
	 * queue 0 and bit 7 represents queue 7.
	 * # A value of 0 indicates that the queue is not configurable
	 * by the hwrm_queue_pri2cos_cfg command.
	 * # A value of 1 indicates that the queue is configurable.
	 * # A hwrm_queue_pri2cos_cfg command shall return error when
	 * trying to configure a queue that is not configurable.
	 */
	uint8_t	queue_pri2cos_cfg_allowed;
	/*
	 * Bitmask indicating which queues can be configured by the
	 * hwrm_queue_pri2cos_cfg command.
	 *
	 * Each bit represents a specific queue where bit 0 represents
	 * queue 0 and bit 7 represents queue 7.
	 * # A value of 0 indicates that the queue is not configurable
	 * by the hwrm_queue_pri2cos_cfg command.
	 * # A value of 1 indicates that the queue is configurable.
	 * # A hwrm_queue_pri2cos_cfg command shall return error when
	 * trying to configure a queue not configurable.
	 */
	uint8_t	queue_cos2bw_cfg_allowed;
	/*
	 * ID of CoS Queue 0.
	 * FF - Invalid id
	 *
	 * # This ID can be used on any subsequent call to an hwrm command
	 * that takes a queue id.
	 * # IDs must always be queried by this command before any use
	 * by the driver or software.
	 * # The CoS queue index is obtained by applying modulo 10 to the
	 * CoS queue ID. Valid CoS queue indexes are in the range of 0 to 7.
	 * The CoS queue index is used to reference port statistics for the
	 * CoS queue.
	 * # A value of 0xff indicates that the queue is not available.
	 * # Available queues may not be in sequential order.
	 */
	uint8_t	queue_id0;
	/* This value specifies service profile kind for CoS queue */
	uint8_t	queue_id0_service_profile;
	/* Lossy (best-effort) */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID0_SERVICE_PROFILE_LOSSY	UINT32_C(0x0)
	/* Lossless */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID0_SERVICE_PROFILE_LOSSLESS	UINT32_C(0x1)
	/* Lossless RoCE (deprecated) */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID0_SERVICE_PROFILE_LOSSLESS_ROCE  UINT32_C(0x1)
	/* Lossy RoCE CNP (deprecated) */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID0_SERVICE_PROFILE_LOSSY_ROCE_CNP UINT32_C(0x2)
	/* Lossless NIC (deprecated) */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID0_SERVICE_PROFILE_LOSSLESS_NIC   UINT32_C(0x3)
	/* Set to 0xFF... (All Fs) if there is no service profile specified */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID0_SERVICE_PROFILE_UNKNOWN	UINT32_C(0xff)
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID0_SERVICE_PROFILE_LAST	HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID0_SERVICE_PROFILE_UNKNOWN
	/*
	 * ID of CoS Queue 1.
	 * FF - Invalid id
	 *
	 * # This ID can be used on any subsequent call to an hwrm command
	 * that takes a queue id.
	 * # IDs must always be queried by this command before any use
	 * by the driver or software.
	 * # The CoS queue index is obtained by applying modulo 10 to the
	 * CoS queue ID. Valid CoS queue indexes are in the range of 0 to 7.
	 * The CoS queue index is used to reference port statistics for the
	 * CoS queue.
	 * # A value of 0xff indicates that the queue is not available.
	 * # Available queues may not be in sequential order.
	 */
	uint8_t	queue_id1;
	/* This value specifies service profile kind for CoS queue */
	uint8_t	queue_id1_service_profile;
	/* Lossy (best-effort) */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID1_SERVICE_PROFILE_LOSSY	UINT32_C(0x0)
	/* Lossless */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID1_SERVICE_PROFILE_LOSSLESS	UINT32_C(0x1)
	/* Lossless RoCE (deprecated) */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID1_SERVICE_PROFILE_LOSSLESS_ROCE  UINT32_C(0x1)
	/* Lossy RoCE CNP (deprecated) */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID1_SERVICE_PROFILE_LOSSY_ROCE_CNP UINT32_C(0x2)
	/* Lossless NIC (deprecated) */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID1_SERVICE_PROFILE_LOSSLESS_NIC   UINT32_C(0x3)
	/* Set to 0xFF... (All Fs) if there is no service profile specified */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID1_SERVICE_PROFILE_UNKNOWN	UINT32_C(0xff)
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID1_SERVICE_PROFILE_LAST	HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID1_SERVICE_PROFILE_UNKNOWN
	/*
	 * ID of CoS Queue 2.
	 * FF - Invalid id
	 *
	 * # This ID can be used on any subsequent call to an hwrm command
	 * that takes a queue id.
	 * # IDs must always be queried by this command before any use
	 * by the driver or software.
	 * # The CoS queue index is obtained by applying modulo 10 to the
	 * CoS queue ID. Valid CoS queue indexes are in the range of 0 to 7.
	 * The CoS queue index is used to reference port statistics for the
	 * CoS queue.
	 * # A value of 0xff indicates that the queue is not available.
	 * # Available queues may not be in sequential order.
	 */
	uint8_t	queue_id2;
	/* This value specifies service profile kind for CoS queue */
	uint8_t	queue_id2_service_profile;
	/* Lossy (best-effort) */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID2_SERVICE_PROFILE_LOSSY	UINT32_C(0x0)
	/* Lossless */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID2_SERVICE_PROFILE_LOSSLESS	UINT32_C(0x1)
	/* Lossless RoCE (deprecated) */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID2_SERVICE_PROFILE_LOSSLESS_ROCE  UINT32_C(0x1)
	/* Lossy RoCE CNP (deprecated) */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID2_SERVICE_PROFILE_LOSSY_ROCE_CNP UINT32_C(0x2)
	/* Lossless NIC (deprecated) */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID2_SERVICE_PROFILE_LOSSLESS_NIC   UINT32_C(0x3)
	/* Set to 0xFF... (All Fs) if there is no service profile specified */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID2_SERVICE_PROFILE_UNKNOWN	UINT32_C(0xff)
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID2_SERVICE_PROFILE_LAST	HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID2_SERVICE_PROFILE_UNKNOWN
	/*
	 * ID of CoS Queue 3.
	 * FF - Invalid id
	 *
	 * # This ID can be used on any subsequent call to an hwrm command
	 * that takes a queue id.
	 * # IDs must always be queried by this command before any use
	 * by the driver or software.
	 * # The CoS queue index is obtained by applying modulo 10 to the
	 * CoS queue ID. Valid CoS queue indexes are in the range of 0 to 7.
	 * The CoS queue index is used to reference port statistics for the
	 * CoS queue.
	 * # A value of 0xff indicates that the queue is not available.
	 * # Available queues may not be in sequential order.
	 */
	uint8_t	queue_id3;
	/* This value specifies service profile kind for CoS queue */
	uint8_t	queue_id3_service_profile;
	/* Lossy (best-effort) */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID3_SERVICE_PROFILE_LOSSY	UINT32_C(0x0)
	/* Lossless */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID3_SERVICE_PROFILE_LOSSLESS	UINT32_C(0x1)
	/* Lossless RoCE (deprecated) */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID3_SERVICE_PROFILE_LOSSLESS_ROCE  UINT32_C(0x1)
	/* Lossy RoCE CNP (deprecated) */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID3_SERVICE_PROFILE_LOSSY_ROCE_CNP UINT32_C(0x2)
	/* Lossless NIC (deprecated) */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID3_SERVICE_PROFILE_LOSSLESS_NIC   UINT32_C(0x3)
	/* Set to 0xFF... (All Fs) if there is no service profile specified */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID3_SERVICE_PROFILE_UNKNOWN	UINT32_C(0xff)
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID3_SERVICE_PROFILE_LAST	HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID3_SERVICE_PROFILE_UNKNOWN
	/*
	 * ID of CoS Queue 4.
	 * FF - Invalid id
	 *
	 * # This ID can be used on any subsequent call to an hwrm command
	 * that takes a queue id.
	 * # IDs must always be queried by this command before any use
	 * by the driver or software.
	 * # The CoS queue index is obtained by applying modulo 10 to the
	 * CoS queue ID. Valid CoS queue indexes are in the range of 0 to 7.
	 * The CoS queue index is used to reference port statistics for the
	 * CoS queue.
	 * # A value of 0xff indicates that the queue is not available.
	 * # Available queues may not be in sequential order.
	 */
	uint8_t	queue_id4;
	/* This value specifies service profile kind for CoS queue */
	uint8_t	queue_id4_service_profile;
	/* Lossy (best-effort) */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID4_SERVICE_PROFILE_LOSSY	UINT32_C(0x0)
	/* Lossless */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID4_SERVICE_PROFILE_LOSSLESS	UINT32_C(0x1)
	/* Lossless RoCE (deprecated) */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID4_SERVICE_PROFILE_LOSSLESS_ROCE  UINT32_C(0x1)
	/* Lossy RoCE CNP (deprecated) */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID4_SERVICE_PROFILE_LOSSY_ROCE_CNP UINT32_C(0x2)
	/* Lossless NIC (deprecated) */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID4_SERVICE_PROFILE_LOSSLESS_NIC   UINT32_C(0x3)
	/* Set to 0xFF... (All Fs) if there is no service profile specified */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID4_SERVICE_PROFILE_UNKNOWN	UINT32_C(0xff)
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID4_SERVICE_PROFILE_LAST	HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID4_SERVICE_PROFILE_UNKNOWN
	/*
	 * ID of CoS Queue 5.
	 * FF - Invalid id
	 *
	 * # This ID can be used on any subsequent call to an hwrm command
	 * that takes a queue id.
	 * # IDs must always be queried by this command before any use
	 * by the driver or software.
	 * # The CoS queue index is obtained by applying modulo 10 to the
	 * CoS queue ID. Valid CoS queue indexes are in the range of 0 to 7.
	 * The CoS queue index is used to reference port statistics for the
	 * CoS queue.
	 * # A value of 0xff indicates that the queue is not available.
	 * # Available queues may not be in sequential order.
	 */
	uint8_t	queue_id5;
	/* This value specifies service profile kind for CoS queue */
	uint8_t	queue_id5_service_profile;
	/* Lossy (best-effort) */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID5_SERVICE_PROFILE_LOSSY	UINT32_C(0x0)
	/* Lossless */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID5_SERVICE_PROFILE_LOSSLESS	UINT32_C(0x1)
	/* Lossless RoCE (deprecated) */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID5_SERVICE_PROFILE_LOSSLESS_ROCE  UINT32_C(0x1)
	/* Lossy RoCE CNP (deprecated) */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID5_SERVICE_PROFILE_LOSSY_ROCE_CNP UINT32_C(0x2)
	/* Lossless NIC (deprecated) */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID5_SERVICE_PROFILE_LOSSLESS_NIC   UINT32_C(0x3)
	/* Set to 0xFF... (All Fs) if there is no service profile specified */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID5_SERVICE_PROFILE_UNKNOWN	UINT32_C(0xff)
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID5_SERVICE_PROFILE_LAST	HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID5_SERVICE_PROFILE_UNKNOWN
	/*
	 * ID of CoS Queue 6.
	 * FF - Invalid id
	 *
	 * # This ID can be used on any subsequent call to an hwrm command
	 * that takes a queue id.
	 * # IDs must always be queried by this command before any use
	 * by the driver or software.
	 * # The CoS queue index is obtained by applying modulo 10 to the
	 * CoS queue ID. Valid CoS queue indexes are in the range of 0 to 7.
	 * The CoS queue index is used to reference port statistics for the
	 * CoS queue.
	 * # A value of 0xff indicates that the queue is not available.
	 * # Available queues may not be in sequential order.
	 */
	uint8_t	queue_id6;
	/* This value specifies service profile kind for CoS queue */
	uint8_t	queue_id6_service_profile;
	/* Lossy (best-effort) */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID6_SERVICE_PROFILE_LOSSY	UINT32_C(0x0)
	/* Lossless */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID6_SERVICE_PROFILE_LOSSLESS	UINT32_C(0x1)
	/* Lossless RoCE (deprecated) */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID6_SERVICE_PROFILE_LOSSLESS_ROCE  UINT32_C(0x1)
	/* Lossy RoCE CNP (deprecated) */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID6_SERVICE_PROFILE_LOSSY_ROCE_CNP UINT32_C(0x2)
	/* Lossless NIC (deprecated) */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID6_SERVICE_PROFILE_LOSSLESS_NIC   UINT32_C(0x3)
	/* Set to 0xFF... (All Fs) if there is no service profile specified */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID6_SERVICE_PROFILE_UNKNOWN	UINT32_C(0xff)
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID6_SERVICE_PROFILE_LAST	HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID6_SERVICE_PROFILE_UNKNOWN
	/*
	 * ID of CoS Queue 7.
	 * FF - Invalid id
	 *
	 * # This ID can be used on any subsequent call to an hwrm command
	 * that takes a queue id.
	 * # IDs must always be queried by this command before any use
	 * by the driver or software.
	 * # The CoS queue index is obtained by applying modulo 10 to the
	 * CoS queue ID. Valid CoS queue indexes are in the range of 0 to 7.
	 * The CoS queue index is used to reference port statistics for the
	 * CoS queue.
	 * # A value of 0xff indicates that the queue is not available.
	 * # Available queues may not be in sequential order.
	 */
	uint8_t	queue_id7;
	/* This value specifies service profile kind for CoS queue */
	uint8_t	queue_id7_service_profile;
	/* Lossy (best-effort) */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID7_SERVICE_PROFILE_LOSSY	UINT32_C(0x0)
	/* Lossless */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID7_SERVICE_PROFILE_LOSSLESS	UINT32_C(0x1)
	/* Lossless RoCE (deprecated) */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID7_SERVICE_PROFILE_LOSSLESS_ROCE  UINT32_C(0x1)
	/* Lossy RoCE CNP (deprecated) */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID7_SERVICE_PROFILE_LOSSY_ROCE_CNP UINT32_C(0x2)
	/* Lossless NIC (deprecated) */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID7_SERVICE_PROFILE_LOSSLESS_NIC   UINT32_C(0x3)
	/* Set to 0xFF... (All Fs) if there is no service profile specified */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID7_SERVICE_PROFILE_UNKNOWN	UINT32_C(0xff)
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID7_SERVICE_PROFILE_LAST	HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID7_SERVICE_PROFILE_UNKNOWN
	/*
	 * This value specifies traffic type for the service profile. We can
	 * have a TC mapped to multiple traffic types. For example shared
	 * CoS Q for CNP and NIC will have both cnp and nic bits set (0x6).
	 * A value of zero is considered as invalid.
	 */
	uint8_t	queue_id0_service_profile_type;
	/* Recommended to be used for RoCE traffic only. */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID0_SERVICE_PROFILE_TYPE_ROCE	UINT32_C(0x1)
	/* Recommended to be used for NIC/L2 traffic only. */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID0_SERVICE_PROFILE_TYPE_NIC	UINT32_C(0x2)
	/* Recommended to be used for CNP traffic only. */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID0_SERVICE_PROFILE_TYPE_CNP	UINT32_C(0x4)
	/*
	 * Up to 16 bytes of null padded ASCII string describing this queue.
	 * The queue name includes a CoS queue index and, in some cases, text
	 * that distinguishes the queue from other queues in the group.
	 */
	char	qid0_name[16];
	/* Up to 16 bytes of null padded ASCII string describing this queue. */
	char	qid1_name[16];
	/* Up to 16 bytes of null padded ASCII string describing this queue. */
	char	qid2_name[16];
	/* Up to 16 bytes of null padded ASCII string describing this queue. */
	char	qid3_name[16];
	/* Up to 16 bytes of null padded ASCII string describing this queue. */
	char	qid4_name[16];
	/* Up to 16 bytes of null padded ASCII string describing this queue. */
	char	qid5_name[16];
	/* Up to 16 bytes of null padded ASCII string describing this queue. */
	char	qid6_name[16];
	/* Up to 16 bytes of null padded ASCII string describing this queue. */
	char	qid7_name[16];
	/*
	 * This value specifies traffic type for the service profile. We can
	 * have a TC mapped to multiple traffic types. For example shared
	 * CoS Q for CNP and NIC will have both cnp and nic bits set (0x6).
	 * A value of zero is considered as invalid.
	 */
	uint8_t	queue_id1_service_profile_type;
	/* Recommended to be used for RoCE traffic only. */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID1_SERVICE_PROFILE_TYPE_ROCE	UINT32_C(0x1)
	/* Recommended to be used for NIC/L2 traffic only. */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID1_SERVICE_PROFILE_TYPE_NIC	UINT32_C(0x2)
	/* Recommended to be used for CNP traffic only. */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID1_SERVICE_PROFILE_TYPE_CNP	UINT32_C(0x4)
	/*
	 * This value specifies traffic type for the service profile. We can
	 * have a TC mapped to multiple traffic types. For example shared
	 * CoS Q for CNP and NIC will have both cnp and nic bits set (0x6).
	 * A value of zero is considered as invalid.
	 */
	uint8_t	queue_id2_service_profile_type;
	/* Recommended to be used for RoCE traffic only. */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID2_SERVICE_PROFILE_TYPE_ROCE	UINT32_C(0x1)
	/* Recommended to be used for NIC/L2 traffic only. */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID2_SERVICE_PROFILE_TYPE_NIC	UINT32_C(0x2)
	/* Recommended to be used for CNP traffic only. */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID2_SERVICE_PROFILE_TYPE_CNP	UINT32_C(0x4)
	/*
	 * This value specifies traffic type for the service profile. We can
	 * have a TC mapped to multiple traffic types. For example shared
	 * CoS Q for CNP and NIC will have both cnp and nic bits set (0x6).
	 * A value of zero is considered as invalid.
	 */
	uint8_t	queue_id3_service_profile_type;
	/* Recommended to be used for RoCE traffic only. */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID3_SERVICE_PROFILE_TYPE_ROCE	UINT32_C(0x1)
	/* Recommended to be used for NIC/L2 traffic only. */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID3_SERVICE_PROFILE_TYPE_NIC	UINT32_C(0x2)
	/* Recommended to be used for CNP traffic only. */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID3_SERVICE_PROFILE_TYPE_CNP	UINT32_C(0x4)
	/*
	 * This value specifies traffic type for the service profile. We can
	 * have a TC mapped to multiple traffic types. For example shared
	 * CoS Q for CNP and NIC will have both cnp and nic bits set (0x6).
	 * A value of zero is considered as invalid.
	 */
	uint8_t	queue_id4_service_profile_type;
	/* Recommended to be used for RoCE traffic only. */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID4_SERVICE_PROFILE_TYPE_ROCE	UINT32_C(0x1)
	/* Recommended to be used for NIC/L2 traffic only. */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID4_SERVICE_PROFILE_TYPE_NIC	UINT32_C(0x2)
	/* Recommended to be used for CNP traffic only. */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID4_SERVICE_PROFILE_TYPE_CNP	UINT32_C(0x4)
	/*
	 * This value specifies traffic type for the service profile. We can
	 * have a TC mapped to multiple traffic types. For example shared
	 * CoS Q for CNP and NIC will have both cnp and nic bits set (0x6).
	 * A value of zero is considered as invalid.
	 */
	uint8_t	queue_id5_service_profile_type;
	/* Recommended to be used for RoCE traffic only. */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID5_SERVICE_PROFILE_TYPE_ROCE	UINT32_C(0x1)
	/* Recommended to be used for NIC/L2 traffic only. */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID5_SERVICE_PROFILE_TYPE_NIC	UINT32_C(0x2)
	/* Recommended to be used for CNP traffic only. */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID5_SERVICE_PROFILE_TYPE_CNP	UINT32_C(0x4)
	/*
	 * This value specifies traffic type for the service profile. We can
	 * have a TC mapped to multiple traffic types. For example shared
	 * CoS Q for CNP and NIC will have both cnp and nic bits set (0x6).
	 * A value of zero is considered as invalid.
	 */
	uint8_t	queue_id6_service_profile_type;
	/* Recommended to be used for RoCE traffic only. */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID6_SERVICE_PROFILE_TYPE_ROCE	UINT32_C(0x1)
	/* Recommended to be used for NIC/L2 traffic only. */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID6_SERVICE_PROFILE_TYPE_NIC	UINT32_C(0x2)
	/* Recommended to be used for CNP traffic only. */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID6_SERVICE_PROFILE_TYPE_CNP	UINT32_C(0x4)
	/*
	 * This value specifies traffic type for the service profile. We can
	 * have a TC mapped to multiple traffic types. For example shared
	 * CoS Q for CNP and NIC will have both cnp and nic bits set (0x6).
	 * A value of zero is considered as invalid.
	 */
	uint8_t	queue_id7_service_profile_type;
	/* Recommended to be used for RoCE traffic only. */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID7_SERVICE_PROFILE_TYPE_ROCE	UINT32_C(0x1)
	/* Recommended to be used for NIC/L2 traffic only. */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID7_SERVICE_PROFILE_TYPE_NIC	UINT32_C(0x2)
	/* Recommended to be used for CNP traffic only. */
	#define HWRM_QUEUE_QPORTCFG_OUTPUT_QUEUE_ID7_SERVICE_PROFILE_TYPE_CNP	UINT32_C(0x4)
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_queue_qportcfg_output_t, *phwrm_queue_qportcfg_output_t;

/*******************
 * hwrm_queue_qcfg *
 *******************/


/* hwrm_queue_qcfg_input (size:192b/24B) */

typedef struct hwrm_queue_qcfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	flags;
	/*
	 * Enumeration denoting the RX, TX type of the resource.
	 * This enumeration is used for resources that are similar for both
	 * TX and RX paths of the chip.
	 */
	#define HWRM_QUEUE_QCFG_INPUT_FLAGS_PATH	UINT32_C(0x1)
	/* tx path */
		#define HWRM_QUEUE_QCFG_INPUT_FLAGS_PATH_TX	UINT32_C(0x0)
	/* rx path */
		#define HWRM_QUEUE_QCFG_INPUT_FLAGS_PATH_RX	UINT32_C(0x1)
		#define HWRM_QUEUE_QCFG_INPUT_FLAGS_PATH_LAST HWRM_QUEUE_QCFG_INPUT_FLAGS_PATH_RX
	/* Queue ID of the queue. */
	uint32_t	queue_id;
} hwrm_queue_qcfg_input_t, *phwrm_queue_qcfg_input_t;

/* hwrm_queue_qcfg_output (size:128b/16B) */

typedef struct hwrm_queue_qcfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * This value is the estimate packet length used in the
	 * TX arbiter.
	 */
	uint32_t	queue_len;
	/* This value is applicable to CoS queues only. */
	uint8_t	service_profile;
	/* Lossy (best-effort) */
	#define HWRM_QUEUE_QCFG_OUTPUT_SERVICE_PROFILE_LOSSY	UINT32_C(0x0)
	/* Lossless */
	#define HWRM_QUEUE_QCFG_OUTPUT_SERVICE_PROFILE_LOSSLESS UINT32_C(0x1)
	/* Set to 0xFF... (All Fs) if there is no service profile specified */
	#define HWRM_QUEUE_QCFG_OUTPUT_SERVICE_PROFILE_UNKNOWN  UINT32_C(0xff)
	#define HWRM_QUEUE_QCFG_OUTPUT_SERVICE_PROFILE_LAST	HWRM_QUEUE_QCFG_OUTPUT_SERVICE_PROFILE_UNKNOWN
	/* Information about queue configuration. */
	uint8_t	queue_cfg_info;
	/*
	 * If this flag is set to '1', then the queue is
	 * configured asymmetrically on TX and RX sides.
	 * If this flag is set to '0', then this queue is
	 * configured symmetrically on TX and RX sides.
	 */
	#define HWRM_QUEUE_QCFG_OUTPUT_QUEUE_CFG_INFO_ASYM_CFG	UINT32_C(0x1)
	uint8_t	unused_0;
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_queue_qcfg_output_t, *phwrm_queue_qcfg_output_t;

/******************
 * hwrm_queue_cfg *
 ******************/


/* hwrm_queue_cfg_input (size:320b/40B) */

typedef struct hwrm_queue_cfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	flags;
	/*
	 * Enumeration denoting the RX, TX, or both directions applicable to the resource.
	 * This enumeration is used for resources that are similar for both
	 * TX and RX paths of the chip.
	 */
	#define HWRM_QUEUE_CFG_INPUT_FLAGS_PATH_MASK UINT32_C(0x3)
	#define HWRM_QUEUE_CFG_INPUT_FLAGS_PATH_SFT  0
	/* tx path */
		#define HWRM_QUEUE_CFG_INPUT_FLAGS_PATH_TX	UINT32_C(0x0)
	/* rx path */
		#define HWRM_QUEUE_CFG_INPUT_FLAGS_PATH_RX	UINT32_C(0x1)
	/* Bi-directional (Symmetrically applicable to TX and RX paths) */
		#define HWRM_QUEUE_CFG_INPUT_FLAGS_PATH_BIDIR  UINT32_C(0x2)
		#define HWRM_QUEUE_CFG_INPUT_FLAGS_PATH_LAST  HWRM_QUEUE_CFG_INPUT_FLAGS_PATH_BIDIR
	uint32_t	enables;
	/*
	 * This bit must be '1' for the dflt_len field to be
	 * configured.
	 */
	#define HWRM_QUEUE_CFG_INPUT_ENABLES_DFLT_LEN		UINT32_C(0x1)
	/*
	 * This bit must be '1' for the service_profile field to be
	 * configured.
	 */
	#define HWRM_QUEUE_CFG_INPUT_ENABLES_SERVICE_PROFILE	UINT32_C(0x2)
	/* Queue ID of queue that is to be configured by this function. */
	uint32_t	queue_id;
	/*
	 * This value is a the estimate packet length used in the
	 * TX arbiter.
	 * Set to 0xFF... (All Fs) to not adjust this value.
	 */
	uint32_t	dflt_len;
	/* This value is applicable to CoS queues only. */
	uint8_t	service_profile;
	/* Lossy (best-effort) */
	#define HWRM_QUEUE_CFG_INPUT_SERVICE_PROFILE_LOSSY	UINT32_C(0x0)
	/* Lossless */
	#define HWRM_QUEUE_CFG_INPUT_SERVICE_PROFILE_LOSSLESS UINT32_C(0x1)
	/* Set to 0xFF... (All Fs) if there is no service profile specified */
	#define HWRM_QUEUE_CFG_INPUT_SERVICE_PROFILE_UNKNOWN  UINT32_C(0xff)
	#define HWRM_QUEUE_CFG_INPUT_SERVICE_PROFILE_LAST	HWRM_QUEUE_CFG_INPUT_SERVICE_PROFILE_UNKNOWN
	uint8_t	unused_0[7];
} hwrm_queue_cfg_input_t, *phwrm_queue_cfg_input_t;

/* hwrm_queue_cfg_output (size:128b/16B) */

typedef struct hwrm_queue_cfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_queue_cfg_output_t, *phwrm_queue_cfg_output_t;

/*****************************
 * hwrm_queue_pfcenable_qcfg *
 *****************************/


/* hwrm_queue_pfcenable_qcfg_input (size:192b/24B) */

typedef struct hwrm_queue_pfcenable_qcfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * Port ID of port for which the table is being configured.
	 * The HWRM needs to check whether this function is allowed
	 * to configure pri2cos mapping on this port.
	 */
	uint16_t	port_id;
	uint8_t	unused_0[6];
} hwrm_queue_pfcenable_qcfg_input_t, *phwrm_queue_pfcenable_qcfg_input_t;

/* hwrm_queue_pfcenable_qcfg_output (size:128b/16B) */

typedef struct hwrm_queue_pfcenable_qcfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint32_t	flags;
	/* If set to 1, then PFC is enabled on PRI 0. */
	#define HWRM_QUEUE_PFCENABLE_QCFG_OUTPUT_FLAGS_PRI0_PFC_ENABLED		UINT32_C(0x1)
	/* If set to 1, then PFC is enabled on PRI 1. */
	#define HWRM_QUEUE_PFCENABLE_QCFG_OUTPUT_FLAGS_PRI1_PFC_ENABLED		UINT32_C(0x2)
	/* If set to 1, then PFC is enabled on PRI 2. */
	#define HWRM_QUEUE_PFCENABLE_QCFG_OUTPUT_FLAGS_PRI2_PFC_ENABLED		UINT32_C(0x4)
	/* If set to 1, then PFC is enabled on PRI 3. */
	#define HWRM_QUEUE_PFCENABLE_QCFG_OUTPUT_FLAGS_PRI3_PFC_ENABLED		UINT32_C(0x8)
	/* If set to 1, then PFC is enabled on PRI 4. */
	#define HWRM_QUEUE_PFCENABLE_QCFG_OUTPUT_FLAGS_PRI4_PFC_ENABLED		UINT32_C(0x10)
	/* If set to 1, then PFC is enabled on PRI 5. */
	#define HWRM_QUEUE_PFCENABLE_QCFG_OUTPUT_FLAGS_PRI5_PFC_ENABLED		UINT32_C(0x20)
	/* If set to 1, then PFC is enabled on PRI 6. */
	#define HWRM_QUEUE_PFCENABLE_QCFG_OUTPUT_FLAGS_PRI6_PFC_ENABLED		UINT32_C(0x40)
	/* If set to 1, then PFC is enabled on PRI 7. */
	#define HWRM_QUEUE_PFCENABLE_QCFG_OUTPUT_FLAGS_PRI7_PFC_ENABLED		UINT32_C(0x80)
	/* If set to 1, then PFC WatchDog is requested to be enabled on PRI0. */
	#define HWRM_QUEUE_PFCENABLE_QCFG_OUTPUT_FLAGS_PRI0_PFC_WATCHDOG_ENABLED	UINT32_C(0x100)
	/* If set to 1, then PFC WatchDog is requested to be enabled on PRI1. */
	#define HWRM_QUEUE_PFCENABLE_QCFG_OUTPUT_FLAGS_PRI1_PFC_WATCHDOG_ENABLED	UINT32_C(0x200)
	/* If set to 1, then PFC WatchDog is requested to be enabled on PRI2. */
	#define HWRM_QUEUE_PFCENABLE_QCFG_OUTPUT_FLAGS_PRI2_PFC_WATCHDOG_ENABLED	UINT32_C(0x400)
	/* If set to 1, then PFC WatchDog is requested to be enabled on PRI3. */
	#define HWRM_QUEUE_PFCENABLE_QCFG_OUTPUT_FLAGS_PRI3_PFC_WATCHDOG_ENABLED	UINT32_C(0x800)
	/* If set to 1, then PFC WatchDog is requested to be enabled on PRI4. */
	#define HWRM_QUEUE_PFCENABLE_QCFG_OUTPUT_FLAGS_PRI4_PFC_WATCHDOG_ENABLED	UINT32_C(0x1000)
	/* If set to 1, then PFC WatchDog is requested to be enabled on PRI5. */
	#define HWRM_QUEUE_PFCENABLE_QCFG_OUTPUT_FLAGS_PRI5_PFC_WATCHDOG_ENABLED	UINT32_C(0x2000)
	/* If set to 1, then PFC WatchDog is requested to be enabled on PRI6. */
	#define HWRM_QUEUE_PFCENABLE_QCFG_OUTPUT_FLAGS_PRI6_PFC_WATCHDOG_ENABLED	UINT32_C(0x4000)
	/* If set to 1, then PFC WatchDog is requested to be enabled on PRI7. */
	#define HWRM_QUEUE_PFCENABLE_QCFG_OUTPUT_FLAGS_PRI7_PFC_WATCHDOG_ENABLED	UINT32_C(0x8000)
	uint8_t	unused_0[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_queue_pfcenable_qcfg_output_t, *phwrm_queue_pfcenable_qcfg_output_t;

/****************************
 * hwrm_queue_pfcenable_cfg *
 ****************************/


/* hwrm_queue_pfcenable_cfg_input (size:192b/24B) */

typedef struct hwrm_queue_pfcenable_cfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	flags;
	/* If set to 1, then PFC is requested to be enabled on PRI 0. */
	#define HWRM_QUEUE_PFCENABLE_CFG_INPUT_FLAGS_PRI0_PFC_ENABLED		UINT32_C(0x1)
	/* If set to 1, then PFC is requested to be enabled on PRI 1. */
	#define HWRM_QUEUE_PFCENABLE_CFG_INPUT_FLAGS_PRI1_PFC_ENABLED		UINT32_C(0x2)
	/* If set to 1, then PFC is requested to be enabled on PRI 2. */
	#define HWRM_QUEUE_PFCENABLE_CFG_INPUT_FLAGS_PRI2_PFC_ENABLED		UINT32_C(0x4)
	/* If set to 1, then PFC is requested to be enabled on PRI 3. */
	#define HWRM_QUEUE_PFCENABLE_CFG_INPUT_FLAGS_PRI3_PFC_ENABLED		UINT32_C(0x8)
	/* If set to 1, then PFC is requested to be enabled on PRI 4. */
	#define HWRM_QUEUE_PFCENABLE_CFG_INPUT_FLAGS_PRI4_PFC_ENABLED		UINT32_C(0x10)
	/* If set to 1, then PFC is requested to be enabled on PRI 5. */
	#define HWRM_QUEUE_PFCENABLE_CFG_INPUT_FLAGS_PRI5_PFC_ENABLED		UINT32_C(0x20)
	/* If set to 1, then PFC is requested to be enabled on PRI 6. */
	#define HWRM_QUEUE_PFCENABLE_CFG_INPUT_FLAGS_PRI6_PFC_ENABLED		UINT32_C(0x40)
	/* If set to 1, then PFC is requested to be enabled on PRI 7. */
	#define HWRM_QUEUE_PFCENABLE_CFG_INPUT_FLAGS_PRI7_PFC_ENABLED		UINT32_C(0x80)
	/* If set to 1, then PFC WatchDog is requested to be enabled on PRI0. */
	#define HWRM_QUEUE_PFCENABLE_CFG_INPUT_FLAGS_PRI0_PFC_WATCHDOG_ENABLED	UINT32_C(0x100)
	/* If set to 1, then PFC WatchDog is requested to be enabled on PRI1. */
	#define HWRM_QUEUE_PFCENABLE_CFG_INPUT_FLAGS_PRI1_PFC_WATCHDOG_ENABLED	UINT32_C(0x200)
	/* If set to 1, then PFC WatchDog is requested to be enabled on PRI2. */
	#define HWRM_QUEUE_PFCENABLE_CFG_INPUT_FLAGS_PRI2_PFC_WATCHDOG_ENABLED	UINT32_C(0x400)
	/* If set to 1, then PFC WatchDog is requested to be enabled on PRI3. */
	#define HWRM_QUEUE_PFCENABLE_CFG_INPUT_FLAGS_PRI3_PFC_WATCHDOG_ENABLED	UINT32_C(0x800)
	/* If set to 1, then PFC WatchDog is requested to be enabled on PRI4. */
	#define HWRM_QUEUE_PFCENABLE_CFG_INPUT_FLAGS_PRI4_PFC_WATCHDOG_ENABLED	UINT32_C(0x1000)
	/* If set to 1, then PFC WatchDog is requested to be enabled on PRI5. */
	#define HWRM_QUEUE_PFCENABLE_CFG_INPUT_FLAGS_PRI5_PFC_WATCHDOG_ENABLED	UINT32_C(0x2000)
	/* If set to 1, then PFC WatchDog is requested to be enabled on PRI6. */
	#define HWRM_QUEUE_PFCENABLE_CFG_INPUT_FLAGS_PRI6_PFC_WATCHDOG_ENABLED	UINT32_C(0x4000)
	/* If set to 1, then PFC WatchDog is requested to be enabled on PRI7. */
	#define HWRM_QUEUE_PFCENABLE_CFG_INPUT_FLAGS_PRI7_PFC_WATCHDOG_ENABLED	UINT32_C(0x8000)
	/*
	 * Port ID of port for which the table is being configured.
	 * The HWRM needs to check whether this function is allowed
	 * to configure pri2cos mapping on this port.
	 */
	uint16_t	port_id;
	uint8_t	unused_0[2];
} hwrm_queue_pfcenable_cfg_input_t, *phwrm_queue_pfcenable_cfg_input_t;

/* hwrm_queue_pfcenable_cfg_output (size:128b/16B) */

typedef struct hwrm_queue_pfcenable_cfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_queue_pfcenable_cfg_output_t, *phwrm_queue_pfcenable_cfg_output_t;

/***************************
 * hwrm_queue_pri2cos_qcfg *
 ***************************/


/* hwrm_queue_pri2cos_qcfg_input (size:192b/24B) */

typedef struct hwrm_queue_pri2cos_qcfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	flags;
	/*
	 * Enumeration denoting the RX, TX type of the resource.
	 * This enumeration is used for resources that are similar for both
	 * TX and RX paths of the chip.
	 */
	#define HWRM_QUEUE_PRI2COS_QCFG_INPUT_FLAGS_PATH	UINT32_C(0x1)
	/* tx path */
		#define HWRM_QUEUE_PRI2COS_QCFG_INPUT_FLAGS_PATH_TX	UINT32_C(0x0)
	/* rx path */
		#define HWRM_QUEUE_PRI2COS_QCFG_INPUT_FLAGS_PATH_RX	UINT32_C(0x1)
		#define HWRM_QUEUE_PRI2COS_QCFG_INPUT_FLAGS_PATH_LAST  HWRM_QUEUE_PRI2COS_QCFG_INPUT_FLAGS_PATH_RX
	/*
	 * When this bit is set to '0', the query is
	 * for PRI from tunnel headers.
	 * When this bit is set to '1', the query is
	 * for PRI from inner packet headers.
	 */
	#define HWRM_QUEUE_PRI2COS_QCFG_INPUT_FLAGS_IVLAN	UINT32_C(0x2)
	/*
	 * Port ID of port for which the table is being configured.
	 * The HWRM needs to check whether this function is allowed
	 * to configure pri2cos mapping on this port.
	 */
	uint8_t	port_id;
	uint8_t	unused_0[3];
} hwrm_queue_pri2cos_qcfg_input_t, *phwrm_queue_pri2cos_qcfg_input_t;

/* hwrm_queue_pri2cos_qcfg_output (size:192b/24B) */

typedef struct hwrm_queue_pri2cos_qcfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * CoS Queue assigned to priority 0. This value can only
	 * be changed before traffic has started.
	 * A value of 0xff indicates that no CoS queue is assigned to the
	 * specified priority.
	 */
	uint8_t	pri0_cos_queue_id;
	/*
	 * CoS Queue assigned to priority 1. This value can only
	 * be changed before traffic has started.
	 * A value of 0xff indicates that no CoS queue is assigned to the
	 * specified priority.
	 */
	uint8_t	pri1_cos_queue_id;
	/*
	 * CoS Queue assigned to priority 2. This value can only
	 * be changed before traffic has started.
	 * A value of 0xff indicates that no CoS queue is assigned to the
	 * specified priority.
	 */
	uint8_t	pri2_cos_queue_id;
	/*
	 * CoS Queue assigned to priority 3. This value can only
	 * be changed before traffic has started.
	 * A value of 0xff indicates that no CoS queue is assigned to the
	 * specified priority.
	 */
	uint8_t	pri3_cos_queue_id;
	/*
	 * CoS Queue assigned to priority 4. This value can only
	 * be changed before traffic has started.
	 * A value of 0xff indicates that no CoS queue is assigned to the
	 * specified priority.
	 */
	uint8_t	pri4_cos_queue_id;
	/*
	 * CoS Queue assigned to priority 5. This value can only
	 * be changed before traffic has started.
	 * A value of 0xff indicates that no CoS queue is assigned to the
	 * specified priority.
	 */
	uint8_t	pri5_cos_queue_id;
	/*
	 * CoS Queue assigned to priority 6. This value can only
	 * be changed before traffic has started.
	 * A value of 0xff indicates that no CoS queue is assigned to the
	 * specified priority.
	 */
	uint8_t	pri6_cos_queue_id;
	/*
	 * CoS Queue assigned to priority 7. This value can only
	 * be changed before traffic has started.
	 * A value of 0xff indicates that no CoS queue is assigned to the
	 * specified priority.
	 */
	uint8_t	pri7_cos_queue_id;
	/* Information about queue configuration. */
	uint8_t	queue_cfg_info;
	/*
	 * If this flag is set to '1', then the PRI to CoS
	 * configuration is asymmetric on TX and RX sides.
	 * If this flag is set to '0', then PRI to CoS configuration
	 * is symmetric on TX and RX sides.
	 */
	#define HWRM_QUEUE_PRI2COS_QCFG_OUTPUT_QUEUE_CFG_INFO_ASYM_CFG	UINT32_C(0x1)
	uint8_t	unused_0[6];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_queue_pri2cos_qcfg_output_t, *phwrm_queue_pri2cos_qcfg_output_t;

/**************************
 * hwrm_queue_pri2cos_cfg *
 **************************/


/* hwrm_queue_pri2cos_cfg_input (size:320b/40B) */

typedef struct hwrm_queue_pri2cos_cfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	flags;
	/*
	 * Enumeration denoting the RX, TX, or both directions applicable to the resource.
	 * This enumeration is used for resources that are similar for both
	 * TX and RX paths of the chip.
	 */
	#define HWRM_QUEUE_PRI2COS_CFG_INPUT_FLAGS_PATH_MASK UINT32_C(0x3)
	#define HWRM_QUEUE_PRI2COS_CFG_INPUT_FLAGS_PATH_SFT  0
	/* tx path */
		#define HWRM_QUEUE_PRI2COS_CFG_INPUT_FLAGS_PATH_TX	UINT32_C(0x0)
	/* rx path */
		#define HWRM_QUEUE_PRI2COS_CFG_INPUT_FLAGS_PATH_RX	UINT32_C(0x1)
	/* Bi-directional (Symmetrically applicable to TX and RX paths) */
		#define HWRM_QUEUE_PRI2COS_CFG_INPUT_FLAGS_PATH_BIDIR  UINT32_C(0x2)
		#define HWRM_QUEUE_PRI2COS_CFG_INPUT_FLAGS_PATH_LAST  HWRM_QUEUE_PRI2COS_CFG_INPUT_FLAGS_PATH_BIDIR
	/*
	 * When this bit is set to '0', the mapping is requested
	 * for PRI from tunnel headers.
	 * When this bit is set to '1', the mapping is requested
	 * for PRI from inner packet headers.
	 */
	#define HWRM_QUEUE_PRI2COS_CFG_INPUT_FLAGS_IVLAN	UINT32_C(0x4)
	uint32_t	enables;
	/*
	 * This bit must be '1' for the pri0_cos_queue_id field to be
	 * configured.
	 */
	#define HWRM_QUEUE_PRI2COS_CFG_INPUT_ENABLES_PRI0_COS_QUEUE_ID	UINT32_C(0x1)
	/*
	 * This bit must be '1' for the pri1_cos_queue_id field to be
	 * configured.
	 */
	#define HWRM_QUEUE_PRI2COS_CFG_INPUT_ENABLES_PRI1_COS_QUEUE_ID	UINT32_C(0x2)
	/*
	 * This bit must be '1' for the pri2_cos_queue_id field to be
	 * configured.
	 */
	#define HWRM_QUEUE_PRI2COS_CFG_INPUT_ENABLES_PRI2_COS_QUEUE_ID	UINT32_C(0x4)
	/*
	 * This bit must be '1' for the pri3_cos_queue_id field to be
	 * configured.
	 */
	#define HWRM_QUEUE_PRI2COS_CFG_INPUT_ENABLES_PRI3_COS_QUEUE_ID	UINT32_C(0x8)
	/*
	 * This bit must be '1' for the pri4_cos_queue_id field to be
	 * configured.
	 */
	#define HWRM_QUEUE_PRI2COS_CFG_INPUT_ENABLES_PRI4_COS_QUEUE_ID	UINT32_C(0x10)
	/*
	 * This bit must be '1' for the pri5_cos_queue_id field to be
	 * configured.
	 */
	#define HWRM_QUEUE_PRI2COS_CFG_INPUT_ENABLES_PRI5_COS_QUEUE_ID	UINT32_C(0x20)
	/*
	 * This bit must be '1' for the pri6_cos_queue_id field to be
	 * configured.
	 */
	#define HWRM_QUEUE_PRI2COS_CFG_INPUT_ENABLES_PRI6_COS_QUEUE_ID	UINT32_C(0x40)
	/*
	 * This bit must be '1' for the pri7_cos_queue_id field to be
	 * configured.
	 */
	#define HWRM_QUEUE_PRI2COS_CFG_INPUT_ENABLES_PRI7_COS_QUEUE_ID	UINT32_C(0x80)
	/*
	 * Port ID of port for which the table is being configured.
	 * The HWRM needs to check whether this function is allowed
	 * to configure pri2cos mapping on this port.
	 */
	uint8_t	port_id;
	/*
	 * CoS Queue assigned to priority 0. This value can only
	 * be changed before traffic has started.
	 */
	uint8_t	pri0_cos_queue_id;
	/*
	 * CoS Queue assigned to priority 1. This value can only
	 * be changed before traffic has started.
	 */
	uint8_t	pri1_cos_queue_id;
	/*
	 * CoS Queue assigned to priority 2  This value can only
	 * be changed before traffic has started.
	 */
	uint8_t	pri2_cos_queue_id;
	/*
	 * CoS Queue assigned to priority 3. This value can only
	 * be changed before traffic has started.
	 */
	uint8_t	pri3_cos_queue_id;
	/*
	 * CoS Queue assigned to priority 4. This value can only
	 * be changed before traffic has started.
	 */
	uint8_t	pri4_cos_queue_id;
	/*
	 * CoS Queue assigned to priority 5. This value can only
	 * be changed before traffic has started.
	 */
	uint8_t	pri5_cos_queue_id;
	/*
	 * CoS Queue assigned to priority 6. This value can only
	 * be changed before traffic has started.
	 */
	uint8_t	pri6_cos_queue_id;
	/*
	 * CoS Queue assigned to priority 7. This value can only
	 * be changed before traffic has started.
	 */
	uint8_t	pri7_cos_queue_id;
	uint8_t	unused_0[7];
} hwrm_queue_pri2cos_cfg_input_t, *phwrm_queue_pri2cos_cfg_input_t;

/* hwrm_queue_pri2cos_cfg_output (size:128b/16B) */

typedef struct hwrm_queue_pri2cos_cfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_queue_pri2cos_cfg_output_t, *phwrm_queue_pri2cos_cfg_output_t;

/**************************
 * hwrm_queue_cos2bw_qcfg *
 **************************/


/* hwrm_queue_cos2bw_qcfg_input (size:192b/24B) */

typedef struct hwrm_queue_cos2bw_qcfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * Port ID of port for which the table is being configured.
	 * The HWRM needs to check whether this function is allowed
	 * to configure TC BW assignment on this port.
	 */
	uint16_t	port_id;
	uint8_t	unused_0[6];
} hwrm_queue_cos2bw_qcfg_input_t, *phwrm_queue_cos2bw_qcfg_input_t;

/* hwrm_queue_cos2bw_qcfg_output (size:896b/112B) */

typedef struct hwrm_queue_cos2bw_qcfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* ID of CoS Queue 0. */
	uint8_t	queue_id0;
	uint8_t	unused_0;
	uint16_t	unused_1;
	/*
	 * Minimum BW allocated to CoS Queue.
	 * The HWRM will translate this value into byte counter and
	 * time interval used for this COS inside the device.
	 */
	uint32_t	queue_id0_min_bw;
	/* The bandwidth value. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID0_MIN_BW_BW_VALUE_MASK		UINT32_C(0xfffffff)
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID0_MIN_BW_BW_VALUE_SFT		0
	/* The granularity of the value (bits or bytes). */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID0_MIN_BW_SCALE			UINT32_C(0x10000000)
	/* Value is in bits. */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID0_MIN_BW_SCALE_BITS		(UINT32_C(0x0) << 28)
	/* Value is in bytes. */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID0_MIN_BW_SCALE_BYTES		(UINT32_C(0x1) << 28)
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID0_MIN_BW_SCALE_LAST		HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID0_MIN_BW_SCALE_BYTES
	/* bw_value_unit is 3 b */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID0_MIN_BW_BW_VALUE_UNIT_MASK	UINT32_C(0xe0000000)
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID0_MIN_BW_BW_VALUE_UNIT_SFT	29
	/* Value is in Mb or MB (base 10). */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID0_MIN_BW_BW_VALUE_UNIT_MEGA	(UINT32_C(0x0) << 29)
	/* Value is in Kb or KB (base 10). */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID0_MIN_BW_BW_VALUE_UNIT_KILO	(UINT32_C(0x2) << 29)
	/* Value is in bits or bytes. */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID0_MIN_BW_BW_VALUE_UNIT_BASE	(UINT32_C(0x4) << 29)
	/* Value is in Gb or GB (base 10). */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID0_MIN_BW_BW_VALUE_UNIT_GIGA	(UINT32_C(0x6) << 29)
	/* Value is in 1/100th of a percentage of total bandwidth. */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID0_MIN_BW_BW_VALUE_UNIT_PERCENT1_100  (UINT32_C(0x1) << 29)
	/* Invalid unit */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID0_MIN_BW_BW_VALUE_UNIT_INVALID	(UINT32_C(0x7) << 29)
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID0_MIN_BW_BW_VALUE_UNIT_LAST	HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID0_MIN_BW_BW_VALUE_UNIT_INVALID
	/*
	 * Maximum BW allocated to CoS Queue.
	 * The HWRM will translate this value into byte counter and
	 * time interval used for this COS inside the device.
	 */
	uint32_t	queue_id0_max_bw;
	/* The bandwidth value. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID0_MAX_BW_BW_VALUE_MASK		UINT32_C(0xfffffff)
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID0_MAX_BW_BW_VALUE_SFT		0
	/* The granularity of the value (bits or bytes). */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID0_MAX_BW_SCALE			UINT32_C(0x10000000)
	/* Value is in bits. */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID0_MAX_BW_SCALE_BITS		(UINT32_C(0x0) << 28)
	/* Value is in bytes. */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID0_MAX_BW_SCALE_BYTES		(UINT32_C(0x1) << 28)
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID0_MAX_BW_SCALE_LAST		HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID0_MAX_BW_SCALE_BYTES
	/* bw_value_unit is 3 b */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID0_MAX_BW_BW_VALUE_UNIT_MASK	UINT32_C(0xe0000000)
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID0_MAX_BW_BW_VALUE_UNIT_SFT	29
	/* Value is in Mb or MB (base 10). */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID0_MAX_BW_BW_VALUE_UNIT_MEGA	(UINT32_C(0x0) << 29)
	/* Value is in Kb or KB (base 10). */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID0_MAX_BW_BW_VALUE_UNIT_KILO	(UINT32_C(0x2) << 29)
	/* Value is in bits or bytes. */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID0_MAX_BW_BW_VALUE_UNIT_BASE	(UINT32_C(0x4) << 29)
	/* Value is in Gb or GB (base 10). */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID0_MAX_BW_BW_VALUE_UNIT_GIGA	(UINT32_C(0x6) << 29)
	/* Value is in 1/100th of a percentage of total bandwidth. */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID0_MAX_BW_BW_VALUE_UNIT_PERCENT1_100  (UINT32_C(0x1) << 29)
	/* Invalid unit */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID0_MAX_BW_BW_VALUE_UNIT_INVALID	(UINT32_C(0x7) << 29)
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID0_MAX_BW_BW_VALUE_UNIT_LAST	HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID0_MAX_BW_BW_VALUE_UNIT_INVALID
	/* Transmission Selection Algorithm (TSA) for CoS Queue. */
	uint8_t	queue_id0_tsa_assign;
	/* Strict Priority */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID0_TSA_ASSIGN_SP		UINT32_C(0x0)
	/* Enhanced Transmission Selection */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID0_TSA_ASSIGN_ETS		UINT32_C(0x1)
	/* reserved. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID0_TSA_ASSIGN_RESERVED_FIRST UINT32_C(0x2)
	/* reserved. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID0_TSA_ASSIGN_RESERVED_LAST  UINT32_C(0xff)
	/*
	 * Priority level for strict priority. Valid only when the
	 * tsa_assign is 0 - Strict Priority (SP)
	 * 0..7 - Valid values.
	 * 8..255 - Reserved.
	 */
	uint8_t	queue_id0_pri_lvl;
	/*
	 * Weight used to allocate remaining BW for this COS after
	 * servicing guaranteed bandwidths for all COS.
	 */
	uint8_t	queue_id0_bw_weight;
	/* ID of CoS Queue 1. */
	uint8_t	queue_id1;
	/*
	 * Minimum BW allocated to CoS Queue.
	 * The HWRM will translate this value into byte counter and
	 * time interval used for this COS inside the device.
	 */
	uint32_t	queue_id1_min_bw;
	/* The bandwidth value. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID1_MIN_BW_BW_VALUE_MASK		UINT32_C(0xfffffff)
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID1_MIN_BW_BW_VALUE_SFT		0
	/* The granularity of the value (bits or bytes). */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID1_MIN_BW_SCALE			UINT32_C(0x10000000)
	/* Value is in bits. */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID1_MIN_BW_SCALE_BITS		(UINT32_C(0x0) << 28)
	/* Value is in bytes. */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID1_MIN_BW_SCALE_BYTES		(UINT32_C(0x1) << 28)
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID1_MIN_BW_SCALE_LAST		HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID1_MIN_BW_SCALE_BYTES
	/* bw_value_unit is 3 b */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID1_MIN_BW_BW_VALUE_UNIT_MASK	UINT32_C(0xe0000000)
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID1_MIN_BW_BW_VALUE_UNIT_SFT	29
	/* Value is in Mb or MB (base 10). */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID1_MIN_BW_BW_VALUE_UNIT_MEGA	(UINT32_C(0x0) << 29)
	/* Value is in Kb or KB (base 10). */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID1_MIN_BW_BW_VALUE_UNIT_KILO	(UINT32_C(0x2) << 29)
	/* Value is in bits or bytes. */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID1_MIN_BW_BW_VALUE_UNIT_BASE	(UINT32_C(0x4) << 29)
	/* Value is in Gb or GB (base 10). */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID1_MIN_BW_BW_VALUE_UNIT_GIGA	(UINT32_C(0x6) << 29)
	/* Value is in 1/100th of a percentage of total bandwidth. */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID1_MIN_BW_BW_VALUE_UNIT_PERCENT1_100  (UINT32_C(0x1) << 29)
	/* Invalid unit */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID1_MIN_BW_BW_VALUE_UNIT_INVALID	(UINT32_C(0x7) << 29)
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID1_MIN_BW_BW_VALUE_UNIT_LAST	HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID1_MIN_BW_BW_VALUE_UNIT_INVALID
	/*
	 * Maximum BW allocated to CoS queue.
	 * The HWRM will translate this value into byte counter and
	 * time interval used for this COS inside the device.
	 */
	uint32_t	queue_id1_max_bw;
	/* The bandwidth value. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID1_MAX_BW_BW_VALUE_MASK		UINT32_C(0xfffffff)
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID1_MAX_BW_BW_VALUE_SFT		0
	/* The granularity of the value (bits or bytes). */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID1_MAX_BW_SCALE			UINT32_C(0x10000000)
	/* Value is in bits. */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID1_MAX_BW_SCALE_BITS		(UINT32_C(0x0) << 28)
	/* Value is in bytes. */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID1_MAX_BW_SCALE_BYTES		(UINT32_C(0x1) << 28)
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID1_MAX_BW_SCALE_LAST		HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID1_MAX_BW_SCALE_BYTES
	/* bw_value_unit is 3 b */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID1_MAX_BW_BW_VALUE_UNIT_MASK	UINT32_C(0xe0000000)
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID1_MAX_BW_BW_VALUE_UNIT_SFT	29
	/* Value is in Mb or MB (base 10). */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID1_MAX_BW_BW_VALUE_UNIT_MEGA	(UINT32_C(0x0) << 29)
	/* Value is in Kb or KB (base 10). */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID1_MAX_BW_BW_VALUE_UNIT_KILO	(UINT32_C(0x2) << 29)
	/* Value is in bits or bytes. */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID1_MAX_BW_BW_VALUE_UNIT_BASE	(UINT32_C(0x4) << 29)
	/* Value is in Gb or GB (base 10). */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID1_MAX_BW_BW_VALUE_UNIT_GIGA	(UINT32_C(0x6) << 29)
	/* Value is in 1/100th of a percentage of total bandwidth. */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID1_MAX_BW_BW_VALUE_UNIT_PERCENT1_100  (UINT32_C(0x1) << 29)
	/* Invalid unit */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID1_MAX_BW_BW_VALUE_UNIT_INVALID	(UINT32_C(0x7) << 29)
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID1_MAX_BW_BW_VALUE_UNIT_LAST	HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID1_MAX_BW_BW_VALUE_UNIT_INVALID
	/* Transmission Selection Algorithm (TSA) for CoS Queue. */
	uint8_t	queue_id1_tsa_assign;
	/* Strict Priority */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID1_TSA_ASSIGN_SP		UINT32_C(0x0)
	/* Enhanced Transmission Selection */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID1_TSA_ASSIGN_ETS		UINT32_C(0x1)
	/* reserved. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID1_TSA_ASSIGN_RESERVED_FIRST UINT32_C(0x2)
	/* reserved. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID1_TSA_ASSIGN_RESERVED_LAST  UINT32_C(0xff)
	/*
	 * Priority level for strict priority. Valid only when the
	 * tsa_assign is 0 - Strict Priority (SP)
	 * 0..7 - Valid values.
	 * 8..255 - Reserved.
	 */
	uint8_t	queue_id1_pri_lvl;
	/*
	 * Weight used to allocate remaining BW for this COS after
	 * servicing guaranteed bandwidths for all COS.
	 */
	uint8_t	queue_id1_bw_weight;
	/* ID of CoS Queue 2. */
	uint8_t	queue_id2;
	/*
	 * Minimum BW allocated to CoS Queue.
	 * The HWRM will translate this value into byte counter and
	 * time interval used for this COS inside the device.
	 */
	uint32_t	queue_id2_min_bw;
	/* The bandwidth value. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID2_MIN_BW_BW_VALUE_MASK		UINT32_C(0xfffffff)
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID2_MIN_BW_BW_VALUE_SFT		0
	/* The granularity of the value (bits or bytes). */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID2_MIN_BW_SCALE			UINT32_C(0x10000000)
	/* Value is in bits. */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID2_MIN_BW_SCALE_BITS		(UINT32_C(0x0) << 28)
	/* Value is in bytes. */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID2_MIN_BW_SCALE_BYTES		(UINT32_C(0x1) << 28)
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID2_MIN_BW_SCALE_LAST		HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID2_MIN_BW_SCALE_BYTES
	/* bw_value_unit is 3 b */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID2_MIN_BW_BW_VALUE_UNIT_MASK	UINT32_C(0xe0000000)
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID2_MIN_BW_BW_VALUE_UNIT_SFT	29
	/* Value is in Mb or MB (base 10). */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID2_MIN_BW_BW_VALUE_UNIT_MEGA	(UINT32_C(0x0) << 29)
	/* Value is in Kb or KB (base 10). */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID2_MIN_BW_BW_VALUE_UNIT_KILO	(UINT32_C(0x2) << 29)
	/* Value is in bits or bytes. */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID2_MIN_BW_BW_VALUE_UNIT_BASE	(UINT32_C(0x4) << 29)
	/* Value is in Gb or GB (base 10). */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID2_MIN_BW_BW_VALUE_UNIT_GIGA	(UINT32_C(0x6) << 29)
	/* Value is in 1/100th of a percentage of total bandwidth. */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID2_MIN_BW_BW_VALUE_UNIT_PERCENT1_100  (UINT32_C(0x1) << 29)
	/* Invalid unit */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID2_MIN_BW_BW_VALUE_UNIT_INVALID	(UINT32_C(0x7) << 29)
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID2_MIN_BW_BW_VALUE_UNIT_LAST	HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID2_MIN_BW_BW_VALUE_UNIT_INVALID
	/*
	 * Maximum BW allocated to CoS queue.
	 * The HWRM will translate this value into byte counter and
	 * time interval used for this COS inside the device.
	 */
	uint32_t	queue_id2_max_bw;
	/* The bandwidth value. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID2_MAX_BW_BW_VALUE_MASK		UINT32_C(0xfffffff)
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID2_MAX_BW_BW_VALUE_SFT		0
	/* The granularity of the value (bits or bytes). */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID2_MAX_BW_SCALE			UINT32_C(0x10000000)
	/* Value is in bits. */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID2_MAX_BW_SCALE_BITS		(UINT32_C(0x0) << 28)
	/* Value is in bytes. */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID2_MAX_BW_SCALE_BYTES		(UINT32_C(0x1) << 28)
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID2_MAX_BW_SCALE_LAST		HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID2_MAX_BW_SCALE_BYTES
	/* bw_value_unit is 3 b */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID2_MAX_BW_BW_VALUE_UNIT_MASK	UINT32_C(0xe0000000)
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID2_MAX_BW_BW_VALUE_UNIT_SFT	29
	/* Value is in Mb or MB (base 10). */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID2_MAX_BW_BW_VALUE_UNIT_MEGA	(UINT32_C(0x0) << 29)
	/* Value is in Kb or KB (base 10). */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID2_MAX_BW_BW_VALUE_UNIT_KILO	(UINT32_C(0x2) << 29)
	/* Value is in bits or bytes. */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID2_MAX_BW_BW_VALUE_UNIT_BASE	(UINT32_C(0x4) << 29)
	/* Value is in Gb or GB (base 10). */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID2_MAX_BW_BW_VALUE_UNIT_GIGA	(UINT32_C(0x6) << 29)
	/* Value is in 1/100th of a percentage of total bandwidth. */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID2_MAX_BW_BW_VALUE_UNIT_PERCENT1_100  (UINT32_C(0x1) << 29)
	/* Invalid unit */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID2_MAX_BW_BW_VALUE_UNIT_INVALID	(UINT32_C(0x7) << 29)
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID2_MAX_BW_BW_VALUE_UNIT_LAST	HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID2_MAX_BW_BW_VALUE_UNIT_INVALID
	/* Transmission Selection Algorithm (TSA) for CoS Queue. */
	uint8_t	queue_id2_tsa_assign;
	/* Strict Priority */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID2_TSA_ASSIGN_SP		UINT32_C(0x0)
	/* Enhanced Transmission Selection */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID2_TSA_ASSIGN_ETS		UINT32_C(0x1)
	/* reserved. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID2_TSA_ASSIGN_RESERVED_FIRST UINT32_C(0x2)
	/* reserved. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID2_TSA_ASSIGN_RESERVED_LAST  UINT32_C(0xff)
	/*
	 * Priority level for strict priority. Valid only when the
	 * tsa_assign is 0 - Strict Priority (SP)
	 * 0..7 - Valid values.
	 * 8..255 - Reserved.
	 */
	uint8_t	queue_id2_pri_lvl;
	/*
	 * Weight used to allocate remaining BW for this COS after
	 * servicing guaranteed bandwidths for all COS.
	 */
	uint8_t	queue_id2_bw_weight;
	/* ID of CoS Queue 3. */
	uint8_t	queue_id3;
	/*
	 * Minimum BW allocated to CoS Queue.
	 * The HWRM will translate this value into byte counter and
	 * time interval used for this COS inside the device.
	 */
	uint32_t	queue_id3_min_bw;
	/* The bandwidth value. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID3_MIN_BW_BW_VALUE_MASK		UINT32_C(0xfffffff)
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID3_MIN_BW_BW_VALUE_SFT		0
	/* The granularity of the value (bits or bytes). */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID3_MIN_BW_SCALE			UINT32_C(0x10000000)
	/* Value is in bits. */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID3_MIN_BW_SCALE_BITS		(UINT32_C(0x0) << 28)
	/* Value is in bytes. */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID3_MIN_BW_SCALE_BYTES		(UINT32_C(0x1) << 28)
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID3_MIN_BW_SCALE_LAST		HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID3_MIN_BW_SCALE_BYTES
	/* bw_value_unit is 3 b */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID3_MIN_BW_BW_VALUE_UNIT_MASK	UINT32_C(0xe0000000)
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID3_MIN_BW_BW_VALUE_UNIT_SFT	29
	/* Value is in Mb or MB (base 10). */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID3_MIN_BW_BW_VALUE_UNIT_MEGA	(UINT32_C(0x0) << 29)
	/* Value is in Kb or KB (base 10). */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID3_MIN_BW_BW_VALUE_UNIT_KILO	(UINT32_C(0x2) << 29)
	/* Value is in bits or bytes. */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID3_MIN_BW_BW_VALUE_UNIT_BASE	(UINT32_C(0x4) << 29)
	/* Value is in Gb or GB (base 10). */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID3_MIN_BW_BW_VALUE_UNIT_GIGA	(UINT32_C(0x6) << 29)
	/* Value is in 1/100th of a percentage of total bandwidth. */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID3_MIN_BW_BW_VALUE_UNIT_PERCENT1_100  (UINT32_C(0x1) << 29)
	/* Invalid unit */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID3_MIN_BW_BW_VALUE_UNIT_INVALID	(UINT32_C(0x7) << 29)
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID3_MIN_BW_BW_VALUE_UNIT_LAST	HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID3_MIN_BW_BW_VALUE_UNIT_INVALID
	/*
	 * Maximum BW allocated to CoS queue.
	 * The HWRM will translate this value into byte counter and
	 * time interval used for this COS inside the device.
	 */
	uint32_t	queue_id3_max_bw;
	/* The bandwidth value. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID3_MAX_BW_BW_VALUE_MASK		UINT32_C(0xfffffff)
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID3_MAX_BW_BW_VALUE_SFT		0
	/* The granularity of the value (bits or bytes). */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID3_MAX_BW_SCALE			UINT32_C(0x10000000)
	/* Value is in bits. */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID3_MAX_BW_SCALE_BITS		(UINT32_C(0x0) << 28)
	/* Value is in bytes. */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID3_MAX_BW_SCALE_BYTES		(UINT32_C(0x1) << 28)
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID3_MAX_BW_SCALE_LAST		HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID3_MAX_BW_SCALE_BYTES
	/* bw_value_unit is 3 b */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID3_MAX_BW_BW_VALUE_UNIT_MASK	UINT32_C(0xe0000000)
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID3_MAX_BW_BW_VALUE_UNIT_SFT	29
	/* Value is in Mb or MB (base 10). */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID3_MAX_BW_BW_VALUE_UNIT_MEGA	(UINT32_C(0x0) << 29)
	/* Value is in Kb or KB (base 10). */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID3_MAX_BW_BW_VALUE_UNIT_KILO	(UINT32_C(0x2) << 29)
	/* Value is in bits or bytes. */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID3_MAX_BW_BW_VALUE_UNIT_BASE	(UINT32_C(0x4) << 29)
	/* Value is in Gb or GB (base 10). */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID3_MAX_BW_BW_VALUE_UNIT_GIGA	(UINT32_C(0x6) << 29)
	/* Value is in 1/100th of a percentage of total bandwidth. */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID3_MAX_BW_BW_VALUE_UNIT_PERCENT1_100  (UINT32_C(0x1) << 29)
	/* Invalid unit */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID3_MAX_BW_BW_VALUE_UNIT_INVALID	(UINT32_C(0x7) << 29)
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID3_MAX_BW_BW_VALUE_UNIT_LAST	HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID3_MAX_BW_BW_VALUE_UNIT_INVALID
	/* Transmission Selection Algorithm (TSA) for CoS Queue. */
	uint8_t	queue_id3_tsa_assign;
	/* Strict Priority */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID3_TSA_ASSIGN_SP		UINT32_C(0x0)
	/* Enhanced Transmission Selection */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID3_TSA_ASSIGN_ETS		UINT32_C(0x1)
	/* reserved. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID3_TSA_ASSIGN_RESERVED_FIRST UINT32_C(0x2)
	/* reserved. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID3_TSA_ASSIGN_RESERVED_LAST  UINT32_C(0xff)
	/*
	 * Priority level for strict priority. Valid only when the
	 * tsa_assign is 0 - Strict Priority (SP)
	 * 0..7 - Valid values.
	 * 8..255 - Reserved.
	 */
	uint8_t	queue_id3_pri_lvl;
	/*
	 * Weight used to allocate remaining BW for this COS after
	 * servicing guaranteed bandwidths for all COS.
	 */
	uint8_t	queue_id3_bw_weight;
	/* ID of CoS Queue 4. */
	uint8_t	queue_id4;
	/*
	 * Minimum BW allocated to CoS Queue.
	 * The HWRM will translate this value into byte counter and
	 * time interval used for this COS inside the device.
	 */
	uint32_t	queue_id4_min_bw;
	/* The bandwidth value. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID4_MIN_BW_BW_VALUE_MASK		UINT32_C(0xfffffff)
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID4_MIN_BW_BW_VALUE_SFT		0
	/* The granularity of the value (bits or bytes). */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID4_MIN_BW_SCALE			UINT32_C(0x10000000)
	/* Value is in bits. */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID4_MIN_BW_SCALE_BITS		(UINT32_C(0x0) << 28)
	/* Value is in bytes. */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID4_MIN_BW_SCALE_BYTES		(UINT32_C(0x1) << 28)
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID4_MIN_BW_SCALE_LAST		HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID4_MIN_BW_SCALE_BYTES
	/* bw_value_unit is 3 b */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID4_MIN_BW_BW_VALUE_UNIT_MASK	UINT32_C(0xe0000000)
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID4_MIN_BW_BW_VALUE_UNIT_SFT	29
	/* Value is in Mb or MB (base 10). */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID4_MIN_BW_BW_VALUE_UNIT_MEGA	(UINT32_C(0x0) << 29)
	/* Value is in Kb or KB (base 10). */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID4_MIN_BW_BW_VALUE_UNIT_KILO	(UINT32_C(0x2) << 29)
	/* Value is in bits or bytes. */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID4_MIN_BW_BW_VALUE_UNIT_BASE	(UINT32_C(0x4) << 29)
	/* Value is in Gb or GB (base 10). */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID4_MIN_BW_BW_VALUE_UNIT_GIGA	(UINT32_C(0x6) << 29)
	/* Value is in 1/100th of a percentage of total bandwidth. */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID4_MIN_BW_BW_VALUE_UNIT_PERCENT1_100  (UINT32_C(0x1) << 29)
	/* Invalid unit */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID4_MIN_BW_BW_VALUE_UNIT_INVALID	(UINT32_C(0x7) << 29)
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID4_MIN_BW_BW_VALUE_UNIT_LAST	HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID4_MIN_BW_BW_VALUE_UNIT_INVALID
	/*
	 * Maximum BW allocated to CoS queue.
	 * The HWRM will translate this value into byte counter and
	 * time interval used for this COS inside the device.
	 */
	uint32_t	queue_id4_max_bw;
	/* The bandwidth value. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID4_MAX_BW_BW_VALUE_MASK		UINT32_C(0xfffffff)
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID4_MAX_BW_BW_VALUE_SFT		0
	/* The granularity of the value (bits or bytes). */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID4_MAX_BW_SCALE			UINT32_C(0x10000000)
	/* Value is in bits. */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID4_MAX_BW_SCALE_BITS		(UINT32_C(0x0) << 28)
	/* Value is in bytes. */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID4_MAX_BW_SCALE_BYTES		(UINT32_C(0x1) << 28)
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID4_MAX_BW_SCALE_LAST		HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID4_MAX_BW_SCALE_BYTES
	/* bw_value_unit is 3 b */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID4_MAX_BW_BW_VALUE_UNIT_MASK	UINT32_C(0xe0000000)
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID4_MAX_BW_BW_VALUE_UNIT_SFT	29
	/* Value is in Mb or MB (base 10). */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID4_MAX_BW_BW_VALUE_UNIT_MEGA	(UINT32_C(0x0) << 29)
	/* Value is in Kb or KB (base 10). */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID4_MAX_BW_BW_VALUE_UNIT_KILO	(UINT32_C(0x2) << 29)
	/* Value is in bits or bytes. */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID4_MAX_BW_BW_VALUE_UNIT_BASE	(UINT32_C(0x4) << 29)
	/* Value is in Gb or GB (base 10). */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID4_MAX_BW_BW_VALUE_UNIT_GIGA	(UINT32_C(0x6) << 29)
	/* Value is in 1/100th of a percentage of total bandwidth. */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID4_MAX_BW_BW_VALUE_UNIT_PERCENT1_100  (UINT32_C(0x1) << 29)
	/* Invalid unit */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID4_MAX_BW_BW_VALUE_UNIT_INVALID	(UINT32_C(0x7) << 29)
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID4_MAX_BW_BW_VALUE_UNIT_LAST	HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID4_MAX_BW_BW_VALUE_UNIT_INVALID
	/* Transmission Selection Algorithm (TSA) for CoS Queue. */
	uint8_t	queue_id4_tsa_assign;
	/* Strict Priority */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID4_TSA_ASSIGN_SP		UINT32_C(0x0)
	/* Enhanced Transmission Selection */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID4_TSA_ASSIGN_ETS		UINT32_C(0x1)
	/* reserved. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID4_TSA_ASSIGN_RESERVED_FIRST UINT32_C(0x2)
	/* reserved. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID4_TSA_ASSIGN_RESERVED_LAST  UINT32_C(0xff)
	/*
	 * Priority level for strict priority. Valid only when the
	 * tsa_assign is 0 - Strict Priority (SP)
	 * 0..7 - Valid values.
	 * 8..255 - Reserved.
	 */
	uint8_t	queue_id4_pri_lvl;
	/*
	 * Weight used to allocate remaining BW for this COS after
	 * servicing guaranteed bandwidths for all COS.
	 */
	uint8_t	queue_id4_bw_weight;
	/* ID of CoS Queue 5. */
	uint8_t	queue_id5;
	/*
	 * Minimum BW allocated to CoS Queue.
	 * The HWRM will translate this value into byte counter and
	 * time interval used for this COS inside the device.
	 */
	uint32_t	queue_id5_min_bw;
	/* The bandwidth value. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID5_MIN_BW_BW_VALUE_MASK		UINT32_C(0xfffffff)
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID5_MIN_BW_BW_VALUE_SFT		0
	/* The granularity of the value (bits or bytes). */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID5_MIN_BW_SCALE			UINT32_C(0x10000000)
	/* Value is in bits. */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID5_MIN_BW_SCALE_BITS		(UINT32_C(0x0) << 28)
	/* Value is in bytes. */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID5_MIN_BW_SCALE_BYTES		(UINT32_C(0x1) << 28)
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID5_MIN_BW_SCALE_LAST		HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID5_MIN_BW_SCALE_BYTES
	/* bw_value_unit is 3 b */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID5_MIN_BW_BW_VALUE_UNIT_MASK	UINT32_C(0xe0000000)
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID5_MIN_BW_BW_VALUE_UNIT_SFT	29
	/* Value is in Mb or MB (base 10). */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID5_MIN_BW_BW_VALUE_UNIT_MEGA	(UINT32_C(0x0) << 29)
	/* Value is in Kb or KB (base 10). */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID5_MIN_BW_BW_VALUE_UNIT_KILO	(UINT32_C(0x2) << 29)
	/* Value is in bits or bytes. */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID5_MIN_BW_BW_VALUE_UNIT_BASE	(UINT32_C(0x4) << 29)
	/* Value is in Gb or GB (base 10). */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID5_MIN_BW_BW_VALUE_UNIT_GIGA	(UINT32_C(0x6) << 29)
	/* Value is in 1/100th of a percentage of total bandwidth. */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID5_MIN_BW_BW_VALUE_UNIT_PERCENT1_100  (UINT32_C(0x1) << 29)
	/* Invalid unit */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID5_MIN_BW_BW_VALUE_UNIT_INVALID	(UINT32_C(0x7) << 29)
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID5_MIN_BW_BW_VALUE_UNIT_LAST	HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID5_MIN_BW_BW_VALUE_UNIT_INVALID
	/*
	 * Maximum BW allocated to CoS queue.
	 * The HWRM will translate this value into byte counter and
	 * time interval used for this COS inside the device.
	 */
	uint32_t	queue_id5_max_bw;
	/* The bandwidth value. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID5_MAX_BW_BW_VALUE_MASK		UINT32_C(0xfffffff)
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID5_MAX_BW_BW_VALUE_SFT		0
	/* The granularity of the value (bits or bytes). */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID5_MAX_BW_SCALE			UINT32_C(0x10000000)
	/* Value is in bits. */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID5_MAX_BW_SCALE_BITS		(UINT32_C(0x0) << 28)
	/* Value is in bytes. */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID5_MAX_BW_SCALE_BYTES		(UINT32_C(0x1) << 28)
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID5_MAX_BW_SCALE_LAST		HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID5_MAX_BW_SCALE_BYTES
	/* bw_value_unit is 3 b */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID5_MAX_BW_BW_VALUE_UNIT_MASK	UINT32_C(0xe0000000)
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID5_MAX_BW_BW_VALUE_UNIT_SFT	29
	/* Value is in Mb or MB (base 10). */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID5_MAX_BW_BW_VALUE_UNIT_MEGA	(UINT32_C(0x0) << 29)
	/* Value is in Kb or KB (base 10). */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID5_MAX_BW_BW_VALUE_UNIT_KILO	(UINT32_C(0x2) << 29)
	/* Value is in bits or bytes. */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID5_MAX_BW_BW_VALUE_UNIT_BASE	(UINT32_C(0x4) << 29)
	/* Value is in Gb or GB (base 10). */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID5_MAX_BW_BW_VALUE_UNIT_GIGA	(UINT32_C(0x6) << 29)
	/* Value is in 1/100th of a percentage of total bandwidth. */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID5_MAX_BW_BW_VALUE_UNIT_PERCENT1_100  (UINT32_C(0x1) << 29)
	/* Invalid unit */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID5_MAX_BW_BW_VALUE_UNIT_INVALID	(UINT32_C(0x7) << 29)
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID5_MAX_BW_BW_VALUE_UNIT_LAST	HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID5_MAX_BW_BW_VALUE_UNIT_INVALID
	/* Transmission Selection Algorithm (TSA) for CoS Queue. */
	uint8_t	queue_id5_tsa_assign;
	/* Strict Priority */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID5_TSA_ASSIGN_SP		UINT32_C(0x0)
	/* Enhanced Transmission Selection */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID5_TSA_ASSIGN_ETS		UINT32_C(0x1)
	/* reserved. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID5_TSA_ASSIGN_RESERVED_FIRST UINT32_C(0x2)
	/* reserved. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID5_TSA_ASSIGN_RESERVED_LAST  UINT32_C(0xff)
	/*
	 * Priority level for strict priority. Valid only when the
	 * tsa_assign is 0 - Strict Priority (SP)
	 * 0..7 - Valid values.
	 * 8..255 - Reserved.
	 */
	uint8_t	queue_id5_pri_lvl;
	/*
	 * Weight used to allocate remaining BW for this COS after
	 * servicing guaranteed bandwidths for all COS.
	 */
	uint8_t	queue_id5_bw_weight;
	/* ID of CoS Queue 6. */
	uint8_t	queue_id6;
	/*
	 * Minimum BW allocated to CoS Queue.
	 * The HWRM will translate this value into byte counter and
	 * time interval used for this COS inside the device.
	 */
	uint32_t	queue_id6_min_bw;
	/* The bandwidth value. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID6_MIN_BW_BW_VALUE_MASK		UINT32_C(0xfffffff)
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID6_MIN_BW_BW_VALUE_SFT		0
	/* The granularity of the value (bits or bytes). */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID6_MIN_BW_SCALE			UINT32_C(0x10000000)
	/* Value is in bits. */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID6_MIN_BW_SCALE_BITS		(UINT32_C(0x0) << 28)
	/* Value is in bytes. */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID6_MIN_BW_SCALE_BYTES		(UINT32_C(0x1) << 28)
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID6_MIN_BW_SCALE_LAST		HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID6_MIN_BW_SCALE_BYTES
	/* bw_value_unit is 3 b */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID6_MIN_BW_BW_VALUE_UNIT_MASK	UINT32_C(0xe0000000)
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID6_MIN_BW_BW_VALUE_UNIT_SFT	29
	/* Value is in Mb or MB (base 10). */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID6_MIN_BW_BW_VALUE_UNIT_MEGA	(UINT32_C(0x0) << 29)
	/* Value is in Kb or KB (base 10). */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID6_MIN_BW_BW_VALUE_UNIT_KILO	(UINT32_C(0x2) << 29)
	/* Value is in bits or bytes. */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID6_MIN_BW_BW_VALUE_UNIT_BASE	(UINT32_C(0x4) << 29)
	/* Value is in Gb or GB (base 10). */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID6_MIN_BW_BW_VALUE_UNIT_GIGA	(UINT32_C(0x6) << 29)
	/* Value is in 1/100th of a percentage of total bandwidth. */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID6_MIN_BW_BW_VALUE_UNIT_PERCENT1_100  (UINT32_C(0x1) << 29)
	/* Invalid unit */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID6_MIN_BW_BW_VALUE_UNIT_INVALID	(UINT32_C(0x7) << 29)
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID6_MIN_BW_BW_VALUE_UNIT_LAST	HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID6_MIN_BW_BW_VALUE_UNIT_INVALID
	/*
	 * Maximum BW allocated to CoS queue.
	 * The HWRM will translate this value into byte counter and
	 * time interval used for this COS inside the device.
	 */
	uint32_t	queue_id6_max_bw;
	/* The bandwidth value. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID6_MAX_BW_BW_VALUE_MASK		UINT32_C(0xfffffff)
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID6_MAX_BW_BW_VALUE_SFT		0
	/* The granularity of the value (bits or bytes). */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID6_MAX_BW_SCALE			UINT32_C(0x10000000)
	/* Value is in bits. */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID6_MAX_BW_SCALE_BITS		(UINT32_C(0x0) << 28)
	/* Value is in bytes. */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID6_MAX_BW_SCALE_BYTES		(UINT32_C(0x1) << 28)
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID6_MAX_BW_SCALE_LAST		HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID6_MAX_BW_SCALE_BYTES
	/* bw_value_unit is 3 b */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID6_MAX_BW_BW_VALUE_UNIT_MASK	UINT32_C(0xe0000000)
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID6_MAX_BW_BW_VALUE_UNIT_SFT	29
	/* Value is in Mb or MB (base 10). */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID6_MAX_BW_BW_VALUE_UNIT_MEGA	(UINT32_C(0x0) << 29)
	/* Value is in Kb or KB (base 10). */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID6_MAX_BW_BW_VALUE_UNIT_KILO	(UINT32_C(0x2) << 29)
	/* Value is in bits or bytes. */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID6_MAX_BW_BW_VALUE_UNIT_BASE	(UINT32_C(0x4) << 29)
	/* Value is in Gb or GB (base 10). */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID6_MAX_BW_BW_VALUE_UNIT_GIGA	(UINT32_C(0x6) << 29)
	/* Value is in 1/100th of a percentage of total bandwidth. */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID6_MAX_BW_BW_VALUE_UNIT_PERCENT1_100  (UINT32_C(0x1) << 29)
	/* Invalid unit */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID6_MAX_BW_BW_VALUE_UNIT_INVALID	(UINT32_C(0x7) << 29)
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID6_MAX_BW_BW_VALUE_UNIT_LAST	HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID6_MAX_BW_BW_VALUE_UNIT_INVALID
	/* Transmission Selection Algorithm (TSA) for CoS Queue. */
	uint8_t	queue_id6_tsa_assign;
	/* Strict Priority */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID6_TSA_ASSIGN_SP		UINT32_C(0x0)
	/* Enhanced Transmission Selection */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID6_TSA_ASSIGN_ETS		UINT32_C(0x1)
	/* reserved. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID6_TSA_ASSIGN_RESERVED_FIRST UINT32_C(0x2)
	/* reserved. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID6_TSA_ASSIGN_RESERVED_LAST  UINT32_C(0xff)
	/*
	 * Priority level for strict priority. Valid only when the
	 * tsa_assign is 0 - Strict Priority (SP)
	 * 0..7 - Valid values.
	 * 8..255 - Reserved.
	 */
	uint8_t	queue_id6_pri_lvl;
	/*
	 * Weight used to allocate remaining BW for this COS after
	 * servicing guaranteed bandwidths for all COS.
	 */
	uint8_t	queue_id6_bw_weight;
	/* ID of CoS Queue 7. */
	uint8_t	queue_id7;
	/*
	 * Minimum BW allocated to CoS Queue.
	 * The HWRM will translate this value into byte counter and
	 * time interval used for this COS inside the device.
	 */
	uint32_t	queue_id7_min_bw;
	/* The bandwidth value. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID7_MIN_BW_BW_VALUE_MASK		UINT32_C(0xfffffff)
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID7_MIN_BW_BW_VALUE_SFT		0
	/* The granularity of the value (bits or bytes). */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID7_MIN_BW_SCALE			UINT32_C(0x10000000)
	/* Value is in bits. */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID7_MIN_BW_SCALE_BITS		(UINT32_C(0x0) << 28)
	/* Value is in bytes. */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID7_MIN_BW_SCALE_BYTES		(UINT32_C(0x1) << 28)
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID7_MIN_BW_SCALE_LAST		HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID7_MIN_BW_SCALE_BYTES
	/* bw_value_unit is 3 b */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID7_MIN_BW_BW_VALUE_UNIT_MASK	UINT32_C(0xe0000000)
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID7_MIN_BW_BW_VALUE_UNIT_SFT	29
	/* Value is in Mb or MB (base 10). */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID7_MIN_BW_BW_VALUE_UNIT_MEGA	(UINT32_C(0x0) << 29)
	/* Value is in Kb or KB (base 10). */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID7_MIN_BW_BW_VALUE_UNIT_KILO	(UINT32_C(0x2) << 29)
	/* Value is in bits or bytes. */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID7_MIN_BW_BW_VALUE_UNIT_BASE	(UINT32_C(0x4) << 29)
	/* Value is in Gb or GB (base 10). */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID7_MIN_BW_BW_VALUE_UNIT_GIGA	(UINT32_C(0x6) << 29)
	/* Value is in 1/100th of a percentage of total bandwidth. */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID7_MIN_BW_BW_VALUE_UNIT_PERCENT1_100  (UINT32_C(0x1) << 29)
	/* Invalid unit */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID7_MIN_BW_BW_VALUE_UNIT_INVALID	(UINT32_C(0x7) << 29)
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID7_MIN_BW_BW_VALUE_UNIT_LAST	HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID7_MIN_BW_BW_VALUE_UNIT_INVALID
	/*
	 * Maximum BW allocated to CoS queue.
	 * The HWRM will translate this value into byte counter and
	 * time interval used for this COS inside the device.
	 */
	uint32_t	queue_id7_max_bw;
	/* The bandwidth value. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID7_MAX_BW_BW_VALUE_MASK		UINT32_C(0xfffffff)
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID7_MAX_BW_BW_VALUE_SFT		0
	/* The granularity of the value (bits or bytes). */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID7_MAX_BW_SCALE			UINT32_C(0x10000000)
	/* Value is in bits. */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID7_MAX_BW_SCALE_BITS		(UINT32_C(0x0) << 28)
	/* Value is in bytes. */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID7_MAX_BW_SCALE_BYTES		(UINT32_C(0x1) << 28)
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID7_MAX_BW_SCALE_LAST		HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID7_MAX_BW_SCALE_BYTES
	/* bw_value_unit is 3 b */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID7_MAX_BW_BW_VALUE_UNIT_MASK	UINT32_C(0xe0000000)
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID7_MAX_BW_BW_VALUE_UNIT_SFT	29
	/* Value is in Mb or MB (base 10). */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID7_MAX_BW_BW_VALUE_UNIT_MEGA	(UINT32_C(0x0) << 29)
	/* Value is in Kb or KB (base 10). */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID7_MAX_BW_BW_VALUE_UNIT_KILO	(UINT32_C(0x2) << 29)
	/* Value is in bits or bytes. */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID7_MAX_BW_BW_VALUE_UNIT_BASE	(UINT32_C(0x4) << 29)
	/* Value is in Gb or GB (base 10). */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID7_MAX_BW_BW_VALUE_UNIT_GIGA	(UINT32_C(0x6) << 29)
	/* Value is in 1/100th of a percentage of total bandwidth. */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID7_MAX_BW_BW_VALUE_UNIT_PERCENT1_100  (UINT32_C(0x1) << 29)
	/* Invalid unit */
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID7_MAX_BW_BW_VALUE_UNIT_INVALID	(UINT32_C(0x7) << 29)
		#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID7_MAX_BW_BW_VALUE_UNIT_LAST	HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID7_MAX_BW_BW_VALUE_UNIT_INVALID
	/* Transmission Selection Algorithm (TSA) for CoS Queue. */
	uint8_t	queue_id7_tsa_assign;
	/* Strict Priority */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID7_TSA_ASSIGN_SP		UINT32_C(0x0)
	/* Enhanced Transmission Selection */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID7_TSA_ASSIGN_ETS		UINT32_C(0x1)
	/* reserved. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID7_TSA_ASSIGN_RESERVED_FIRST UINT32_C(0x2)
	/* reserved. */
	#define HWRM_QUEUE_COS2BW_QCFG_OUTPUT_QUEUE_ID7_TSA_ASSIGN_RESERVED_LAST  UINT32_C(0xff)
	/*
	 * Priority level for strict priority. Valid only when the
	 * tsa_assign is 0 - Strict Priority (SP)
	 * 0..7 - Valid values.
	 * 8..255 - Reserved.
	 */
	uint8_t	queue_id7_pri_lvl;
	/*
	 * Weight used to allocate remaining BW for this COS after
	 * servicing guaranteed bandwidths for all COS.
	 */
	uint8_t	queue_id7_bw_weight;
	uint8_t	unused_2[4];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_queue_cos2bw_qcfg_output_t, *phwrm_queue_cos2bw_qcfg_output_t;

/*************************
 * hwrm_queue_cos2bw_cfg *
 *************************/


/* hwrm_queue_cos2bw_cfg_input (size:1024b/128B) */

typedef struct hwrm_queue_cos2bw_cfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	flags;
	uint32_t	enables;
	/*
	 * If this bit is set to 1, then all queue_id0 related
	 * parameters in this command are valid.
	 */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_ENABLES_COS_QUEUE_ID0_VALID	UINT32_C(0x1)
	/*
	 * If this bit is set to 1, then all queue_id1 related
	 * parameters in this command are valid.
	 */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_ENABLES_COS_QUEUE_ID1_VALID	UINT32_C(0x2)
	/*
	 * If this bit is set to 1, then all queue_id2 related
	 * parameters in this command are valid.
	 */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_ENABLES_COS_QUEUE_ID2_VALID	UINT32_C(0x4)
	/*
	 * If this bit is set to 1, then all queue_id3 related
	 * parameters in this command are valid.
	 */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_ENABLES_COS_QUEUE_ID3_VALID	UINT32_C(0x8)
	/*
	 * If this bit is set to 1, then all queue_id4 related
	 * parameters in this command are valid.
	 */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_ENABLES_COS_QUEUE_ID4_VALID	UINT32_C(0x10)
	/*
	 * If this bit is set to 1, then all queue_id5 related
	 * parameters in this command are valid.
	 */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_ENABLES_COS_QUEUE_ID5_VALID	UINT32_C(0x20)
	/*
	 * If this bit is set to 1, then all queue_id6 related
	 * parameters in this command are valid.
	 */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_ENABLES_COS_QUEUE_ID6_VALID	UINT32_C(0x40)
	/*
	 * If this bit is set to 1, then all queue_id7 related
	 * parameters in this command are valid.
	 */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_ENABLES_COS_QUEUE_ID7_VALID	UINT32_C(0x80)
	/*
	 * Port ID of port for which the table is being configured.
	 * The HWRM needs to check whether this function is allowed
	 * to configure TC BW assignment on this port.
	 */
	uint16_t	port_id;
	/* ID of CoS Queue 0. */
	uint8_t	queue_id0;
	uint8_t	unused_0;
	/*
	 * Minimum BW allocated to CoS Queue.
	 * The HWRM will translate this value into byte counter and
	 * time interval used for this COS inside the device.
	 */
	uint32_t	queue_id0_min_bw;
	/* The bandwidth value. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID0_MIN_BW_BW_VALUE_MASK		UINT32_C(0xfffffff)
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID0_MIN_BW_BW_VALUE_SFT		0
	/* The granularity of the value (bits or bytes). */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID0_MIN_BW_SCALE			UINT32_C(0x10000000)
	/* Value is in bits. */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID0_MIN_BW_SCALE_BITS		(UINT32_C(0x0) << 28)
	/* Value is in bytes. */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID0_MIN_BW_SCALE_BYTES		(UINT32_C(0x1) << 28)
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID0_MIN_BW_SCALE_LAST		HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID0_MIN_BW_SCALE_BYTES
	/* bw_value_unit is 3 b */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID0_MIN_BW_BW_VALUE_UNIT_MASK	UINT32_C(0xe0000000)
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID0_MIN_BW_BW_VALUE_UNIT_SFT	29
	/* Value is in Mb or MB (base 10). */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID0_MIN_BW_BW_VALUE_UNIT_MEGA	(UINT32_C(0x0) << 29)
	/* Value is in Kb or KB (base 10). */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID0_MIN_BW_BW_VALUE_UNIT_KILO	(UINT32_C(0x2) << 29)
	/* Value is in bits or bytes. */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID0_MIN_BW_BW_VALUE_UNIT_BASE	(UINT32_C(0x4) << 29)
	/* Value is in Gb or GB (base 10). */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID0_MIN_BW_BW_VALUE_UNIT_GIGA	(UINT32_C(0x6) << 29)
	/* Value is in 1/100th of a percentage of total bandwidth. */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID0_MIN_BW_BW_VALUE_UNIT_PERCENT1_100  (UINT32_C(0x1) << 29)
	/* Invalid unit */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID0_MIN_BW_BW_VALUE_UNIT_INVALID	(UINT32_C(0x7) << 29)
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID0_MIN_BW_BW_VALUE_UNIT_LAST	HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID0_MIN_BW_BW_VALUE_UNIT_INVALID
	/*
	 * Maximum BW allocated to CoS Queue.
	 * The HWRM will translate this value into byte counter and
	 * time interval used for this COS inside the device.
	 */
	uint32_t	queue_id0_max_bw;
	/* The bandwidth value. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID0_MAX_BW_BW_VALUE_MASK		UINT32_C(0xfffffff)
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID0_MAX_BW_BW_VALUE_SFT		0
	/* The granularity of the value (bits or bytes). */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID0_MAX_BW_SCALE			UINT32_C(0x10000000)
	/* Value is in bits. */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID0_MAX_BW_SCALE_BITS		(UINT32_C(0x0) << 28)
	/* Value is in bytes. */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID0_MAX_BW_SCALE_BYTES		(UINT32_C(0x1) << 28)
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID0_MAX_BW_SCALE_LAST		HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID0_MAX_BW_SCALE_BYTES
	/* bw_value_unit is 3 b */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID0_MAX_BW_BW_VALUE_UNIT_MASK	UINT32_C(0xe0000000)
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID0_MAX_BW_BW_VALUE_UNIT_SFT	29
	/* Value is in Mb or MB (base 10). */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID0_MAX_BW_BW_VALUE_UNIT_MEGA	(UINT32_C(0x0) << 29)
	/* Value is in Kb or KB (base 10). */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID0_MAX_BW_BW_VALUE_UNIT_KILO	(UINT32_C(0x2) << 29)
	/* Value is in bits or bytes. */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID0_MAX_BW_BW_VALUE_UNIT_BASE	(UINT32_C(0x4) << 29)
	/* Value is in Gb or GB (base 10). */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID0_MAX_BW_BW_VALUE_UNIT_GIGA	(UINT32_C(0x6) << 29)
	/* Value is in 1/100th of a percentage of total bandwidth. */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID0_MAX_BW_BW_VALUE_UNIT_PERCENT1_100  (UINT32_C(0x1) << 29)
	/* Invalid unit */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID0_MAX_BW_BW_VALUE_UNIT_INVALID	(UINT32_C(0x7) << 29)
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID0_MAX_BW_BW_VALUE_UNIT_LAST	HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID0_MAX_BW_BW_VALUE_UNIT_INVALID
	/* Transmission Selection Algorithm (TSA) for CoS Queue. */
	uint8_t	queue_id0_tsa_assign;
	/* Strict Priority */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID0_TSA_ASSIGN_SP		UINT32_C(0x0)
	/* Enhanced Transmission Selection */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID0_TSA_ASSIGN_ETS		UINT32_C(0x1)
	/* reserved. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID0_TSA_ASSIGN_RESERVED_FIRST UINT32_C(0x2)
	/* reserved. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID0_TSA_ASSIGN_RESERVED_LAST  UINT32_C(0xff)
	/*
	 * Priority level for strict priority. Valid only when the
	 * tsa_assign is 0 - Strict Priority (SP)
	 * 0..7 - Valid values.
	 * 8..255 - Reserved.
	 */
	uint8_t	queue_id0_pri_lvl;
	/*
	 * Weight used to allocate remaining BW for this COS after
	 * servicing guaranteed bandwidths for all COS.
	 */
	uint8_t	queue_id0_bw_weight;
	/* ID of CoS Queue 1. */
	uint8_t	queue_id1;
	/*
	 * Minimum BW allocated to CoS Queue.
	 * The HWRM will translate this value into byte counter and
	 * time interval used for this COS inside the device.
	 */
	uint32_t	queue_id1_min_bw;
	/* The bandwidth value. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID1_MIN_BW_BW_VALUE_MASK		UINT32_C(0xfffffff)
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID1_MIN_BW_BW_VALUE_SFT		0
	/* The granularity of the value (bits or bytes). */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID1_MIN_BW_SCALE			UINT32_C(0x10000000)
	/* Value is in bits. */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID1_MIN_BW_SCALE_BITS		(UINT32_C(0x0) << 28)
	/* Value is in bytes. */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID1_MIN_BW_SCALE_BYTES		(UINT32_C(0x1) << 28)
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID1_MIN_BW_SCALE_LAST		HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID1_MIN_BW_SCALE_BYTES
	/* bw_value_unit is 3 b */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID1_MIN_BW_BW_VALUE_UNIT_MASK	UINT32_C(0xe0000000)
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID1_MIN_BW_BW_VALUE_UNIT_SFT	29
	/* Value is in Mb or MB (base 10). */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID1_MIN_BW_BW_VALUE_UNIT_MEGA	(UINT32_C(0x0) << 29)
	/* Value is in Kb or KB (base 10). */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID1_MIN_BW_BW_VALUE_UNIT_KILO	(UINT32_C(0x2) << 29)
	/* Value is in bits or bytes. */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID1_MIN_BW_BW_VALUE_UNIT_BASE	(UINT32_C(0x4) << 29)
	/* Value is in Gb or GB (base 10). */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID1_MIN_BW_BW_VALUE_UNIT_GIGA	(UINT32_C(0x6) << 29)
	/* Value is in 1/100th of a percentage of total bandwidth. */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID1_MIN_BW_BW_VALUE_UNIT_PERCENT1_100  (UINT32_C(0x1) << 29)
	/* Invalid unit */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID1_MIN_BW_BW_VALUE_UNIT_INVALID	(UINT32_C(0x7) << 29)
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID1_MIN_BW_BW_VALUE_UNIT_LAST	HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID1_MIN_BW_BW_VALUE_UNIT_INVALID
	/*
	 * Maximum BW allocated to CoS queue.
	 * The HWRM will translate this value into byte counter and
	 * time interval used for this COS inside the device.
	 */
	uint32_t	queue_id1_max_bw;
	/* The bandwidth value. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID1_MAX_BW_BW_VALUE_MASK		UINT32_C(0xfffffff)
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID1_MAX_BW_BW_VALUE_SFT		0
	/* The granularity of the value (bits or bytes). */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID1_MAX_BW_SCALE			UINT32_C(0x10000000)
	/* Value is in bits. */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID1_MAX_BW_SCALE_BITS		(UINT32_C(0x0) << 28)
	/* Value is in bytes. */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID1_MAX_BW_SCALE_BYTES		(UINT32_C(0x1) << 28)
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID1_MAX_BW_SCALE_LAST		HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID1_MAX_BW_SCALE_BYTES
	/* bw_value_unit is 3 b */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID1_MAX_BW_BW_VALUE_UNIT_MASK	UINT32_C(0xe0000000)
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID1_MAX_BW_BW_VALUE_UNIT_SFT	29
	/* Value is in Mb or MB (base 10). */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID1_MAX_BW_BW_VALUE_UNIT_MEGA	(UINT32_C(0x0) << 29)
	/* Value is in Kb or KB (base 10). */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID1_MAX_BW_BW_VALUE_UNIT_KILO	(UINT32_C(0x2) << 29)
	/* Value is in bits or bytes. */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID1_MAX_BW_BW_VALUE_UNIT_BASE	(UINT32_C(0x4) << 29)
	/* Value is in Gb or GB (base 10). */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID1_MAX_BW_BW_VALUE_UNIT_GIGA	(UINT32_C(0x6) << 29)
	/* Value is in 1/100th of a percentage of total bandwidth. */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID1_MAX_BW_BW_VALUE_UNIT_PERCENT1_100  (UINT32_C(0x1) << 29)
	/* Invalid unit */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID1_MAX_BW_BW_VALUE_UNIT_INVALID	(UINT32_C(0x7) << 29)
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID1_MAX_BW_BW_VALUE_UNIT_LAST	HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID1_MAX_BW_BW_VALUE_UNIT_INVALID
	/* Transmission Selection Algorithm (TSA) for CoS Queue. */
	uint8_t	queue_id1_tsa_assign;
	/* Strict Priority */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID1_TSA_ASSIGN_SP		UINT32_C(0x0)
	/* Enhanced Transmission Selection */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID1_TSA_ASSIGN_ETS		UINT32_C(0x1)
	/* reserved. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID1_TSA_ASSIGN_RESERVED_FIRST UINT32_C(0x2)
	/* reserved. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID1_TSA_ASSIGN_RESERVED_LAST  UINT32_C(0xff)
	/*
	 * Priority level for strict priority. Valid only when the
	 * tsa_assign is 0 - Strict Priority (SP)
	 * 0..7 - Valid values.
	 * 8..255 - Reserved.
	 */
	uint8_t	queue_id1_pri_lvl;
	/*
	 * Weight used to allocate remaining BW for this COS after
	 * servicing guaranteed bandwidths for all COS.
	 */
	uint8_t	queue_id1_bw_weight;
	/* ID of CoS Queue 2. */
	uint8_t	queue_id2;
	/*
	 * Minimum BW allocated to CoS Queue.
	 * The HWRM will translate this value into byte counter and
	 * time interval used for this COS inside the device.
	 */
	uint32_t	queue_id2_min_bw;
	/* The bandwidth value. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID2_MIN_BW_BW_VALUE_MASK		UINT32_C(0xfffffff)
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID2_MIN_BW_BW_VALUE_SFT		0
	/* The granularity of the value (bits or bytes). */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID2_MIN_BW_SCALE			UINT32_C(0x10000000)
	/* Value is in bits. */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID2_MIN_BW_SCALE_BITS		(UINT32_C(0x0) << 28)
	/* Value is in bytes. */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID2_MIN_BW_SCALE_BYTES		(UINT32_C(0x1) << 28)
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID2_MIN_BW_SCALE_LAST		HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID2_MIN_BW_SCALE_BYTES
	/* bw_value_unit is 3 b */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID2_MIN_BW_BW_VALUE_UNIT_MASK	UINT32_C(0xe0000000)
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID2_MIN_BW_BW_VALUE_UNIT_SFT	29
	/* Value is in Mb or MB (base 10). */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID2_MIN_BW_BW_VALUE_UNIT_MEGA	(UINT32_C(0x0) << 29)
	/* Value is in Kb or KB (base 10). */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID2_MIN_BW_BW_VALUE_UNIT_KILO	(UINT32_C(0x2) << 29)
	/* Value is in bits or bytes. */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID2_MIN_BW_BW_VALUE_UNIT_BASE	(UINT32_C(0x4) << 29)
	/* Value is in Gb or GB (base 10). */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID2_MIN_BW_BW_VALUE_UNIT_GIGA	(UINT32_C(0x6) << 29)
	/* Value is in 1/100th of a percentage of total bandwidth. */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID2_MIN_BW_BW_VALUE_UNIT_PERCENT1_100  (UINT32_C(0x1) << 29)
	/* Invalid unit */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID2_MIN_BW_BW_VALUE_UNIT_INVALID	(UINT32_C(0x7) << 29)
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID2_MIN_BW_BW_VALUE_UNIT_LAST	HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID2_MIN_BW_BW_VALUE_UNIT_INVALID
	/*
	 * Maximum BW allocated to CoS queue.
	 * The HWRM will translate this value into byte counter and
	 * time interval used for this COS inside the device.
	 */
	uint32_t	queue_id2_max_bw;
	/* The bandwidth value. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID2_MAX_BW_BW_VALUE_MASK		UINT32_C(0xfffffff)
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID2_MAX_BW_BW_VALUE_SFT		0
	/* The granularity of the value (bits or bytes). */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID2_MAX_BW_SCALE			UINT32_C(0x10000000)
	/* Value is in bits. */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID2_MAX_BW_SCALE_BITS		(UINT32_C(0x0) << 28)
	/* Value is in bytes. */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID2_MAX_BW_SCALE_BYTES		(UINT32_C(0x1) << 28)
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID2_MAX_BW_SCALE_LAST		HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID2_MAX_BW_SCALE_BYTES
	/* bw_value_unit is 3 b */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID2_MAX_BW_BW_VALUE_UNIT_MASK	UINT32_C(0xe0000000)
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID2_MAX_BW_BW_VALUE_UNIT_SFT	29
	/* Value is in Mb or MB (base 10). */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID2_MAX_BW_BW_VALUE_UNIT_MEGA	(UINT32_C(0x0) << 29)
	/* Value is in Kb or KB (base 10). */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID2_MAX_BW_BW_VALUE_UNIT_KILO	(UINT32_C(0x2) << 29)
	/* Value is in bits or bytes. */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID2_MAX_BW_BW_VALUE_UNIT_BASE	(UINT32_C(0x4) << 29)
	/* Value is in Gb or GB (base 10). */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID2_MAX_BW_BW_VALUE_UNIT_GIGA	(UINT32_C(0x6) << 29)
	/* Value is in 1/100th of a percentage of total bandwidth. */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID2_MAX_BW_BW_VALUE_UNIT_PERCENT1_100  (UINT32_C(0x1) << 29)
	/* Invalid unit */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID2_MAX_BW_BW_VALUE_UNIT_INVALID	(UINT32_C(0x7) << 29)
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID2_MAX_BW_BW_VALUE_UNIT_LAST	HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID2_MAX_BW_BW_VALUE_UNIT_INVALID
	/* Transmission Selection Algorithm (TSA) for CoS Queue. */
	uint8_t	queue_id2_tsa_assign;
	/* Strict Priority */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID2_TSA_ASSIGN_SP		UINT32_C(0x0)
	/* Enhanced Transmission Selection */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID2_TSA_ASSIGN_ETS		UINT32_C(0x1)
	/* reserved. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID2_TSA_ASSIGN_RESERVED_FIRST UINT32_C(0x2)
	/* reserved. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID2_TSA_ASSIGN_RESERVED_LAST  UINT32_C(0xff)
	/*
	 * Priority level for strict priority. Valid only when the
	 * tsa_assign is 0 - Strict Priority (SP)
	 * 0..7 - Valid values.
	 * 8..255 - Reserved.
	 */
	uint8_t	queue_id2_pri_lvl;
	/*
	 * Weight used to allocate remaining BW for this COS after
	 * servicing guaranteed bandwidths for all COS.
	 */
	uint8_t	queue_id2_bw_weight;
	/* ID of CoS Queue 3. */
	uint8_t	queue_id3;
	/*
	 * Minimum BW allocated to CoS Queue.
	 * The HWRM will translate this value into byte counter and
	 * time interval used for this COS inside the device.
	 */
	uint32_t	queue_id3_min_bw;
	/* The bandwidth value. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID3_MIN_BW_BW_VALUE_MASK		UINT32_C(0xfffffff)
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID3_MIN_BW_BW_VALUE_SFT		0
	/* The granularity of the value (bits or bytes). */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID3_MIN_BW_SCALE			UINT32_C(0x10000000)
	/* Value is in bits. */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID3_MIN_BW_SCALE_BITS		(UINT32_C(0x0) << 28)
	/* Value is in bytes. */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID3_MIN_BW_SCALE_BYTES		(UINT32_C(0x1) << 28)
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID3_MIN_BW_SCALE_LAST		HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID3_MIN_BW_SCALE_BYTES
	/* bw_value_unit is 3 b */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID3_MIN_BW_BW_VALUE_UNIT_MASK	UINT32_C(0xe0000000)
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID3_MIN_BW_BW_VALUE_UNIT_SFT	29
	/* Value is in Mb or MB (base 10). */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID3_MIN_BW_BW_VALUE_UNIT_MEGA	(UINT32_C(0x0) << 29)
	/* Value is in Kb or KB (base 10). */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID3_MIN_BW_BW_VALUE_UNIT_KILO	(UINT32_C(0x2) << 29)
	/* Value is in bits or bytes. */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID3_MIN_BW_BW_VALUE_UNIT_BASE	(UINT32_C(0x4) << 29)
	/* Value is in Gb or GB (base 10). */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID3_MIN_BW_BW_VALUE_UNIT_GIGA	(UINT32_C(0x6) << 29)
	/* Value is in 1/100th of a percentage of total bandwidth. */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID3_MIN_BW_BW_VALUE_UNIT_PERCENT1_100  (UINT32_C(0x1) << 29)
	/* Invalid unit */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID3_MIN_BW_BW_VALUE_UNIT_INVALID	(UINT32_C(0x7) << 29)
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID3_MIN_BW_BW_VALUE_UNIT_LAST	HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID3_MIN_BW_BW_VALUE_UNIT_INVALID
	/*
	 * Maximum BW allocated to CoS queue.
	 * The HWRM will translate this value into byte counter and
	 * time interval used for this COS inside the device.
	 */
	uint32_t	queue_id3_max_bw;
	/* The bandwidth value. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID3_MAX_BW_BW_VALUE_MASK		UINT32_C(0xfffffff)
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID3_MAX_BW_BW_VALUE_SFT		0
	/* The granularity of the value (bits or bytes). */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID3_MAX_BW_SCALE			UINT32_C(0x10000000)
	/* Value is in bits. */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID3_MAX_BW_SCALE_BITS		(UINT32_C(0x0) << 28)
	/* Value is in bytes. */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID3_MAX_BW_SCALE_BYTES		(UINT32_C(0x1) << 28)
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID3_MAX_BW_SCALE_LAST		HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID3_MAX_BW_SCALE_BYTES
	/* bw_value_unit is 3 b */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID3_MAX_BW_BW_VALUE_UNIT_MASK	UINT32_C(0xe0000000)
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID3_MAX_BW_BW_VALUE_UNIT_SFT	29
	/* Value is in Mb or MB (base 10). */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID3_MAX_BW_BW_VALUE_UNIT_MEGA	(UINT32_C(0x0) << 29)
	/* Value is in Kb or KB (base 10). */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID3_MAX_BW_BW_VALUE_UNIT_KILO	(UINT32_C(0x2) << 29)
	/* Value is in bits or bytes. */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID3_MAX_BW_BW_VALUE_UNIT_BASE	(UINT32_C(0x4) << 29)
	/* Value is in Gb or GB (base 10). */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID3_MAX_BW_BW_VALUE_UNIT_GIGA	(UINT32_C(0x6) << 29)
	/* Value is in 1/100th of a percentage of total bandwidth. */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID3_MAX_BW_BW_VALUE_UNIT_PERCENT1_100  (UINT32_C(0x1) << 29)
	/* Invalid unit */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID3_MAX_BW_BW_VALUE_UNIT_INVALID	(UINT32_C(0x7) << 29)
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID3_MAX_BW_BW_VALUE_UNIT_LAST	HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID3_MAX_BW_BW_VALUE_UNIT_INVALID
	/* Transmission Selection Algorithm (TSA) for CoS Queue. */
	uint8_t	queue_id3_tsa_assign;
	/* Strict Priority */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID3_TSA_ASSIGN_SP		UINT32_C(0x0)
	/* Enhanced Transmission Selection */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID3_TSA_ASSIGN_ETS		UINT32_C(0x1)
	/* reserved. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID3_TSA_ASSIGN_RESERVED_FIRST UINT32_C(0x2)
	/* reserved. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID3_TSA_ASSIGN_RESERVED_LAST  UINT32_C(0xff)
	/*
	 * Priority level for strict priority. Valid only when the
	 * tsa_assign is 0 - Strict Priority (SP)
	 * 0..7 - Valid values.
	 * 8..255 - Reserved.
	 */
	uint8_t	queue_id3_pri_lvl;
	/*
	 * Weight used to allocate remaining BW for this COS after
	 * servicing guaranteed bandwidths for all COS.
	 */
	uint8_t	queue_id3_bw_weight;
	/* ID of CoS Queue 4. */
	uint8_t	queue_id4;
	/*
	 * Minimum BW allocated to CoS Queue.
	 * The HWRM will translate this value into byte counter and
	 * time interval used for this COS inside the device.
	 */
	uint32_t	queue_id4_min_bw;
	/* The bandwidth value. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID4_MIN_BW_BW_VALUE_MASK		UINT32_C(0xfffffff)
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID4_MIN_BW_BW_VALUE_SFT		0
	/* The granularity of the value (bits or bytes). */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID4_MIN_BW_SCALE			UINT32_C(0x10000000)
	/* Value is in bits. */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID4_MIN_BW_SCALE_BITS		(UINT32_C(0x0) << 28)
	/* Value is in bytes. */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID4_MIN_BW_SCALE_BYTES		(UINT32_C(0x1) << 28)
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID4_MIN_BW_SCALE_LAST		HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID4_MIN_BW_SCALE_BYTES
	/* bw_value_unit is 3 b */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID4_MIN_BW_BW_VALUE_UNIT_MASK	UINT32_C(0xe0000000)
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID4_MIN_BW_BW_VALUE_UNIT_SFT	29
	/* Value is in Mb or MB (base 10). */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID4_MIN_BW_BW_VALUE_UNIT_MEGA	(UINT32_C(0x0) << 29)
	/* Value is in Kb or KB (base 10). */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID4_MIN_BW_BW_VALUE_UNIT_KILO	(UINT32_C(0x2) << 29)
	/* Value is in bits or bytes. */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID4_MIN_BW_BW_VALUE_UNIT_BASE	(UINT32_C(0x4) << 29)
	/* Value is in Gb or GB (base 10). */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID4_MIN_BW_BW_VALUE_UNIT_GIGA	(UINT32_C(0x6) << 29)
	/* Value is in 1/100th of a percentage of total bandwidth. */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID4_MIN_BW_BW_VALUE_UNIT_PERCENT1_100  (UINT32_C(0x1) << 29)
	/* Invalid unit */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID4_MIN_BW_BW_VALUE_UNIT_INVALID	(UINT32_C(0x7) << 29)
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID4_MIN_BW_BW_VALUE_UNIT_LAST	HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID4_MIN_BW_BW_VALUE_UNIT_INVALID
	/*
	 * Maximum BW allocated to CoS queue.
	 * The HWRM will translate this value into byte counter and
	 * time interval used for this COS inside the device.
	 */
	uint32_t	queue_id4_max_bw;
	/* The bandwidth value. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID4_MAX_BW_BW_VALUE_MASK		UINT32_C(0xfffffff)
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID4_MAX_BW_BW_VALUE_SFT		0
	/* The granularity of the value (bits or bytes). */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID4_MAX_BW_SCALE			UINT32_C(0x10000000)
	/* Value is in bits. */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID4_MAX_BW_SCALE_BITS		(UINT32_C(0x0) << 28)
	/* Value is in bytes. */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID4_MAX_BW_SCALE_BYTES		(UINT32_C(0x1) << 28)
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID4_MAX_BW_SCALE_LAST		HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID4_MAX_BW_SCALE_BYTES
	/* bw_value_unit is 3 b */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID4_MAX_BW_BW_VALUE_UNIT_MASK	UINT32_C(0xe0000000)
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID4_MAX_BW_BW_VALUE_UNIT_SFT	29
	/* Value is in Mb or MB (base 10). */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID4_MAX_BW_BW_VALUE_UNIT_MEGA	(UINT32_C(0x0) << 29)
	/* Value is in Kb or KB (base 10). */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID4_MAX_BW_BW_VALUE_UNIT_KILO	(UINT32_C(0x2) << 29)
	/* Value is in bits or bytes. */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID4_MAX_BW_BW_VALUE_UNIT_BASE	(UINT32_C(0x4) << 29)
	/* Value is in Gb or GB (base 10). */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID4_MAX_BW_BW_VALUE_UNIT_GIGA	(UINT32_C(0x6) << 29)
	/* Value is in 1/100th of a percentage of total bandwidth. */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID4_MAX_BW_BW_VALUE_UNIT_PERCENT1_100  (UINT32_C(0x1) << 29)
	/* Invalid unit */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID4_MAX_BW_BW_VALUE_UNIT_INVALID	(UINT32_C(0x7) << 29)
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID4_MAX_BW_BW_VALUE_UNIT_LAST	HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID4_MAX_BW_BW_VALUE_UNIT_INVALID
	/* Transmission Selection Algorithm (TSA) for CoS Queue. */
	uint8_t	queue_id4_tsa_assign;
	/* Strict Priority */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID4_TSA_ASSIGN_SP		UINT32_C(0x0)
	/* Enhanced Transmission Selection */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID4_TSA_ASSIGN_ETS		UINT32_C(0x1)
	/* reserved. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID4_TSA_ASSIGN_RESERVED_FIRST UINT32_C(0x2)
	/* reserved. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID4_TSA_ASSIGN_RESERVED_LAST  UINT32_C(0xff)
	/*
	 * Priority level for strict priority. Valid only when the
	 * tsa_assign is 0 - Strict Priority (SP)
	 * 0..7 - Valid values.
	 * 8..255 - Reserved.
	 */
	uint8_t	queue_id4_pri_lvl;
	/*
	 * Weight used to allocate remaining BW for this COS after
	 * servicing guaranteed bandwidths for all COS.
	 */
	uint8_t	queue_id4_bw_weight;
	/* ID of CoS Queue 5. */
	uint8_t	queue_id5;
	/*
	 * Minimum BW allocated to CoS Queue.
	 * The HWRM will translate this value into byte counter and
	 * time interval used for this COS inside the device.
	 */
	uint32_t	queue_id5_min_bw;
	/* The bandwidth value. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID5_MIN_BW_BW_VALUE_MASK		UINT32_C(0xfffffff)
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID5_MIN_BW_BW_VALUE_SFT		0
	/* The granularity of the value (bits or bytes). */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID5_MIN_BW_SCALE			UINT32_C(0x10000000)
	/* Value is in bits. */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID5_MIN_BW_SCALE_BITS		(UINT32_C(0x0) << 28)
	/* Value is in bytes. */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID5_MIN_BW_SCALE_BYTES		(UINT32_C(0x1) << 28)
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID5_MIN_BW_SCALE_LAST		HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID5_MIN_BW_SCALE_BYTES
	/* bw_value_unit is 3 b */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID5_MIN_BW_BW_VALUE_UNIT_MASK	UINT32_C(0xe0000000)
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID5_MIN_BW_BW_VALUE_UNIT_SFT	29
	/* Value is in Mb or MB (base 10). */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID5_MIN_BW_BW_VALUE_UNIT_MEGA	(UINT32_C(0x0) << 29)
	/* Value is in Kb or KB (base 10). */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID5_MIN_BW_BW_VALUE_UNIT_KILO	(UINT32_C(0x2) << 29)
	/* Value is in bits or bytes. */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID5_MIN_BW_BW_VALUE_UNIT_BASE	(UINT32_C(0x4) << 29)
	/* Value is in Gb or GB (base 10). */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID5_MIN_BW_BW_VALUE_UNIT_GIGA	(UINT32_C(0x6) << 29)
	/* Value is in 1/100th of a percentage of total bandwidth. */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID5_MIN_BW_BW_VALUE_UNIT_PERCENT1_100  (UINT32_C(0x1) << 29)
	/* Invalid unit */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID5_MIN_BW_BW_VALUE_UNIT_INVALID	(UINT32_C(0x7) << 29)
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID5_MIN_BW_BW_VALUE_UNIT_LAST	HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID5_MIN_BW_BW_VALUE_UNIT_INVALID
	/*
	 * Maximum BW allocated to CoS queue.
	 * The HWRM will translate this value into byte counter and
	 * time interval used for this COS inside the device.
	 */
	uint32_t	queue_id5_max_bw;
	/* The bandwidth value. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID5_MAX_BW_BW_VALUE_MASK		UINT32_C(0xfffffff)
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID5_MAX_BW_BW_VALUE_SFT		0
	/* The granularity of the value (bits or bytes). */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID5_MAX_BW_SCALE			UINT32_C(0x10000000)
	/* Value is in bits. */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID5_MAX_BW_SCALE_BITS		(UINT32_C(0x0) << 28)
	/* Value is in bytes. */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID5_MAX_BW_SCALE_BYTES		(UINT32_C(0x1) << 28)
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID5_MAX_BW_SCALE_LAST		HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID5_MAX_BW_SCALE_BYTES
	/* bw_value_unit is 3 b */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID5_MAX_BW_BW_VALUE_UNIT_MASK	UINT32_C(0xe0000000)
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID5_MAX_BW_BW_VALUE_UNIT_SFT	29
	/* Value is in Mb or MB (base 10). */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID5_MAX_BW_BW_VALUE_UNIT_MEGA	(UINT32_C(0x0) << 29)
	/* Value is in Kb or KB (base 10). */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID5_MAX_BW_BW_VALUE_UNIT_KILO	(UINT32_C(0x2) << 29)
	/* Value is in bits or bytes. */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID5_MAX_BW_BW_VALUE_UNIT_BASE	(UINT32_C(0x4) << 29)
	/* Value is in Gb or GB (base 10). */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID5_MAX_BW_BW_VALUE_UNIT_GIGA	(UINT32_C(0x6) << 29)
	/* Value is in 1/100th of a percentage of total bandwidth. */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID5_MAX_BW_BW_VALUE_UNIT_PERCENT1_100  (UINT32_C(0x1) << 29)
	/* Invalid unit */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID5_MAX_BW_BW_VALUE_UNIT_INVALID	(UINT32_C(0x7) << 29)
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID5_MAX_BW_BW_VALUE_UNIT_LAST	HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID5_MAX_BW_BW_VALUE_UNIT_INVALID
	/* Transmission Selection Algorithm (TSA) for CoS Queue. */
	uint8_t	queue_id5_tsa_assign;
	/* Strict Priority */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID5_TSA_ASSIGN_SP		UINT32_C(0x0)
	/* Enhanced Transmission Selection */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID5_TSA_ASSIGN_ETS		UINT32_C(0x1)
	/* reserved. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID5_TSA_ASSIGN_RESERVED_FIRST UINT32_C(0x2)
	/* reserved. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID5_TSA_ASSIGN_RESERVED_LAST  UINT32_C(0xff)
	/*
	 * Priority level for strict priority. Valid only when the
	 * tsa_assign is 0 - Strict Priority (SP)
	 * 0..7 - Valid values.
	 * 8..255 - Reserved.
	 */
	uint8_t	queue_id5_pri_lvl;
	/*
	 * Weight used to allocate remaining BW for this COS after
	 * servicing guaranteed bandwidths for all COS.
	 */
	uint8_t	queue_id5_bw_weight;
	/* ID of CoS Queue 6. */
	uint8_t	queue_id6;
	/*
	 * Minimum BW allocated to CoS Queue.
	 * The HWRM will translate this value into byte counter and
	 * time interval used for this COS inside the device.
	 */
	uint32_t	queue_id6_min_bw;
	/* The bandwidth value. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID6_MIN_BW_BW_VALUE_MASK		UINT32_C(0xfffffff)
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID6_MIN_BW_BW_VALUE_SFT		0
	/* The granularity of the value (bits or bytes). */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID6_MIN_BW_SCALE			UINT32_C(0x10000000)
	/* Value is in bits. */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID6_MIN_BW_SCALE_BITS		(UINT32_C(0x0) << 28)
	/* Value is in bytes. */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID6_MIN_BW_SCALE_BYTES		(UINT32_C(0x1) << 28)
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID6_MIN_BW_SCALE_LAST		HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID6_MIN_BW_SCALE_BYTES
	/* bw_value_unit is 3 b */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID6_MIN_BW_BW_VALUE_UNIT_MASK	UINT32_C(0xe0000000)
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID6_MIN_BW_BW_VALUE_UNIT_SFT	29
	/* Value is in Mb or MB (base 10). */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID6_MIN_BW_BW_VALUE_UNIT_MEGA	(UINT32_C(0x0) << 29)
	/* Value is in Kb or KB (base 10). */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID6_MIN_BW_BW_VALUE_UNIT_KILO	(UINT32_C(0x2) << 29)
	/* Value is in bits or bytes. */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID6_MIN_BW_BW_VALUE_UNIT_BASE	(UINT32_C(0x4) << 29)
	/* Value is in Gb or GB (base 10). */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID6_MIN_BW_BW_VALUE_UNIT_GIGA	(UINT32_C(0x6) << 29)
	/* Value is in 1/100th of a percentage of total bandwidth. */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID6_MIN_BW_BW_VALUE_UNIT_PERCENT1_100  (UINT32_C(0x1) << 29)
	/* Invalid unit */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID6_MIN_BW_BW_VALUE_UNIT_INVALID	(UINT32_C(0x7) << 29)
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID6_MIN_BW_BW_VALUE_UNIT_LAST	HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID6_MIN_BW_BW_VALUE_UNIT_INVALID
	/*
	 * Maximum BW allocated to CoS queue.
	 * The HWRM will translate this value into byte counter and
	 * time interval used for this COS inside the device.
	 */
	uint32_t	queue_id6_max_bw;
	/* The bandwidth value. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID6_MAX_BW_BW_VALUE_MASK		UINT32_C(0xfffffff)
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID6_MAX_BW_BW_VALUE_SFT		0
	/* The granularity of the value (bits or bytes). */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID6_MAX_BW_SCALE			UINT32_C(0x10000000)
	/* Value is in bits. */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID6_MAX_BW_SCALE_BITS		(UINT32_C(0x0) << 28)
	/* Value is in bytes. */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID6_MAX_BW_SCALE_BYTES		(UINT32_C(0x1) << 28)
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID6_MAX_BW_SCALE_LAST		HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID6_MAX_BW_SCALE_BYTES
	/* bw_value_unit is 3 b */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID6_MAX_BW_BW_VALUE_UNIT_MASK	UINT32_C(0xe0000000)
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID6_MAX_BW_BW_VALUE_UNIT_SFT	29
	/* Value is in Mb or MB (base 10). */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID6_MAX_BW_BW_VALUE_UNIT_MEGA	(UINT32_C(0x0) << 29)
	/* Value is in Kb or KB (base 10). */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID6_MAX_BW_BW_VALUE_UNIT_KILO	(UINT32_C(0x2) << 29)
	/* Value is in bits or bytes. */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID6_MAX_BW_BW_VALUE_UNIT_BASE	(UINT32_C(0x4) << 29)
	/* Value is in Gb or GB (base 10). */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID6_MAX_BW_BW_VALUE_UNIT_GIGA	(UINT32_C(0x6) << 29)
	/* Value is in 1/100th of a percentage of total bandwidth. */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID6_MAX_BW_BW_VALUE_UNIT_PERCENT1_100  (UINT32_C(0x1) << 29)
	/* Invalid unit */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID6_MAX_BW_BW_VALUE_UNIT_INVALID	(UINT32_C(0x7) << 29)
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID6_MAX_BW_BW_VALUE_UNIT_LAST	HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID6_MAX_BW_BW_VALUE_UNIT_INVALID
	/* Transmission Selection Algorithm (TSA) for CoS Queue. */
	uint8_t	queue_id6_tsa_assign;
	/* Strict Priority */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID6_TSA_ASSIGN_SP		UINT32_C(0x0)
	/* Enhanced Transmission Selection */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID6_TSA_ASSIGN_ETS		UINT32_C(0x1)
	/* reserved. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID6_TSA_ASSIGN_RESERVED_FIRST UINT32_C(0x2)
	/* reserved. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID6_TSA_ASSIGN_RESERVED_LAST  UINT32_C(0xff)
	/*
	 * Priority level for strict priority. Valid only when the
	 * tsa_assign is 0 - Strict Priority (SP)
	 * 0..7 - Valid values.
	 * 8..255 - Reserved.
	 */
	uint8_t	queue_id6_pri_lvl;
	/*
	 * Weight used to allocate remaining BW for this COS after
	 * servicing guaranteed bandwidths for all COS.
	 */
	uint8_t	queue_id6_bw_weight;
	/* ID of CoS Queue 7. */
	uint8_t	queue_id7;
	/*
	 * Minimum BW allocated to CoS Queue.
	 * The HWRM will translate this value into byte counter and
	 * time interval used for this COS inside the device.
	 */
	uint32_t	queue_id7_min_bw;
	/* The bandwidth value. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID7_MIN_BW_BW_VALUE_MASK		UINT32_C(0xfffffff)
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID7_MIN_BW_BW_VALUE_SFT		0
	/* The granularity of the value (bits or bytes). */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID7_MIN_BW_SCALE			UINT32_C(0x10000000)
	/* Value is in bits. */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID7_MIN_BW_SCALE_BITS		(UINT32_C(0x0) << 28)
	/* Value is in bytes. */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID7_MIN_BW_SCALE_BYTES		(UINT32_C(0x1) << 28)
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID7_MIN_BW_SCALE_LAST		HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID7_MIN_BW_SCALE_BYTES
	/* bw_value_unit is 3 b */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID7_MIN_BW_BW_VALUE_UNIT_MASK	UINT32_C(0xe0000000)
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID7_MIN_BW_BW_VALUE_UNIT_SFT	29
	/* Value is in Mb or MB (base 10). */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID7_MIN_BW_BW_VALUE_UNIT_MEGA	(UINT32_C(0x0) << 29)
	/* Value is in Kb or KB (base 10). */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID7_MIN_BW_BW_VALUE_UNIT_KILO	(UINT32_C(0x2) << 29)
	/* Value is in bits or bytes. */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID7_MIN_BW_BW_VALUE_UNIT_BASE	(UINT32_C(0x4) << 29)
	/* Value is in Gb or GB (base 10). */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID7_MIN_BW_BW_VALUE_UNIT_GIGA	(UINT32_C(0x6) << 29)
	/* Value is in 1/100th of a percentage of total bandwidth. */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID7_MIN_BW_BW_VALUE_UNIT_PERCENT1_100  (UINT32_C(0x1) << 29)
	/* Invalid unit */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID7_MIN_BW_BW_VALUE_UNIT_INVALID	(UINT32_C(0x7) << 29)
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID7_MIN_BW_BW_VALUE_UNIT_LAST	HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID7_MIN_BW_BW_VALUE_UNIT_INVALID
	/*
	 * Maximum BW allocated to CoS queue.
	 * The HWRM will translate this value into byte counter and
	 * time interval used for this COS inside the device.
	 */
	uint32_t	queue_id7_max_bw;
	/* The bandwidth value. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID7_MAX_BW_BW_VALUE_MASK		UINT32_C(0xfffffff)
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID7_MAX_BW_BW_VALUE_SFT		0
	/* The granularity of the value (bits or bytes). */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID7_MAX_BW_SCALE			UINT32_C(0x10000000)
	/* Value is in bits. */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID7_MAX_BW_SCALE_BITS		(UINT32_C(0x0) << 28)
	/* Value is in bytes. */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID7_MAX_BW_SCALE_BYTES		(UINT32_C(0x1) << 28)
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID7_MAX_BW_SCALE_LAST		HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID7_MAX_BW_SCALE_BYTES
	/* bw_value_unit is 3 b */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID7_MAX_BW_BW_VALUE_UNIT_MASK	UINT32_C(0xe0000000)
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID7_MAX_BW_BW_VALUE_UNIT_SFT	29
	/* Value is in Mb or MB (base 10). */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID7_MAX_BW_BW_VALUE_UNIT_MEGA	(UINT32_C(0x0) << 29)
	/* Value is in Kb or KB (base 10). */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID7_MAX_BW_BW_VALUE_UNIT_KILO	(UINT32_C(0x2) << 29)
	/* Value is in bits or bytes. */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID7_MAX_BW_BW_VALUE_UNIT_BASE	(UINT32_C(0x4) << 29)
	/* Value is in Gb or GB (base 10). */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID7_MAX_BW_BW_VALUE_UNIT_GIGA	(UINT32_C(0x6) << 29)
	/* Value is in 1/100th of a percentage of total bandwidth. */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID7_MAX_BW_BW_VALUE_UNIT_PERCENT1_100  (UINT32_C(0x1) << 29)
	/* Invalid unit */
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID7_MAX_BW_BW_VALUE_UNIT_INVALID	(UINT32_C(0x7) << 29)
		#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID7_MAX_BW_BW_VALUE_UNIT_LAST	HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID7_MAX_BW_BW_VALUE_UNIT_INVALID
	/* Transmission Selection Algorithm (TSA) for CoS Queue. */
	uint8_t	queue_id7_tsa_assign;
	/* Strict Priority */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID7_TSA_ASSIGN_SP		UINT32_C(0x0)
	/* Enhanced Transmission Selection */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID7_TSA_ASSIGN_ETS		UINT32_C(0x1)
	/* reserved. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID7_TSA_ASSIGN_RESERVED_FIRST UINT32_C(0x2)
	/* reserved. */
	#define HWRM_QUEUE_COS2BW_CFG_INPUT_QUEUE_ID7_TSA_ASSIGN_RESERVED_LAST  UINT32_C(0xff)
	/*
	 * Priority level for strict priority. Valid only when the
	 * tsa_assign is 0 - Strict Priority (SP)
	 * 0..7 - Valid values.
	 * 8..255 - Reserved.
	 */
	uint8_t	queue_id7_pri_lvl;
	/*
	 * Weight used to allocate remaining BW for this COS after
	 * servicing guaranteed bandwidths for all COS.
	 */
	uint8_t	queue_id7_bw_weight;
	uint8_t	unused_1[5];
} hwrm_queue_cos2bw_cfg_input_t, *phwrm_queue_cos2bw_cfg_input_t;

/* hwrm_queue_cos2bw_cfg_output (size:128b/16B) */

typedef struct hwrm_queue_cos2bw_cfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_queue_cos2bw_cfg_output_t, *phwrm_queue_cos2bw_cfg_output_t;

/*************************
 * hwrm_queue_dscp_qcaps *
 *************************/


/* hwrm_queue_dscp_qcaps_input (size:192b/24B) */

typedef struct hwrm_queue_dscp_qcaps_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * Port ID of port for which the table is being configured.
	 * The HWRM needs to check whether this function is allowed
	 * to configure pri2cos mapping on this port.
	 */
	uint8_t	port_id;
	uint8_t	unused_0[7];
} hwrm_queue_dscp_qcaps_input_t, *phwrm_queue_dscp_qcaps_input_t;

/* hwrm_queue_dscp_qcaps_output (size:128b/16B) */

typedef struct hwrm_queue_dscp_qcaps_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* The number of bits provided by the hardware for the DSCP value. */
	uint8_t	num_dscp_bits;
	uint8_t	unused_0;
	/* Max number of DSCP-MASK-PRI entries supported. */
	uint16_t	max_entries;
	uint8_t	unused_1[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_queue_dscp_qcaps_output_t, *phwrm_queue_dscp_qcaps_output_t;

/****************************
 * hwrm_queue_dscp2pri_qcfg *
 ****************************/


/* hwrm_queue_dscp2pri_qcfg_input (size:256b/32B) */

typedef struct hwrm_queue_dscp2pri_qcfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * This is the host address where the 24-bits DSCP-MASK-PRI
	 * tuple(s) will be copied to.
	 */
	uint64_t	dest_data_addr;
	/*
	 * Port ID of port for which the table is being configured.
	 * The HWRM needs to check whether this function is allowed
	 * to configure pri2cos mapping on this port.
	 */
	uint8_t	port_id;
	uint8_t	unused_0;
	/* Size of the buffer pointed to by dest_data_addr. */
	uint16_t	dest_data_buffer_size;
	uint8_t	unused_1[4];
} hwrm_queue_dscp2pri_qcfg_input_t, *phwrm_queue_dscp2pri_qcfg_input_t;

/* hwrm_queue_dscp2pri_qcfg_output (size:128b/16B) */

typedef struct hwrm_queue_dscp2pri_qcfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * A count of the number of DSCP-MASK-PRI tuple(s) pointed to
	 * by the dest_data_addr.
	 */
	uint16_t	entry_cnt;
	/*
	 * This is the default PRI which un-initialized DSCP values are
	 * mapped to.
	 */
	uint8_t	default_pri;
	uint8_t	unused_0[4];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_queue_dscp2pri_qcfg_output_t, *phwrm_queue_dscp2pri_qcfg_output_t;

/***************************
 * hwrm_queue_dscp2pri_cfg *
 ***************************/


/* hwrm_queue_dscp2pri_cfg_input (size:320b/40B) */

typedef struct hwrm_queue_dscp2pri_cfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * This is the host address where the 24-bits DSCP-MASK-PRI tuple
	 * will be copied from.
	 */
	uint64_t	src_data_addr;
	uint32_t	flags;
	/* use_hw_default_pri is 1 b */
	#define HWRM_QUEUE_DSCP2PRI_CFG_INPUT_FLAGS_USE_HW_DEFAULT_PRI	UINT32_C(0x1)
	uint32_t	enables;
	/*
	 * This bit must be '1' for the default_pri field to be
	 * configured.
	 */
	#define HWRM_QUEUE_DSCP2PRI_CFG_INPUT_ENABLES_DEFAULT_PRI	UINT32_C(0x1)
	/*
	 * Port ID of port for which the table is being configured.
	 * The HWRM needs to check whether this function is allowed
	 * to configure pri2cos mapping on this port.
	 */
	uint8_t	port_id;
	/*
	 * This is the default PRI which un-initialized DSCP values will be
	 * mapped to.
	 */
	uint8_t	default_pri;
	/*
	 * A count of the number of DSCP-MASK-PRI tuple(s) in the data pointed
	 * to by src_data_addr.
	 */
	uint16_t	entry_cnt;
	uint8_t	unused_0[4];
} hwrm_queue_dscp2pri_cfg_input_t, *phwrm_queue_dscp2pri_cfg_input_t;

/* hwrm_queue_dscp2pri_cfg_output (size:128b/16B) */

typedef struct hwrm_queue_dscp2pri_cfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_queue_dscp2pri_cfg_output_t, *phwrm_queue_dscp2pri_cfg_output_t;

/*************************
 * hwrm_queue_mpls_qcaps *
 *************************/


/* hwrm_queue_mpls_qcaps_input (size:192b/24B) */

typedef struct hwrm_queue_mpls_qcaps_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * Port ID of port for which the table is being configured.
	 * The HWRM needs to check whether this function is allowed
	 * to configure MPLS TC(EXP) to pri mapping on this port.
	 */
	uint8_t	port_id;
	uint8_t	unused_0[7];
} hwrm_queue_mpls_qcaps_input_t, *phwrm_queue_mpls_qcaps_input_t;

/* hwrm_queue_mpls_qcaps_output (size:128b/16B) */

typedef struct hwrm_queue_mpls_qcaps_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * Bitmask indicating which queues can be configured by the
	 * hwrm_queue_mplstc2pri_cfg command.
	 *
	 * Each bit represents a specific pri where bit 0 represents
	 * pri 0 and bit 7 represents pri 7.
	 * # A value of 0 indicates that the pri is not configurable
	 * by the hwrm_queue_mplstc2pri_cfg command.
	 * # A value of 1 indicates that the pri is configurable.
	 * # A hwrm_queue_mplstc2pri_cfg command shall return error when
	 * trying to configure a pri that is not configurable.
	 */
	uint8_t	queue_mplstc2pri_cfg_allowed;
	/*
	 * This is the default PRI which un-initialized MPLS values will be
	 * mapped to.
	 */
	uint8_t	hw_default_pri;
	uint8_t	unused_0[5];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_queue_mpls_qcaps_output_t, *phwrm_queue_mpls_qcaps_output_t;

/******************************
 * hwrm_queue_mplstc2pri_qcfg *
 ******************************/


/* hwrm_queue_mplstc2pri_qcfg_input (size:192b/24B) */

typedef struct hwrm_queue_mplstc2pri_qcfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * Port ID of port for which the table is being configured.
	 * The HWRM needs to check whether this function is allowed
	 * to configure MPLS TC(EXP) to pri mapping on this port.
	 */
	uint8_t	port_id;
	uint8_t	unused_0[7];
} hwrm_queue_mplstc2pri_qcfg_input_t, *phwrm_queue_mplstc2pri_qcfg_input_t;

/* hwrm_queue_mplstc2pri_qcfg_output (size:192b/24B) */

typedef struct hwrm_queue_mplstc2pri_qcfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * pri assigned to MPLS TC(EXP) 0. This value can only be changed
	 * before traffic has started.
	 * A value of 0xff indicates that no pri is assigned to the
	 * MPLS TC(EXP) 0.
	 */
	uint8_t	tc0_pri_queue_id;
	/*
	 * pri assigned to MPLS TC(EXP) 1. This value can only be changed
	 * before traffic has started.
	 * A value of 0xff indicates that no pri is assigned to the
	 * MPLS TC(EXP) 1.
	 */
	uint8_t	tc1_pri_queue_id;
	/*
	 * pri assigned to MPLS TC(EXP) 2. This value can only be changed
	 * before traffic has started.
	 * A value of 0xff indicates that no pri is assigned to the
	 * MPLS TC(EXP) 2.
	 */
	uint8_t	tc2_pri_queue_id;
	/*
	 * pri assigned to MPLS TC(EXP) 3. This value can only be changed
	 * before traffic has started.
	 * A value of 0xff indicates that no pri is assigned to the
	 * MPLS TC(EXP) 3.
	 */
	uint8_t	tc3_pri_queue_id;
	/*
	 * pri assigned to MPLS TC(EXP) 4. This value can only be changed
	 * before traffic has started.
	 * A value of 0xff indicates that no pri is assigned to the
	 * MPLS TC(EXP) 4.
	 */
	uint8_t	tc4_pri_queue_id;
	/*
	 * pri assigned to MPLS TC(EXP) 5. This value can only be changed
	 * before traffic has started.
	 * A value of 0xff indicates that no pri is assigned to the
	 * MPLS TC(EXP) 5.
	 */
	uint8_t	tc5_pri_queue_id;
	/*
	 * pri assigned to MPLS TC(EXP) 6. This value can only
	 * be changed before traffic has started.
	 * A value of 0xff indicates that no pri is assigned to the
	 * MPLS TC(EXP) 6.
	 */
	uint8_t	tc6_pri_queue_id;
	/*
	 * pri assigned to MPLS TC(EXP) 7. This value can only
	 * be changed before traffic has started.
	 * A value of 0xff indicates that no pri is assigned to the
	 * MPLS TC(EXP) 7.
	 */
	uint8_t	tc7_pri_queue_id;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_queue_mplstc2pri_qcfg_output_t, *phwrm_queue_mplstc2pri_qcfg_output_t;

/*****************************
 * hwrm_queue_mplstc2pri_cfg *
 *****************************/


/* hwrm_queue_mplstc2pri_cfg_input (size:256b/32B) */

typedef struct hwrm_queue_mplstc2pri_cfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	enables;
	/*
	 * This bit must be '1' for the mplstc0_pri_queue_id field to be
	 * configured.
	 */
	#define HWRM_QUEUE_MPLSTC2PRI_CFG_INPUT_ENABLES_TC0_PRI_QUEUE_ID	UINT32_C(0x1)
	/*
	 * This bit must be '1' for the mplstc1_pri_queue_id field to be
	 * configured.
	 */
	#define HWRM_QUEUE_MPLSTC2PRI_CFG_INPUT_ENABLES_TC1_PRI_QUEUE_ID	UINT32_C(0x2)
	/*
	 * This bit must be '1' for the mplstc2_pri_queue_id field to be
	 * configured.
	 */
	#define HWRM_QUEUE_MPLSTC2PRI_CFG_INPUT_ENABLES_TC2_PRI_QUEUE_ID	UINT32_C(0x4)
	/*
	 * This bit must be '1' for the mplstc3_pri_queue_id field to be
	 * configured.
	 */
	#define HWRM_QUEUE_MPLSTC2PRI_CFG_INPUT_ENABLES_TC3_PRI_QUEUE_ID	UINT32_C(0x8)
	/*
	 * This bit must be '1' for the mplstc4_pri_queue_id field to be
	 * configured.
	 */
	#define HWRM_QUEUE_MPLSTC2PRI_CFG_INPUT_ENABLES_TC4_PRI_QUEUE_ID	UINT32_C(0x10)
	/*
	 * This bit must be '1' for the mplstc5_pri_queue_id field to be
	 * configured.
	 */
	#define HWRM_QUEUE_MPLSTC2PRI_CFG_INPUT_ENABLES_TC5_PRI_QUEUE_ID	UINT32_C(0x20)
	/*
	 * This bit must be '1' for the mplstc6_pri_queue_id field to be
	 * configured.
	 */
	#define HWRM_QUEUE_MPLSTC2PRI_CFG_INPUT_ENABLES_TC6_PRI_QUEUE_ID	UINT32_C(0x40)
	/*
	 * This bit must be '1' for the mplstc7_pri_queue_id field to be
	 * configured.
	 */
	#define HWRM_QUEUE_MPLSTC2PRI_CFG_INPUT_ENABLES_TC7_PRI_QUEUE_ID	UINT32_C(0x80)
	/*
	 * Port ID of port for which the table is being configured.
	 * The HWRM needs to check whether this function is allowed
	 * to configure MPLS TC(EXP)to pri mapping on this port.
	 */
	uint8_t	port_id;
	uint8_t	unused_0[3];
	/*
	 * pri assigned to MPLS TC(EXP) 0. This value can only
	 * be changed before traffic has started.
	 */
	uint8_t	tc0_pri_queue_id;
	/*
	 * pri assigned to MPLS TC(EXP) 1. This value can only
	 * be changed before traffic has started.
	 */
	uint8_t	tc1_pri_queue_id;
	/*
	 * pri assigned to MPLS TC(EXP) 2  This value can only
	 * be changed before traffic has started.
	 */
	uint8_t	tc2_pri_queue_id;
	/*
	 * pri assigned to MPLS TC(EXP) 3. This value can only
	 * be changed before traffic has started.
	 */
	uint8_t	tc3_pri_queue_id;
	/*
	 * pri assigned to MPLS TC(EXP) 4. This value can only
	 * be changed before traffic has started.
	 */
	uint8_t	tc4_pri_queue_id;
	/*
	 * pri assigned to MPLS TC(EXP) 5. This value can only
	 * be changed before traffic has started.
	 */
	uint8_t	tc5_pri_queue_id;
	/*
	 * pri assigned to MPLS TC(EXP) 6. This value can only
	 * be changed before traffic has started.
	 */
	uint8_t	tc6_pri_queue_id;
	/*
	 * pri assigned to MPLS TC(EXP) 7. This value can only
	 * be changed before traffic has started.
	 */
	uint8_t	tc7_pri_queue_id;
} hwrm_queue_mplstc2pri_cfg_input_t, *phwrm_queue_mplstc2pri_cfg_input_t;

/* hwrm_queue_mplstc2pri_cfg_output (size:128b/16B) */

typedef struct hwrm_queue_mplstc2pri_cfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_queue_mplstc2pri_cfg_output_t, *phwrm_queue_mplstc2pri_cfg_output_t;

/****************************
 * hwrm_queue_vlanpri_qcaps *
 ****************************/


/* hwrm_queue_vlanpri_qcaps_input (size:192b/24B) */

typedef struct hwrm_queue_vlanpri_qcaps_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * Port ID of port for which the table is being configured.
	 * The HWRM needs to check whether this function is allowed
	 * to configure VLAN priority to user priority mapping on this port.
	 */
	uint8_t	port_id;
	uint8_t	unused_0[7];
} hwrm_queue_vlanpri_qcaps_input_t, *phwrm_queue_vlanpri_qcaps_input_t;

/* hwrm_queue_vlanpri_qcaps_output (size:128b/16B) */

typedef struct hwrm_queue_vlanpri_qcaps_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * This is the default user priority which all VLAN priority values
	 * are mapped to if there is no VLAN priority to user priority mapping.
	 */
	uint8_t	hw_default_pri;
	uint8_t	unused_0[6];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_queue_vlanpri_qcaps_output_t, *phwrm_queue_vlanpri_qcaps_output_t;

/*******************************
 * hwrm_queue_vlanpri2pri_qcfg *
 *******************************/


/* hwrm_queue_vlanpri2pri_qcfg_input (size:192b/24B) */

typedef struct hwrm_queue_vlanpri2pri_qcfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * Port ID of port for which the table is being configured.
	 * The HWRM needs to check whether this function is allowed
	 * to configure VLAN priority to user priority mapping on this port.
	 */
	uint8_t	port_id;
	uint8_t	unused_0[7];
} hwrm_queue_vlanpri2pri_qcfg_input_t, *phwrm_queue_vlanpri2pri_qcfg_input_t;

/* hwrm_queue_vlanpri2pri_qcfg_output (size:192b/24B) */

typedef struct hwrm_queue_vlanpri2pri_qcfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * User priority assigned to VLAN priority 0. A value of 0xff
	 * indicates that no user priority is assigned. The default user
	 * priority will be used.
	 */
	uint8_t	vlanpri0_user_pri_id;
	/*
	 * User priority assigned to VLAN priority 1. A value of 0xff
	 * indicates that no user priority is assigned. The default user
	 * priority will be used.
	 */
	uint8_t	vlanpri1_user_pri_id;
	/*
	 * User priority assigned to VLAN priority 2. A value of 0xff
	 * indicates that no user priority is assigned. The default user
	 * priority will be used.
	 */
	uint8_t	vlanpri2_user_pri_id;
	/*
	 * User priority assigned to VLAN priority 3. A value of 0xff
	 * indicates that no user priority is assigned. The default user
	 * priority will be used.
	 */
	uint8_t	vlanpri3_user_pri_id;
	/*
	 * User priority assigned to VLAN priority 4. A value of 0xff
	 * indicates that no user priority is assigned. The default user
	 * priority will be used.
	 */
	uint8_t	vlanpri4_user_pri_id;
	/*
	 * User priority assigned to VLAN priority 5. A value of 0xff
	 * indicates that no user priority is assigned. The default user
	 * priority will be used.
	 */
	uint8_t	vlanpri5_user_pri_id;
	/*
	 * User priority assigned to VLAN priority 6. A value of 0xff
	 * indicates that no user priority is assigned. The default user
	 * priority will be used.
	 */
	uint8_t	vlanpri6_user_pri_id;
	/*
	 * User priority assigned to VLAN priority 7. A value of 0xff
	 * indicates that no user priority is assigned. The default user
	 * priority will be used.
	 */
	uint8_t	vlanpri7_user_pri_id;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_queue_vlanpri2pri_qcfg_output_t, *phwrm_queue_vlanpri2pri_qcfg_output_t;

/******************************
 * hwrm_queue_vlanpri2pri_cfg *
 ******************************/


/* hwrm_queue_vlanpri2pri_cfg_input (size:256b/32B) */

typedef struct hwrm_queue_vlanpri2pri_cfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	enables;
	/*
	 * This bit must be '1' for the vlanpri0_user_pri_id field to be
	 * configured.
	 */
	#define HWRM_QUEUE_VLANPRI2PRI_CFG_INPUT_ENABLES_VLANPRI0_USER_PRI_ID	UINT32_C(0x1)
	/*
	 * This bit must be '1' for the vlanpri1_user_pri_id field to be
	 * configured.
	 */
	#define HWRM_QUEUE_VLANPRI2PRI_CFG_INPUT_ENABLES_VLANPRI1_USER_PRI_ID	UINT32_C(0x2)
	/*
	 * This bit must be '1' for the vlanpri2_user_pri_id field to be
	 * configured.
	 */
	#define HWRM_QUEUE_VLANPRI2PRI_CFG_INPUT_ENABLES_VLANPRI2_USER_PRI_ID	UINT32_C(0x4)
	/*
	 * This bit must be '1' for the vlanpri3_user_pri_id field to be
	 * configured.
	 */
	#define HWRM_QUEUE_VLANPRI2PRI_CFG_INPUT_ENABLES_VLANPRI3_USER_PRI_ID	UINT32_C(0x8)
	/*
	 * This bit must be '1' for the vlanpri4_user_pri_id field to be
	 * configured.
	 */
	#define HWRM_QUEUE_VLANPRI2PRI_CFG_INPUT_ENABLES_VLANPRI4_USER_PRI_ID	UINT32_C(0x10)
	/*
	 * This bit must be '1' for the vlanpri5_user_pri_id field to be
	 * configured.
	 */
	#define HWRM_QUEUE_VLANPRI2PRI_CFG_INPUT_ENABLES_VLANPRI5_USER_PRI_ID	UINT32_C(0x20)
	/*
	 * This bit must be '1' for the vlanpri6_user_pri_id field to be
	 * configured.
	 */
	#define HWRM_QUEUE_VLANPRI2PRI_CFG_INPUT_ENABLES_VLANPRI6_USER_PRI_ID	UINT32_C(0x40)
	/*
	 * This bit must be '1' for the vlanpri7_user_pri_id field to be
	 * configured.
	 */
	#define HWRM_QUEUE_VLANPRI2PRI_CFG_INPUT_ENABLES_VLANPRI7_USER_PRI_ID	UINT32_C(0x80)
	/*
	 * Port ID of port for which the table is being configured.
	 * The HWRM needs to check whether this function is allowed
	 * to configure VLAN priority to user priority mapping on this port.
	 */
	uint8_t	port_id;
	uint8_t	unused_0[3];
	/*
	 * User priority assigned to VLAN priority 0. This value can only
	 * be changed before traffic has started.
	 */
	uint8_t	vlanpri0_user_pri_id;
	/*
	 * User priority assigned to VLAN priority 1. This value can only
	 * be changed before traffic has started.
	 */
	uint8_t	vlanpri1_user_pri_id;
	/*
	 * User priority assigned to VLAN priority 2. This value can only
	 * be changed before traffic has started.
	 */
	uint8_t	vlanpri2_user_pri_id;
	/*
	 * User priority assigned to VLAN priority 3. This value can only
	 * be changed before traffic has started.
	 */
	uint8_t	vlanpri3_user_pri_id;
	/*
	 * User priority assigned to VLAN priority 4. This value can only
	 * be changed before traffic has started.
	 */
	uint8_t	vlanpri4_user_pri_id;
	/*
	 * User priority assigned to VLAN priority 5. This value can only
	 * be changed before traffic has started.
	 */
	uint8_t	vlanpri5_user_pri_id;
	/*
	 * User priority assigned to VLAN priority 6. This value can only
	 * be changed before traffic has started.
	 */
	uint8_t	vlanpri6_user_pri_id;
	/*
	 * User priority assigned to VLAN priority 7. This value can only
	 * be changed before traffic has started.
	 */
	uint8_t	vlanpri7_user_pri_id;
} hwrm_queue_vlanpri2pri_cfg_input_t, *phwrm_queue_vlanpri2pri_cfg_input_t;

/* hwrm_queue_vlanpri2pri_cfg_output (size:128b/16B) */

typedef struct hwrm_queue_vlanpri2pri_cfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_queue_vlanpri2pri_cfg_output_t, *phwrm_queue_vlanpri2pri_cfg_output_t;

/*************************
 * hwrm_queue_global_cfg *
 *************************/


/* hwrm_queue_global_cfg_input (size:192b/24B) */

typedef struct hwrm_queue_global_cfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * Configuration mode for rx cos queues, configuring whether they
	 * use one shared buffer pool (across ports or PCIe endpoints) or
	 * independent per port or per endpoint buffer pools.
	 */
	uint8_t	mode;
	/* One shared buffer pool to be used by all RX CoS queues */
	#define HWRM_QUEUE_GLOBAL_CFG_INPUT_MODE_SHARED	UINT32_C(0x0)
	/*
	 * Each port or PCIe endpoint to use an independent buffer pool
	 * for its RX CoS queues
	 */
	#define HWRM_QUEUE_GLOBAL_CFG_INPUT_MODE_INDEPENDENT UINT32_C(0x1)
	#define HWRM_QUEUE_GLOBAL_CFG_INPUT_MODE_LAST	HWRM_QUEUE_GLOBAL_CFG_INPUT_MODE_INDEPENDENT
	uint8_t	unused_0[7];
} hwrm_queue_global_cfg_input_t, *phwrm_queue_global_cfg_input_t;

/* hwrm_queue_global_cfg_output (size:128b/16B) */

typedef struct hwrm_queue_global_cfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_queue_global_cfg_output_t, *phwrm_queue_global_cfg_output_t;

/**************************
 * hwrm_queue_global_qcfg *
 **************************/


/* hwrm_queue_global_qcfg_input (size:128b/16B) */

typedef struct hwrm_queue_global_qcfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
} hwrm_queue_global_qcfg_input_t, *phwrm_queue_global_qcfg_input_t;

/* hwrm_queue_global_qcfg_output (size:256b/32B) */

typedef struct hwrm_queue_global_qcfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Port or PCIe endpoint id to be mapped for buffer pool 0. */
	uint8_t	buffer_pool_id0_map;
	/* Port or PCIe endpoint id to be mapped for buffer pool 1. */
	uint8_t	buffer_pool_id1_map;
	/* Port or PCIe endpoint id to be mapped for buffer pool 2. */
	uint8_t	buffer_pool_id2_map;
	/* Port or PCIe endpoint id to be mapped for buffer pool 3. */
	uint8_t	buffer_pool_id3_map;
	/* Size of buffer pool 0 (KBytes). */
	uint32_t	buffer_pool_id0_size;
	/* Size of buffer pool 1 (KBytes). */
	uint32_t	buffer_pool_id1_size;
	/* Size of buffer pool 2 (KBytes). */
	uint32_t	buffer_pool_id2_size;
	/* Size of buffer pool 3 (KBytes). */
	uint32_t	buffer_pool_id3_size;
	uint16_t	flags;
	/*
	 * Enumeration denoting whether the rx buffer pool mapping is
	 * per port or per PCIe endpoint
	 */
	#define HWRM_QUEUE_GLOBAL_QCFG_OUTPUT_FLAGS_MAPPING			UINT32_C(0x1)
	/*
	 * The buffer_pool_id[0-3]_map field represents mapping of rx
	 * buffer pools to a port.
	 */
		#define HWRM_QUEUE_GLOBAL_QCFG_OUTPUT_FLAGS_MAPPING_MAPPING_PER_PORT	UINT32_C(0x0)
	/*
	 * The buffer_pool_id[0-3]_map field represents mapping of rx
	 * buffer pools to a PCIe endpoint.
	 */
		#define HWRM_QUEUE_GLOBAL_QCFG_OUTPUT_FLAGS_MAPPING_MAPPING_PER_ENDPOINT  UINT32_C(0x1)
		#define HWRM_QUEUE_GLOBAL_QCFG_OUTPUT_FLAGS_MAPPING_LAST		HWRM_QUEUE_GLOBAL_QCFG_OUTPUT_FLAGS_MAPPING_MAPPING_PER_ENDPOINT
	/*
	 * Configuration mode for rx cos queues, configuring whether they
	 * use one shared buffer pool (across ports or PCIe endpoints) or
	 * independent per port or per endpoint buffer pools.
	 */
	uint8_t	mode;
	/* One shared buffer pool to be used by all RX CoS queues */
	#define HWRM_QUEUE_GLOBAL_QCFG_OUTPUT_MODE_SHARED	UINT32_C(0x0)
	/*
	 * Each port or PCIe endpoint to use an independent buffer pool
	 * for its RX CoS queues
	 */
	#define HWRM_QUEUE_GLOBAL_QCFG_OUTPUT_MODE_INDEPENDENT UINT32_C(0x1)
	#define HWRM_QUEUE_GLOBAL_QCFG_OUTPUT_MODE_LAST	HWRM_QUEUE_GLOBAL_QCFG_OUTPUT_MODE_INDEPENDENT
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_queue_global_qcfg_output_t, *phwrm_queue_global_qcfg_output_t;

/*******************
 * hwrm_vnic_alloc *
 *******************/


/* hwrm_vnic_alloc_input (size:192b/24B) */

typedef struct hwrm_vnic_alloc_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	flags;
	/*
	 * When this bit is '1', this VNIC is requested to
	 * be the default VNIC for this function.
	 */
	#define HWRM_VNIC_ALLOC_INPUT_FLAGS_DEFAULT		UINT32_C(0x1)
	/*
	 * When this bit is '1', proxy VEE PF is requesting
	 * allocation of a default VNIC on behalf of virtio-net
	 * function given in virtio_net_fid field.
	 */
	#define HWRM_VNIC_ALLOC_INPUT_FLAGS_VIRTIO_NET_FID_VALID	UINT32_C(0x2)
	/*
	 * Virtio-net function's FID.
	 * This virtio-net function is requesting allocation of default
	 * VNIC through proxy VEE PF.
	 */
	uint16_t	virtio_net_fid;
	uint8_t	unused_0[2];
} hwrm_vnic_alloc_input_t, *phwrm_vnic_alloc_input_t;

/* hwrm_vnic_alloc_output (size:128b/16B) */

typedef struct hwrm_vnic_alloc_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Logical vnic ID */
	uint32_t	vnic_id;
	uint8_t	unused_0[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_vnic_alloc_output_t, *phwrm_vnic_alloc_output_t;

/********************
 * hwrm_vnic_update *
 ********************/


/* hwrm_vnic_update_input (size:256b/32B) */

typedef struct hwrm_vnic_update_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Logical vnic ID */
	uint32_t	vnic_id;
	uint32_t	enables;
	/*
	 * This bit must be '1' for the vnic_state field to be
	 * configured.
	 */
	#define HWRM_VNIC_UPDATE_INPUT_ENABLES_VNIC_STATE_VALID		UINT32_C(0x1)
	/*
	 * This bit must be '1' for the mru field to be
	 * configured.
	 */
	#define HWRM_VNIC_UPDATE_INPUT_ENABLES_MRU_VALID			UINT32_C(0x2)
	/*
	 * This bit must be '1' for the metadata_format_type field to be
	 * configured.
	 */
	#define HWRM_VNIC_UPDATE_INPUT_ENABLES_METADATA_FORMAT_TYPE_VALID	UINT32_C(0x4)
	/*
	 * This will update the context variable with the same name if
	 * the corresponding enable is set.
	 */
	uint8_t	vnic_state;
	/* Normal operation state for the VNIC. */
	#define HWRM_VNIC_UPDATE_INPUT_VNIC_STATE_NORMAL UINT32_C(0x0)
	/* All packets are dropped in this state. */
	#define HWRM_VNIC_UPDATE_INPUT_VNIC_STATE_DROP   UINT32_C(0x1)
	#define HWRM_VNIC_UPDATE_INPUT_VNIC_STATE_LAST  HWRM_VNIC_UPDATE_INPUT_VNIC_STATE_DROP
	/*
	 * The metadata format type used in all the RX packet completions
	 * going through this VNIC.
	 */
	uint8_t	metadata_format_type;
	/* No metadata information. */
	#define HWRM_VNIC_UPDATE_INPUT_METADATA_FORMAT_TYPE_NONE		UINT32_C(0x0)
	/*
	 * Action record pointer (table_scope[4:0], act_rec_ptr[25:0],
	 * vtag[19:0]).
	 */
	#define HWRM_VNIC_UPDATE_INPUT_METADATA_FORMAT_TYPE_ACT_RECORD_PTR  UINT32_C(0x1)
	/* Tunnel ID (tunnel_id[31:0], vtag[19:0]) */
	#define HWRM_VNIC_UPDATE_INPUT_METADATA_FORMAT_TYPE_TUNNEL_ID	UINT32_C(0x2)
	/* Custom header data (updated_chdr_data[31:0], vtag[19:0]) */
	#define HWRM_VNIC_UPDATE_INPUT_METADATA_FORMAT_TYPE_CUSTOM_HDR_DATA UINT32_C(0x3)
	/* Header offsets (hdr_offsets[31:0], vtag[19:0]) */
	#define HWRM_VNIC_UPDATE_INPUT_METADATA_FORMAT_TYPE_HDR_OFFSETS	UINT32_C(0x4)
	#define HWRM_VNIC_UPDATE_INPUT_METADATA_FORMAT_TYPE_LAST	HWRM_VNIC_UPDATE_INPUT_METADATA_FORMAT_TYPE_HDR_OFFSETS
	/*
	 * The maximum receive unit of the vnic.
	 * Each vnic is associated with a function.
	 * The vnic mru value overwrites the mru setting of the
	 * associated function.
	 * The HWRM shall make sure that vnic mru does not exceed
	 * the mru of the port the function is associated with.
	 */
	uint16_t	mru;
	uint8_t	unused_1[4];
} hwrm_vnic_update_input_t, *phwrm_vnic_update_input_t;

/* hwrm_vnic_update_output (size:128b/16B) */

typedef struct hwrm_vnic_update_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_vnic_update_output_t, *phwrm_vnic_update_output_t;

/******************
 * hwrm_vnic_free *
 ******************/


/* hwrm_vnic_free_input (size:192b/24B) */

typedef struct hwrm_vnic_free_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Logical vnic ID */
	uint32_t	vnic_id;
	uint8_t	unused_0[4];
} hwrm_vnic_free_input_t, *phwrm_vnic_free_input_t;

/* hwrm_vnic_free_output (size:128b/16B) */

typedef struct hwrm_vnic_free_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_vnic_free_output_t, *phwrm_vnic_free_output_t;

/*****************
 * hwrm_vnic_cfg *
 *****************/


/* hwrm_vnic_cfg_input (size:384b/48B) */

typedef struct hwrm_vnic_cfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	flags;
	/*
	 * When this bit is '1', the VNIC is requested to
	 * be the default VNIC for the function.
	 */
	#define HWRM_VNIC_CFG_INPUT_FLAGS_DEFAULT				UINT32_C(0x1)
	/*
	 * When this bit is '1', the VNIC is being configured to
	 * strip VLAN in the RX path.
	 * If set to '0', then VLAN stripping is disabled on
	 * this VNIC.
	 */
	#define HWRM_VNIC_CFG_INPUT_FLAGS_VLAN_STRIP_MODE			UINT32_C(0x2)
	/*
	 * When this bit is '1', the VNIC is being configured to
	 * buffer receive packets in the hardware until the host
	 * posts new receive buffers.
	 * If set to '0', then bd_stall is being configured to be
	 * disabled on this VNIC.
	 */
	#define HWRM_VNIC_CFG_INPUT_FLAGS_BD_STALL_MODE			UINT32_C(0x4)
	/*
	 * When this bit is '1', the VNIC is being configured to
	 * receive both RoCE and non-RoCE traffic.
	 * If set to '0', then this VNIC is not configured to be
	 * operating in dual VNIC mode.
	 */
	#define HWRM_VNIC_CFG_INPUT_FLAGS_ROCE_DUAL_VNIC_MODE		UINT32_C(0x8)
	/*
	 * When this flag is set to '1', the VNIC is requested to
	 * be configured to receive only RoCE traffic.
	 * If this flag is set to '0', then this flag shall be
	 * ignored by the HWRM.
	 * If roce_dual_vnic_mode flag is set to '1'
	 * or roce_mirroring_capable_vnic_mode flag to 1,
	 * then the HWRM client shall not set this flag to '1'.
	 */
	#define HWRM_VNIC_CFG_INPUT_FLAGS_ROCE_ONLY_VNIC_MODE		UINT32_C(0x10)
	/*
	 * When a VNIC uses one destination ring group for certain
	 * application (e.g. Receive Flow Steering) where
	 * exact match is used to direct packets to a VNIC with one
	 * destination ring group only, there is no need to configure
	 * RSS indirection table for that VNIC as only one destination
	 * ring group is used.
	 *
	 * This flag is used to enable a mode where
	 * RSS is enabled in the VNIC using a RSS context
	 * for computing RSS hash but the RSS indirection table is
	 * not configured using hwrm_vnic_rss_cfg.
	 *
	 * If this mode is enabled, then the driver should not program
	 * RSS indirection table for the RSS context that is used for
	 * computing RSS hash only.
	 */
	#define HWRM_VNIC_CFG_INPUT_FLAGS_RSS_DFLT_CR_MODE			UINT32_C(0x20)
	/*
	 * When this bit is '1', the VNIC is being configured to
	 * receive both RoCE and non-RoCE traffic, but forward only the
	 * RoCE traffic further. Also, RoCE traffic can be mirrored to
	 * L2 driver.
	 */
	#define HWRM_VNIC_CFG_INPUT_FLAGS_ROCE_MIRRORING_CAPABLE_VNIC_MODE	UINT32_C(0x40)
	uint32_t	enables;
	/*
	 * This bit must be '1' for the dflt_ring_grp field to be
	 * configured.
	 */
	#define HWRM_VNIC_CFG_INPUT_ENABLES_DFLT_RING_GRP		UINT32_C(0x1)
	/*
	 * This bit must be '1' for the rss_rule field to be
	 * configured.
	 */
	#define HWRM_VNIC_CFG_INPUT_ENABLES_RSS_RULE		UINT32_C(0x2)
	/*
	 * This bit must be '1' for the cos_rule field to be
	 * configured.
	 */
	#define HWRM_VNIC_CFG_INPUT_ENABLES_COS_RULE		UINT32_C(0x4)
	/*
	 * This bit must be '1' for the lb_rule field to be
	 * configured.
	 */
	#define HWRM_VNIC_CFG_INPUT_ENABLES_LB_RULE		UINT32_C(0x8)
	/*
	 * This bit must be '1' for the mru field to be
	 * configured.
	 */
	#define HWRM_VNIC_CFG_INPUT_ENABLES_MRU			UINT32_C(0x10)
	/*
	 * This bit must be '1' for the default_rx_ring_id field to be
	 * configured.
	 */
	#define HWRM_VNIC_CFG_INPUT_ENABLES_DEFAULT_RX_RING_ID	UINT32_C(0x20)
	/*
	 * This bit must be '1' for the default_cmpl_ring_id field to be
	 * configured.
	 */
	#define HWRM_VNIC_CFG_INPUT_ENABLES_DEFAULT_CMPL_RING_ID	UINT32_C(0x40)
	/* This bit must be '1' for the queue_id field to be configured. */
	#define HWRM_VNIC_CFG_INPUT_ENABLES_QUEUE_ID		UINT32_C(0x80)
	/* This bit must be '1' for the rx_csum_v2_mode field to be configured. */
	#define HWRM_VNIC_CFG_INPUT_ENABLES_RX_CSUM_V2_MODE	UINT32_C(0x100)
	/* Logical vnic ID */
	uint16_t	vnic_id;
	/*
	 * Default Completion ring for the VNIC.  This ring will
	 * be chosen if packet does not match any RSS rules and if
	 * there is no COS rule.
	 */
	uint16_t	dflt_ring_grp;
	/*
	 * RSS ID for RSS rule/table structure.  0xFF... (All Fs) if
	 * there is no RSS rule.
	 */
	uint16_t	rss_rule;
	/*
	 * RSS ID for COS rule/table structure.  0xFF... (All Fs) if
	 * there is no COS rule.
	 */
	uint16_t	cos_rule;
	/*
	 * RSS ID for load balancing rule/table structure.
	 * 0xFF... (All Fs) if there is no LB rule.
	 */
	uint16_t	lb_rule;
	/*
	 * The maximum receive unit of the vnic.
	 * Each vnic is associated with a function.
	 * The vnic mru value overwrites the mru setting of the
	 * associated function.
	 * The HWRM shall make sure that vnic mru does not exceed
	 * the mru of the port the function is associated with.
	 */
	uint16_t	mru;
	/*
	 * Default Rx ring for the VNIC.  This ring will
	 * be chosen if packet does not match any RSS rules.
	 * The aggregation ring associated with the Rx ring is
	 * implied based on the Rx ring specified when the
	 * aggregation ring was allocated.
	 */
	uint16_t	default_rx_ring_id;
	/*
	 * Default completion ring for the VNIC.  This ring will
	 * be chosen if packet does not match any RSS rules.
	 */
	uint16_t	default_cmpl_ring_id;
	/*
	 * When specified, only incoming packets classified to the specified CoS
	 * queue ID will be arriving on this VNIC.  Packet priority to CoS mapping
	 * rules can be specified using HWRM_QUEUE_PRI2COS_CFG.  In this mode,
	 * ntuple filters with VNIC destination specified are invalid since they
	 * conflict with the the CoS to VNIC steering rules in this mode.
	 *
	 * If this field is not specified, packet to VNIC steering will be
	 * subject to the standard L2 filter rules and any additional ntuple
	 * filter rules with destination VNIC specified.
	 */
	uint16_t	queue_id;
	/*
	 * If the device supports the RX V2 and RX TPA start V2 completion
	 * records as indicated by the HWRM_VNIC_QCAPS command, this field is
	 * used to specify the two RX checksum modes supported by these
	 * completion records.
	 */
	uint8_t	rx_csum_v2_mode;
	/*
	 * When configured with this checksum mode, the number of header
	 * groups in the delivered packet with a valid IP checksum and
	 * the number of header groups in the delivered packet with a valid
	 * L4 checksum are reported. Valid checksums are counted from the
	 * outermost header group to the innermost header group, stopping at
	 * the first error.  This is the default checksum mode supported if
	 * the driver doesn't explicitly configure the RX checksum mode.
	 */
	#define HWRM_VNIC_CFG_INPUT_RX_CSUM_V2_MODE_DEFAULT UINT32_C(0x0)
	/*
	 * When configured with this checksum mode, the checksum status is
	 * reported using 'all ok' mode. In the RX completion record, one
	 * bit indicates if the IP checksum is valid for all the parsed
	 * header groups with an IP checksum. Another bit indicates if the
	 * L4 checksum is valid for all the parsed header groups with an L4
	 * checksum. The number of header groups that were parsed by the
	 * chip and passed in the delivered packet is also reported.
	 */
	#define HWRM_VNIC_CFG_INPUT_RX_CSUM_V2_MODE_ALL_OK  UINT32_C(0x1)
	/*
	 * Any rx_csum_v2_mode value larger than or equal to this is not
	 * valid
	 */
	#define HWRM_VNIC_CFG_INPUT_RX_CSUM_V2_MODE_MAX	UINT32_C(0x2)
	#define HWRM_VNIC_CFG_INPUT_RX_CSUM_V2_MODE_LAST   HWRM_VNIC_CFG_INPUT_RX_CSUM_V2_MODE_MAX
	uint8_t	unused0[5];
} hwrm_vnic_cfg_input_t, *phwrm_vnic_cfg_input_t;

/* hwrm_vnic_cfg_output (size:128b/16B) */

typedef struct hwrm_vnic_cfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_vnic_cfg_output_t, *phwrm_vnic_cfg_output_t;

/******************
 * hwrm_vnic_qcfg *
 ******************/


/* hwrm_vnic_qcfg_input (size:256b/32B) */

typedef struct hwrm_vnic_qcfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	enables;
	/*
	 * This bit must be '1' for the vf_id_valid field to be
	 * configured.
	 */
	#define HWRM_VNIC_QCFG_INPUT_ENABLES_VF_ID_VALID	UINT32_C(0x1)
	/* Logical vnic ID */
	uint32_t	vnic_id;
	/* ID of Virtual Function whose VNIC resource is being queried. */
	uint16_t	vf_id;
	uint8_t	unused_0[6];
} hwrm_vnic_qcfg_input_t, *phwrm_vnic_qcfg_input_t;

/* hwrm_vnic_qcfg_output (size:256b/32B) */

typedef struct hwrm_vnic_qcfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Default Completion ring for the VNIC. */
	uint16_t	dflt_ring_grp;
	/*
	 * RSS ID for RSS rule/table structure.  0xFF... (All Fs) if
	 * there is no RSS rule.
	 */
	uint16_t	rss_rule;
	/*
	 * RSS ID for COS rule/table structure.  0xFF... (All Fs) if
	 * there is no COS rule.
	 */
	uint16_t	cos_rule;
	/*
	 * RSS ID for load balancing rule/table structure.
	 * 0xFF... (All Fs) if there is no LB rule.
	 */
	uint16_t	lb_rule;
	/* The maximum receive unit of the vnic. */
	uint16_t	mru;
	uint8_t	unused_0[2];
	uint32_t	flags;
	/*
	 * When this bit is '1', the VNIC is the default VNIC for
	 * the function.
	 */
	#define HWRM_VNIC_QCFG_OUTPUT_FLAGS_DEFAULT				UINT32_C(0x1)
	/*
	 * When this bit is '1', the VNIC is configured to
	 * strip VLAN in the RX path.
	 * If set to '0', then VLAN stripping is disabled on
	 * this VNIC.
	 */
	#define HWRM_VNIC_QCFG_OUTPUT_FLAGS_VLAN_STRIP_MODE			UINT32_C(0x2)
	/*
	 * When this bit is '1', the VNIC is configured to
	 * buffer receive packets in the hardware until the host
	 * posts new receive buffers.
	 * If set to '0', then bd_stall is disabled on
	 * this VNIC.
	 */
	#define HWRM_VNIC_QCFG_OUTPUT_FLAGS_BD_STALL_MODE			UINT32_C(0x4)
	/*
	 * When this bit is '1', the VNIC is configured to
	 * receive both RoCE and non-RoCE traffic.
	 * If set to '0', then this VNIC is not configured to
	 * operate in dual VNIC mode.
	 */
	#define HWRM_VNIC_QCFG_OUTPUT_FLAGS_ROCE_DUAL_VNIC_MODE		UINT32_C(0x8)
	/*
	 * When this flag is set to '1', the VNIC is configured to
	 * receive only RoCE traffic.
	 * When this flag is set to '0', the VNIC is not configured
	 * to receive only RoCE traffic.
	 * If roce_dual_vnic_mode flag and this flag both are set
	 * to '1', then it is an invalid configuration of the
	 * VNIC. The HWRM should not allow that type of
	 * mis-configuration by HWRM clients.
	 */
	#define HWRM_VNIC_QCFG_OUTPUT_FLAGS_ROCE_ONLY_VNIC_MODE		UINT32_C(0x10)
	/*
	 * When a VNIC uses one destination ring group for certain
	 * application (e.g. Receive Flow Steering) where
	 * exact match is used to direct packets to a VNIC with one
	 * destination ring group only, there is no need to configure
	 * RSS indirection table for that VNIC as only one destination
	 * ring group is used.
	 *
	 * When this bit is set to '1', then the VNIC is enabled in a
	 * mode where RSS is enabled in the VNIC using a RSS context
	 * for computing RSS hash but the RSS indirection table is
	 * not configured.
	 */
	#define HWRM_VNIC_QCFG_OUTPUT_FLAGS_RSS_DFLT_CR_MODE			UINT32_C(0x20)
	/*
	 * When this bit is '1', the VNIC is configured to
	 * receive both RoCE and non-RoCE traffic, but forward only
	 * RoCE traffic further. Also RoCE traffic can be mirrored to
	 * L2 driver.
	 */
	#define HWRM_VNIC_QCFG_OUTPUT_FLAGS_ROCE_MIRRORING_CAPABLE_VNIC_MODE	UINT32_C(0x40)
	/*
	 * When this bit is '0', VNIC is in normal operation state.
	 * When this bit is '1', VNIC drops all the received packets.
	 */
	#define HWRM_VNIC_QCFG_OUTPUT_FLAGS_OPERATION_STATE			UINT32_C(0x80)
	/*
	 * When returned with a valid CoS Queue id, the CoS Queue/VNIC association
	 * is valid.  Otherwise it will return 0xFFFF to indicate no VNIC/CoS
	 * queue association.
	 */
	uint16_t	queue_id;
	/*
	 * If the device supports the RX V2 and RX TPA start V2 completion
	 * records as indicated by the HWRM_VNIC_QCAPS command, this field is
	 * used to specify the current RX checksum mode configured for all the
	 * RX rings of a VNIC.
	 */
	uint8_t	rx_csum_v2_mode;
	/*
	 * This value indicates that the VNIC is configured to use the
	 * default RX checksum mode for all the rings associated with this
	 * VNIC.
	 */
	#define HWRM_VNIC_QCFG_OUTPUT_RX_CSUM_V2_MODE_DEFAULT UINT32_C(0x0)
	/*
	 * This value indicates that the VNIC is configured to use the RX
	 * checksum ‘all_ok’ mode for all the rings associated with this
	 * VNIC.
	 */
	#define HWRM_VNIC_QCFG_OUTPUT_RX_CSUM_V2_MODE_ALL_OK  UINT32_C(0x1)
	/*
	 * Any rx_csum_v2_mode value larger than or equal to this is not
	 * valid
	 */
	#define HWRM_VNIC_QCFG_OUTPUT_RX_CSUM_V2_MODE_MAX	UINT32_C(0x2)
	#define HWRM_VNIC_QCFG_OUTPUT_RX_CSUM_V2_MODE_LAST   HWRM_VNIC_QCFG_OUTPUT_RX_CSUM_V2_MODE_MAX
	uint8_t	unused_1[4];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_vnic_qcfg_output_t, *phwrm_vnic_qcfg_output_t;

/*******************
 * hwrm_vnic_qcaps *
 *******************/


/* hwrm_vnic_qcaps_input (size:192b/24B) */

typedef struct hwrm_vnic_qcaps_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	enables;
	uint8_t	unused_0[4];
} hwrm_vnic_qcaps_input_t, *phwrm_vnic_qcaps_input_t;

/* hwrm_vnic_qcaps_output (size:192b/24B) */

typedef struct hwrm_vnic_qcaps_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* The maximum receive unit that is settable on a vnic. */
	uint16_t	mru;
	uint8_t	unused_0[2];
	uint32_t	flags;
	/* Unused. */
	#define HWRM_VNIC_QCAPS_OUTPUT_FLAGS_UNUSED				UINT32_C(0x1)
	/*
	 * When this bit is '1', the capability of stripping VLAN in
	 * the RX path is supported on VNIC(s).
	 * If set to '0', then VLAN stripping capability is
	 * not supported on VNIC(s).
	 */
	#define HWRM_VNIC_QCAPS_OUTPUT_FLAGS_VLAN_STRIP_CAP			UINT32_C(0x2)
	/*
	 * When this bit is '1', the capability to buffer receive
	 * packets in the hardware until the host posts new receive buffers
	 * is supported on VNIC(s).
	 * If set to '0', then bd_stall capability is not supported
	 * on VNIC(s).
	 */
	#define HWRM_VNIC_QCAPS_OUTPUT_FLAGS_BD_STALL_CAP			UINT32_C(0x4)
	/*
	 * When this bit is '1', the capability to
	 * receive both RoCE and non-RoCE traffic on VNIC(s) is
	 * supported.
	 * If set to '0', then the capability to receive
	 * both RoCE and non-RoCE traffic on VNIC(s) is
	 * not supported.
	 */
	#define HWRM_VNIC_QCAPS_OUTPUT_FLAGS_ROCE_DUAL_VNIC_CAP		UINT32_C(0x8)
	/*
	 * When this bit is set to '1', the capability to configure
	 * a VNIC to receive only RoCE traffic is supported.
	 * When this flag is set to '0', the VNIC capability to
	 * configure to receive only RoCE traffic is not supported.
	 */
	#define HWRM_VNIC_QCAPS_OUTPUT_FLAGS_ROCE_ONLY_VNIC_CAP		UINT32_C(0x10)
	/*
	 * When this bit is set to '1', then the capability to enable
	 * a VNIC in a mode where RSS context without configuring
	 * RSS indirection table is supported (for RSS hash computation).
	 * When this bit is set to '0', then a VNIC can not be configured
	 * with a mode to enable RSS context without configuring RSS
	 * indirection table.
	 */
	#define HWRM_VNIC_QCAPS_OUTPUT_FLAGS_RSS_DFLT_CR_CAP			UINT32_C(0x20)
	/*
	 * When this bit is '1', the capability to
	 * mirror the the RoCE traffic is supported.
	 * If set to '0', then the capability to mirror the
	 * RoCE traffic is not supported.
	 */
	#define HWRM_VNIC_QCAPS_OUTPUT_FLAGS_ROCE_MIRRORING_CAPABLE_VNIC_CAP	UINT32_C(0x40)
	/*
	 * When this bit is '1', the outermost RSS hashing capability
	 * is supported. If set to '0', then the outermost RSS hashing
	 * capability is not supported.
	 */
	#define HWRM_VNIC_QCAPS_OUTPUT_FLAGS_OUTERMOST_RSS_CAP		UINT32_C(0x80)
	/*
	 * When this bit is '1', it indicates that firmware supports the
	 * ability to steer incoming packets from one CoS queue to one
	 * VNIC.  This optional feature can then be enabled
	 * using HWRM_VNIC_CFG on any VNIC.  This feature is only
	 * available when NVM option “enable_cos_classfication” is set
	 * to 1.  If set to '0', firmware does not support this feature.
	 */
	#define HWRM_VNIC_QCAPS_OUTPUT_FLAGS_COS_ASSIGNMENT_CAP		UINT32_C(0x100)
	/*
	 * When this bit is '1', it indicates that HW and firmware supports
	 * the use of RX V2 and RX TPA start V2 completion records for all
	 * the RX rings of a VNIC. Once set, this feature is mandatory to
	 * be used for the RX rings of the VNIC. Additionally, two new RX
	 * checksum features supported by these ompletion records can be
	 * configured using the HWRM_VNIC_CFG on a VNIC. If set to '0', the
	 * HW and the firmware does not support this feature.
	 */
	#define HWRM_VNIC_QCAPS_OUTPUT_FLAGS_RX_CMPL_V2_CAP			UINT32_C(0x200)
	/*
	 * When this bit is '1', it indicates that HW and firmware support
	 * vnic state change. Host drivers can change the vnic state using
	 * HWRM_VNIC_UPDATE. If set to '0', the HW and firmware do not
	 * support this feature.
	 */
	#define HWRM_VNIC_QCAPS_OUTPUT_FLAGS_VNIC_STATE_CAP			UINT32_C(0x400)
	/*
	 * When this bit is '1', it indicates that firmware supports
	 * virtio-net functions default VNIC allocation using
	 * HWRM_VNIC_ALLOC.
	 * This capability is available only on Proxy VEE PF. If set to '0',
	 * firmware does not support this feature.
	 */
	#define HWRM_VNIC_QCAPS_OUTPUT_FLAGS_VIRTIO_NET_VNIC_ALLOC_CAP	UINT32_C(0x800)
	/*
	 * When this bit is set '1', then the capability to configure the
	 * metadata format in the RX completion is supported for the VNIC.
	 * When this bit is set to '0', then the capability to configure
	 * the metadata format in the RX completion is not supported for
	 * the VNIC.
	 */
	#define HWRM_VNIC_QCAPS_OUTPUT_FLAGS_METADATA_FORMAT_CAP		UINT32_C(0x1000)
	/*
	 * This field advertises the maximum concurrent TPA aggregations
	 * supported by the VNIC on new devices that support TPA v2.
	 * '0' means that TPA v2 is not supported.
	 */
	uint16_t	max_aggs_supported;
	uint8_t	unused_1[5];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_vnic_qcaps_output_t, *phwrm_vnic_qcaps_output_t;

/*********************
 * hwrm_vnic_tpa_cfg *
 *********************/


/* hwrm_vnic_tpa_cfg_input (size:320b/40B) */

typedef struct hwrm_vnic_tpa_cfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	flags;
	/*
	 * When this bit is '1', the VNIC shall be configured to
	 * perform transparent packet aggregation (TPA) of
	 * non-tunneled TCP packets.
	 */
	#define HWRM_VNIC_TPA_CFG_INPUT_FLAGS_TPA			UINT32_C(0x1)
	/*
	 * When this bit is '1', the VNIC shall be configured to
	 * perform transparent packet aggregation (TPA) of
	 * tunneled TCP packets.
	 */
	#define HWRM_VNIC_TPA_CFG_INPUT_FLAGS_ENCAP_TPA		UINT32_C(0x2)
	/*
	 * When this bit is '1', the VNIC shall be configured to
	 * perform transparent packet aggregation (TPA) according
	 * to Windows Receive Segment Coalescing (RSC) rules.
	 */
	#define HWRM_VNIC_TPA_CFG_INPUT_FLAGS_RSC_WND_UPDATE		UINT32_C(0x4)
	/*
	 * When this bit is '1', the VNIC shall be configured to
	 * perform transparent packet aggregation (TPA) according
	 * to Linux Generic Receive Offload (GRO) rules.
	 */
	#define HWRM_VNIC_TPA_CFG_INPUT_FLAGS_GRO			UINT32_C(0x8)
	/*
	 * When this bit is '1', the VNIC shall be configured to
	 * perform transparent packet aggregation (TPA) for TCP
	 * packets with IP ECN set to non-zero.
	 */
	#define HWRM_VNIC_TPA_CFG_INPUT_FLAGS_AGG_WITH_ECN		UINT32_C(0x10)
	/*
	 * When this bit is '1', the VNIC shall be configured to
	 * perform transparent packet aggregation (TPA) for
	 * GRE tunneled TCP packets only if all packets have the
	 * same GRE sequence.
	 */
	#define HWRM_VNIC_TPA_CFG_INPUT_FLAGS_AGG_WITH_SAME_GRE_SEQ	UINT32_C(0x20)
	/*
	 * When this bit is '1' and the GRO mode is enabled,
	 * the VNIC shall be configured to
	 * perform transparent packet aggregation (TPA) for
	 * TCP/IPv4 packets with consecutively increasing IPIDs.
	 * In other words, the last packet that is being
	 * aggregated to an already existing aggregation context
	 * shall have IPID 1 more than the IPID of the last packet
	 * that was aggregated in that aggregation context.
	 */
	#define HWRM_VNIC_TPA_CFG_INPUT_FLAGS_GRO_IPID_CHECK		UINT32_C(0x40)
	/*
	 * When this bit is '1' and the GRO mode is enabled,
	 * the VNIC shall be configured to
	 * perform transparent packet aggregation (TPA) for
	 * TCP packets with the same TTL (IPv4) or Hop limit (IPv6)
	 * value.
	 */
	#define HWRM_VNIC_TPA_CFG_INPUT_FLAGS_GRO_TTL_CHECK		UINT32_C(0x80)
	/*
	 * When this bit is '1' and the GRO mode is enabled,
	 * the VNIC shall DMA payload data using GRO rules.
	 * When this bit is '0', the VNIC shall DMA payload data
	 * using the more efficient LRO rules of filling all
	 * aggregation buffers.
	 */
	#define HWRM_VNIC_TPA_CFG_INPUT_FLAGS_AGG_PACK_AS_GRO	UINT32_C(0x100)
	uint32_t	enables;
	/*
	 * This bit must be '1' for the max_agg_segs field to be
	 * configured.
	 */
	#define HWRM_VNIC_TPA_CFG_INPUT_ENABLES_MAX_AGG_SEGS	UINT32_C(0x1)
	/*
	 * This bit must be '1' for the max_aggs field to be
	 * configured.
	 */
	#define HWRM_VNIC_TPA_CFG_INPUT_ENABLES_MAX_AGGS	UINT32_C(0x2)
	/*
	 * This bit must be '1' for the max_agg_timer field to be
	 * configured.
	 */
	#define HWRM_VNIC_TPA_CFG_INPUT_ENABLES_MAX_AGG_TIMER	UINT32_C(0x4)
	/* deprecated bit.  Do not use!!! */
	#define HWRM_VNIC_TPA_CFG_INPUT_ENABLES_MIN_AGG_LEN	UINT32_C(0x8)
	/* Logical vnic ID */
	uint16_t	vnic_id;
	/*
	 * This is the maximum number of TCP segments that can
	 * be aggregated (unit is Log2). Max value is 31. On new
	 * devices supporting TPA v2, the unit is multiples of 4 and
	 * valid values are > 0 and <= 63.
	 */
	uint16_t	max_agg_segs;
	/* 1 segment */
	#define HWRM_VNIC_TPA_CFG_INPUT_MAX_AGG_SEGS_1   UINT32_C(0x0)
	/* 2 segments */
	#define HWRM_VNIC_TPA_CFG_INPUT_MAX_AGG_SEGS_2   UINT32_C(0x1)
	/* 4 segments */
	#define HWRM_VNIC_TPA_CFG_INPUT_MAX_AGG_SEGS_4   UINT32_C(0x2)
	/* 8 segments */
	#define HWRM_VNIC_TPA_CFG_INPUT_MAX_AGG_SEGS_8   UINT32_C(0x3)
	/* Any segment size larger than this is not valid */
	#define HWRM_VNIC_TPA_CFG_INPUT_MAX_AGG_SEGS_MAX UINT32_C(0x1f)
	#define HWRM_VNIC_TPA_CFG_INPUT_MAX_AGG_SEGS_LAST HWRM_VNIC_TPA_CFG_INPUT_MAX_AGG_SEGS_MAX
	/*
	 * This is the maximum number of aggregations this VNIC is
	 * allowed (unit is Log2). Max value is 7. On new devices
	 * supporting TPA v2, this is in unit of 1 and must be > 0
	 * and <= max_aggs_supported in the hwrm_vnic_qcaps response
	 * to enable TPA v2.
	 */
	uint16_t	max_aggs;
	/* 1 aggregation */
	#define HWRM_VNIC_TPA_CFG_INPUT_MAX_AGGS_1   UINT32_C(0x0)
	/* 2 aggregations */
	#define HWRM_VNIC_TPA_CFG_INPUT_MAX_AGGS_2   UINT32_C(0x1)
	/* 4 aggregations */
	#define HWRM_VNIC_TPA_CFG_INPUT_MAX_AGGS_4   UINT32_C(0x2)
	/* 8 aggregations */
	#define HWRM_VNIC_TPA_CFG_INPUT_MAX_AGGS_8   UINT32_C(0x3)
	/* 16 aggregations */
	#define HWRM_VNIC_TPA_CFG_INPUT_MAX_AGGS_16  UINT32_C(0x4)
	/* Any aggregation size larger than this is not valid */
	#define HWRM_VNIC_TPA_CFG_INPUT_MAX_AGGS_MAX UINT32_C(0x7)
	#define HWRM_VNIC_TPA_CFG_INPUT_MAX_AGGS_LAST HWRM_VNIC_TPA_CFG_INPUT_MAX_AGGS_MAX
	uint8_t	unused_0[2];
	/*
	 * This is the maximum amount of time allowed for
	 * an aggregation context to complete after it was initiated.
	 */
	uint32_t	max_agg_timer;
	/*
	 * This is the minimum amount of payload length required to
	 * start an aggregation context. This field is deprecated and
	 * should be set to 0.  The minimum length is set by firmware
	 * and can be queried using hwrm_vnic_tpa_qcfg.
	 */
	uint32_t	min_agg_len;
} hwrm_vnic_tpa_cfg_input_t, *phwrm_vnic_tpa_cfg_input_t;

/* hwrm_vnic_tpa_cfg_output (size:128b/16B) */

typedef struct hwrm_vnic_tpa_cfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_vnic_tpa_cfg_output_t, *phwrm_vnic_tpa_cfg_output_t;

/*********************
 * hwrm_vnic_rss_cfg *
 *********************/


/* hwrm_vnic_rss_cfg_input (size:384b/48B) */

typedef struct hwrm_vnic_rss_cfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	hash_type;
	/*
	 * When this bit is '1', the RSS hash shall be computed
	 * over source and destination IPv4 addresses of IPv4
	 * packets.
	 */
	#define HWRM_VNIC_RSS_CFG_INPUT_HASH_TYPE_IPV4	UINT32_C(0x1)
	/*
	 * When this bit is '1', the RSS hash shall be computed
	 * over source/destination IPv4 addresses and
	 * source/destination ports of TCP/IPv4 packets.
	 */
	#define HWRM_VNIC_RSS_CFG_INPUT_HASH_TYPE_TCP_IPV4	UINT32_C(0x2)
	/*
	 * When this bit is '1', the RSS hash shall be computed
	 * over source/destination IPv4 addresses and
	 * source/destination ports of UDP/IPv4 packets.
	 */
	#define HWRM_VNIC_RSS_CFG_INPUT_HASH_TYPE_UDP_IPV4	UINT32_C(0x4)
	/*
	 * When this bit is '1', the RSS hash shall be computed
	 * over source and destination IPv4 addresses of IPv6
	 * packets.
	 */
	#define HWRM_VNIC_RSS_CFG_INPUT_HASH_TYPE_IPV6	UINT32_C(0x8)
	/*
	 * When this bit is '1', the RSS hash shall be computed
	 * over source/destination IPv6 addresses and
	 * source/destination ports of TCP/IPv6 packets.
	 */
	#define HWRM_VNIC_RSS_CFG_INPUT_HASH_TYPE_TCP_IPV6	UINT32_C(0x10)
	/*
	 * When this bit is '1', the RSS hash shall be computed
	 * over source/destination IPv6 addresses and
	 * source/destination ports of UDP/IPv6 packets.
	 */
	#define HWRM_VNIC_RSS_CFG_INPUT_HASH_TYPE_UDP_IPV6	UINT32_C(0x20)
	/* VNIC ID of VNIC associated with RSS table being configured. */
	uint16_t	vnic_id;
	/*
	 * Specifies which VNIC ring table pair to configure.
	 * Valid values range from 0 to 7.
	 */
	uint8_t	ring_table_pair_index;
	/* Flags to specify different RSS hash modes. */
	uint8_t	hash_mode_flags;
	/*
	 * When this bit is '1', it indicates using current RSS
	 * hash mode setting configured in the device.
	 */
	#define HWRM_VNIC_RSS_CFG_INPUT_HASH_MODE_FLAGS_DEFAULT	UINT32_C(0x1)
	/*
	 * When this bit is '1', it indicates requesting support of
	 * RSS hashing over innermost 4 tuples {l3.src, l3.dest,
	 * l4.src, l4.dest} for tunnel packets. For none-tunnel
	 * packets, the RSS hash is computed over the normal
	 * src/dest l3 and src/dest l4 headers.
	 */
	#define HWRM_VNIC_RSS_CFG_INPUT_HASH_MODE_FLAGS_INNERMOST_4	UINT32_C(0x2)
	/*
	 * When this bit is '1', it indicates requesting support of
	 * RSS hashing over innermost 2 tuples {l3.src, l3.dest} for
	 * tunnel packets. For none-tunnel packets, the RSS hash is
	 * computed over the normal src/dest l3 headers.
	 */
	#define HWRM_VNIC_RSS_CFG_INPUT_HASH_MODE_FLAGS_INNERMOST_2	UINT32_C(0x4)
	/*
	 * When this bit is '1', it indicates requesting support of
	 * RSS hashing over outermost 4 tuples {t_l3.src, t_l3.dest,
	 * t_l4.src, t_l4.dest} for tunnel packets. For none-tunnel
	 * packets, the RSS hash is computed over the normal
	 * src/dest l3 and src/dest l4 headers.
	 */
	#define HWRM_VNIC_RSS_CFG_INPUT_HASH_MODE_FLAGS_OUTERMOST_4	UINT32_C(0x8)
	/*
	 * When this bit is '1', it indicates requesting support of
	 * RSS hashing over outermost 2 tuples {t_l3.src, t_l3.dest} for
	 * tunnel packets. For none-tunnel packets, the RSS hash is
	 * computed over the normal src/dest l3 headers.
	 */
	#define HWRM_VNIC_RSS_CFG_INPUT_HASH_MODE_FLAGS_OUTERMOST_2	UINT32_C(0x10)
	/* This is the address for rss ring group table */
	uint64_t	ring_grp_tbl_addr;
	/* This is the address for rss hash key table */
	uint64_t	hash_key_tbl_addr;
	/* Index to the rss indirection table. */
	uint16_t	rss_ctx_idx;
	uint8_t	unused_1[6];
} hwrm_vnic_rss_cfg_input_t, *phwrm_vnic_rss_cfg_input_t;

/* hwrm_vnic_rss_cfg_output (size:128b/16B) */

typedef struct hwrm_vnic_rss_cfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_vnic_rss_cfg_output_t, *phwrm_vnic_rss_cfg_output_t;

/* hwrm_vnic_rss_cfg_cmd_err (size:64b/8B) */

typedef struct hwrm_vnic_rss_cfg_cmd_err {
	/*
	 * command specific error codes that goes to
	 * the cmd_err field in Common HWRM Error Response.
	 */
	uint8_t	code;
	/* Unknown error */
	#define HWRM_VNIC_RSS_CFG_CMD_ERR_CODE_UNKNOWN		UINT32_C(0x0)
	/*
	 * Unable to change global RSS mode to outer due to all active
	 * interfaces are not ready to support outer RSS hashing.
	 */
	#define HWRM_VNIC_RSS_CFG_CMD_ERR_CODE_INTERFACE_NOT_READY UINT32_C(0x1)
	#define HWRM_VNIC_RSS_CFG_CMD_ERR_CODE_LAST		HWRM_VNIC_RSS_CFG_CMD_ERR_CODE_INTERFACE_NOT_READY
	uint8_t	unused_0[7];
} hwrm_vnic_rss_cfg_cmd_err_t, *phwrm_vnic_rss_cfg_cmd_err_t;

/**********************
 * hwrm_vnic_rss_qcfg *
 **********************/


/* hwrm_vnic_rss_qcfg_input (size:192b/24B) */

typedef struct hwrm_vnic_rss_qcfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Index to the rss indirection table. */
	uint16_t	rss_ctx_idx;
	uint8_t	unused_0[6];
} hwrm_vnic_rss_qcfg_input_t, *phwrm_vnic_rss_qcfg_input_t;

/* hwrm_vnic_rss_qcfg_output (size:512b/64B) */

typedef struct hwrm_vnic_rss_qcfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint32_t	hash_type;
	/*
	 * When this bit is '1', the RSS hash shall be computed
	 * over source and destination IPv4 addresses of IPv4
	 * packets.
	 */
	#define HWRM_VNIC_RSS_QCFG_OUTPUT_HASH_TYPE_IPV4	UINT32_C(0x1)
	/*
	 * When this bit is '1', the RSS hash shall be computed
	 * over source/destination IPv4 addresses and
	 * source/destination ports of TCP/IPv4 packets.
	 */
	#define HWRM_VNIC_RSS_QCFG_OUTPUT_HASH_TYPE_TCP_IPV4	UINT32_C(0x2)
	/*
	 * When this bit is '1', the RSS hash shall be computed
	 * over source/destination IPv4 addresses and
	 * source/destination ports of UDP/IPv4 packets.
	 */
	#define HWRM_VNIC_RSS_QCFG_OUTPUT_HASH_TYPE_UDP_IPV4	UINT32_C(0x4)
	/*
	 * When this bit is '1', the RSS hash shall be computed
	 * over source and destination IPv4 addresses of IPv6
	 * packets.
	 */
	#define HWRM_VNIC_RSS_QCFG_OUTPUT_HASH_TYPE_IPV6	UINT32_C(0x8)
	/*
	 * When this bit is '1', the RSS hash shall be computed
	 * over source/destination IPv6 addresses and
	 * source/destination ports of TCP/IPv6 packets.
	 */
	#define HWRM_VNIC_RSS_QCFG_OUTPUT_HASH_TYPE_TCP_IPV6	UINT32_C(0x10)
	/*
	 * When this bit is '1', the RSS hash shall be computed
	 * over source/destination IPv6 addresses and
	 * source/destination ports of UDP/IPv6 packets.
	 */
	#define HWRM_VNIC_RSS_QCFG_OUTPUT_HASH_TYPE_UDP_IPV6	UINT32_C(0x20)
	uint8_t	unused_0[4];
	/* This is the value of rss hash key */
	uint32_t	hash_key[10];
	/* Flags to specify different RSS hash modes. */
	uint8_t	hash_mode_flags;
	/*
	 * When this bit is '1', it indicates using current RSS
	 * hash mode setting configured in the device.
	 */
	#define HWRM_VNIC_RSS_QCFG_OUTPUT_HASH_MODE_FLAGS_DEFAULT	UINT32_C(0x1)
	/*
	 * When this bit is '1', it indicates requesting support of
	 * RSS hashing over innermost 4 tuples {l3.src, l3.dest,
	 * l4.src, l4.dest} for tunnel packets. For none-tunnel
	 * packets, the RSS hash is computed over the normal
	 * src/dest l3 and src/dest l4 headers.
	 */
	#define HWRM_VNIC_RSS_QCFG_OUTPUT_HASH_MODE_FLAGS_INNERMOST_4	UINT32_C(0x2)
	/*
	 * When this bit is '1', it indicates requesting support of
	 * RSS hashing over innermost 2 tuples {l3.src, l3.dest} for
	 * tunnel packets. For none-tunnel packets, the RSS hash is
	 * computed over the normal src/dest l3 headers.
	 */
	#define HWRM_VNIC_RSS_QCFG_OUTPUT_HASH_MODE_FLAGS_INNERMOST_2	UINT32_C(0x4)
	/*
	 * When this bit is '1', it indicates requesting support of
	 * RSS hashing over outermost 4 tuples {t_l3.src, t_l3.dest,
	 * t_l4.src, t_l4.dest} for tunnel packets. For none-tunnel
	 * packets, the RSS hash is computed over the normal
	 * src/dest l3 and src/dest l4 headers.
	 */
	#define HWRM_VNIC_RSS_QCFG_OUTPUT_HASH_MODE_FLAGS_OUTERMOST_4	UINT32_C(0x8)
	/*
	 * When this bit is '1', it indicates requesting support of
	 * RSS hashing over outermost 2 tuples {t_l3.src, t_l3.dest} for
	 * tunnel packets. For none-tunnel packets, the RSS hash is
	 * computed over the normal src/dest l3 headers.
	 */
	#define HWRM_VNIC_RSS_QCFG_OUTPUT_HASH_MODE_FLAGS_OUTERMOST_2	UINT32_C(0x10)
	uint8_t	unused_1[6];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_vnic_rss_qcfg_output_t, *phwrm_vnic_rss_qcfg_output_t;

/**************************
 * hwrm_vnic_plcmodes_cfg *
 **************************/


/* hwrm_vnic_plcmodes_cfg_input (size:320b/40B) */

typedef struct hwrm_vnic_plcmodes_cfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	flags;
	/*
	 * When this bit is '1', the VNIC shall be configured to
	 * use regular placement algorithm.
	 * By default, the regular placement algorithm shall be
	 * enabled on the VNIC.
	 */
	#define HWRM_VNIC_PLCMODES_CFG_INPUT_FLAGS_REGULAR_PLACEMENT	UINT32_C(0x1)
	/*
	 * When this bit is '1', the VNIC shall be configured
	 * use the jumbo placement algorithm.
	 */
	#define HWRM_VNIC_PLCMODES_CFG_INPUT_FLAGS_JUMBO_PLACEMENT	UINT32_C(0x2)
	/*
	 * When this bit is '1', the VNIC shall be configured
	 * to enable Header-Data split for IPv4 packets according
	 * to the following rules:
	 * # If the packet is identified as TCP/IPv4, then the
	 * packet is split at the beginning of the TCP payload.
	 * # If the packet is identified as UDP/IPv4, then the
	 * packet is split at the beginning of UDP payload.
	 * # If the packet is identified as non-TCP and non-UDP
	 * IPv4 packet, then the packet is split at the beginning
	 * of the upper layer protocol header carried in the IPv4
	 * packet.
	 */
	#define HWRM_VNIC_PLCMODES_CFG_INPUT_FLAGS_HDS_IPV4		UINT32_C(0x4)
	/*
	 * When this bit is '1', the VNIC shall be configured
	 * to enable Header-Data split for IPv6 packets according
	 * to the following rules:
	 * # If the packet is identified as TCP/IPv6, then the
	 * packet is split at the beginning of the TCP payload.
	 * # If the packet is identified as UDP/IPv6, then the
	 * packet is split at the beginning of UDP payload.
	 * # If the packet is identified as non-TCP and non-UDP
	 * IPv6 packet, then the packet is split at the beginning
	 * of the upper layer protocol header carried in the IPv6
	 * packet.
	 */
	#define HWRM_VNIC_PLCMODES_CFG_INPUT_FLAGS_HDS_IPV6		UINT32_C(0x8)
	/*
	 * When this bit is '1', the VNIC shall be configured
	 * to enable Header-Data split for FCoE packets at the
	 * beginning of FC payload.
	 */
	#define HWRM_VNIC_PLCMODES_CFG_INPUT_FLAGS_HDS_FCOE		UINT32_C(0x10)
	/*
	 * When this bit is '1', the VNIC shall be configured
	 * to enable Header-Data split for RoCE packets at the
	 * beginning of RoCE payload (after BTH/GRH headers).
	 */
	#define HWRM_VNIC_PLCMODES_CFG_INPUT_FLAGS_HDS_ROCE		UINT32_C(0x20)
	/*
	 * When this bit is '1', the VNIC shall be configured use the virtio
	 * placement algorithm. This feature can only be configured when
	 * proxy mode is supported on the function.
	 */
	#define HWRM_VNIC_PLCMODES_CFG_INPUT_FLAGS_VIRTIO_PLACEMENT	UINT32_C(0x40)
	uint32_t	enables;
	/*
	 * This bit must be '1' for the jumbo_thresh_valid field to be
	 * configured.
	 */
	#define HWRM_VNIC_PLCMODES_CFG_INPUT_ENABLES_JUMBO_THRESH_VALID	UINT32_C(0x1)
	/*
	 * This bit must be '1' for the hds_offset_valid field to be
	 * configured.
	 */
	#define HWRM_VNIC_PLCMODES_CFG_INPUT_ENABLES_HDS_OFFSET_VALID	UINT32_C(0x2)
	/*
	 * This bit must be '1' for the hds_threshold_valid field to be
	 * configured.
	 */
	#define HWRM_VNIC_PLCMODES_CFG_INPUT_ENABLES_HDS_THRESHOLD_VALID	UINT32_C(0x4)
	/*
	 * This bit must be '1' for the max_bds_valid field to be
	 * configured.
	 */
	#define HWRM_VNIC_PLCMODES_CFG_INPUT_ENABLES_MAX_BDS_VALID	UINT32_C(0x8)
	/* Logical vnic ID */
	uint32_t	vnic_id;
	/*
	 * When jumbo placement algorithm is enabled, this value
	 * is used to determine the threshold for jumbo placement.
	 * Packets with length larger than this value will be
	 * placed according to the jumbo placement algorithm.
	 */
	uint16_t	jumbo_thresh;
	/*
	 * This value is used to determine the offset into
	 * packet buffer where the split data (payload) will be
	 * placed according to one of HDS placement algorithm.
	 *
	 * The lengths of packet buffers provided for split data
	 * shall be larger than this value.
	 */
	uint16_t	hds_offset;
	/*
	 * When one of the HDS placement algorithm is enabled, this
	 * value is used to determine the threshold for HDS
	 * placement.
	 * Packets with length larger than this value will be
	 * placed according to the HDS placement algorithm.
	 * This value shall be in multiple of 4 bytes.
	 */
	uint16_t	hds_threshold;
	/*
	 * When virtio placement algorithm is enabled, this
	 * value is used to determine the the maximum number of BDs
	 * that can be used to place an Rx Packet.
	 * If an incoming packet does not fit in the buffers described
	 * by the max BDs, the packet will be dropped and an error
	 * will be reported in the completion. Valid values for this
	 * field are between 1 and 8. If the VNIC uses header-data-
	 * separation and/or TPA with buffer spanning enabled, valid
	 * values for this field are between 2 and 8.
	 * This feature can only be configured when proxy mode is
	 * supported on the function.
	 */
	uint16_t	max_bds;
	uint8_t	unused_0[4];
} hwrm_vnic_plcmodes_cfg_input_t, *phwrm_vnic_plcmodes_cfg_input_t;

/* hwrm_vnic_plcmodes_cfg_output (size:128b/16B) */

typedef struct hwrm_vnic_plcmodes_cfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_vnic_plcmodes_cfg_output_t, *phwrm_vnic_plcmodes_cfg_output_t;

/***************************
 * hwrm_vnic_plcmodes_qcfg *
 ***************************/


/* hwrm_vnic_plcmodes_qcfg_input (size:192b/24B) */

typedef struct hwrm_vnic_plcmodes_qcfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Logical vnic ID */
	uint32_t	vnic_id;
	uint8_t	unused_0[4];
} hwrm_vnic_plcmodes_qcfg_input_t, *phwrm_vnic_plcmodes_qcfg_input_t;

/* hwrm_vnic_plcmodes_qcfg_output (size:192b/24B) */

typedef struct hwrm_vnic_plcmodes_qcfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint32_t	flags;
	/*
	 * When this bit is '1', the VNIC is configured to
	 * use regular placement algorithm.
	 */
	#define HWRM_VNIC_PLCMODES_QCFG_OUTPUT_FLAGS_REGULAR_PLACEMENT	UINT32_C(0x1)
	/*
	 * When this bit is '1', the VNIC is configured to
	 * use the jumbo placement algorithm.
	 */
	#define HWRM_VNIC_PLCMODES_QCFG_OUTPUT_FLAGS_JUMBO_PLACEMENT	UINT32_C(0x2)
	/*
	 * When this bit is '1', the VNIC is configured
	 * to enable Header-Data split for IPv4 packets.
	 */
	#define HWRM_VNIC_PLCMODES_QCFG_OUTPUT_FLAGS_HDS_IPV4		UINT32_C(0x4)
	/*
	 * When this bit is '1', the VNIC is configured
	 * to enable Header-Data split for IPv6 packets.
	 */
	#define HWRM_VNIC_PLCMODES_QCFG_OUTPUT_FLAGS_HDS_IPV6		UINT32_C(0x8)
	/*
	 * When this bit is '1', the VNIC is configured
	 * to enable Header-Data split for FCoE packets.
	 */
	#define HWRM_VNIC_PLCMODES_QCFG_OUTPUT_FLAGS_HDS_FCOE		UINT32_C(0x10)
	/*
	 * When this bit is '1', the VNIC is configured
	 * to enable Header-Data split for RoCE packets.
	 */
	#define HWRM_VNIC_PLCMODES_QCFG_OUTPUT_FLAGS_HDS_ROCE		UINT32_C(0x20)
	/*
	 * When this bit is '1', the VNIC is configured
	 * to be the default VNIC of the requesting function.
	 */
	#define HWRM_VNIC_PLCMODES_QCFG_OUTPUT_FLAGS_DFLT_VNIC		UINT32_C(0x40)
	/*
	 * When this bit is '1', the VNIC is configured to use the virtio
	 * placement algorithm. This feature can only be configured when
	 * proxy mode is supported on the function.
	 */
	#define HWRM_VNIC_PLCMODES_QCFG_OUTPUT_FLAGS_VIRTIO_PLACEMENT	UINT32_C(0x80)
	/*
	 * When jumbo placement algorithm is enabled, this value
	 * is used to determine the threshold for jumbo placement.
	 * Packets with length larger than this value will be
	 * placed according to the jumbo placement algorithm.
	 */
	uint16_t	jumbo_thresh;
	/*
	 * This value is used to determine the offset into
	 * packet buffer where the split data (payload) will be
	 * placed according to one of HDS placement algorithm.
	 *
	 * The lengths of packet buffers provided for split data
	 * shall be larger than this value.
	 */
	uint16_t	hds_offset;
	/*
	 * When one of the HDS placement algorithm is enabled, this
	 * value is used to determine the threshold for HDS
	 * placement.
	 * Packets with length larger than this value will be
	 * placed according to the HDS placement algorithm.
	 * This value shall be in multiple of 4 bytes.
	 */
	uint16_t	hds_threshold;
	/*
	 * When virtio placement algorithm is enabled, this
	 * value is used to determine the the maximum number of BDs
	 * that can be used to place an Rx Packet.
	 * If an incoming packet does not fit in the buffers described
	 * by the max BDs, the packet will be dropped and an error
	 * will be reported in the completion. Valid values for this
	 * field are between 1 and 8. If the VNIC uses header-data-
	 * separation and/or TPA with buffer spanning enabled, valid
	 * values for this field are between 2 and 8.
	 * This feature can only be configured when proxy mode is supported
	 * on the function
	 */
	uint16_t	max_bds;
	uint8_t	unused_0[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_vnic_plcmodes_qcfg_output_t, *phwrm_vnic_plcmodes_qcfg_output_t;

/**********************************
 * hwrm_vnic_rss_cos_lb_ctx_alloc *
 **********************************/


/* hwrm_vnic_rss_cos_lb_ctx_alloc_input (size:128b/16B) */

typedef struct hwrm_vnic_rss_cos_lb_ctx_alloc_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
} hwrm_vnic_rss_cos_lb_ctx_alloc_input_t, *phwrm_vnic_rss_cos_lb_ctx_alloc_input_t;

/* hwrm_vnic_rss_cos_lb_ctx_alloc_output (size:128b/16B) */

typedef struct hwrm_vnic_rss_cos_lb_ctx_alloc_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* rss_cos_lb_ctx_id is 16 b */
	uint16_t	rss_cos_lb_ctx_id;
	uint8_t	unused_0[5];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_vnic_rss_cos_lb_ctx_alloc_output_t, *phwrm_vnic_rss_cos_lb_ctx_alloc_output_t;

/*********************************
 * hwrm_vnic_rss_cos_lb_ctx_free *
 *********************************/


/* hwrm_vnic_rss_cos_lb_ctx_free_input (size:192b/24B) */

typedef struct hwrm_vnic_rss_cos_lb_ctx_free_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* rss_cos_lb_ctx_id is 16 b */
	uint16_t	rss_cos_lb_ctx_id;
	uint8_t	unused_0[6];
} hwrm_vnic_rss_cos_lb_ctx_free_input_t, *phwrm_vnic_rss_cos_lb_ctx_free_input_t;

/* hwrm_vnic_rss_cos_lb_ctx_free_output (size:128b/16B) */

typedef struct hwrm_vnic_rss_cos_lb_ctx_free_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_vnic_rss_cos_lb_ctx_free_output_t, *phwrm_vnic_rss_cos_lb_ctx_free_output_t;

/*******************
 * hwrm_ring_alloc *
 *******************/


/* hwrm_ring_alloc_input (size:704b/88B) */

typedef struct hwrm_ring_alloc_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	enables;
	/*
	 * This bit must be '1' for the ring_arb_cfg field to be
	 * configured.
	 */
	#define HWRM_RING_ALLOC_INPUT_ENABLES_RING_ARB_CFG	UINT32_C(0x2)
	/*
	 * This bit must be '1' for the stat_ctx_id_valid field to be
	 * configured.
	 */
	#define HWRM_RING_ALLOC_INPUT_ENABLES_STAT_CTX_ID_VALID	UINT32_C(0x8)
	/*
	 * This bit must be '1' for the max_bw_valid field to be
	 * configured.
	 */
	#define HWRM_RING_ALLOC_INPUT_ENABLES_MAX_BW_VALID	UINT32_C(0x20)
	/*
	 * This bit must be '1' for the rx_ring_id field to be
	 * configured.
	 */
	#define HWRM_RING_ALLOC_INPUT_ENABLES_RX_RING_ID_VALID	UINT32_C(0x40)
	/*
	 * This bit must be '1' for the nq_ring_id field to be
	 * configured.
	 */
	#define HWRM_RING_ALLOC_INPUT_ENABLES_NQ_RING_ID_VALID	UINT32_C(0x80)
	/*
	 * This bit must be '1' for the rx_buf_size field to be
	 * configured.
	 */
	#define HWRM_RING_ALLOC_INPUT_ENABLES_RX_BUF_SIZE_VALID	UINT32_C(0x100)
	/*
	 * This bit must be '1' for the schq_id field to be
	 * configured.
	 */
	#define HWRM_RING_ALLOC_INPUT_ENABLES_SCHQ_ID		UINT32_C(0x200)
	/*
	 * This bit must be '1' for the mpc_chnls_type field to be
	 * configured.
	 */
	#define HWRM_RING_ALLOC_INPUT_ENABLES_MPC_CHNLS_TYPE	UINT32_C(0x400)
	/* Ring Type. */
	uint8_t	ring_type;
	/* L2 Completion Ring (CR) */
	#define HWRM_RING_ALLOC_INPUT_RING_TYPE_L2_CMPL   UINT32_C(0x0)
	/* TX Ring (TR) */
	#define HWRM_RING_ALLOC_INPUT_RING_TYPE_TX	UINT32_C(0x1)
	/* RX Ring (RR) */
	#define HWRM_RING_ALLOC_INPUT_RING_TYPE_RX	UINT32_C(0x2)
	/* RoCE Notification Completion Ring (ROCE_CR) */
	#define HWRM_RING_ALLOC_INPUT_RING_TYPE_ROCE_CMPL UINT32_C(0x3)
	/* RX Aggregation Ring */
	#define HWRM_RING_ALLOC_INPUT_RING_TYPE_RX_AGG	UINT32_C(0x4)
	/* Notification Queue */
	#define HWRM_RING_ALLOC_INPUT_RING_TYPE_NQ	UINT32_C(0x5)
	#define HWRM_RING_ALLOC_INPUT_RING_TYPE_LAST	HWRM_RING_ALLOC_INPUT_RING_TYPE_NQ
	uint8_t	unused_0;
	/* Ring allocation flags. */
	uint16_t	flags;
	/*
	 * For Rx rings, the incoming packet data can be placed at either
	 * a 0B or 2B offset from the start of the Rx packet buffer. When
	 * '1', the received packet will be padded with 2B of zeros at the
	 * front of the packet. Note that this flag is only used for
	 * Rx rings and is ignored for all other rings included Rx
	 * Aggregation rings.
	 */
	#define HWRM_RING_ALLOC_INPUT_FLAGS_RX_SOP_PAD	UINT32_C(0x1)
	/*
	 * This value is a pointer to the page table for the
	 * Ring.
	 */
	uint64_t	page_tbl_addr;
	/* First Byte Offset of the first entry in the first page. */
	uint32_t	fbo;
	/*
	 * Actual page size in 2^page_size. The supported range is increments
	 * in powers of 2 from 16 bytes to 1GB.
	 * - 4 = 16 B
	 *	Page size is 16 B.
	 * - 12 = 4 KB
	 *	Page size is 4 KB.
	 * - 13 = 8 KB
	 *	Page size is 8 KB.
	 * - 16 = 64 KB
	 *	Page size is 64 KB.
	 * - 21 = 2 MB
	 *	Page size is 2 MB.
	 * - 22 = 4 MB
	 *	Page size is 4 MB.
	 * - 30 = 1 GB
	 *	Page size is 1 GB.
	 */
	uint8_t	page_size;
	/*
	 * This value indicates the depth of page table.
	 * For this version of the specification, value other than 0 or
	 * 1 shall be considered as an invalid value.
	 * When the page_tbl_depth = 0, then it is treated as a
	 * special case with the following.
	 * 1. FBO and page size fields are not valid.
	 * 2. page_tbl_addr is the physical address of the first
	 *	element of the ring.
	 */
	uint8_t	page_tbl_depth;
	/* Used by a PF driver to associate a SCHQ with one of its TX rings. */
	uint16_t	schq_id;
	/*
	 * Number of 16B units in the ring.  Minimum size for
	 * a ring is 16 16B entries.
	 */
	uint32_t	length;
	/*
	 * Logical ring number for the ring to be allocated.
	 * This value determines the position in the doorbell
	 * area where the update to the ring will be made.
	 *
	 * For completion rings, this value is also the MSI-X
	 * vector number for the function the completion ring is
	 * associated with.
	 */
	uint16_t	logical_id;
	/*
	 * This field is used only when ring_type is a TX ring.
	 * This value indicates what completion ring the TX ring
	 * is associated with.
	 */
	uint16_t	cmpl_ring_id;
	/*
	 * This field is used only when ring_type is a TX ring.
	 * This value indicates what CoS queue the TX ring
	 * is associated with.
	 */
	uint16_t	queue_id;
	/*
	 * When allocating a Rx ring or Rx aggregation ring, this field
	 * specifies the size of the buffer descriptors posted to the ring.
	 */
	uint16_t	rx_buf_size;
	/*
	 * When allocating an Rx aggregation ring, this field
	 * specifies the associated Rx ring ID.
	 */
	uint16_t	rx_ring_id;
	/*
	 * When allocating a completion ring, this field
	 * specifies the associated NQ ring ID.
	 */
	uint16_t	nq_ring_id;
	/*
	 * This field is used only when ring_type is a TX ring.
	 * This field is used to configure arbitration related
	 * parameters for a TX ring.
	 */
	uint16_t	ring_arb_cfg;
	/* Arbitration policy used for the ring. */
	#define HWRM_RING_ALLOC_INPUT_RING_ARB_CFG_ARB_POLICY_MASK	UINT32_C(0xf)
	#define HWRM_RING_ALLOC_INPUT_RING_ARB_CFG_ARB_POLICY_SFT	0
	/*
	 * Use strict priority for the TX ring.
	 * Priority value is specified in arb_policy_param
	 */
		#define HWRM_RING_ALLOC_INPUT_RING_ARB_CFG_ARB_POLICY_SP	UINT32_C(0x1)
	/*
	 * Use weighted fair queue arbitration for the TX ring.
	 * Weight is specified in arb_policy_param
	 */
		#define HWRM_RING_ALLOC_INPUT_RING_ARB_CFG_ARB_POLICY_WFQ	UINT32_C(0x2)
		#define HWRM_RING_ALLOC_INPUT_RING_ARB_CFG_ARB_POLICY_LAST	HWRM_RING_ALLOC_INPUT_RING_ARB_CFG_ARB_POLICY_WFQ
	/* Reserved field. */
	#define HWRM_RING_ALLOC_INPUT_RING_ARB_CFG_RSVD_MASK		UINT32_C(0xf0)
	#define HWRM_RING_ALLOC_INPUT_RING_ARB_CFG_RSVD_SFT		4
	/*
	 * Arbitration policy specific parameter.
	 * # For strict priority arbitration policy, this field
	 * represents a priority value. If set to 0, then the priority
	 * is not specified and the HWRM is allowed to select
	 * any priority for this TX ring.
	 * # For weighted fair queue arbitration policy, this field
	 * represents a weight value. If set to 0, then the weight
	 * is not specified and the HWRM is allowed to select
	 * any weight for this TX ring.
	 */
	#define HWRM_RING_ALLOC_INPUT_RING_ARB_CFG_ARB_POLICY_PARAM_MASK UINT32_C(0xff00)
	#define HWRM_RING_ALLOC_INPUT_RING_ARB_CFG_ARB_POLICY_PARAM_SFT 8
	uint16_t	unused_3;
	/*
	 * This field is reserved for the future use.
	 * It shall be set to 0.
	 */
	uint32_t	reserved3;
	/*
	 * This field is used only when ring_type is a TX ring.
	 * This input indicates what statistics context this ring
	 * should be associated with.
	 */
	uint32_t	stat_ctx_id;
	/*
	 * This field is reserved for the future use.
	 * It shall be set to 0.
	 */
	uint32_t	reserved4;
	/*
	 * This field is used only when ring_type is a TX ring
	 * to specify maximum BW allocated to the TX ring.
	 * The HWRM will translate this value into byte counter and
	 * time interval used for this ring inside the device.
	 */
	uint32_t	max_bw;
	/* The bandwidth value. */
	#define HWRM_RING_ALLOC_INPUT_MAX_BW_BW_VALUE_MASK		UINT32_C(0xfffffff)
	#define HWRM_RING_ALLOC_INPUT_MAX_BW_BW_VALUE_SFT		0
	/* The granularity of the value (bits or bytes). */
	#define HWRM_RING_ALLOC_INPUT_MAX_BW_SCALE			UINT32_C(0x10000000)
	/* Value is in bits. */
		#define HWRM_RING_ALLOC_INPUT_MAX_BW_SCALE_BITS		(UINT32_C(0x0) << 28)
	/* Value is in bytes. */
		#define HWRM_RING_ALLOC_INPUT_MAX_BW_SCALE_BYTES		(UINT32_C(0x1) << 28)
		#define HWRM_RING_ALLOC_INPUT_MAX_BW_SCALE_LAST		HWRM_RING_ALLOC_INPUT_MAX_BW_SCALE_BYTES
	/* bw_value_unit is 3 b */
	#define HWRM_RING_ALLOC_INPUT_MAX_BW_BW_VALUE_UNIT_MASK	UINT32_C(0xe0000000)
	#define HWRM_RING_ALLOC_INPUT_MAX_BW_BW_VALUE_UNIT_SFT	29
	/* Value is in Mb or MB (base 10). */
		#define HWRM_RING_ALLOC_INPUT_MAX_BW_BW_VALUE_UNIT_MEGA	(UINT32_C(0x0) << 29)
	/* Value is in Kb or KB (base 10). */
		#define HWRM_RING_ALLOC_INPUT_MAX_BW_BW_VALUE_UNIT_KILO	(UINT32_C(0x2) << 29)
	/* Value is in bits or bytes. */
		#define HWRM_RING_ALLOC_INPUT_MAX_BW_BW_VALUE_UNIT_BASE	(UINT32_C(0x4) << 29)
	/* Value is in Gb or GB (base 10). */
		#define HWRM_RING_ALLOC_INPUT_MAX_BW_BW_VALUE_UNIT_GIGA	(UINT32_C(0x6) << 29)
	/* Value is in 1/100th of a percentage of total bandwidth. */
		#define HWRM_RING_ALLOC_INPUT_MAX_BW_BW_VALUE_UNIT_PERCENT1_100  (UINT32_C(0x1) << 29)
	/* Invalid unit */
		#define HWRM_RING_ALLOC_INPUT_MAX_BW_BW_VALUE_UNIT_INVALID	(UINT32_C(0x7) << 29)
		#define HWRM_RING_ALLOC_INPUT_MAX_BW_BW_VALUE_UNIT_LAST	HWRM_RING_ALLOC_INPUT_MAX_BW_BW_VALUE_UNIT_INVALID
	/*
	 * This field is used only when ring_type is a Completion ring.
	 * This value indicates what interrupt mode should be used
	 * on this completion ring.
	 * Note: In the legacy interrupt mode, no more than 16
	 * completion rings are allowed.
	 */
	uint8_t	int_mode;
	/* Legacy INTA */
	#define HWRM_RING_ALLOC_INPUT_INT_MODE_LEGACY UINT32_C(0x0)
	/* Reserved */
	#define HWRM_RING_ALLOC_INPUT_INT_MODE_RSVD   UINT32_C(0x1)
	/* MSI-X */
	#define HWRM_RING_ALLOC_INPUT_INT_MODE_MSIX   UINT32_C(0x2)
	/* No Interrupt - Polled mode */
	#define HWRM_RING_ALLOC_INPUT_INT_MODE_POLL   UINT32_C(0x3)
	#define HWRM_RING_ALLOC_INPUT_INT_MODE_LAST  HWRM_RING_ALLOC_INPUT_INT_MODE_POLL
	/* Midpath channel type */
	uint8_t	mpc_chnls_type;
	/*
	 * Indicate the TX ring alloc MPC channel type is a MPC channel
	 * with destination to the TX crypto engine block.
	 */
	#define HWRM_RING_ALLOC_INPUT_MPC_CHNLS_TYPE_TCE	UINT32_C(0x0)
	/*
	 * Indicate the RX ring alloc MPC channel type is a MPC channel
	 * with destination to the RX crypto engine block.
	 */
	#define HWRM_RING_ALLOC_INPUT_MPC_CHNLS_TYPE_RCE	UINT32_C(0x1)
	/*
	 * Indicate the RX ring alloc MPC channel type is a MPC channel
	 * with destination to the TX configurable flow processing block.
	 */
	#define HWRM_RING_ALLOC_INPUT_MPC_CHNLS_TYPE_TE_CFA  UINT32_C(0x2)
	/*
	 * Indicate the RX ring alloc MPC channel type is a MPC channel
	 * with destination to the RX configurable flow processing block.
	 */
	#define HWRM_RING_ALLOC_INPUT_MPC_CHNLS_TYPE_RE_CFA  UINT32_C(0x3)
	/*
	 * Indicate the RX ring alloc MPC channel type is a MPC channel
	 * with destination to the primate processor block.
	 */
	#define HWRM_RING_ALLOC_INPUT_MPC_CHNLS_TYPE_PRIMATE UINT32_C(0x4)
	#define HWRM_RING_ALLOC_INPUT_MPC_CHNLS_TYPE_LAST   HWRM_RING_ALLOC_INPUT_MPC_CHNLS_TYPE_PRIMATE
	uint8_t	unused_4[2];
	/*
	 * The cq_handle is specified when allocating a completion ring. For
	 * devices that support NQs, this cq_handle will be included in the
	 * NQE to specify which CQ should be read to retrieve the completion
	 * record.
	 */
	uint64_t	cq_handle;
} hwrm_ring_alloc_input_t, *phwrm_ring_alloc_input_t;

/* hwrm_ring_alloc_output (size:128b/16B) */

typedef struct hwrm_ring_alloc_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * Physical number of ring allocated.
	 * This value shall be unique for a ring type.
	 */
	uint16_t	ring_id;
	/* Logical number of ring allocated. */
	uint16_t	logical_ring_id;
	/*
	 * This field will tell whether to use ping or pong buffer
	 * for first push operation.
	 */
	uint8_t	push_buffer_index;
	/* Start push from ping buffer index */
	#define HWRM_RING_ALLOC_OUTPUT_PUSH_BUFFER_INDEX_PING_BUFFER UINT32_C(0x0)
	/* Start push from pong buffer index */
	#define HWRM_RING_ALLOC_OUTPUT_PUSH_BUFFER_INDEX_PONG_BUFFER UINT32_C(0x1)
	#define HWRM_RING_ALLOC_OUTPUT_PUSH_BUFFER_INDEX_LAST	HWRM_RING_ALLOC_OUTPUT_PUSH_BUFFER_INDEX_PONG_BUFFER
	uint8_t	unused_0[2];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_ring_alloc_output_t, *phwrm_ring_alloc_output_t;

/******************
 * hwrm_ring_free *
 ******************/


/* hwrm_ring_free_input (size:256b/32B) */

typedef struct hwrm_ring_free_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Ring Type. */
	uint8_t	ring_type;
	/* L2 Completion Ring (CR) */
	#define HWRM_RING_FREE_INPUT_RING_TYPE_L2_CMPL   UINT32_C(0x0)
	/* TX Ring (TR) */
	#define HWRM_RING_FREE_INPUT_RING_TYPE_TX	UINT32_C(0x1)
	/* RX Ring (RR) */
	#define HWRM_RING_FREE_INPUT_RING_TYPE_RX	UINT32_C(0x2)
	/* RoCE Notification Completion Ring (ROCE_CR) */
	#define HWRM_RING_FREE_INPUT_RING_TYPE_ROCE_CMPL UINT32_C(0x3)
	/* RX Aggregation Ring */
	#define HWRM_RING_FREE_INPUT_RING_TYPE_RX_AGG	UINT32_C(0x4)
	/* Notification Queue */
	#define HWRM_RING_FREE_INPUT_RING_TYPE_NQ	UINT32_C(0x5)
	#define HWRM_RING_FREE_INPUT_RING_TYPE_LAST	HWRM_RING_FREE_INPUT_RING_TYPE_NQ
	uint8_t	flags;
	/*
	 * If this bit is set to '1', ring_id in this command belongs to
	 * virtio function. prod_idx in this command corresponds to doorbell
	 * producer index. opaque field in this command needs to be inserted
	 * by firmware in VEE_FLUSH completion record.
	 * Firmware will poll the corresponding ring context to reach the
	 * given producer index before sending successful response. It will
	 * finish the completion using VEE_FLUSH completion record.
	 *
	 * If this bit is '0', firmware will not treat ring_id as virtio
	 * ring and ignore prod_idx, opaque fields.
	 *
	 * This feature is not applicable for L2 or RoCE.
	 */
	#define HWRM_RING_FREE_INPUT_FLAGS_VIRTIO_RING_VALID UINT32_C(0x1)
	#define HWRM_RING_FREE_INPUT_FLAGS_LAST		HWRM_RING_FREE_INPUT_FLAGS_VIRTIO_RING_VALID
	/* Physical number of ring allocated. */
	uint16_t	ring_id;
	/*
	 * Ring BD producer index posted by the virtio block.
	 * This field is valid if virtio_ring_valid flag is set.
	 */
	uint32_t	prod_idx;
	/*
	 * User defined opaque field to be inserted into VEE_FLUSH completion
	 * record. This field is valid if virtio_ring_valid flag is set.
	 */
	uint32_t	opaque;
	uint32_t	unused_1;
} hwrm_ring_free_input_t, *phwrm_ring_free_input_t;

/* hwrm_ring_free_output (size:128b/16B) */

typedef struct hwrm_ring_free_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_ring_free_output_t, *phwrm_ring_free_output_t;

/*******************
 * hwrm_ring_reset *
 *******************/


/* hwrm_ring_reset_input (size:192b/24B) */

typedef struct hwrm_ring_reset_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Ring Type. */
	uint8_t	ring_type;
	/* L2 Completion Ring (CR) */
	#define HWRM_RING_RESET_INPUT_RING_TYPE_L2_CMPL	UINT32_C(0x0)
	/* TX Ring (TR) */
	#define HWRM_RING_RESET_INPUT_RING_TYPE_TX	UINT32_C(0x1)
	/* RX Ring (RR) */
	#define HWRM_RING_RESET_INPUT_RING_TYPE_RX	UINT32_C(0x2)
	/* RoCE Notification Completion Ring (ROCE_CR) */
	#define HWRM_RING_RESET_INPUT_RING_TYPE_ROCE_CMPL   UINT32_C(0x3)
	/*
	 * Rx Ring Group.  This is to reset rx and aggregation in an atomic
	 * operation. Completion ring associated with this ring group is
	 * not reset.
	 */
	#define HWRM_RING_RESET_INPUT_RING_TYPE_RX_RING_GRP UINT32_C(0x6)
	#define HWRM_RING_RESET_INPUT_RING_TYPE_LAST	HWRM_RING_RESET_INPUT_RING_TYPE_RX_RING_GRP
	uint8_t	unused_0;
	/*
	 * Physical number of the ring. When ring type is rx_ring_grp, ring id
	 * actually refers to ring group id.
	 */
	uint16_t	ring_id;
	uint8_t	unused_1[4];
} hwrm_ring_reset_input_t, *phwrm_ring_reset_input_t;

/* hwrm_ring_reset_output (size:128b/16B) */

typedef struct hwrm_ring_reset_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * This field will tell whether to use ping or pong buffer
	 * for first push operation.
	 */
	uint8_t	push_buffer_index;
	/* Start push from ping buffer index */
	#define HWRM_RING_RESET_OUTPUT_PUSH_BUFFER_INDEX_PING_BUFFER UINT32_C(0x0)
	/* Start push from pong buffer index */
	#define HWRM_RING_RESET_OUTPUT_PUSH_BUFFER_INDEX_PONG_BUFFER UINT32_C(0x1)
	#define HWRM_RING_RESET_OUTPUT_PUSH_BUFFER_INDEX_LAST	HWRM_RING_RESET_OUTPUT_PUSH_BUFFER_INDEX_PONG_BUFFER
	uint8_t	unused_0[3];
	/* Position of consumer index after ring reset completes. */
	uint8_t	consumer_idx[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_ring_reset_output_t, *phwrm_ring_reset_output_t;

/*****************
 * hwrm_ring_cfg *
 *****************/


/* hwrm_ring_cfg_input (size:320b/40B) */

typedef struct hwrm_ring_cfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Ring Type. */
	uint8_t	ring_type;
	/* TX Ring (TR) */
	#define HWRM_RING_CFG_INPUT_RING_TYPE_TX UINT32_C(0x1)
	/* RX Ring (RR) */
	#define HWRM_RING_CFG_INPUT_RING_TYPE_RX UINT32_C(0x2)
	#define HWRM_RING_CFG_INPUT_RING_TYPE_LAST HWRM_RING_CFG_INPUT_RING_TYPE_RX
	uint8_t	unused_0;
	/* Physical number of the ring. */
	uint16_t	ring_id;
	/* Ring config enable bits. */
	uint16_t	enables;
	/*
	 * For Rx rings, the incoming packet data can be placed at either
	 * a 0B, 2B, 10B or 12B offset from the start of the Rx packet
	 * buffer.
	 * When '1', the received packet will be padded with 2B, 10B or 12B
	 * of zeros at the front of the packet. The exact offset is specified
	 * by rx_sop_pad_bytes parameter.
	 * When '0', the received packet will not be padded.
	 * Note that this flag is only used for Rx rings and is ignored
	 * for all other rings included Rx Aggregation rings.
	 */
	#define HWRM_RING_CFG_INPUT_ENABLES_RX_SOP_PAD_ENABLE		UINT32_C(0x1)
	/*
	 * Proxy mode enable, for Tx, Rx and Rx aggregation rings only.
	 * When rings are allocated, the PCI function on which driver issues
	 * HWRM_RING_CFG command is assumed to own the rings. Hardware takes
	 * the buffer descriptors (BDs) from those rings is assumed to issue
	 * packet payload DMA using same PCI function. When proxy mode is
	 * enabled, hardware can perform payload DMA using another PCI
	 * function on same or different host.
	 * When set to '0', the PCI function on which driver issues
	 * HWRM_RING_CFG command is used for host payload DMA operation.
	 * When set to '1', the host PCI function specified by proxy_fid is
	 * used for host payload DMA operation.
	 */
	#define HWRM_RING_CFG_INPUT_ENABLES_PROXY_MODE_ENABLE		UINT32_C(0x2)
	/*
	 * Tx ring packet source interface override, for Tx rings only.
	 * When TX rings are allocated, the PCI function on which driver
	 * issues HWRM_RING_CFG is assumed to be source interface of
	 * packets sent from TX ring.
	 * When set to '1', the host PCI function specified by proxy_fid
	 * is used as source interface of the transmitted packets.
	 */
	#define HWRM_RING_CFG_INPUT_ENABLES_TX_PROXY_SRC_INTF_OVERRIDE	UINT32_C(0x4)
	/* The schq_id field is valid */
	#define HWRM_RING_CFG_INPUT_ENABLES_SCHQ_ID			UINT32_C(0x8)
	/* Update completion ring ID associated with Tx or Rx ring. */
	#define HWRM_RING_CFG_INPUT_ENABLES_CMPL_RING_ID_UPDATE		UINT32_C(0x10)
	/*
	 * When set to '1', metadata value provided by tx_metadata
	 * field in this command is inserted in the lb_header_metadata
	 * QP context field. When set to '0', no change done to metadata.
	 * Firmware rejects the tx ring metadata programming with
	 * HWRM_ERR_CODE_UNSUPPORTED error if the per function CFA BD
	 * metadata feature is not disabled.
	 */
	#define HWRM_RING_CFG_INPUT_ENABLES_TX_METADATA			UINT32_C(0x20)
	/*
	 * Proxy function FID value.
	 * This value is only used when either proxy_mode_enable flag or
	 * tx_proxy_svif_override is set to '1'.
	 * When proxy_mode_enable is set to '1', it identifies a host PCI
	 * function used for host payload DMA operations.
	 * When tx_proxy_src_intf is set to '1', it identifies a host PCI
	 * function as source interface for all transmitted packets from
	 * the TX ring.
	 */
	uint16_t	proxy_fid;
	/*
	 * Identifies the new scheduler queue (SCHQ) to associate with the
	 * ring. Only valid for Tx rings.
	 * A value of zero indicates that the Tx ring should be associated
	 * with the default scheduler queue (SCHQ).
	 */
	uint16_t	schq_id;
	/*
	 * This field is valid for TX or Rx rings. This value identifies the
	 * new completion ring ID to associate with the TX or Rx ring.
	 */
	uint16_t	cmpl_ring_id;
	/*
	 * Rx SOP padding amount in bytes.
	 * This value is only used when rx_sop_pad_enable flag is set to '1'.
	 */
	uint8_t	rx_sop_pad_bytes;
	uint8_t	unused_1[3];
	/*
	 * When tx_metadata enable bit is set, value specified in this field
	 * is copied to lb_header_metadata in the QP context.
	 */
	uint32_t	tx_metadata;
	uint8_t	unused_2[4];
} hwrm_ring_cfg_input_t, *phwrm_ring_cfg_input_t;

/* hwrm_ring_cfg_output (size:128b/16B) */

typedef struct hwrm_ring_cfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_ring_cfg_output_t, *phwrm_ring_cfg_output_t;

/******************
 * hwrm_ring_qcfg *
 ******************/


/* hwrm_ring_qcfg_input (size:192b/24B) */

typedef struct hwrm_ring_qcfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Ring Type. */
	uint8_t	ring_type;
	/* TX Ring (TR) */
	#define HWRM_RING_QCFG_INPUT_RING_TYPE_TX UINT32_C(0x1)
	/* RX Ring (RR) */
	#define HWRM_RING_QCFG_INPUT_RING_TYPE_RX UINT32_C(0x2)
	#define HWRM_RING_QCFG_INPUT_RING_TYPE_LAST HWRM_RING_QCFG_INPUT_RING_TYPE_RX
	uint8_t	unused_0[5];
	/* Physical number of the ring. */
	uint16_t	ring_id;
} hwrm_ring_qcfg_input_t, *phwrm_ring_qcfg_input_t;

/* hwrm_ring_qcfg_output (size:256b/32B) */

typedef struct hwrm_ring_qcfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Ring config enable bits. */
	uint16_t	enables;
	/*
	 * For Rx rings, the incoming packet data can be placed at either
	 * a 0B, 2B, 10B or 12B offset from the start of the Rx packet
	 * buffer.
	 * When '1', the received packet will be padded with 2B, 10B or 12B
	 * of zeros at the front of the packet. The exact offset is specified
	 * by rx_sop_pad_bytes parameter.
	 * When '0', the received packet will not be padded.
	 * Note that this flag is only used for Rx rings and is ignored
	 * for all other rings included Rx Aggregation rings.
	 */
	#define HWRM_RING_QCFG_OUTPUT_ENABLES_RX_SOP_PAD_ENABLE		UINT32_C(0x1)
	/*
	 * Proxy mode enable, for Tx, Rx and Rx aggregation rings only.
	 * When rings are allocated, the PCI function on which driver issues
	 * HWRM_RING_CFG command is assumed to own the rings. Hardware takes
	 * the buffer descriptors (BDs) from those rings is assumed to issue
	 * packet payload DMA using same PCI function. When proxy mode is
	 * enabled, hardware can perform payload DMA using another PCI
	 * function on same or different host.
	 * When set to '0', the PCI function on which driver issues
	 * HWRM_RING_CFG command is used for host payload DMA operation.
	 * When set to '1', the host PCI function specified by proxy_fid is
	 * used for host payload DMA operation.
	 */
	#define HWRM_RING_QCFG_OUTPUT_ENABLES_PROXY_MODE_ENABLE		UINT32_C(0x2)
	/*
	 * Tx ring packet source interface override, for Tx rings only.
	 * When TX rings are allocated, the PCI function on which driver
	 * issues HWRM_RING_CFG is assumed to be source interface of
	 * packets sent from TX ring.
	 * When set to '1', the host PCI function specified by proxy_fid is
	 * used as source interface of the transmitted packets.
	 */
	#define HWRM_RING_QCFG_OUTPUT_ENABLES_TX_PROXY_SRC_INTF_OVERRIDE	UINT32_C(0x4)
	/*
	 * Proxy function FID value.
	 * This value is only used when either proxy_mode_enable flag or
	 * tx_proxy_svif_override is set to '1'.
	 * When proxy_mode_enable is set to '1', it identifies a host PCI
	 * function used for host payload DMA operations.
	 * When tx_proxy_src_intf is set to '1', it identifies a host PCI
	 * function as source interface for all transmitted packets from the TX
	 * ring.
	 */
	uint16_t	proxy_fid;
	/*
	 * Identifies the new scheduler queue (SCHQ) to associate with the
	 * ring. Only valid for Tx rings.
	 * A value of zero indicates that the Tx ring should be associated with
	 * the default scheduler queue (SCHQ).
	 */
	uint16_t	schq_id;
	/*
	 * This field is used when ring_type is a TX or Rx ring.
	 * This value indicates what completion ring the TX or Rx ring
	 * is associated with.
	 */
	uint16_t	cmpl_ring_id;
	/*
	 * Rx SOP padding amount in bytes.
	 * This value is only used when rx_sop_pad_enable flag is set to '1'.
	 */
	uint8_t	rx_sop_pad_bytes;
	uint8_t	unused_0[3];
	/* lb_header_metadata in the QP context is copied to this field. */
	uint32_t	tx_metadata;
	uint8_t	unused_1[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_ring_qcfg_output_t, *phwrm_ring_qcfg_output_t;

/**************************
 * hwrm_ring_aggint_qcaps *
 **************************/


/* hwrm_ring_aggint_qcaps_input (size:128b/16B) */

typedef struct hwrm_ring_aggint_qcaps_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
} hwrm_ring_aggint_qcaps_input_t, *phwrm_ring_aggint_qcaps_input_t;

/* hwrm_ring_aggint_qcaps_output (size:384b/48B) */

typedef struct hwrm_ring_aggint_qcaps_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint32_t	cmpl_params;
	/*
	 * When this bit is set to '1', int_lat_tmr_min can be configured
	 * on completion rings.
	 */
	#define HWRM_RING_AGGINT_QCAPS_OUTPUT_CMPL_PARAMS_INT_LAT_TMR_MIN		UINT32_C(0x1)
	/*
	 * When this bit is set to '1', int_lat_tmr_max can be configured
	 * on completion rings.
	 */
	#define HWRM_RING_AGGINT_QCAPS_OUTPUT_CMPL_PARAMS_INT_LAT_TMR_MAX		UINT32_C(0x2)
	/*
	 * When this bit is set to '1', timer_reset can be enabled
	 * on completion rings.
	 */
	#define HWRM_RING_AGGINT_QCAPS_OUTPUT_CMPL_PARAMS_TIMER_RESET			UINT32_C(0x4)
	/*
	 * When this bit is set to '1', ring_idle can be enabled
	 * on completion rings.
	 */
	#define HWRM_RING_AGGINT_QCAPS_OUTPUT_CMPL_PARAMS_RING_IDLE			UINT32_C(0x8)
	/*
	 * When this bit is set to '1', num_cmpl_dma_aggr can be configured
	 * on completion rings.
	 */
	#define HWRM_RING_AGGINT_QCAPS_OUTPUT_CMPL_PARAMS_NUM_CMPL_DMA_AGGR		UINT32_C(0x10)
	/*
	 * When this bit is set to '1', num_cmpl_dma_aggr_during_int can be configured
	 * on completion rings.
	 */
	#define HWRM_RING_AGGINT_QCAPS_OUTPUT_CMPL_PARAMS_NUM_CMPL_DMA_AGGR_DURING_INT	UINT32_C(0x20)
	/*
	 * When this bit is set to '1', cmpl_aggr_dma_tmr can be configured
	 * on completion rings.
	 */
	#define HWRM_RING_AGGINT_QCAPS_OUTPUT_CMPL_PARAMS_CMPL_AGGR_DMA_TMR		UINT32_C(0x40)
	/*
	 * When this bit is set to '1', cmpl_aggr_dma_tmr_during_int can be configured
	 * on completion rings.
	 */
	#define HWRM_RING_AGGINT_QCAPS_OUTPUT_CMPL_PARAMS_CMPL_AGGR_DMA_TMR_DURING_INT	UINT32_C(0x80)
	/*
	 * When this bit is set to '1', num_cmpl_aggr_int can be configured
	 * on completion rings.
	 */
	#define HWRM_RING_AGGINT_QCAPS_OUTPUT_CMPL_PARAMS_NUM_CMPL_AGGR_INT		UINT32_C(0x100)
	uint32_t	nq_params;
	/*
	 * When this bit is set to '1', int_lat_tmr_min can be configured
	 * on notification queues.
	 */
	#define HWRM_RING_AGGINT_QCAPS_OUTPUT_NQ_PARAMS_INT_LAT_TMR_MIN	UINT32_C(0x1)
	/* Minimum value for num_cmpl_dma_aggr */
	uint16_t	num_cmpl_dma_aggr_min;
	/* Maximum value for num_cmpl_dma_aggr */
	uint16_t	num_cmpl_dma_aggr_max;
	/* Minimum value for num_cmpl_dma_aggr_during_int */
	uint16_t	num_cmpl_dma_aggr_during_int_min;
	/* Maximum value for num_cmpl_dma_aggr_during_int */
	uint16_t	num_cmpl_dma_aggr_during_int_max;
	/* Minimum value for cmpl_aggr_dma_tmr */
	uint16_t	cmpl_aggr_dma_tmr_min;
	/* Maximum value for cmpl_aggr_dma_tmr */
	uint16_t	cmpl_aggr_dma_tmr_max;
	/* Minimum value for cmpl_aggr_dma_tmr_during_int */
	uint16_t	cmpl_aggr_dma_tmr_during_int_min;
	/* Maximum value for cmpl_aggr_dma_tmr_during_int */
	uint16_t	cmpl_aggr_dma_tmr_during_int_max;
	/* Minimum value for int_lat_tmr_min */
	uint16_t	int_lat_tmr_min_min;
	/* Maximum value for int_lat_tmr_min */
	uint16_t	int_lat_tmr_min_max;
	/* Minimum value for int_lat_tmr_max */
	uint16_t	int_lat_tmr_max_min;
	/* Maximum value for int_lat_tmr_max */
	uint16_t	int_lat_tmr_max_max;
	/* Minimum value for num_cmpl_aggr_int */
	uint16_t	num_cmpl_aggr_int_min;
	/* Maximum value for num_cmpl_aggr_int */
	uint16_t	num_cmpl_aggr_int_max;
	/* The units for timer parameters, in nanoseconds. */
	uint16_t	timer_units;
	uint8_t	unused_0[1];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_ring_aggint_qcaps_output_t, *phwrm_ring_aggint_qcaps_output_t;

/**************************************
 * hwrm_ring_cmpl_ring_qaggint_params *
 **************************************/


/* hwrm_ring_cmpl_ring_qaggint_params_input (size:192b/24B) */

typedef struct hwrm_ring_cmpl_ring_qaggint_params_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Physical number of completion ring. */
	uint16_t	ring_id;
	uint16_t	flags;
	#define HWRM_RING_CMPL_RING_QAGGINT_PARAMS_INPUT_FLAGS_UNUSED_0_MASK UINT32_C(0x3)
	#define HWRM_RING_CMPL_RING_QAGGINT_PARAMS_INPUT_FLAGS_UNUSED_0_SFT 0
	/*
	 * Set this flag to 1 when querying parameters on a notification
	 * queue. Set this flag to 0 when querying parameters on a
	 * completion queue or completion ring.
	 */
	#define HWRM_RING_CMPL_RING_QAGGINT_PARAMS_INPUT_FLAGS_IS_NQ	UINT32_C(0x4)
	uint8_t	unused_0[4];
} hwrm_ring_cmpl_ring_qaggint_params_input_t, *phwrm_ring_cmpl_ring_qaggint_params_input_t;

/* hwrm_ring_cmpl_ring_qaggint_params_output (size:256b/32B) */

typedef struct hwrm_ring_cmpl_ring_qaggint_params_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint16_t	flags;
	/*
	 * When this bit is set to '1', interrupt max
	 * timer is reset whenever a completion is received.
	 */
	#define HWRM_RING_CMPL_RING_QAGGINT_PARAMS_OUTPUT_FLAGS_TIMER_RESET	UINT32_C(0x1)
	/*
	 * When this bit is set to '1', ring idle mode
	 * aggregation will be enabled.
	 */
	#define HWRM_RING_CMPL_RING_QAGGINT_PARAMS_OUTPUT_FLAGS_RING_IDLE	UINT32_C(0x2)
	/*
	 * Number of completions to aggregate before DMA
	 * during the normal mode.
	 */
	uint16_t	num_cmpl_dma_aggr;
	/*
	 * Number of completions to aggregate before DMA
	 * during the interrupt mode.
	 */
	uint16_t	num_cmpl_dma_aggr_during_int;
	/*
	 * Timer used to aggregate completions before
	 * DMA during the normal mode (not in interrupt mode).
	 */
	uint16_t	cmpl_aggr_dma_tmr;
	/*
	 * Timer used to aggregate completions before
	 * DMA when in interrupt mode.
	 */
	uint16_t	cmpl_aggr_dma_tmr_during_int;
	/* Minimum time between two interrupts. */
	uint16_t	int_lat_tmr_min;
	/*
	 * Maximum wait time spent aggregating
	 * completions before signaling the interrupt after the
	 * interrupt is enabled.
	 */
	uint16_t	int_lat_tmr_max;
	/*
	 * Minimum number of completions aggregated before signaling
	 * an interrupt.
	 */
	uint16_t	num_cmpl_aggr_int;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_ring_cmpl_ring_qaggint_params_output_t, *phwrm_ring_cmpl_ring_qaggint_params_output_t;

/*****************************************
 * hwrm_ring_cmpl_ring_cfg_aggint_params *
 *****************************************/


/* hwrm_ring_cmpl_ring_cfg_aggint_params_input (size:320b/40B) */

typedef struct hwrm_ring_cmpl_ring_cfg_aggint_params_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Physical number of completion ring. */
	uint16_t	ring_id;
	uint16_t	flags;
	/*
	 * When this bit is set to '1', interrupt latency max
	 * timer is reset whenever a completion is received.
	 */
	#define HWRM_RING_CMPL_RING_CFG_AGGINT_PARAMS_INPUT_FLAGS_TIMER_RESET	UINT32_C(0x1)
	/*
	 * When this bit is set to '1', ring idle mode
	 * aggregation will be enabled.
	 */
	#define HWRM_RING_CMPL_RING_CFG_AGGINT_PARAMS_INPUT_FLAGS_RING_IDLE	UINT32_C(0x2)
	/*
	 * Set this flag to 1 when configuring parameters on a
	 * notification queue. Set this flag to 0 when configuring
	 * parameters on a completion queue or completion ring.
	 */
	#define HWRM_RING_CMPL_RING_CFG_AGGINT_PARAMS_INPUT_FLAGS_IS_NQ	UINT32_C(0x4)
	/*
	 * Number of completions to aggregate before DMA
	 * during the normal mode.
	 */
	uint16_t	num_cmpl_dma_aggr;
	/*
	 * Number of completions to aggregate before DMA
	 * during the interrupt mode.
	 */
	uint16_t	num_cmpl_dma_aggr_during_int;
	/*
	 * Timer used to aggregate completions before
	 * DMA during the normal mode (not in interrupt mode).
	 */
	uint16_t	cmpl_aggr_dma_tmr;
	/*
	 * Timer used to aggregate completions before
	 * DMA while in interrupt mode.
	 */
	uint16_t	cmpl_aggr_dma_tmr_during_int;
	/* Minimum time between two interrupts. */
	uint16_t	int_lat_tmr_min;
	/*
	 * Maximum wait time spent aggregating
	 * completions before signaling the interrupt after the
	 * interrupt is enabled.
	 */
	uint16_t	int_lat_tmr_max;
	/*
	 * Minimum number of completions aggregated before signaling
	 * an interrupt.
	 */
	uint16_t	num_cmpl_aggr_int;
	/*
	 * Bitfield that indicates which parameters are to be applied. Only
	 * required when configuring devices with notification queues, and
	 * used in that case to set certain parameters on completion queues
	 * and others on notification queues.
	 */
	uint16_t	enables;
	/*
	 * This bit must be '1' for the num_cmpl_dma_aggr field to be
	 * configured.
	 */
	#define HWRM_RING_CMPL_RING_CFG_AGGINT_PARAMS_INPUT_ENABLES_NUM_CMPL_DMA_AGGR		UINT32_C(0x1)
	/*
	 * This bit must be '1' for the num_cmpl_dma_aggr_during_int field to be
	 * configured.
	 */
	#define HWRM_RING_CMPL_RING_CFG_AGGINT_PARAMS_INPUT_ENABLES_NUM_CMPL_DMA_AGGR_DURING_INT	UINT32_C(0x2)
	/*
	 * This bit must be '1' for the cmpl_aggr_dma_tmr field to be
	 * configured.
	 */
	#define HWRM_RING_CMPL_RING_CFG_AGGINT_PARAMS_INPUT_ENABLES_CMPL_AGGR_DMA_TMR		UINT32_C(0x4)
	/*
	 * This bit must be '1' for the int_lat_tmr_min field to be
	 * configured.
	 */
	#define HWRM_RING_CMPL_RING_CFG_AGGINT_PARAMS_INPUT_ENABLES_INT_LAT_TMR_MIN		UINT32_C(0x8)
	/*
	 * This bit must be '1' for the int_lat_tmr_max field to be
	 * configured.
	 */
	#define HWRM_RING_CMPL_RING_CFG_AGGINT_PARAMS_INPUT_ENABLES_INT_LAT_TMR_MAX		UINT32_C(0x10)
	/*
	 * This bit must be '1' for the num_cmpl_aggr_int field to be
	 * configured.
	 */
	#define HWRM_RING_CMPL_RING_CFG_AGGINT_PARAMS_INPUT_ENABLES_NUM_CMPL_AGGR_INT		UINT32_C(0x20)
	uint8_t	unused_0[4];
} hwrm_ring_cmpl_ring_cfg_aggint_params_input_t, *phwrm_ring_cmpl_ring_cfg_aggint_params_input_t;

/* hwrm_ring_cmpl_ring_cfg_aggint_params_output (size:128b/16B) */

typedef struct hwrm_ring_cmpl_ring_cfg_aggint_params_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_ring_cmpl_ring_cfg_aggint_params_output_t, *phwrm_ring_cmpl_ring_cfg_aggint_params_output_t;

/***********************
 * hwrm_ring_grp_alloc *
 ***********************/


/* hwrm_ring_grp_alloc_input (size:192b/24B) */

typedef struct hwrm_ring_grp_alloc_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * This value identifies the CR associated with the ring
	 * group.
	 */
	uint16_t	cr;
	/*
	 * This value identifies the main RR associated with the ring
	 * group.
	 */
	uint16_t	rr;
	/*
	 * This value identifies the aggregation RR associated with
	 * the ring group.  If this value is 0xFF... (All Fs), then no
	 * Aggregation ring will be set.
	 */
	uint16_t	ar;
	/*
	 * This value identifies the statistics context associated
	 * with the ring group.
	 */
	uint16_t	sc;
} hwrm_ring_grp_alloc_input_t, *phwrm_ring_grp_alloc_input_t;

/* hwrm_ring_grp_alloc_output (size:128b/16B) */

typedef struct hwrm_ring_grp_alloc_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * This is the ring group ID value.  Use this value to program
	 * the default ring group for the VNIC or as table entries
	 * in an RSS/COS context.
	 */
	uint32_t	ring_group_id;
	uint8_t	unused_0[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_ring_grp_alloc_output_t, *phwrm_ring_grp_alloc_output_t;

/**********************
 * hwrm_ring_grp_free *
 **********************/


/* hwrm_ring_grp_free_input (size:192b/24B) */

typedef struct hwrm_ring_grp_free_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* This is the ring group ID value. */
	uint32_t	ring_group_id;
	uint8_t	unused_0[4];
} hwrm_ring_grp_free_input_t, *phwrm_ring_grp_free_input_t;

/* hwrm_ring_grp_free_output (size:128b/16B) */

typedef struct hwrm_ring_grp_free_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_ring_grp_free_output_t, *phwrm_ring_grp_free_output_t;

/************************
 * hwrm_ring_schq_alloc *
 ************************/


/* hwrm_ring_schq_alloc_input (size:1088b/136B) */

typedef struct hwrm_ring_schq_alloc_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	enables;
	/*
	 * This bit must be '1' for the tqm_ring0 fields to be
	 * configured.
	 */
	#define HWRM_RING_SCHQ_ALLOC_INPUT_ENABLES_TQM_RING0	UINT32_C(0x1)
	/*
	 * This bit must be '1' for the tqm_ring1 fields to be
	 * configured.
	 */
	#define HWRM_RING_SCHQ_ALLOC_INPUT_ENABLES_TQM_RING1	UINT32_C(0x2)
	/*
	 * This bit must be '1' for the tqm_ring2 fields to be
	 * configured.
	 */
	#define HWRM_RING_SCHQ_ALLOC_INPUT_ENABLES_TQM_RING2	UINT32_C(0x4)
	/*
	 * This bit must be '1' for the tqm_ring3 fields to be
	 * configured.
	 */
	#define HWRM_RING_SCHQ_ALLOC_INPUT_ENABLES_TQM_RING3	UINT32_C(0x8)
	/*
	 * This bit must be '1' for the tqm_ring4 fields to be
	 * configured.
	 */
	#define HWRM_RING_SCHQ_ALLOC_INPUT_ENABLES_TQM_RING4	UINT32_C(0x10)
	/*
	 * This bit must be '1' for the tqm_ring5 fields to be
	 * configured.
	 */
	#define HWRM_RING_SCHQ_ALLOC_INPUT_ENABLES_TQM_RING5	UINT32_C(0x20)
	/*
	 * This bit must be '1' for the tqm_ring6 fields to be
	 * configured.
	 */
	#define HWRM_RING_SCHQ_ALLOC_INPUT_ENABLES_TQM_RING6	UINT32_C(0x40)
	/*
	 * This bit must be '1' for the tqm_ring7 fields to be
	 * configured.
	 */
	#define HWRM_RING_SCHQ_ALLOC_INPUT_ENABLES_TQM_RING7	UINT32_C(0x80)
	/* Reserved for future use. */
	uint32_t	reserved;
	/* TQM ring 0 page size and level. */
	uint8_t	tqm_ring0_pg_size_tqm_ring0_lvl;
	/* TQM ring 0 PBL indirect levels. */
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING0_LVL_MASK	UINT32_C(0xf)
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING0_LVL_SFT	0
	/* PBL pointer is physical start address. */
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING0_LVL_LVL_0	UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING0_LVL_LVL_1	UINT32_C(0x1)
	/*
	 * PBL pointer points to PDE table with each entry pointing to PTE
	 * tables.
	 */
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING0_LVL_LVL_2	UINT32_C(0x2)
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING0_LVL_LAST	HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING0_LVL_LVL_2
	/* TQM ring 0 page size. */
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING0_PG_SIZE_MASK  UINT32_C(0xf0)
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING0_PG_SIZE_SFT   4
	/* 4KB. */
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING0_PG_SIZE_PG_4K   (UINT32_C(0x0) << 4)
	/* 8KB. */
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING0_PG_SIZE_PG_8K   (UINT32_C(0x1) << 4)
	/* 64KB. */
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING0_PG_SIZE_PG_64K  (UINT32_C(0x2) << 4)
	/* 2MB. */
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING0_PG_SIZE_PG_2M   (UINT32_C(0x3) << 4)
	/* 8MB. */
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING0_PG_SIZE_PG_8M   (UINT32_C(0x4) << 4)
	/* 1GB. */
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING0_PG_SIZE_PG_1G   (UINT32_C(0x5) << 4)
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING0_PG_SIZE_LAST   HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING0_PG_SIZE_PG_1G
	/* TQM ring 1 page size and level. */
	uint8_t	tqm_ring1_pg_size_tqm_ring1_lvl;
	/* TQM ring 1 PBL indirect levels. */
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING1_LVL_MASK	UINT32_C(0xf)
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING1_LVL_SFT	0
	/* PBL pointer is physical start address. */
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING1_LVL_LVL_0	UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING1_LVL_LVL_1	UINT32_C(0x1)
	/*
	 * PBL pointer points to PDE table with each entry pointing to PTE
	 * tables.
	 */
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING1_LVL_LVL_2	UINT32_C(0x2)
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING1_LVL_LAST	HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING1_LVL_LVL_2
	/* TQM ring 1 page size. */
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING1_PG_SIZE_MASK  UINT32_C(0xf0)
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING1_PG_SIZE_SFT   4
	/* 4KB. */
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING1_PG_SIZE_PG_4K   (UINT32_C(0x0) << 4)
	/* 8KB. */
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING1_PG_SIZE_PG_8K   (UINT32_C(0x1) << 4)
	/* 64KB. */
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING1_PG_SIZE_PG_64K  (UINT32_C(0x2) << 4)
	/* 2MB. */
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING1_PG_SIZE_PG_2M   (UINT32_C(0x3) << 4)
	/* 8MB. */
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING1_PG_SIZE_PG_8M   (UINT32_C(0x4) << 4)
	/* 1GB. */
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING1_PG_SIZE_PG_1G   (UINT32_C(0x5) << 4)
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING1_PG_SIZE_LAST   HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING1_PG_SIZE_PG_1G
	/* TQM ring 2 page size and level. */
	uint8_t	tqm_ring2_pg_size_tqm_ring2_lvl;
	/* TQM ring 2 PBL indirect levels. */
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING2_LVL_MASK	UINT32_C(0xf)
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING2_LVL_SFT	0
	/* PBL pointer is physical start address. */
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING2_LVL_LVL_0	UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING2_LVL_LVL_1	UINT32_C(0x1)
	/*
	 * PBL pointer points to PDE table with each entry pointing to PTE
	 * tables.
	 */
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING2_LVL_LVL_2	UINT32_C(0x2)
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING2_LVL_LAST	HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING2_LVL_LVL_2
	/* TQM ring 2 page size. */
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING2_PG_SIZE_MASK  UINT32_C(0xf0)
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING2_PG_SIZE_SFT   4
	/* 4KB. */
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING2_PG_SIZE_PG_4K   (UINT32_C(0x0) << 4)
	/* 8KB. */
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING2_PG_SIZE_PG_8K   (UINT32_C(0x1) << 4)
	/* 64KB. */
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING2_PG_SIZE_PG_64K  (UINT32_C(0x2) << 4)
	/* 2MB. */
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING2_PG_SIZE_PG_2M   (UINT32_C(0x3) << 4)
	/* 8MB. */
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING2_PG_SIZE_PG_8M   (UINT32_C(0x4) << 4)
	/* 1GB. */
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING2_PG_SIZE_PG_1G   (UINT32_C(0x5) << 4)
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING2_PG_SIZE_LAST   HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING2_PG_SIZE_PG_1G
	/* TQM ring 3 page size and level. */
	uint8_t	tqm_ring3_pg_size_tqm_ring3_lvl;
	/* TQM ring 3 PBL indirect levels. */
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING3_LVL_MASK	UINT32_C(0xf)
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING3_LVL_SFT	0
	/* PBL pointer is physical start address. */
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING3_LVL_LVL_0	UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING3_LVL_LVL_1	UINT32_C(0x1)
	/*
	 * PBL pointer points to PDE table with each entry pointing to PTE
	 * tables.
	 */
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING3_LVL_LVL_2	UINT32_C(0x2)
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING3_LVL_LAST	HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING3_LVL_LVL_2
	/* TQM ring 3 page size. */
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING3_PG_SIZE_MASK  UINT32_C(0xf0)
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING3_PG_SIZE_SFT   4
	/* 4KB. */
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING3_PG_SIZE_PG_4K   (UINT32_C(0x0) << 4)
	/* 8KB. */
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING3_PG_SIZE_PG_8K   (UINT32_C(0x1) << 4)
	/* 64KB. */
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING3_PG_SIZE_PG_64K  (UINT32_C(0x2) << 4)
	/* 2MB. */
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING3_PG_SIZE_PG_2M   (UINT32_C(0x3) << 4)
	/* 8MB. */
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING3_PG_SIZE_PG_8M   (UINT32_C(0x4) << 4)
	/* 1GB. */
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING3_PG_SIZE_PG_1G   (UINT32_C(0x5) << 4)
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING3_PG_SIZE_LAST   HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING3_PG_SIZE_PG_1G
	/* TQM ring 4 page size and level. */
	uint8_t	tqm_ring4_pg_size_tqm_ring4_lvl;
	/* TQM ring 4 PBL indirect levels. */
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING4_LVL_MASK	UINT32_C(0xf)
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING4_LVL_SFT	0
	/* PBL pointer is physical start address. */
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING4_LVL_LVL_0	UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING4_LVL_LVL_1	UINT32_C(0x1)
	/*
	 * PBL pointer points to PDE table with each entry pointing to PTE
	 * tables.
	 */
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING4_LVL_LVL_2	UINT32_C(0x2)
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING4_LVL_LAST	HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING4_LVL_LVL_2
	/* TQM ring 4 page size. */
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING4_PG_SIZE_MASK  UINT32_C(0xf0)
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING4_PG_SIZE_SFT   4
	/* 4KB. */
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING4_PG_SIZE_PG_4K   (UINT32_C(0x0) << 4)
	/* 8KB. */
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING4_PG_SIZE_PG_8K   (UINT32_C(0x1) << 4)
	/* 64KB. */
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING4_PG_SIZE_PG_64K  (UINT32_C(0x2) << 4)
	/* 2MB. */
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING4_PG_SIZE_PG_2M   (UINT32_C(0x3) << 4)
	/* 8MB. */
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING4_PG_SIZE_PG_8M   (UINT32_C(0x4) << 4)
	/* 1GB. */
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING4_PG_SIZE_PG_1G   (UINT32_C(0x5) << 4)
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING4_PG_SIZE_LAST   HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING4_PG_SIZE_PG_1G
	/* TQM ring 5 page size and level. */
	uint8_t	tqm_ring5_pg_size_tqm_ring5_lvl;
	/* TQM ring 5 PBL indirect levels. */
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING5_LVL_MASK	UINT32_C(0xf)
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING5_LVL_SFT	0
	/* PBL pointer is physical start address. */
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING5_LVL_LVL_0	UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING5_LVL_LVL_1	UINT32_C(0x1)
	/*
	 * PBL pointer points to PDE table with each entry pointing to PTE
	 * tables.
	 */
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING5_LVL_LVL_2	UINT32_C(0x2)
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING5_LVL_LAST	HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING5_LVL_LVL_2
	/* TQM ring 5 page size. */
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING5_PG_SIZE_MASK  UINT32_C(0xf0)
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING5_PG_SIZE_SFT   4
	/* 4KB. */
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING5_PG_SIZE_PG_4K   (UINT32_C(0x0) << 4)
	/* 8KB. */
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING5_PG_SIZE_PG_8K   (UINT32_C(0x1) << 4)
	/* 64KB. */
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING5_PG_SIZE_PG_64K  (UINT32_C(0x2) << 4)
	/* 2MB. */
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING5_PG_SIZE_PG_2M   (UINT32_C(0x3) << 4)
	/* 8MB. */
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING5_PG_SIZE_PG_8M   (UINT32_C(0x4) << 4)
	/* 1GB. */
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING5_PG_SIZE_PG_1G   (UINT32_C(0x5) << 4)
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING5_PG_SIZE_LAST   HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING5_PG_SIZE_PG_1G
	/* TQM ring 6 page size and level. */
	uint8_t	tqm_ring6_pg_size_tqm_ring6_lvl;
	/* TQM ring 6 PBL indirect levels. */
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING6_LVL_MASK	UINT32_C(0xf)
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING6_LVL_SFT	0
	/* PBL pointer is physical start address. */
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING6_LVL_LVL_0	UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING6_LVL_LVL_1	UINT32_C(0x1)
	/*
	 * PBL pointer points to PDE table with each entry pointing to PTE
	 * tables.
	 */
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING6_LVL_LVL_2	UINT32_C(0x2)
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING6_LVL_LAST	HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING6_LVL_LVL_2
	/* TQM ring 6 page size. */
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING6_PG_SIZE_MASK  UINT32_C(0xf0)
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING6_PG_SIZE_SFT   4
	/* 4KB. */
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING6_PG_SIZE_PG_4K   (UINT32_C(0x0) << 4)
	/* 8KB. */
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING6_PG_SIZE_PG_8K   (UINT32_C(0x1) << 4)
	/* 64KB. */
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING6_PG_SIZE_PG_64K  (UINT32_C(0x2) << 4)
	/* 2MB. */
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING6_PG_SIZE_PG_2M   (UINT32_C(0x3) << 4)
	/* 8MB. */
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING6_PG_SIZE_PG_8M   (UINT32_C(0x4) << 4)
	/* 1GB. */
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING6_PG_SIZE_PG_1G   (UINT32_C(0x5) << 4)
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING6_PG_SIZE_LAST   HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING6_PG_SIZE_PG_1G
	/* TQM ring 7 page size and level. */
	uint8_t	tqm_ring7_pg_size_tqm_ring7_lvl;
	/* TQM ring 7 PBL indirect levels. */
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING7_LVL_MASK	UINT32_C(0xf)
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING7_LVL_SFT	0
	/* PBL pointer is physical start address. */
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING7_LVL_LVL_0	UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING7_LVL_LVL_1	UINT32_C(0x1)
	/*
	 * PBL pointer points to PDE table with each entry pointing to PTE
	 * tables.
	 */
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING7_LVL_LVL_2	UINT32_C(0x2)
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING7_LVL_LAST	HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING7_LVL_LVL_2
	/* TQM ring 7 page size. */
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING7_PG_SIZE_MASK  UINT32_C(0xf0)
	#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING7_PG_SIZE_SFT   4
	/* 4KB. */
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING7_PG_SIZE_PG_4K   (UINT32_C(0x0) << 4)
	/* 8KB. */
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING7_PG_SIZE_PG_8K   (UINT32_C(0x1) << 4)
	/* 64KB. */
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING7_PG_SIZE_PG_64K  (UINT32_C(0x2) << 4)
	/* 2MB. */
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING7_PG_SIZE_PG_2M   (UINT32_C(0x3) << 4)
	/* 8MB. */
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING7_PG_SIZE_PG_8M   (UINT32_C(0x4) << 4)
	/* 1GB. */
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING7_PG_SIZE_PG_1G   (UINT32_C(0x5) << 4)
		#define HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING7_PG_SIZE_LAST   HWRM_RING_SCHQ_ALLOC_INPUT_TQM_RING7_PG_SIZE_PG_1G
	/* TQM ring 0 page directory. */
	uint64_t	tqm_ring0_page_dir;
	/* TQM ring 1 page directory. */
	uint64_t	tqm_ring1_page_dir;
	/* TQM ring 2 page directory. */
	uint64_t	tqm_ring2_page_dir;
	/* TQM ring 3 page directory. */
	uint64_t	tqm_ring3_page_dir;
	/* TQM ring 4 page directory. */
	uint64_t	tqm_ring4_page_dir;
	/* TQM ring 5 page directory. */
	uint64_t	tqm_ring5_page_dir;
	/* TQM ring 6 page directory. */
	uint64_t	tqm_ring6_page_dir;
	/* TQM ring 7 page directory. */
	uint64_t	tqm_ring7_page_dir;
	/*
	 * Number of TQM ring 0 entries.
	 *
	 * TQM fastpath rings should be sized large enough to accommodate the
	 * maximum number of QPs (either L2 or RoCE, or both if shared)
	 * that can be enqueued to the TQM ring.
	 *
	 * Note that TQM ring sizes cannot be extended while the system is
	 * operational. If a PF driver needs to extend a TQM ring, it needs
	 * to delete the SCHQ and then reallocate it.
	 */
	uint32_t	tqm_ring0_num_entries;
	/*
	 * Number of TQM ring 1 entries.
	 *
	 * TQM fastpath rings should be sized large enough to accommodate the
	 * maximum number of QPs (either L2 or RoCE, or both if shared)
	 * that can be enqueued to the TQM ring.
	 *
	 * Note that TQM ring sizes cannot be extended while the system is
	 * operational. If a PF driver needs to extend a TQM ring, it needs
	 * to delete the SCHQ and then reallocate it.
	 */
	uint32_t	tqm_ring1_num_entries;
	/*
	 * Number of TQM ring 2 entries.
	 *
	 * TQM fastpath rings should be sized large enough to accommodate the
	 * maximum number of QPs (either L2 or RoCE, or both if shared)
	 * that can be enqueued to the TQM ring.
	 *
	 * Note that TQM ring sizes cannot be extended while the system is
	 * operational. If a PF driver needs to extend a TQM ring, it needs
	 * to delete the SCHQ and then reallocate it.
	 */
	uint32_t	tqm_ring2_num_entries;
	/*
	 * Number of TQM ring 3 entries.
	 *
	 * TQM fastpath rings should be sized large enough to accommodate the
	 * maximum number of QPs (either L2 or RoCE, or both if shared)
	 * that can be enqueued to the TQM ring.
	 *
	 * Note that TQM ring sizes cannot be extended while the system is
	 * operational. If a PF driver needs to extend a TQM ring, it needs
	 * to delete the SCHQ and then reallocate it.
	 */
	uint32_t	tqm_ring3_num_entries;
	/*
	 * Number of TQM ring 4 entries.
	 *
	 * TQM fastpath rings should be sized large enough to accommodate the
	 * maximum number of QPs (either L2 or RoCE, or both if shared)
	 * that can be enqueued to the TQM ring.
	 *
	 * Note that TQM ring sizes cannot be extended while the system is
	 * operational. If a PF driver needs to extend a TQM ring, it needs
	 * to delete the SCHQ and then reallocate it.
	 */
	uint32_t	tqm_ring4_num_entries;
	/*
	 * Number of TQM ring 5 entries.
	 *
	 * TQM fastpath rings should be sized large enough to accommodate the
	 * maximum number of QPs (either L2 or RoCE, or both if shared)
	 * that can be enqueued to the TQM ring.
	 *
	 * Note that TQM ring sizes cannot be extended while the system is
	 * operational. If a PF driver needs to extend a TQM ring, it needs
	 * to delete the SCHQ and then reallocate it.
	 */
	uint32_t	tqm_ring5_num_entries;
	/*
	 * Number of TQM ring 6 entries.
	 *
	 * TQM fastpath rings should be sized large enough to accommodate the
	 * maximum number of QPs (either L2 or RoCE, or both if shared)
	 * that can be enqueued to the TQM ring.
	 *
	 * Note that TQM ring sizes cannot be extended while the system is
	 * operational. If a PF driver needs to extend a TQM ring, it needs
	 * to delete the SCHQ and then reallocate it.
	 */
	uint32_t	tqm_ring6_num_entries;
	/*
	 * Number of TQM ring 7 entries.
	 *
	 * TQM fastpath rings should be sized large enough to accommodate the
	 * maximum number of QPs (either L2 or RoCE, or both if shared)
	 * that can be enqueued to the TQM ring.
	 *
	 * Note that TQM ring sizes cannot be extended while the system is
	 * operational. If a PF driver needs to extend a TQM ring, it needs
	 * to delete the SCHQ and then reallocate it.
	 */
	uint32_t	tqm_ring7_num_entries;
	/* Number of bytes that have been allocated for each context entry. */
	uint16_t	tqm_entry_size;
	uint8_t	unused_0[6];
} hwrm_ring_schq_alloc_input_t, *phwrm_ring_schq_alloc_input_t;

/* hwrm_ring_schq_alloc_output (size:128b/16B) */

typedef struct hwrm_ring_schq_alloc_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * This is an identifier for the SCHQ to be used in other HWRM commands
	 * that need to reference this SCHQ. This value is greater than zero
	 * (i.e. a schq_id of zero references the default SCHQ).
	 */
	uint16_t	schq_id;
	uint8_t	unused_0[5];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_ring_schq_alloc_output_t, *phwrm_ring_schq_alloc_output_t;

/**********************
 * hwrm_ring_schq_cfg *
 **********************/


/* hwrm_ring_schq_cfg_input (size:768b/96B) */

typedef struct hwrm_ring_schq_cfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * Identifies the SCHQ being configured. A schq_id of zero refers to
	 * the default SCHQ.
	 */
	uint16_t	schq_id;
	/*
	 * This field is an 8 bit bitmap that indicates which TCs are enabled
	 * in this SCHQ. Bit 0 represents traffic class 0 and bit 7 represents
	 * traffic class 7.
	 */
	uint8_t	tc_enabled;
	uint8_t	unused_0;
	uint32_t	flags;
	/* The tc_max_bw array and the max_bw parameters are valid */
	#define HWRM_RING_SCHQ_CFG_INPUT_FLAGS_TC_MAX_BW_ENABLED	UINT32_C(0x1)
	/* The tc_min_bw array is valid */
	#define HWRM_RING_SCHQ_CFG_INPUT_FLAGS_TC_MIN_BW_ENABLED	UINT32_C(0x2)
	/* Maximum bandwidth of the traffic class, specified in Mbps. */
	uint32_t	max_bw_tc0;
	/* Maximum bandwidth of the traffic class, specified in Mbps. */
	uint32_t	max_bw_tc1;
	/* Maximum bandwidth of the traffic class, specified in Mbps. */
	uint32_t	max_bw_tc2;
	/* Maximum bandwidth of the traffic class, specified in Mbps. */
	uint32_t	max_bw_tc3;
	/* Maximum bandwidth of the traffic class, specified in Mbps. */
	uint32_t	max_bw_tc4;
	/* Maximum bandwidth of the traffic class, specified in Mbps. */
	uint32_t	max_bw_tc5;
	/* Maximum bandwidth of the traffic class, specified in Mbps. */
	uint32_t	max_bw_tc6;
	/* Maximum bandwidth of the traffic class, specified in Mbps. */
	uint32_t	max_bw_tc7;
	/*
	 * Bandwidth reservation for the traffic class, specified in Mbps.
	 * A value of zero signifies that traffic belonging to this class
	 * shares the bandwidth reservation for the same traffic class of
	 * the default SCHQ.
	 */
	uint32_t	min_bw_tc0;
	/*
	 * Bandwidth reservation for the traffic class, specified in Mbps.
	 * A value of zero signifies that traffic belonging to this class
	 * shares the bandwidth reservation for the same traffic class of
	 * the default SCHQ.
	 */
	uint32_t	min_bw_tc1;
	/*
	 * Bandwidth reservation for the traffic class, specified in Mbps.
	 * A value of zero signifies that traffic belonging to this class
	 * shares the bandwidth reservation for the same traffic class of
	 * the default SCHQ.
	 */
	uint32_t	min_bw_tc2;
	/*
	 * Bandwidth reservation for the traffic class, specified in Mbps.
	 * A value of zero signifies that traffic belonging to this class
	 * shares the bandwidth reservation for the same traffic class of
	 * the default SCHQ.
	 */
	uint32_t	min_bw_tc3;
	/*
	 * Bandwidth reservation for the traffic class, specified in Mbps.
	 * A value of zero signifies that traffic belonging to this class
	 * shares the bandwidth reservation for the same traffic class of
	 * the default SCHQ.
	 */
	uint32_t	min_bw_tc4;
	/*
	 * Bandwidth reservation for the traffic class, specified in Mbps.
	 * A value of zero signifies that traffic belonging to this class
	 * shares the bandwidth reservation for the same traffic class of
	 * the default SCHQ.
	 */
	uint32_t	min_bw_tc5;
	/*
	 * Bandwidth reservation for the traffic class, specified in Mbps.
	 * A value of zero signifies that traffic belonging to this class
	 * shares the bandwidth reservation for the same traffic class of
	 * the default SCHQ.
	 */
	uint32_t	min_bw_tc6;
	/*
	 * Bandwidth reservation for the traffic class, specified in Mbps.
	 * A value of zero signifies that traffic belonging to this class
	 * shares the bandwidth reservation for the same traffic class of
	 * the default SCHQ.
	 */
	uint32_t	min_bw_tc7;
	/*
	 * Indicates the max bandwidth for all enabled traffic classes in
	 * this SCHQ, specified in Mbps.
	 */
	uint32_t	max_bw;
	uint8_t	unused_1[4];
} hwrm_ring_schq_cfg_input_t, *phwrm_ring_schq_cfg_input_t;

/* hwrm_ring_schq_cfg_output (size:128b/16B) */

typedef struct hwrm_ring_schq_cfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_ring_schq_cfg_output_t, *phwrm_ring_schq_cfg_output_t;

/***********************
 * hwrm_ring_schq_free *
 ***********************/


/* hwrm_ring_schq_free_input (size:192b/24B) */

typedef struct hwrm_ring_schq_free_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Identifies the SCHQ being freed. */
	uint16_t	schq_id;
	uint8_t	unused_0[6];
} hwrm_ring_schq_free_input_t, *phwrm_ring_schq_free_input_t;

/* hwrm_ring_schq_free_output (size:128b/16B) */

typedef struct hwrm_ring_schq_free_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_ring_schq_free_output_t, *phwrm_ring_schq_free_output_t;

/*
 * special reserved flow ID to identify per function default
 * flows for vSwitch offload
 */
#define DEFAULT_FLOW_ID 0xFFFFFFFFUL
/*
 * special reserved flow ID to identify per function RoCEv1
 * flows
 */
#define ROCEV1_FLOW_ID 0xFFFFFFFEUL
/*
 * special reserved flow ID to identify per function RoCEv2
 * flows
 */
#define ROCEV2_FLOW_ID 0xFFFFFFFDUL
/*
 * special reserved flow ID to identify per function RoCEv2
 * CNP flows
 */
#define ROCEV2_CNP_FLOW_ID 0xFFFFFFFCUL

/****************************
 * hwrm_cfa_l2_filter_alloc *
 ****************************/


/* hwrm_cfa_l2_filter_alloc_input (size:768b/96B) */

typedef struct hwrm_cfa_l2_filter_alloc_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	flags;
	/*
	 * Enumeration denoting the RX, TX type of the resource.
	 * This enumeration is used for resources that are similar for both
	 * TX and RX paths of the chip.
	 */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_FLAGS_PATH		UINT32_C(0x1)
	/* tx path */
		#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_FLAGS_PATH_TX		UINT32_C(0x0)
	/* rx path */
		#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_FLAGS_PATH_RX		UINT32_C(0x1)
		#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_FLAGS_PATH_LAST	HWRM_CFA_L2_FILTER_ALLOC_INPUT_FLAGS_PATH_RX
	/*
	 * Setting of this flag indicates the applicability to the loopback
	 * path.
	 */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_FLAGS_LOOPBACK	UINT32_C(0x2)
	/*
	 * Setting of this flag indicates drop action. If this flag is not
	 * set, then it should be considered accept action.
	 */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_FLAGS_DROP		UINT32_C(0x4)
	/*
	 * If this flag is set, all t_l2_* fields are invalid
	 * and they should not be specified.
	 * If this flag is set, then l2_* fields refer to
	 * fields of outermost L2 header.
	 */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_FLAGS_OUTERMOST	UINT32_C(0x8)
	/*
	 * Enumeration denoting NO_ROCE_L2 to support old drivers.
	 * New driver L2 for only L2 traffic, ROCE for roce and l2 traffic
	 */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_FLAGS_TRAFFIC_MASK	UINT32_C(0x30)
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_FLAGS_TRAFFIC_SFT	4
	/* To support old drivers */
		#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_FLAGS_TRAFFIC_NO_ROCE_L2  (UINT32_C(0x0) << 4)
	/* Only L2 traffic */
		#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_FLAGS_TRAFFIC_L2	(UINT32_C(0x1) << 4)
	/* Roce & L2 traffic */
		#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_FLAGS_TRAFFIC_ROCE	(UINT32_C(0x2) << 4)
		#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_FLAGS_TRAFFIC_LAST	HWRM_CFA_L2_FILTER_ALLOC_INPUT_FLAGS_TRAFFIC_ROCE
	/*
	 * Setting of this flag indicates that no XDP filter is created with
	 * L2 filter.
	 * 0 - legacy behavior, XDP filter is created with L2 filter
	 * 1 - XDP filter won't be created with L2 filter
	 */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_FLAGS_XDP_DISABLE	UINT32_C(0x40)
	/*
	 * Setting this flag to 1 indicate the L2 fields in this command
	 * pertain to source fields. Setting this flag to 0 indicate the
	 * L2 fields in this command pertain to the destination fields
	 * and this is the default/legacy behavior.
	 */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_FLAGS_SOURCE_VALID	UINT32_C(0x80)
	uint32_t	enables;
	/*
	 * This bit must be '1' for the l2_addr field to be
	 * configured.
	 */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_ENABLES_L2_ADDR		UINT32_C(0x1)
	/*
	 * This bit must be '1' for the l2_addr_mask field to be
	 * configured.
	 */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_ENABLES_L2_ADDR_MASK	UINT32_C(0x2)
	/*
	 * This bit must be '1' for the l2_ovlan field to be
	 * configured.
	 */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_ENABLES_L2_OVLAN		UINT32_C(0x4)
	/*
	 * This bit must be '1' for the l2_ovlan_mask field to be
	 * configured.
	 */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_ENABLES_L2_OVLAN_MASK	UINT32_C(0x8)
	/*
	 * This bit must be '1' for the l2_ivlan field to be
	 * configured.
	 */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_ENABLES_L2_IVLAN		UINT32_C(0x10)
	/*
	 * This bit must be '1' for the l2_ivlan_mask field to be
	 * configured.
	 */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_ENABLES_L2_IVLAN_MASK	UINT32_C(0x20)
	/*
	 * This bit must be '1' for the t_l2_addr field to be
	 * configured.
	 */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_ENABLES_T_L2_ADDR	UINT32_C(0x40)
	/*
	 * This bit must be '1' for the t_l2_addr_mask field to be
	 * configured.
	 */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_ENABLES_T_L2_ADDR_MASK	UINT32_C(0x80)
	/*
	 * This bit must be '1' for the t_l2_ovlan field to be
	 * configured.
	 */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_ENABLES_T_L2_OVLAN	UINT32_C(0x100)
	/*
	 * This bit must be '1' for the t_l2_ovlan_mask field to be
	 * configured.
	 */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_ENABLES_T_L2_OVLAN_MASK	UINT32_C(0x200)
	/*
	 * This bit must be '1' for the t_l2_ivlan field to be
	 * configured.
	 */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_ENABLES_T_L2_IVLAN	UINT32_C(0x400)
	/*
	 * This bit must be '1' for the t_l2_ivlan_mask field to be
	 * configured.
	 */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_ENABLES_T_L2_IVLAN_MASK	UINT32_C(0x800)
	/*
	 * This bit must be '1' for the src_type field to be
	 * configured.
	 */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_ENABLES_SRC_TYPE		UINT32_C(0x1000)
	/*
	 * This bit must be '1' for the src_id field to be
	 * configured.
	 */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_ENABLES_SRC_ID		UINT32_C(0x2000)
	/*
	 * This bit must be '1' for the tunnel_type field to be
	 * configured.
	 */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_ENABLES_TUNNEL_TYPE	UINT32_C(0x4000)
	/*
	 * This bit must be '1' for the dst_id field to be
	 * configured.
	 */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_ENABLES_DST_ID		UINT32_C(0x8000)
	/*
	 * This bit must be '1' for the mirror_vnic_id field to be
	 * configured.
	 */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_ENABLES_MIRROR_VNIC_ID	UINT32_C(0x10000)
	/*
	 * This bit must be '1' for the num_vlans field to be
	 * configured.
	 */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_ENABLES_NUM_VLANS	UINT32_C(0x20000)
	/*
	 * This bit must be '1' for the t_num_vlans field to be
	 * configured.
	 */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_ENABLES_T_NUM_VLANS	UINT32_C(0x40000)
	/*
	 * This value sets the match value for the L2 MAC address.
	 * Destination MAC address for RX path.
	 * Source MAC address for TX path.
	 */
	uint8_t	l2_addr[6];
	/* This value sets the match value for the number of VLANs. */
	uint8_t	num_vlans;
	/*
	 * This value sets the match value for the number of VLANs
	 * in the tunnel headers.
	 */
	uint8_t	t_num_vlans;
	/*
	 * This value sets the mask value for the L2 address.
	 * A value of 0 will mask the corresponding bit from
	 * compare.
	 */
	uint8_t	l2_addr_mask[6];
	/* This value sets VLAN ID value for outer VLAN. */
	uint16_t	l2_ovlan;
	/*
	 * This value sets the mask value for the ovlan id.
	 * A value of 0 will mask the corresponding bit from
	 * compare.
	 */
	uint16_t	l2_ovlan_mask;
	/* This value sets VLAN ID value for inner VLAN. */
	uint16_t	l2_ivlan;
	/*
	 * This value sets the mask value for the ivlan id.
	 * A value of 0 will mask the corresponding bit from
	 * compare.
	 */
	uint16_t	l2_ivlan_mask;
	uint8_t	unused_1[2];
	/*
	 * This value sets the match value for the tunnel
	 * L2 MAC address.
	 * Destination MAC address for RX path.
	 * Source MAC address for TX path.
	 */
	uint8_t	t_l2_addr[6];
	uint8_t	unused_2[2];
	/*
	 * This value sets the mask value for the tunnel L2
	 * address.
	 * A value of 0 will mask the corresponding bit from
	 * compare.
	 */
	uint8_t	t_l2_addr_mask[6];
	/* This value sets VLAN ID value for tunnel outer VLAN. */
	uint16_t	t_l2_ovlan;
	/*
	 * This value sets the mask value for the tunnel ovlan id.
	 * A value of 0 will mask the corresponding bit from
	 * compare.
	 */
	uint16_t	t_l2_ovlan_mask;
	/* This value sets VLAN ID value for tunnel inner VLAN. */
	uint16_t	t_l2_ivlan;
	/*
	 * This value sets the mask value for the tunnel ivlan id.
	 * A value of 0 will mask the corresponding bit from
	 * compare.
	 */
	uint16_t	t_l2_ivlan_mask;
	/* This value identifies the type of source of the packet. */
	uint8_t	src_type;
	/* Network port */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_SRC_TYPE_NPORT UINT32_C(0x0)
	/* Physical function */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_SRC_TYPE_PF	UINT32_C(0x1)
	/* Virtual function */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_SRC_TYPE_VF	UINT32_C(0x2)
	/* Virtual NIC of a function */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_SRC_TYPE_VNIC  UINT32_C(0x3)
	/* Embedded processor for CFA management */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_SRC_TYPE_KONG  UINT32_C(0x4)
	/* Embedded processor for OOB management */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_SRC_TYPE_APE   UINT32_C(0x5)
	/* Embedded processor for RoCE */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_SRC_TYPE_BONO  UINT32_C(0x6)
	/* Embedded processor for network proxy functions */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_SRC_TYPE_TANG  UINT32_C(0x7)
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_SRC_TYPE_LAST HWRM_CFA_L2_FILTER_ALLOC_INPUT_SRC_TYPE_TANG
	uint8_t	unused_3;
	/*
	 * This value is the id of the source.
	 * For a network port, it represents port_id.
	 * For a physical function, it represents fid.
	 * For a virtual function, it represents vf_id.
	 * For a vnic, it represents vnic_id.
	 * For embedded processors, this id is not valid.
	 *
	 * Notes:
	 * 1. The function ID is implied if it src_id is
	 *	not provided for a src_type that is either
	 */
	uint32_t	src_id;
	/* Tunnel Type. */
	uint8_t	tunnel_type;
	/* Non-tunnel */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_TUNNEL_TYPE_NONTUNNEL	UINT32_C(0x0)
	/* Virtual eXtensible Local Area Network (VXLAN) */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_TUNNEL_TYPE_VXLAN	UINT32_C(0x1)
	/* Network Virtualization Generic Routing Encapsulation (NVGRE) */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_TUNNEL_TYPE_NVGRE	UINT32_C(0x2)
	/* Generic Routing Encapsulation (GRE) inside Ethernet payload */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_TUNNEL_TYPE_L2GRE	UINT32_C(0x3)
	/* IP in IP */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_TUNNEL_TYPE_IPIP	UINT32_C(0x4)
	/* Generic Network Virtualization Encapsulation (Geneve) */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_TUNNEL_TYPE_GENEVE	UINT32_C(0x5)
	/* Multi-Protocol Label Switching (MPLS) */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_TUNNEL_TYPE_MPLS	UINT32_C(0x6)
	/* Stateless Transport Tunnel (STT) */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_TUNNEL_TYPE_STT	UINT32_C(0x7)
	/* Generic Routing Encapsulation (GRE) inside IP datagram payload */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_TUNNEL_TYPE_IPGRE	UINT32_C(0x8)
	/* IPV4 over virtual eXtensible Local Area Network (IPV4oVXLAN) */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_TUNNEL_TYPE_VXLAN_V4	UINT32_C(0x9)
	/*
	 * Enhance Generic Routing Encapsulation (GRE version 1) inside IP
	 * datagram payload
	 */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_TUNNEL_TYPE_IPGRE_V1	UINT32_C(0xa)
	/* Use fixed layer 2 ether type of 0xFFFF */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_TUNNEL_TYPE_L2_ETYPE	UINT32_C(0xb)
	/*
	 * IPV6 over virtual eXtensible Local Area Network with GPE header
	 * (IPV6oVXLANGPE)
	 */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_TUNNEL_TYPE_VXLAN_GPE_V6 UINT32_C(0xc)
	/* Any tunneled traffic */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_TUNNEL_TYPE_ANYTUNNEL	UINT32_C(0xff)
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_TUNNEL_TYPE_LAST	HWRM_CFA_L2_FILTER_ALLOC_INPUT_TUNNEL_TYPE_ANYTUNNEL
	uint8_t	unused_4;
	/*
	 * If set, this value shall represent the
	 * Logical VNIC ID of the destination VNIC for the RX
	 * path and network port id of the destination port for
	 * the TX path.
	 */
	uint16_t	dst_id;
	/*
	 * Logical VNIC ID of the VNIC where traffic is
	 * mirrored.
	 */
	uint16_t	mirror_vnic_id;
	/*
	 * This hint is provided to help in placing
	 * the filter in the filter table.
	 */
	uint8_t	pri_hint;
	/* No preference */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_PRI_HINT_NO_PREFER	UINT32_C(0x0)
	/* Above the given filter */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_PRI_HINT_ABOVE_FILTER UINT32_C(0x1)
	/* Below the given filter */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_PRI_HINT_BELOW_FILTER UINT32_C(0x2)
	/* As high as possible */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_PRI_HINT_MAX	UINT32_C(0x3)
	/* As low as possible */
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_PRI_HINT_MIN	UINT32_C(0x4)
	#define HWRM_CFA_L2_FILTER_ALLOC_INPUT_PRI_HINT_LAST	HWRM_CFA_L2_FILTER_ALLOC_INPUT_PRI_HINT_MIN
	uint8_t	unused_5;
	uint32_t	unused_6;
	/*
	 * This is the ID of the filter that goes along with
	 * the pri_hint.
	 *
	 * This field is valid only for the following values.
	 * 1 - Above the given filter
	 * 2 - Below the given filter
	 */
	uint64_t	l2_filter_id_hint;
} hwrm_cfa_l2_filter_alloc_input_t, *phwrm_cfa_l2_filter_alloc_input_t;

/* hwrm_cfa_l2_filter_alloc_output (size:192b/24B) */

typedef struct hwrm_cfa_l2_filter_alloc_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * This value identifies a set of CFA data structures used for an L2
	 * context.
	 */
	uint64_t	l2_filter_id;
	/*
	 * The flow id value in bit 0-29 is the actual ID of the flow
	 * associated with this filter and it shall be used to match
	 * and associate the flow identifier returned in completion
	 * records. A value of 0xFFFFFFFF in the 32-bit flow_id field
	 * shall indicate no valid flow id.
	 */
	uint32_t	flow_id;
	/* Indicate the flow id value. */
	#define HWRM_CFA_L2_FILTER_ALLOC_OUTPUT_FLOW_ID_VALUE_MASK UINT32_C(0x3fffffff)
	#define HWRM_CFA_L2_FILTER_ALLOC_OUTPUT_FLOW_ID_VALUE_SFT 0
	/* Indicate type of the flow. */
	#define HWRM_CFA_L2_FILTER_ALLOC_OUTPUT_FLOW_ID_TYPE	UINT32_C(0x40000000)
	/*
	 * If this bit set to 0, then it indicates that the flow is
	 * internal flow.
	 */
		#define HWRM_CFA_L2_FILTER_ALLOC_OUTPUT_FLOW_ID_TYPE_INT	(UINT32_C(0x0) << 30)
	/*
	 * If this bit is set to 1, then it indicates that the flow is
	 * external flow.
	 */
		#define HWRM_CFA_L2_FILTER_ALLOC_OUTPUT_FLOW_ID_TYPE_EXT	(UINT32_C(0x1) << 30)
		#define HWRM_CFA_L2_FILTER_ALLOC_OUTPUT_FLOW_ID_TYPE_LAST  HWRM_CFA_L2_FILTER_ALLOC_OUTPUT_FLOW_ID_TYPE_EXT
	/* Indicate the flow direction. */
	#define HWRM_CFA_L2_FILTER_ALLOC_OUTPUT_FLOW_ID_DIR	UINT32_C(0x80000000)
	/* If this bit set to 0, then it indicates rx flow. */
		#define HWRM_CFA_L2_FILTER_ALLOC_OUTPUT_FLOW_ID_DIR_RX	(UINT32_C(0x0) << 31)
	/* If this bit is set to 1, then it indicates that tx flow. */
		#define HWRM_CFA_L2_FILTER_ALLOC_OUTPUT_FLOW_ID_DIR_TX	(UINT32_C(0x1) << 31)
		#define HWRM_CFA_L2_FILTER_ALLOC_OUTPUT_FLOW_ID_DIR_LAST   HWRM_CFA_L2_FILTER_ALLOC_OUTPUT_FLOW_ID_DIR_TX
	uint8_t	unused_0[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_cfa_l2_filter_alloc_output_t, *phwrm_cfa_l2_filter_alloc_output_t;

/***************************
 * hwrm_cfa_l2_filter_free *
 ***************************/


/* hwrm_cfa_l2_filter_free_input (size:192b/24B) */

typedef struct hwrm_cfa_l2_filter_free_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * This value identifies a set of CFA data structures used for an L2
	 * context.
	 */
	uint64_t	l2_filter_id;
} hwrm_cfa_l2_filter_free_input_t, *phwrm_cfa_l2_filter_free_input_t;

/* hwrm_cfa_l2_filter_free_output (size:128b/16B) */

typedef struct hwrm_cfa_l2_filter_free_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_cfa_l2_filter_free_output_t, *phwrm_cfa_l2_filter_free_output_t;

/**************************
 * hwrm_cfa_l2_filter_cfg *
 **************************/


/* hwrm_cfa_l2_filter_cfg_input (size:320b/40B) */

typedef struct hwrm_cfa_l2_filter_cfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	flags;
	/*
	 * Enumeration denoting the RX, TX type of the resource.
	 * This enumeration is used for resources that are similar for both
	 * TX and RX paths of the chip.
	 */
	#define HWRM_CFA_L2_FILTER_CFG_INPUT_FLAGS_PATH		UINT32_C(0x1)
	/* tx path */
		#define HWRM_CFA_L2_FILTER_CFG_INPUT_FLAGS_PATH_TX		UINT32_C(0x0)
	/* rx path */
		#define HWRM_CFA_L2_FILTER_CFG_INPUT_FLAGS_PATH_RX		UINT32_C(0x1)
		#define HWRM_CFA_L2_FILTER_CFG_INPUT_FLAGS_PATH_LAST	HWRM_CFA_L2_FILTER_CFG_INPUT_FLAGS_PATH_RX
	/*
	 * Setting of this flag indicates drop action. If this flag is not
	 * set, then it should be considered accept action.
	 */
	#define HWRM_CFA_L2_FILTER_CFG_INPUT_FLAGS_DROP		UINT32_C(0x2)
	/*
	 * Enumeration denoting NO_ROCE_L2 to support old drivers.
	 * New driver L2 for only L2 traffic, ROCE for roce and l2 traffic
	 */
	#define HWRM_CFA_L2_FILTER_CFG_INPUT_FLAGS_TRAFFIC_MASK	UINT32_C(0xc)
	#define HWRM_CFA_L2_FILTER_CFG_INPUT_FLAGS_TRAFFIC_SFT	2
	/* To support old drivers */
		#define HWRM_CFA_L2_FILTER_CFG_INPUT_FLAGS_TRAFFIC_NO_ROCE_L2  (UINT32_C(0x0) << 2)
	/* Only L2 traffic */
		#define HWRM_CFA_L2_FILTER_CFG_INPUT_FLAGS_TRAFFIC_L2	(UINT32_C(0x1) << 2)
	/* Roce & L2 traffic */
		#define HWRM_CFA_L2_FILTER_CFG_INPUT_FLAGS_TRAFFIC_ROCE	(UINT32_C(0x2) << 2)
		#define HWRM_CFA_L2_FILTER_CFG_INPUT_FLAGS_TRAFFIC_LAST	HWRM_CFA_L2_FILTER_CFG_INPUT_FLAGS_TRAFFIC_ROCE
	uint32_t	enables;
	/*
	 * This bit must be '1' for the dst_id field to be
	 * configured.
	 */
	#define HWRM_CFA_L2_FILTER_CFG_INPUT_ENABLES_DST_ID		UINT32_C(0x1)
	/*
	 * This bit must be '1' for the new_mirror_vnic_id field to be
	 * configured.
	 */
	#define HWRM_CFA_L2_FILTER_CFG_INPUT_ENABLES_NEW_MIRROR_VNIC_ID	UINT32_C(0x2)
	/*
	 * This value identifies a set of CFA data structures used for an L2
	 * context.
	 */
	uint64_t	l2_filter_id;
	/*
	 * If set, this value shall represent the
	 * Logical VNIC ID of the destination VNIC for the RX
	 * path and network port id of the destination port for
	 * the TX path.
	 */
	uint32_t	dst_id;
	/*
	 * New Logical VNIC ID of the VNIC where traffic is
	 * mirrored.
	 */
	uint32_t	new_mirror_vnic_id;
} hwrm_cfa_l2_filter_cfg_input_t, *phwrm_cfa_l2_filter_cfg_input_t;

/* hwrm_cfa_l2_filter_cfg_output (size:128b/16B) */

typedef struct hwrm_cfa_l2_filter_cfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_cfa_l2_filter_cfg_output_t, *phwrm_cfa_l2_filter_cfg_output_t;

/***************************
 * hwrm_cfa_l2_set_rx_mask *
 ***************************/


/* hwrm_cfa_l2_set_rx_mask_input (size:448b/56B) */

typedef struct hwrm_cfa_l2_set_rx_mask_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* VNIC ID */
	uint32_t	vnic_id;
	uint32_t	mask;
	/*
	 * When this bit is '1', the function is requested to accept
	 * multi-cast packets specified by the multicast addr table.
	 */
	#define HWRM_CFA_L2_SET_RX_MASK_INPUT_MASK_MCAST		UINT32_C(0x2)
	/*
	 * When this bit is '1', the function is requested to accept
	 * all multi-cast packets.
	 */
	#define HWRM_CFA_L2_SET_RX_MASK_INPUT_MASK_ALL_MCAST	UINT32_C(0x4)
	/*
	 * When this bit is '1', the function is requested to accept
	 * broadcast packets.
	 */
	#define HWRM_CFA_L2_SET_RX_MASK_INPUT_MASK_BCAST		UINT32_C(0x8)
	/*
	 * When this bit is '1', the function is requested to be
	 * put in the promiscuous mode.
	 *
	 * The HWRM should accept any function to set up
	 * promiscuous mode.
	 *
	 * The HWRM shall follow the semantics below for the
	 * promiscuous mode support.
	 * # When partitioning is not enabled on a port
	 * (i.e. single PF on the port), then the PF shall
	 * be allowed to be in the promiscuous mode. When the
	 * PF is in the promiscuous mode, then it shall
	 * receive all host bound traffic on that port.
	 * # When partitioning is enabled on a port
	 * (i.e. multiple PFs per port) and a PF on that
	 * port is in the promiscuous mode, then the PF
	 * receives all traffic within that partition as
	 * identified by a unique identifier for the
	 * PF (e.g. S-Tag). If a unique outer VLAN
	 * for the PF is specified, then the setting of
	 * promiscuous mode on that PF shall result in the
	 * PF receiving all host bound traffic with matching
	 * outer VLAN.
	 * # A VF shall can be set in the promiscuous mode.
	 * In the promiscuous mode, the VF does not receive any
	 * traffic unless a unique outer VLAN for the
	 * VF is specified. If a unique outer VLAN
	 * for the VF is specified, then the setting of
	 * promiscuous mode on that VF shall result in the
	 * VF receiving all host bound traffic with the
	 * matching outer VLAN.
	 * # The HWRM shall allow the setting of promiscuous
	 * mode on a function independently from the
	 * promiscuous mode settings on other functions.
	 */
	#define HWRM_CFA_L2_SET_RX_MASK_INPUT_MASK_PROMISCUOUS	UINT32_C(0x10)
	/*
	 * If this flag is set, the corresponding RX
	 * filters shall be set up to cover multicast/broadcast
	 * filters for the outermost Layer 2 destination MAC
	 * address field.
	 */
	#define HWRM_CFA_L2_SET_RX_MASK_INPUT_MASK_OUTERMOST	UINT32_C(0x20)
	/*
	 * If this flag is set, the corresponding RX
	 * filters shall be set up to cover multicast/broadcast
	 * filters for the VLAN-tagged packets that match the
	 * TPID and VID fields of VLAN tags in the VLAN tag
	 * table specified in this command.
	 */
	#define HWRM_CFA_L2_SET_RX_MASK_INPUT_MASK_VLANONLY		UINT32_C(0x40)
	/*
	 * If this flag is set, the corresponding RX
	 * filters shall be set up to cover multicast/broadcast
	 * filters for non-VLAN tagged packets and VLAN-tagged
	 * packets that match the TPID and VID fields of VLAN
	 * tags in the VLAN tag table specified in this command.
	 */
	#define HWRM_CFA_L2_SET_RX_MASK_INPUT_MASK_VLAN_NONVLAN	UINT32_C(0x80)
	/*
	 * If this flag is set, the corresponding RX
	 * filters shall be set up to cover multicast/broadcast
	 * filters for non-VLAN tagged packets and VLAN-tagged
	 * packets matching any VLAN tag.
	 *
	 * If this flag is set, then the HWRM shall ignore
	 * VLAN tags specified in vlan_tag_tbl.
	 *
	 * If none of vlanonly, vlan_nonvlan, and anyvlan_nonvlan
	 * flags is set, then the HWRM shall ignore
	 * VLAN tags specified in vlan_tag_tbl.
	 *
	 * The HWRM client shall set at most one flag out of
	 * vlanonly, vlan_nonvlan, and anyvlan_nonvlan.
	 */
	#define HWRM_CFA_L2_SET_RX_MASK_INPUT_MASK_ANYVLAN_NONVLAN	UINT32_C(0x100)
	/* This is the address for mcast address tbl. */
	uint64_t	mc_tbl_addr;
	/*
	 * This value indicates how many entries in mc_tbl are valid.
	 * Each entry is 6 bytes.
	 */
	uint32_t	num_mc_entries;
	uint8_t	unused_0[4];
	/*
	 * This is the address for VLAN tag table.
	 * Each VLAN entry in the table is 4 bytes of a VLAN tag
	 * including TPID, PCP, DEI, and VID fields in network byte
	 * order.
	 */
	uint64_t	vlan_tag_tbl_addr;
	/*
	 * This value indicates how many entries in vlan_tag_tbl are
	 * valid. Each entry is 4 bytes.
	 */
	uint32_t	num_vlan_tags;
	uint8_t	unused_1[4];
} hwrm_cfa_l2_set_rx_mask_input_t, *phwrm_cfa_l2_set_rx_mask_input_t;

/* hwrm_cfa_l2_set_rx_mask_output (size:128b/16B) */

typedef struct hwrm_cfa_l2_set_rx_mask_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_cfa_l2_set_rx_mask_output_t, *phwrm_cfa_l2_set_rx_mask_output_t;

/* hwrm_cfa_l2_set_rx_mask_cmd_err (size:64b/8B) */

typedef struct hwrm_cfa_l2_set_rx_mask_cmd_err {
	/*
	 * command specific error codes that goes to
	 * the cmd_err field in Common HWRM Error Response.
	 */
	uint8_t	code;
	/* Unknown error */
	#define HWRM_CFA_L2_SET_RX_MASK_CMD_ERR_CODE_UNKNOWN			UINT32_C(0x0)
	/* Unable to complete operation due to conflict with Ntuple Filter */
	#define HWRM_CFA_L2_SET_RX_MASK_CMD_ERR_CODE_NTUPLE_FILTER_CONFLICT_ERR UINT32_C(0x1)
	#define HWRM_CFA_L2_SET_RX_MASK_CMD_ERR_CODE_LAST			HWRM_CFA_L2_SET_RX_MASK_CMD_ERR_CODE_NTUPLE_FILTER_CONFLICT_ERR
	uint8_t	unused_0[7];
} hwrm_cfa_l2_set_rx_mask_cmd_err_t, *phwrm_cfa_l2_set_rx_mask_cmd_err_t;

/*******************************
 * hwrm_cfa_vlan_antispoof_cfg *
 *******************************/


/* hwrm_cfa_vlan_antispoof_cfg_input (size:256b/32B) */

typedef struct hwrm_cfa_vlan_antispoof_cfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * Function ID of the function that is being configured.
	 * Only valid for a VF FID configured by the PF.
	 */
	uint16_t	fid;
	uint8_t	unused_0[2];
	/* Number of VLAN entries in the vlan_tag_mask_tbl. */
	uint32_t	num_vlan_entries;
	/*
	 * The vlan_tag_mask_tbl_addr is the DMA address of the VLAN
	 * antispoof table. Each table entry contains the 16-bit TPID
	 * (0x8100 or 0x88a8 only), 16-bit VLAN ID, and a 16-bit mask,
	 * all in network order to match hwrm_cfa_l2_set_rx_mask.
	 * For an individual VLAN entry, the mask value should be 0xfff
	 * for the 12-bit VLAN ID.
	 */
	uint64_t	vlan_tag_mask_tbl_addr;
} hwrm_cfa_vlan_antispoof_cfg_input_t, *phwrm_cfa_vlan_antispoof_cfg_input_t;

/* hwrm_cfa_vlan_antispoof_cfg_output (size:128b/16B) */

typedef struct hwrm_cfa_vlan_antispoof_cfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_cfa_vlan_antispoof_cfg_output_t, *phwrm_cfa_vlan_antispoof_cfg_output_t;

/********************************
 * hwrm_cfa_vlan_antispoof_qcfg *
 ********************************/


/* hwrm_cfa_vlan_antispoof_qcfg_input (size:256b/32B) */

typedef struct hwrm_cfa_vlan_antispoof_qcfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * Function ID of the function that is being queried.
	 * Only valid for a VF FID queried by the PF.
	 */
	uint16_t	fid;
	uint8_t	unused_0[2];
	/*
	 * Maximum number of VLAN entries the firmware is allowed to DMA
	 * to vlan_tag_mask_tbl.
	 */
	uint32_t	max_vlan_entries;
	/*
	 * The vlan_tag_mask_tbl_addr is the DMA address of the VLAN
	 * antispoof table to which firmware will DMA to. Each table
	 * entry will contain the 16-bit TPID (0x8100 or 0x88a8 only),
	 * 16-bit VLAN ID, and a 16-bit mask, all in network order to
	 * match hwrm_cfa_l2_set_rx_mask. For an individual VLAN entry,
	 * the mask value should be 0xfff for the 12-bit VLAN ID.
	 */
	uint64_t	vlan_tag_mask_tbl_addr;
} hwrm_cfa_vlan_antispoof_qcfg_input_t, *phwrm_cfa_vlan_antispoof_qcfg_input_t;

/* hwrm_cfa_vlan_antispoof_qcfg_output (size:128b/16B) */

typedef struct hwrm_cfa_vlan_antispoof_qcfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Number of valid entries DMAd by firmware to vlan_tag_mask_tbl. */
	uint32_t	num_vlan_entries;
	uint8_t	unused_0[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_cfa_vlan_antispoof_qcfg_output_t, *phwrm_cfa_vlan_antispoof_qcfg_output_t;

/********************************
 * hwrm_cfa_tunnel_filter_alloc *
 ********************************/


/* hwrm_cfa_tunnel_filter_alloc_input (size:704b/88B) */

typedef struct hwrm_cfa_tunnel_filter_alloc_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	flags;
	/*
	 * Setting of this flag indicates the applicability to the loopback
	 * path.
	 */
	#define HWRM_CFA_TUNNEL_FILTER_ALLOC_INPUT_FLAGS_LOOPBACK	UINT32_C(0x1)
	uint32_t	enables;
	/*
	 * This bit must be '1' for the l2_filter_id field to be
	 * configured.
	 */
	#define HWRM_CFA_TUNNEL_FILTER_ALLOC_INPUT_ENABLES_L2_FILTER_ID	UINT32_C(0x1)
	/*
	 * This bit must be '1' for the l2_addr field to be
	 * configured.
	 */
	#define HWRM_CFA_TUNNEL_FILTER_ALLOC_INPUT_ENABLES_L2_ADDR		UINT32_C(0x2)
	/*
	 * This bit must be '1' for the l2_ivlan field to be
	 * configured.
	 */
	#define HWRM_CFA_TUNNEL_FILTER_ALLOC_INPUT_ENABLES_L2_IVLAN	UINT32_C(0x4)
	/*
	 * This bit must be '1' for the l3_addr field to be
	 * configured.
	 */
	#define HWRM_CFA_TUNNEL_FILTER_ALLOC_INPUT_ENABLES_L3_ADDR		UINT32_C(0x8)
	/*
	 * This bit must be '1' for the l3_addr_type field to be
	 * configured.
	 */
	#define HWRM_CFA_TUNNEL_FILTER_ALLOC_INPUT_ENABLES_L3_ADDR_TYPE	UINT32_C(0x10)
	/*
	 * This bit must be '1' for the t_l3_addr_type field to be
	 * configured.
	 */
	#define HWRM_CFA_TUNNEL_FILTER_ALLOC_INPUT_ENABLES_T_L3_ADDR_TYPE	UINT32_C(0x20)
	/*
	 * This bit must be '1' for the t_l3_addr field to be
	 * configured.
	 */
	#define HWRM_CFA_TUNNEL_FILTER_ALLOC_INPUT_ENABLES_T_L3_ADDR	UINT32_C(0x40)
	/*
	 * This bit must be '1' for the tunnel_type field to be
	 * configured.
	 */
	#define HWRM_CFA_TUNNEL_FILTER_ALLOC_INPUT_ENABLES_TUNNEL_TYPE	UINT32_C(0x80)
	/*
	 * This bit must be '1' for the vni field to be
	 * configured.
	 */
	#define HWRM_CFA_TUNNEL_FILTER_ALLOC_INPUT_ENABLES_VNI		UINT32_C(0x100)
	/*
	 * This bit must be '1' for the dst_vnic_id field to be
	 * configured.
	 */
	#define HWRM_CFA_TUNNEL_FILTER_ALLOC_INPUT_ENABLES_DST_VNIC_ID	UINT32_C(0x200)
	/*
	 * This bit must be '1' for the mirror_vnic_id field to be
	 * configured.
	 */
	#define HWRM_CFA_TUNNEL_FILTER_ALLOC_INPUT_ENABLES_MIRROR_VNIC_ID	UINT32_C(0x400)
	/*
	 * This value identifies a set of CFA data structures used for an L2
	 * context.
	 */
	uint64_t	l2_filter_id;
	/*
	 * This value sets the match value for the inner L2
	 * MAC address.
	 * Destination MAC address for RX path.
	 * Source MAC address for TX path.
	 */
	uint8_t	l2_addr[6];
	/*
	 * This value sets VLAN ID value for inner VLAN.
	 * Only 12-bits of VLAN ID are used in setting the filter.
	 */
	uint16_t	l2_ivlan;
	/*
	 * The value of inner destination IP address to be used in filtering.
	 * For IPv4, first four bytes represent the IP address.
	 */
	uint32_t	l3_addr[4];
	/*
	 * The value of tunnel destination IP address to be used in filtering.
	 * For IPv4, first four bytes represent the IP address.
	 */
	uint32_t	t_l3_addr[4];
	/*
	 * This value indicates the type of inner IP address.
	 * 4 - IPv4
	 * 6 - IPv6
	 * All others are invalid.
	 */
	uint8_t	l3_addr_type;
	/*
	 * This value indicates the type of tunnel IP address.
	 * 4 - IPv4
	 * 6 - IPv6
	 * All others are invalid.
	 */
	uint8_t	t_l3_addr_type;
	/* Tunnel Type. */
	uint8_t	tunnel_type;
	/* Non-tunnel */
	#define HWRM_CFA_TUNNEL_FILTER_ALLOC_INPUT_TUNNEL_TYPE_NONTUNNEL	UINT32_C(0x0)
	/* Virtual eXtensible Local Area Network (VXLAN) */
	#define HWRM_CFA_TUNNEL_FILTER_ALLOC_INPUT_TUNNEL_TYPE_VXLAN	UINT32_C(0x1)
	/* Network Virtualization Generic Routing Encapsulation (NVGRE) */
	#define HWRM_CFA_TUNNEL_FILTER_ALLOC_INPUT_TUNNEL_TYPE_NVGRE	UINT32_C(0x2)
	/* Generic Routing Encapsulation (GRE) inside Ethernet payload */
	#define HWRM_CFA_TUNNEL_FILTER_ALLOC_INPUT_TUNNEL_TYPE_L2GRE	UINT32_C(0x3)
	/* IP in IP */
	#define HWRM_CFA_TUNNEL_FILTER_ALLOC_INPUT_TUNNEL_TYPE_IPIP	UINT32_C(0x4)
	/* Generic Network Virtualization Encapsulation (Geneve) */
	#define HWRM_CFA_TUNNEL_FILTER_ALLOC_INPUT_TUNNEL_TYPE_GENEVE	UINT32_C(0x5)
	/* Multi-Protocol Label Switching (MPLS) */
	#define HWRM_CFA_TUNNEL_FILTER_ALLOC_INPUT_TUNNEL_TYPE_MPLS	UINT32_C(0x6)
	/* Stateless Transport Tunnel (STT) */
	#define HWRM_CFA_TUNNEL_FILTER_ALLOC_INPUT_TUNNEL_TYPE_STT	UINT32_C(0x7)
	/* Generic Routing Encapsulation (GRE) inside IP datagram payload */
	#define HWRM_CFA_TUNNEL_FILTER_ALLOC_INPUT_TUNNEL_TYPE_IPGRE	UINT32_C(0x8)
	/* IPV4 over virtual eXtensible Local Area Network (IPV4oVXLAN) */
	#define HWRM_CFA_TUNNEL_FILTER_ALLOC_INPUT_TUNNEL_TYPE_VXLAN_V4	UINT32_C(0x9)
	/*
	 * Enhance Generic Routing Encapsulation (GRE version 1) inside IP
	 * datagram payload
	 */
	#define HWRM_CFA_TUNNEL_FILTER_ALLOC_INPUT_TUNNEL_TYPE_IPGRE_V1	UINT32_C(0xa)
	/* Use fixed layer 2 ether type of 0xFFFF */
	#define HWRM_CFA_TUNNEL_FILTER_ALLOC_INPUT_TUNNEL_TYPE_L2_ETYPE	UINT32_C(0xb)
	/*
	 * IPV6 over virtual eXtensible Local Area Network with GPE header
	 * (IPV6oVXLANGPE)
	 */
	#define HWRM_CFA_TUNNEL_FILTER_ALLOC_INPUT_TUNNEL_TYPE_VXLAN_GPE_V6 UINT32_C(0xc)
	/* Any tunneled traffic */
	#define HWRM_CFA_TUNNEL_FILTER_ALLOC_INPUT_TUNNEL_TYPE_ANYTUNNEL	UINT32_C(0xff)
	#define HWRM_CFA_TUNNEL_FILTER_ALLOC_INPUT_TUNNEL_TYPE_LAST	HWRM_CFA_TUNNEL_FILTER_ALLOC_INPUT_TUNNEL_TYPE_ANYTUNNEL
	/*
	 * tunnel_flags allows the user to indicate the tunnel tag detection
	 * for the tunnel type specified in tunnel_type.
	 */
	uint8_t	tunnel_flags;
	/*
	 * If the tunnel_type is geneve, then this bit indicates if we
	 * need to match the geneve OAM packet.
	 * If the tunnel_type is nvgre or gre, then this bit indicates if
	 * we need to detect checksum present bit in geneve header.
	 * If the tunnel_type is mpls, then this bit indicates if we need
	 * to match mpls packet with explicit IPV4/IPV6 null header.
	 */
	#define HWRM_CFA_TUNNEL_FILTER_ALLOC_INPUT_TUNNEL_FLAGS_TUN_FLAGS_OAM_CHECKSUM_EXPLHDR	UINT32_C(0x1)
	/*
	 * If the tunnel_type is geneve, then this bit indicates if we
	 * need to detect the critical option bit set in the oam packet.
	 * If the tunnel_type is nvgre or gre, then this bit indicates
	 * if we need to match nvgre packets with key present bit set in
	 * gre header.
	 * If the tunnel_type is mpls, then this bit indicates if we
	 * need to match mpls packet with S bit from inner/second label.
	 */
	#define HWRM_CFA_TUNNEL_FILTER_ALLOC_INPUT_TUNNEL_FLAGS_TUN_FLAGS_CRITICAL_OPT_S1	UINT32_C(0x2)
	/*
	 * If the tunnel_type is geneve, then this bit indicates if we
	 * need to match geneve packet with extended header bit set in
	 * geneve header.
	 * If the tunnel_type is nvgre or gre, then this bit indicates
	 * if we need to match nvgre packets with sequence number
	 * present bit set in gre header.
	 * If the tunnel_type is mpls, then this bit indicates if we
	 * need to match mpls packet with S bit from out/first label.
	 */
	#define HWRM_CFA_TUNNEL_FILTER_ALLOC_INPUT_TUNNEL_FLAGS_TUN_FLAGS_EXTHDR_SEQNUM_S0	UINT32_C(0x4)
	/*
	 * Virtual Network Identifier (VNI). Only valid with
	 * tunnel_types VXLAN, NVGRE, and Geneve.
	 * Only lower 24-bits of VNI field are used
	 * in setting up the filter.
	 */
	uint32_t	vni;
	/* Logical VNIC ID of the destination VNIC. */
	uint32_t	dst_vnic_id;
	/*
	 * Logical VNIC ID of the VNIC where traffic is
	 * mirrored.
	 */
	uint32_t	mirror_vnic_id;
} hwrm_cfa_tunnel_filter_alloc_input_t, *phwrm_cfa_tunnel_filter_alloc_input_t;

/* hwrm_cfa_tunnel_filter_alloc_output (size:192b/24B) */

typedef struct hwrm_cfa_tunnel_filter_alloc_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* This value is an opaque id into CFA data structures. */
	uint64_t	tunnel_filter_id;
	/*
	 * The flow id value in bit 0-29 is the actual ID of the flow
	 * associated with this filter and it shall be used to match
	 * and associate the flow identifier returned in completion
	 * records. A value of 0xFFFFFFFF in the 32-bit flow_id field
	 * shall indicate no valid flow id.
	 */
	uint32_t	flow_id;
	/* Indicate the flow id value. */
	#define HWRM_CFA_TUNNEL_FILTER_ALLOC_OUTPUT_FLOW_ID_VALUE_MASK UINT32_C(0x3fffffff)
	#define HWRM_CFA_TUNNEL_FILTER_ALLOC_OUTPUT_FLOW_ID_VALUE_SFT 0
	/* Indicate type of the flow. */
	#define HWRM_CFA_TUNNEL_FILTER_ALLOC_OUTPUT_FLOW_ID_TYPE	UINT32_C(0x40000000)
	/*
	 * If this bit set to 0, then it indicates that the flow is
	 * internal flow.
	 */
		#define HWRM_CFA_TUNNEL_FILTER_ALLOC_OUTPUT_FLOW_ID_TYPE_INT	(UINT32_C(0x0) << 30)
	/*
	 * If this bit is set to 1, then it indicates that the flow is
	 * external flow.
	 */
		#define HWRM_CFA_TUNNEL_FILTER_ALLOC_OUTPUT_FLOW_ID_TYPE_EXT	(UINT32_C(0x1) << 30)
		#define HWRM_CFA_TUNNEL_FILTER_ALLOC_OUTPUT_FLOW_ID_TYPE_LAST  HWRM_CFA_TUNNEL_FILTER_ALLOC_OUTPUT_FLOW_ID_TYPE_EXT
	/* Indicate the flow direction. */
	#define HWRM_CFA_TUNNEL_FILTER_ALLOC_OUTPUT_FLOW_ID_DIR	UINT32_C(0x80000000)
	/* If this bit set to 0, then it indicates rx flow. */
		#define HWRM_CFA_TUNNEL_FILTER_ALLOC_OUTPUT_FLOW_ID_DIR_RX	(UINT32_C(0x0) << 31)
	/* If this bit is set to 1, then it indicates that tx flow. */
		#define HWRM_CFA_TUNNEL_FILTER_ALLOC_OUTPUT_FLOW_ID_DIR_TX	(UINT32_C(0x1) << 31)
		#define HWRM_CFA_TUNNEL_FILTER_ALLOC_OUTPUT_FLOW_ID_DIR_LAST   HWRM_CFA_TUNNEL_FILTER_ALLOC_OUTPUT_FLOW_ID_DIR_TX
	uint8_t	unused_0[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_cfa_tunnel_filter_alloc_output_t, *phwrm_cfa_tunnel_filter_alloc_output_t;

/*******************************
 * hwrm_cfa_tunnel_filter_free *
 *******************************/


/* hwrm_cfa_tunnel_filter_free_input (size:192b/24B) */

typedef struct hwrm_cfa_tunnel_filter_free_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* This value is an opaque id into CFA data structures. */
	uint64_t	tunnel_filter_id;
} hwrm_cfa_tunnel_filter_free_input_t, *phwrm_cfa_tunnel_filter_free_input_t;

/* hwrm_cfa_tunnel_filter_free_output (size:128b/16B) */

typedef struct hwrm_cfa_tunnel_filter_free_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_cfa_tunnel_filter_free_output_t, *phwrm_cfa_tunnel_filter_free_output_t;

/***************************************
 * hwrm_cfa_redirect_tunnel_type_alloc *
 ***************************************/


/* hwrm_cfa_redirect_tunnel_type_alloc_input (size:192b/24B) */

typedef struct hwrm_cfa_redirect_tunnel_type_alloc_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* The destination function id, to whom the traffic is redirected. */
	uint16_t	dest_fid;
	/* Tunnel Type. */
	uint8_t	tunnel_type;
	/* Non-tunnel */
	#define HWRM_CFA_REDIRECT_TUNNEL_TYPE_ALLOC_INPUT_TUNNEL_TYPE_NONTUNNEL	UINT32_C(0x0)
	/* Virtual eXtensible Local Area Network (VXLAN) */
	#define HWRM_CFA_REDIRECT_TUNNEL_TYPE_ALLOC_INPUT_TUNNEL_TYPE_VXLAN	UINT32_C(0x1)
	/* Network Virtualization Generic Routing Encapsulation (NVGRE) */
	#define HWRM_CFA_REDIRECT_TUNNEL_TYPE_ALLOC_INPUT_TUNNEL_TYPE_NVGRE	UINT32_C(0x2)
	/* Generic Routing Encapsulation (GRE) inside Ethernet payload */
	#define HWRM_CFA_REDIRECT_TUNNEL_TYPE_ALLOC_INPUT_TUNNEL_TYPE_L2GRE	UINT32_C(0x3)
	/* IP in IP */
	#define HWRM_CFA_REDIRECT_TUNNEL_TYPE_ALLOC_INPUT_TUNNEL_TYPE_IPIP	UINT32_C(0x4)
	/* Generic Network Virtualization Encapsulation (Geneve) */
	#define HWRM_CFA_REDIRECT_TUNNEL_TYPE_ALLOC_INPUT_TUNNEL_TYPE_GENEVE	UINT32_C(0x5)
	/* Multi-Protocol Label Switching (MPLS) */
	#define HWRM_CFA_REDIRECT_TUNNEL_TYPE_ALLOC_INPUT_TUNNEL_TYPE_MPLS	UINT32_C(0x6)
	/* Stateless Transport Tunnel (STT) */
	#define HWRM_CFA_REDIRECT_TUNNEL_TYPE_ALLOC_INPUT_TUNNEL_TYPE_STT	UINT32_C(0x7)
	/* Generic Routing Encapsulation (GRE) inside IP datagram payload */
	#define HWRM_CFA_REDIRECT_TUNNEL_TYPE_ALLOC_INPUT_TUNNEL_TYPE_IPGRE	UINT32_C(0x8)
	/* IPV4 over virtual eXtensible Local Area Network (IPV4oVXLAN) */
	#define HWRM_CFA_REDIRECT_TUNNEL_TYPE_ALLOC_INPUT_TUNNEL_TYPE_VXLAN_V4	UINT32_C(0x9)
	/*
	 * Enhance Generic Routing Encapsulation (GRE version 1) inside IP
	 * datagram payload
	 */
	#define HWRM_CFA_REDIRECT_TUNNEL_TYPE_ALLOC_INPUT_TUNNEL_TYPE_IPGRE_V1	UINT32_C(0xa)
	/* Use fixed layer 2 ether type of 0xFFFF */
	#define HWRM_CFA_REDIRECT_TUNNEL_TYPE_ALLOC_INPUT_TUNNEL_TYPE_L2_ETYPE	UINT32_C(0xb)
	/*
	 * IPV6 over virtual eXtensible Local Area Network with GPE header
	 * (IPV6oVXLANGPE)
	 */
	#define HWRM_CFA_REDIRECT_TUNNEL_TYPE_ALLOC_INPUT_TUNNEL_TYPE_VXLAN_GPE_V6 UINT32_C(0xc)
	/* Any tunneled traffic */
	#define HWRM_CFA_REDIRECT_TUNNEL_TYPE_ALLOC_INPUT_TUNNEL_TYPE_ANYTUNNEL	UINT32_C(0xff)
	#define HWRM_CFA_REDIRECT_TUNNEL_TYPE_ALLOC_INPUT_TUNNEL_TYPE_LAST	HWRM_CFA_REDIRECT_TUNNEL_TYPE_ALLOC_INPUT_TUNNEL_TYPE_ANYTUNNEL
	/* Tunnel alloc flags. */
	uint8_t	flags;
	/*
	 * Setting of this flag indicates modify existing redirect tunnel
	 * to new destination function ID.
	 */
	#define HWRM_CFA_REDIRECT_TUNNEL_TYPE_ALLOC_INPUT_FLAGS_MODIFY_DST	UINT32_C(0x1)
	uint8_t	unused_0[4];
} hwrm_cfa_redirect_tunnel_type_alloc_input_t, *phwrm_cfa_redirect_tunnel_type_alloc_input_t;

/* hwrm_cfa_redirect_tunnel_type_alloc_output (size:128b/16B) */

typedef struct hwrm_cfa_redirect_tunnel_type_alloc_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_cfa_redirect_tunnel_type_alloc_output_t, *phwrm_cfa_redirect_tunnel_type_alloc_output_t;

/**************************************
 * hwrm_cfa_redirect_tunnel_type_free *
 **************************************/


/* hwrm_cfa_redirect_tunnel_type_free_input (size:192b/24B) */

typedef struct hwrm_cfa_redirect_tunnel_type_free_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* The destination function id, to whom the traffic is redirected. */
	uint16_t	dest_fid;
	/* Tunnel Type. */
	uint8_t	tunnel_type;
	/* Non-tunnel */
	#define HWRM_CFA_REDIRECT_TUNNEL_TYPE_FREE_INPUT_TUNNEL_TYPE_NONTUNNEL	UINT32_C(0x0)
	/* Virtual eXtensible Local Area Network (VXLAN) */
	#define HWRM_CFA_REDIRECT_TUNNEL_TYPE_FREE_INPUT_TUNNEL_TYPE_VXLAN	UINT32_C(0x1)
	/* Network Virtualization Generic Routing Encapsulation (NVGRE) */
	#define HWRM_CFA_REDIRECT_TUNNEL_TYPE_FREE_INPUT_TUNNEL_TYPE_NVGRE	UINT32_C(0x2)
	/* Generic Routing Encapsulation (GRE) inside Ethernet payload */
	#define HWRM_CFA_REDIRECT_TUNNEL_TYPE_FREE_INPUT_TUNNEL_TYPE_L2GRE	UINT32_C(0x3)
	/* IP in IP */
	#define HWRM_CFA_REDIRECT_TUNNEL_TYPE_FREE_INPUT_TUNNEL_TYPE_IPIP	UINT32_C(0x4)
	/* Generic Network Virtualization Encapsulation (Geneve) */
	#define HWRM_CFA_REDIRECT_TUNNEL_TYPE_FREE_INPUT_TUNNEL_TYPE_GENEVE	UINT32_C(0x5)
	/* Multi-Protocol Label Switching (MPLS) */
	#define HWRM_CFA_REDIRECT_TUNNEL_TYPE_FREE_INPUT_TUNNEL_TYPE_MPLS	UINT32_C(0x6)
	/* Stateless Transport Tunnel (STT) */
	#define HWRM_CFA_REDIRECT_TUNNEL_TYPE_FREE_INPUT_TUNNEL_TYPE_STT	UINT32_C(0x7)
	/* Generic Routing Encapsulation (GRE) inside IP datagram payload */
	#define HWRM_CFA_REDIRECT_TUNNEL_TYPE_FREE_INPUT_TUNNEL_TYPE_IPGRE	UINT32_C(0x8)
	/* IPV4 over virtual eXtensible Local Area Network (IPV4oVXLAN) */
	#define HWRM_CFA_REDIRECT_TUNNEL_TYPE_FREE_INPUT_TUNNEL_TYPE_VXLAN_V4	UINT32_C(0x9)
	/*
	 * Enhance Generic Routing Encapsulation (GRE version 1) inside IP
	 * datagram payload
	 */
	#define HWRM_CFA_REDIRECT_TUNNEL_TYPE_FREE_INPUT_TUNNEL_TYPE_IPGRE_V1	UINT32_C(0xa)
	/* Use fixed layer 2 ether type of 0xFFFF */
	#define HWRM_CFA_REDIRECT_TUNNEL_TYPE_FREE_INPUT_TUNNEL_TYPE_L2_ETYPE	UINT32_C(0xb)
	/*
	 * IPV6 over virtual eXtensible Local Area Network with GPE header
	 * (IPV6oVXLANGPE)
	 */
	#define HWRM_CFA_REDIRECT_TUNNEL_TYPE_FREE_INPUT_TUNNEL_TYPE_VXLAN_GPE_V6 UINT32_C(0xc)
	/* Any tunneled traffic */
	#define HWRM_CFA_REDIRECT_TUNNEL_TYPE_FREE_INPUT_TUNNEL_TYPE_ANYTUNNEL	UINT32_C(0xff)
	#define HWRM_CFA_REDIRECT_TUNNEL_TYPE_FREE_INPUT_TUNNEL_TYPE_LAST	HWRM_CFA_REDIRECT_TUNNEL_TYPE_FREE_INPUT_TUNNEL_TYPE_ANYTUNNEL
	uint8_t	unused_0[5];
} hwrm_cfa_redirect_tunnel_type_free_input_t, *phwrm_cfa_redirect_tunnel_type_free_input_t;

/* hwrm_cfa_redirect_tunnel_type_free_output (size:128b/16B) */

typedef struct hwrm_cfa_redirect_tunnel_type_free_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_cfa_redirect_tunnel_type_free_output_t, *phwrm_cfa_redirect_tunnel_type_free_output_t;

/**************************************
 * hwrm_cfa_redirect_tunnel_type_info *
 **************************************/


/* hwrm_cfa_redirect_tunnel_type_info_input (size:192b/24B) */

typedef struct hwrm_cfa_redirect_tunnel_type_info_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* The source function id. */
	uint16_t	src_fid;
	/* Tunnel Type. */
	uint8_t	tunnel_type;
	/* Non-tunnel */
	#define HWRM_CFA_REDIRECT_TUNNEL_TYPE_INFO_INPUT_TUNNEL_TYPE_NONTUNNEL	UINT32_C(0x0)
	/* Virtual eXtensible Local Area Network (VXLAN) */
	#define HWRM_CFA_REDIRECT_TUNNEL_TYPE_INFO_INPUT_TUNNEL_TYPE_VXLAN	UINT32_C(0x1)
	/* Network Virtualization Generic Routing Encapsulation (NVGRE) */
	#define HWRM_CFA_REDIRECT_TUNNEL_TYPE_INFO_INPUT_TUNNEL_TYPE_NVGRE	UINT32_C(0x2)
	/* Generic Routing Encapsulation (GRE) inside Ethernet payload */
	#define HWRM_CFA_REDIRECT_TUNNEL_TYPE_INFO_INPUT_TUNNEL_TYPE_L2GRE	UINT32_C(0x3)
	/* IP in IP */
	#define HWRM_CFA_REDIRECT_TUNNEL_TYPE_INFO_INPUT_TUNNEL_TYPE_IPIP	UINT32_C(0x4)
	/* Generic Network Virtualization Encapsulation (Geneve) */
	#define HWRM_CFA_REDIRECT_TUNNEL_TYPE_INFO_INPUT_TUNNEL_TYPE_GENEVE	UINT32_C(0x5)
	/* Multi-Protocol Label Switching (MPLS) */
	#define HWRM_CFA_REDIRECT_TUNNEL_TYPE_INFO_INPUT_TUNNEL_TYPE_MPLS	UINT32_C(0x6)
	/* Stateless Transport Tunnel (STT) */
	#define HWRM_CFA_REDIRECT_TUNNEL_TYPE_INFO_INPUT_TUNNEL_TYPE_STT	UINT32_C(0x7)
	/* Generic Routing Encapsulation (GRE) inside IP datagram payload */
	#define HWRM_CFA_REDIRECT_TUNNEL_TYPE_INFO_INPUT_TUNNEL_TYPE_IPGRE	UINT32_C(0x8)
	/* IPV4 over virtual eXtensible Local Area Network (IPV4oVXLAN) */
	#define HWRM_CFA_REDIRECT_TUNNEL_TYPE_INFO_INPUT_TUNNEL_TYPE_VXLAN_V4	UINT32_C(0x9)
	/*
	 * Enhance Generic Routing Encapsulation (GRE version 1) inside IP
	 * datagram payload
	 */
	#define HWRM_CFA_REDIRECT_TUNNEL_TYPE_INFO_INPUT_TUNNEL_TYPE_IPGRE_V1	UINT32_C(0xa)
	/* Use fixed layer 2 ether type of 0xFFFF */
	#define HWRM_CFA_REDIRECT_TUNNEL_TYPE_INFO_INPUT_TUNNEL_TYPE_L2_ETYPE	UINT32_C(0xb)
	/*
	 * IPV6 over virtual eXtensible Local Area Network with GPE header
	 * (IPV6oVXLANGPE)
	 */
	#define HWRM_CFA_REDIRECT_TUNNEL_TYPE_INFO_INPUT_TUNNEL_TYPE_VXLAN_GPE_V6 UINT32_C(0xc)
	/* Any tunneled traffic */
	#define HWRM_CFA_REDIRECT_TUNNEL_TYPE_INFO_INPUT_TUNNEL_TYPE_ANYTUNNEL	UINT32_C(0xff)
	#define HWRM_CFA_REDIRECT_TUNNEL_TYPE_INFO_INPUT_TUNNEL_TYPE_LAST	HWRM_CFA_REDIRECT_TUNNEL_TYPE_INFO_INPUT_TUNNEL_TYPE_ANYTUNNEL
	uint8_t	unused_0[5];
} hwrm_cfa_redirect_tunnel_type_info_input_t, *phwrm_cfa_redirect_tunnel_type_info_input_t;

/* hwrm_cfa_redirect_tunnel_type_info_output (size:128b/16B) */

typedef struct hwrm_cfa_redirect_tunnel_type_info_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* The destination function id, to whom the traffic is redirected. */
	uint16_t	dest_fid;
	uint8_t	unused_0[5];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_cfa_redirect_tunnel_type_info_output_t, *phwrm_cfa_redirect_tunnel_type_info_output_t;

/* hwrm_vxlan_ipv4_hdr (size:128b/16B) */

typedef struct hwrm_vxlan_ipv4_hdr {
	/* IPv4 version and header length. */
	uint8_t	ver_hlen;
	/* IPv4 header length */
	#define HWRM_VXLAN_IPV4_HDR_VER_HLEN_HEADER_LENGTH_MASK UINT32_C(0xf)
	#define HWRM_VXLAN_IPV4_HDR_VER_HLEN_HEADER_LENGTH_SFT 0
	/* Version */
	#define HWRM_VXLAN_IPV4_HDR_VER_HLEN_VERSION_MASK	UINT32_C(0xf0)
	#define HWRM_VXLAN_IPV4_HDR_VER_HLEN_VERSION_SFT	4
	/* IPv4 type of service. */
	uint8_t	tos;
	/* IPv4 identification. */
	uint16_t	ip_id;
	/* IPv4 flags and offset. */
	uint16_t	flags_frag_offset;
	/* IPv4 TTL. */
	uint8_t	ttl;
	/* IPv4 protocol. */
	uint8_t	protocol;
	/* IPv4 source address. */
	uint32_t	src_ip_addr;
	/* IPv4 destination address. */
	uint32_t	dest_ip_addr;
} hwrm_vxlan_ipv4_hdr_t, *phwrm_vxlan_ipv4_hdr_t;

/* hwrm_vxlan_ipv6_hdr (size:320b/40B) */

typedef struct hwrm_vxlan_ipv6_hdr {
	/* IPv6 version, traffic class and flow label. */
	uint32_t	ver_tc_flow_label;
	/* IPv6 version shift */
	#define HWRM_VXLAN_IPV6_HDR_VER_TC_FLOW_LABEL_VER_SFT	UINT32_C(0x1c)
	/* IPv6 version mask */
	#define HWRM_VXLAN_IPV6_HDR_VER_TC_FLOW_LABEL_VER_MASK	UINT32_C(0xf0000000)
	/* IPv6 TC shift */
	#define HWRM_VXLAN_IPV6_HDR_VER_TC_FLOW_LABEL_TC_SFT	UINT32_C(0x14)
	/* IPv6 TC mask */
	#define HWRM_VXLAN_IPV6_HDR_VER_TC_FLOW_LABEL_TC_MASK	UINT32_C(0xff00000)
	/* IPv6 flow label shift */
	#define HWRM_VXLAN_IPV6_HDR_VER_TC_FLOW_LABEL_FLOW_LABEL_SFT  UINT32_C(0x0)
	/* IPv6 flow label mask */
	#define HWRM_VXLAN_IPV6_HDR_VER_TC_FLOW_LABEL_FLOW_LABEL_MASK UINT32_C(0xfffff)
	#define HWRM_VXLAN_IPV6_HDR_VER_TC_FLOW_LABEL_LAST	HWRM_VXLAN_IPV6_HDR_VER_TC_FLOW_LABEL_FLOW_LABEL_MASK
	/* IPv6 payload length. */
	uint16_t	payload_len;
	/* IPv6 next header. */
	uint8_t	next_hdr;
	/* IPv6 TTL. */
	uint8_t	ttl;
	/* IPv6 source address. */
	uint32_t	src_ip_addr[4];
	/* IPv6 destination address. */
	uint32_t	dest_ip_addr[4];
} hwrm_vxlan_ipv6_hdr_t, *phwrm_vxlan_ipv6_hdr_t;

/* hwrm_cfa_encap_data_vxlan (size:640b/80B) */

typedef struct hwrm_cfa_encap_data_vxlan {
	/* Source MAC address. */
	uint8_t	src_mac_addr[6];
	/* reserved. */
	uint16_t	unused_0;
	/* Destination MAC address. */
	uint8_t	dst_mac_addr[6];
	/* Number of VLAN tags. */
	uint8_t	num_vlan_tags;
	/* reserved. */
	uint8_t	unused_1;
	/* Outer VLAN TPID. */
	uint16_t	ovlan_tpid;
	/* Outer VLAN TCI. */
	uint16_t	ovlan_tci;
	/* Inner VLAN TPID. */
	uint16_t	ivlan_tpid;
	/* Inner VLAN TCI. */
	uint16_t	ivlan_tci;
	/* L3 header fields. */
	uint32_t	l3[10];
	/* IP version mask. */
	#define HWRM_CFA_ENCAP_DATA_VXLAN_L3_VER_MASK UINT32_C(0xf)
	/* IP version 4. */
	#define HWRM_CFA_ENCAP_DATA_VXLAN_L3_VER_IPV4 UINT32_C(0x4)
	/* IP version 6. */
	#define HWRM_CFA_ENCAP_DATA_VXLAN_L3_VER_IPV6 UINT32_C(0x6)
	#define HWRM_CFA_ENCAP_DATA_VXLAN_L3_LAST	HWRM_CFA_ENCAP_DATA_VXLAN_L3_VER_IPV6
	/* UDP source port. */
	uint16_t	src_port;
	/* UDP destination port. */
	uint16_t	dst_port;
	/* VXLAN Network Identifier. */
	uint32_t	vni;
	/*
	 * 3 bytes VXLAN header reserve fields from 1st dword of the VXLAN
	 * header.
	 */
	uint8_t	hdr_rsvd0[3];
	/* 1 byte VXLAN header reserve field from 2nd dword of the VXLAN header. */
	uint8_t	hdr_rsvd1;
	/* VXLAN header flags field. */
	uint8_t	hdr_flags;
	uint8_t	unused[3];
} hwrm_cfa_encap_data_vxlan_t, *phwrm_cfa_encap_data_vxlan_t;

/*******************************
 * hwrm_cfa_encap_record_alloc *
 *******************************/


/* hwrm_cfa_encap_record_alloc_input (size:832b/104B) */

typedef struct hwrm_cfa_encap_record_alloc_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	flags;
	/*
	 * Setting of this flag indicates the applicability to the loopback
	 * path.
	 */
	#define HWRM_CFA_ENCAP_RECORD_ALLOC_INPUT_FLAGS_LOOPBACK	UINT32_C(0x1)
	/*
	 * Setting of this flag indicates this encap record is external
	 * encap record. Resetting of this flag indicates this flag is
	 * internal encap record and this is the default setting.
	 */
	#define HWRM_CFA_ENCAP_RECORD_ALLOC_INPUT_FLAGS_EXTERNAL	UINT32_C(0x2)
	/* Encapsulation Type. */
	uint8_t	encap_type;
	/* Virtual eXtensible Local Area Network (VXLAN) */
	#define HWRM_CFA_ENCAP_RECORD_ALLOC_INPUT_ENCAP_TYPE_VXLAN	UINT32_C(0x1)
	/* Network Virtualization Generic Routing Encapsulation (NVGRE) */
	#define HWRM_CFA_ENCAP_RECORD_ALLOC_INPUT_ENCAP_TYPE_NVGRE	UINT32_C(0x2)
	/* Generic Routing Encapsulation (GRE) after inside Ethernet payload */
	#define HWRM_CFA_ENCAP_RECORD_ALLOC_INPUT_ENCAP_TYPE_L2GRE	UINT32_C(0x3)
	/* IP in IP */
	#define HWRM_CFA_ENCAP_RECORD_ALLOC_INPUT_ENCAP_TYPE_IPIP	UINT32_C(0x4)
	/* Generic Network Virtualization Encapsulation (Geneve) */
	#define HWRM_CFA_ENCAP_RECORD_ALLOC_INPUT_ENCAP_TYPE_GENEVE	UINT32_C(0x5)
	/* Multi-Protocol Label Switching (MPLS) */
	#define HWRM_CFA_ENCAP_RECORD_ALLOC_INPUT_ENCAP_TYPE_MPLS	UINT32_C(0x6)
	/* VLAN */
	#define HWRM_CFA_ENCAP_RECORD_ALLOC_INPUT_ENCAP_TYPE_VLAN	UINT32_C(0x7)
	/* Generic Routing Encapsulation (GRE) inside IP datagram payload */
	#define HWRM_CFA_ENCAP_RECORD_ALLOC_INPUT_ENCAP_TYPE_IPGRE	UINT32_C(0x8)
	/* IPV4 over virtual eXtensible Local Area Network (IPV4oVXLAN) */
	#define HWRM_CFA_ENCAP_RECORD_ALLOC_INPUT_ENCAP_TYPE_VXLAN_V4	UINT32_C(0x9)
	/*
	 * Enhance Generic Routing Encapsulation (GRE version 1) inside IP
	 * datagram payload
	 */
	#define HWRM_CFA_ENCAP_RECORD_ALLOC_INPUT_ENCAP_TYPE_IPGRE_V1	UINT32_C(0xa)
	/* Use fixed layer 2 ether type of 0xFFFF */
	#define HWRM_CFA_ENCAP_RECORD_ALLOC_INPUT_ENCAP_TYPE_L2_ETYPE	UINT32_C(0xb)
	/*
	 * IPV6 over virtual eXtensible Local Area Network with GPE header
	 * (IPV6oVXLANGPE)
	 */
	#define HWRM_CFA_ENCAP_RECORD_ALLOC_INPUT_ENCAP_TYPE_VXLAN_GPE_V6 UINT32_C(0xc)
	#define HWRM_CFA_ENCAP_RECORD_ALLOC_INPUT_ENCAP_TYPE_LAST	HWRM_CFA_ENCAP_RECORD_ALLOC_INPUT_ENCAP_TYPE_VXLAN_GPE_V6
	uint8_t	unused_0[3];
	/* This value is encap data used for the given encap type. */
	uint32_t	encap_data[20];
} hwrm_cfa_encap_record_alloc_input_t, *phwrm_cfa_encap_record_alloc_input_t;

/* hwrm_cfa_encap_record_alloc_output (size:128b/16B) */

typedef struct hwrm_cfa_encap_record_alloc_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* This value is an opaque id into CFA data structures. */
	uint32_t	encap_record_id;
	uint8_t	unused_0[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_cfa_encap_record_alloc_output_t, *phwrm_cfa_encap_record_alloc_output_t;

/******************************
 * hwrm_cfa_encap_record_free *
 ******************************/


/* hwrm_cfa_encap_record_free_input (size:192b/24B) */

typedef struct hwrm_cfa_encap_record_free_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* This value is an opaque id into CFA data structures. */
	uint32_t	encap_record_id;
	uint8_t	unused_0[4];
} hwrm_cfa_encap_record_free_input_t, *phwrm_cfa_encap_record_free_input_t;

/* hwrm_cfa_encap_record_free_output (size:128b/16B) */

typedef struct hwrm_cfa_encap_record_free_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_cfa_encap_record_free_output_t, *phwrm_cfa_encap_record_free_output_t;

/********************************
 * hwrm_cfa_ntuple_filter_alloc *
 ********************************/


/* hwrm_cfa_ntuple_filter_alloc_input (size:1024b/128B) */

typedef struct hwrm_cfa_ntuple_filter_alloc_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	flags;
	/*
	 * Setting of this flag indicates the applicability to the loopback
	 * path.
	 */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_FLAGS_LOOPBACK		UINT32_C(0x1)
	/*
	 * Setting of this flag indicates drop action. If this flag is not
	 * set, then it should be considered accept action.
	 */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_FLAGS_DROP		UINT32_C(0x2)
	/*
	 * Setting of this flag indicates that a meter is expected to be
	 * attached to this flow. This hint can be used when choosing the
	 * action record format required for the flow.
	 */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_FLAGS_METER		UINT32_C(0x4)
	/*
	 * Setting of this flag indicates that the dst_id field contains
	 * function ID. If this is not set it indicates dest_id is VNIC
	 * or VPORT.
	 */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_FLAGS_DEST_FID		UINT32_C(0x8)
	/*
	 * Setting of this flag indicates match on arp reply when ethertype
	 * is 0x0806. If this is not set it indicates no specific arp opcode
	 * matching.
	 */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_FLAGS_ARP_REPLY		UINT32_C(0x10)
	/*
	 * Setting of this flag indicates that the dst_id field contains RFS
	 * ring table index. If this is not set it indicates dst_id is VNIC
	 * or VPORT or function ID.  Note dest_fid and dest_rfs_ring_idx
	 * can’t be set at the same time.
	 */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_FLAGS_DEST_RFS_RING_IDX	UINT32_C(0x20)
	uint32_t	enables;
	/*
	 * This bit must be '1' for the l2_filter_id field to be
	 * configured.
	 */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_ENABLES_L2_FILTER_ID	UINT32_C(0x1)
	/*
	 * This bit must be '1' for the ethertype field to be
	 * configured.
	 */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_ENABLES_ETHERTYPE		UINT32_C(0x2)
	/*
	 * This bit must be '1' for the tunnel_type field to be
	 * configured.
	 */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_ENABLES_TUNNEL_TYPE	UINT32_C(0x4)
	/*
	 * This bit must be '1' for the src_macaddr field to be
	 * configured.
	 */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_ENABLES_SRC_MACADDR	UINT32_C(0x8)
	/*
	 * This bit must be '1' for the ipaddr_type field to be
	 * configured.
	 */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_ENABLES_IPADDR_TYPE	UINT32_C(0x10)
	/*
	 * This bit must be '1' for the src_ipaddr field to be
	 * configured.
	 */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_ENABLES_SRC_IPADDR	UINT32_C(0x20)
	/*
	 * This bit must be '1' for the src_ipaddr_mask field to be
	 * configured.
	 */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_ENABLES_SRC_IPADDR_MASK	UINT32_C(0x40)
	/*
	 * This bit must be '1' for the dst_ipaddr field to be
	 * configured.
	 */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_ENABLES_DST_IPADDR	UINT32_C(0x80)
	/*
	 * This bit must be '1' for the dst_ipaddr_mask field to be
	 * configured.
	 */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_ENABLES_DST_IPADDR_MASK	UINT32_C(0x100)
	/*
	 * This bit must be '1' for the ip_protocol field to be
	 * configured.
	 */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_ENABLES_IP_PROTOCOL	UINT32_C(0x200)
	/*
	 * This bit must be '1' for the src_port field to be
	 * configured.
	 */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_ENABLES_SRC_PORT		UINT32_C(0x400)
	/*
	 * This bit must be '1' for the src_port_mask field to be
	 * configured.
	 */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_ENABLES_SRC_PORT_MASK	UINT32_C(0x800)
	/*
	 * This bit must be '1' for the dst_port field to be
	 * configured.
	 */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_ENABLES_DST_PORT		UINT32_C(0x1000)
	/*
	 * This bit must be '1' for the dst_port_mask field to be
	 * configured.
	 */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_ENABLES_DST_PORT_MASK	UINT32_C(0x2000)
	/*
	 * This bit must be '1' for the pri_hint field to be
	 * configured.
	 */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_ENABLES_PRI_HINT		UINT32_C(0x4000)
	/*
	 * This bit must be '1' for the ntuple_filter_id field to be
	 * configured.
	 */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_ENABLES_NTUPLE_FILTER_ID	UINT32_C(0x8000)
	/*
	 * This bit must be '1' for the dst_id field to be
	 * configured.
	 */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_ENABLES_DST_ID		UINT32_C(0x10000)
	/*
	 * This bit must be '1' for the mirror_vnic_id field to be
	 * configured.
	 */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_ENABLES_MIRROR_VNIC_ID	UINT32_C(0x20000)
	/*
	 * This bit must be '1' for the dst_macaddr field to be
	 * configured.
	 */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_ENABLES_DST_MACADDR	UINT32_C(0x40000)
	/* This flag is deprecated. */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_ENABLES_RFS_RING_TBL_IDX	UINT32_C(0x80000)
	/*
	 * This value identifies a set of CFA data structures used for an L2
	 * context.
	 */
	uint64_t	l2_filter_id;
	/*
	 * This value indicates the source MAC address in
	 * the Ethernet header.
	 */
	uint8_t	src_macaddr[6];
	/* This value indicates the ethertype in the Ethernet header. */
	uint16_t	ethertype;
	/*
	 * This value indicates the type of IP address.
	 * 4 - IPv4
	 * 6 - IPv6
	 * All others are invalid.
	 */
	uint8_t	ip_addr_type;
	/* invalid */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_IP_ADDR_TYPE_UNKNOWN UINT32_C(0x0)
	/* IPv4 */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_IP_ADDR_TYPE_IPV4	UINT32_C(0x4)
	/* IPv6 */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_IP_ADDR_TYPE_IPV6	UINT32_C(0x6)
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_IP_ADDR_TYPE_LAST   HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_IP_ADDR_TYPE_IPV6
	/*
	 * The value of protocol filed in IP header.
	 * Applies to UDP and TCP traffic.
	 * 6 - TCP
	 * 17 - UDP
	 */
	uint8_t	ip_protocol;
	/* invalid */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_IP_PROTOCOL_UNKNOWN UINT32_C(0x0)
	/* TCP */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_IP_PROTOCOL_TCP	UINT32_C(0x6)
	/* UDP */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_IP_PROTOCOL_UDP	UINT32_C(0x11)
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_IP_PROTOCOL_LAST   HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_IP_PROTOCOL_UDP
	/*
	 * If set, this value shall represent the
	 * Logical VNIC ID of the destination VNIC for the RX
	 * path and network port id of the destination port for
	 * the TX path.
	 */
	uint16_t	dst_id;
	/*
	 * Logical VNIC ID of the VNIC where traffic is
	 * mirrored.
	 */
	uint16_t	mirror_vnic_id;
	/*
	 * This value indicates the tunnel type for this filter.
	 * If this field is not specified, then the filter shall
	 * apply to both non-tunneled and tunneled packets.
	 * If this field conflicts with the tunnel_type specified
	 * in the l2_filter_id, then the HWRM shall return an
	 * error for this command.
	 */
	uint8_t	tunnel_type;
	/* Non-tunnel */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_TUNNEL_TYPE_NONTUNNEL	UINT32_C(0x0)
	/* Virtual eXtensible Local Area Network (VXLAN) */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_TUNNEL_TYPE_VXLAN	UINT32_C(0x1)
	/* Network Virtualization Generic Routing Encapsulation (NVGRE) */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_TUNNEL_TYPE_NVGRE	UINT32_C(0x2)
	/* Generic Routing Encapsulation (GRE) inside Ethernet payload */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_TUNNEL_TYPE_L2GRE	UINT32_C(0x3)
	/* IP in IP */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_TUNNEL_TYPE_IPIP	UINT32_C(0x4)
	/* Generic Network Virtualization Encapsulation (Geneve) */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_TUNNEL_TYPE_GENEVE	UINT32_C(0x5)
	/* Multi-Protocol Label Switching (MPLS) */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_TUNNEL_TYPE_MPLS	UINT32_C(0x6)
	/* Stateless Transport Tunnel (STT) */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_TUNNEL_TYPE_STT	UINT32_C(0x7)
	/* Generic Routing Encapsulation (GRE) inside IP datagram payload */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_TUNNEL_TYPE_IPGRE	UINT32_C(0x8)
	/* IPV4 over virtual eXtensible Local Area Network (IPV4oVXLAN) */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_TUNNEL_TYPE_VXLAN_V4	UINT32_C(0x9)
	/*
	 * Enhance Generic Routing Encapsulation (GRE version 1) inside IP
	 * datagram payload
	 */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_TUNNEL_TYPE_IPGRE_V1	UINT32_C(0xa)
	/* Use fixed layer 2 ether type of 0xFFFF */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_TUNNEL_TYPE_L2_ETYPE	UINT32_C(0xb)
	/*
	 * IPV6 over virtual eXtensible Local Area Network with GPE header
	 * (IPV6oVXLANGPE)
	 */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_TUNNEL_TYPE_VXLAN_GPE_V6 UINT32_C(0xc)
	/* Any tunneled traffic */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_TUNNEL_TYPE_ANYTUNNEL	UINT32_C(0xff)
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_TUNNEL_TYPE_LAST	HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_TUNNEL_TYPE_ANYTUNNEL
	/*
	 * This hint is provided to help in placing
	 * the filter in the filter table.
	 */
	uint8_t	pri_hint;
	/* No preference */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_PRI_HINT_NO_PREFER UINT32_C(0x0)
	/* Above the given filter */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_PRI_HINT_ABOVE	UINT32_C(0x1)
	/* Below the given filter */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_PRI_HINT_BELOW	UINT32_C(0x2)
	/* As high as possible */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_PRI_HINT_HIGHEST   UINT32_C(0x3)
	/* As low as possible */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_PRI_HINT_LOWEST	UINT32_C(0x4)
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_PRI_HINT_LAST	HWRM_CFA_NTUPLE_FILTER_ALLOC_INPUT_PRI_HINT_LOWEST
	/*
	 * The value of source IP address to be used in filtering.
	 * For IPv4, first four bytes represent the IP address.
	 */
	uint32_t	src_ipaddr[4];
	/*
	 * The value of source IP address mask to be used in
	 * filtering.
	 * For IPv4, first four bytes represent the IP address mask.
	 */
	uint32_t	src_ipaddr_mask[4];
	/*
	 * The value of destination IP address to be used in filtering.
	 * For IPv4, first four bytes represent the IP address.
	 */
	uint32_t	dst_ipaddr[4];
	/*
	 * The value of destination IP address mask to be used in
	 * filtering.
	 * For IPv4, first four bytes represent the IP address mask.
	 */
	uint32_t	dst_ipaddr_mask[4];
	/*
	 * The value of source port to be used in filtering.
	 * Applies to UDP and TCP traffic.
	 */
	uint16_t	src_port;
	/*
	 * The value of source port mask to be used in filtering.
	 * Applies to UDP and TCP traffic.
	 */
	uint16_t	src_port_mask;
	/*
	 * The value of destination port to be used in filtering.
	 * Applies to UDP and TCP traffic.
	 */
	uint16_t	dst_port;
	/*
	 * The value of destination port mask to be used in
	 * filtering.
	 * Applies to UDP and TCP traffic.
	 */
	uint16_t	dst_port_mask;
	/*
	 * This is the ID of the filter that goes along with
	 * the pri_hint.
	 */
	uint64_t	ntuple_filter_id_hint;
} hwrm_cfa_ntuple_filter_alloc_input_t, *phwrm_cfa_ntuple_filter_alloc_input_t;

/* hwrm_cfa_ntuple_filter_alloc_output (size:192b/24B) */

typedef struct hwrm_cfa_ntuple_filter_alloc_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* This value is an opaque id into CFA data structures. */
	uint64_t	ntuple_filter_id;
	/*
	 * The flow id value in bit 0-29 is the actual ID of the flow
	 * associated with this filter and it shall be used to match
	 * and associate the flow identifier returned in completion
	 * records. A value of 0xFFFFFFFF in the 32-bit flow_id field
	 * shall indicate no valid flow id.
	 */
	uint32_t	flow_id;
	/* Indicate the flow id value. */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_OUTPUT_FLOW_ID_VALUE_MASK UINT32_C(0x3fffffff)
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_OUTPUT_FLOW_ID_VALUE_SFT 0
	/* Indicate type of the flow. */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_OUTPUT_FLOW_ID_TYPE	UINT32_C(0x40000000)
	/*
	 * If this bit set to 0, then it indicates that the flow is
	 * internal flow.
	 */
		#define HWRM_CFA_NTUPLE_FILTER_ALLOC_OUTPUT_FLOW_ID_TYPE_INT	(UINT32_C(0x0) << 30)
	/*
	 * If this bit is set to 1, then it indicates that the flow is
	 * external flow.
	 */
		#define HWRM_CFA_NTUPLE_FILTER_ALLOC_OUTPUT_FLOW_ID_TYPE_EXT	(UINT32_C(0x1) << 30)
		#define HWRM_CFA_NTUPLE_FILTER_ALLOC_OUTPUT_FLOW_ID_TYPE_LAST  HWRM_CFA_NTUPLE_FILTER_ALLOC_OUTPUT_FLOW_ID_TYPE_EXT
	/* Indicate the flow direction. */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_OUTPUT_FLOW_ID_DIR	UINT32_C(0x80000000)
	/* If this bit set to 0, then it indicates rx flow. */
		#define HWRM_CFA_NTUPLE_FILTER_ALLOC_OUTPUT_FLOW_ID_DIR_RX	(UINT32_C(0x0) << 31)
	/* If this bit is set to 1, then it indicates that tx flow. */
		#define HWRM_CFA_NTUPLE_FILTER_ALLOC_OUTPUT_FLOW_ID_DIR_TX	(UINT32_C(0x1) << 31)
		#define HWRM_CFA_NTUPLE_FILTER_ALLOC_OUTPUT_FLOW_ID_DIR_LAST   HWRM_CFA_NTUPLE_FILTER_ALLOC_OUTPUT_FLOW_ID_DIR_TX
	uint8_t	unused_0[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_cfa_ntuple_filter_alloc_output_t, *phwrm_cfa_ntuple_filter_alloc_output_t;

/* hwrm_cfa_ntuple_filter_alloc_cmd_err (size:64b/8B) */

typedef struct hwrm_cfa_ntuple_filter_alloc_cmd_err {
	/*
	 * command specific error codes that goes to
	 * the cmd_err field in Common HWRM Error Response.
	 */
	uint8_t	code;
	/* Unknown error */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_CMD_ERR_CODE_UNKNOWN		UINT32_C(0x0)
	/* Unable to complete operation due to conflict with Rx Mask VLAN */
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_CMD_ERR_CODE_RX_MASK_VLAN_CONFLICT_ERR UINT32_C(0x1)
	#define HWRM_CFA_NTUPLE_FILTER_ALLOC_CMD_ERR_CODE_LAST			HWRM_CFA_NTUPLE_FILTER_ALLOC_CMD_ERR_CODE_RX_MASK_VLAN_CONFLICT_ERR
	uint8_t	unused_0[7];
} hwrm_cfa_ntuple_filter_alloc_cmd_err_t, *phwrm_cfa_ntuple_filter_alloc_cmd_err_t;

/*******************************
 * hwrm_cfa_ntuple_filter_free *
 *******************************/


/* hwrm_cfa_ntuple_filter_free_input (size:192b/24B) */

typedef struct hwrm_cfa_ntuple_filter_free_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* This value is an opaque id into CFA data structures. */
	uint64_t	ntuple_filter_id;
} hwrm_cfa_ntuple_filter_free_input_t, *phwrm_cfa_ntuple_filter_free_input_t;

/* hwrm_cfa_ntuple_filter_free_output (size:128b/16B) */

typedef struct hwrm_cfa_ntuple_filter_free_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_cfa_ntuple_filter_free_output_t, *phwrm_cfa_ntuple_filter_free_output_t;

/******************************
 * hwrm_cfa_ntuple_filter_cfg *
 ******************************/


/* hwrm_cfa_ntuple_filter_cfg_input (size:384b/48B) */

typedef struct hwrm_cfa_ntuple_filter_cfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	enables;
	/*
	 * This bit must be '1' for the new_dst_id field to be
	 * configured.
	 */
	#define HWRM_CFA_NTUPLE_FILTER_CFG_INPUT_ENABLES_NEW_DST_ID		UINT32_C(0x1)
	/*
	 * This bit must be '1' for the new_mirror_vnic_id field to be
	 * configured.
	 */
	#define HWRM_CFA_NTUPLE_FILTER_CFG_INPUT_ENABLES_NEW_MIRROR_VNIC_ID	UINT32_C(0x2)
	/*
	 * This bit must be '1' for the new_meter_instance_id field to be
	 * configured.
	 */
	#define HWRM_CFA_NTUPLE_FILTER_CFG_INPUT_ENABLES_NEW_METER_INSTANCE_ID	UINT32_C(0x4)
	uint32_t	flags;
	/*
	 * Setting this bit to 1 indicates that dest_id field contains FID.
	 * Setting this to 0 indicates that dest_id field contains VNIC or
	 * VPORT.
	 */
	#define HWRM_CFA_NTUPLE_FILTER_CFG_INPUT_FLAGS_DEST_FID		UINT32_C(0x1)
	/*
	 * Setting of this flag indicates that the new_dst_id field contains
	 * RFS ring table index. If this is not set it indicates new_dst_id
	 * is VNIC or VPORT or function ID.  Note dest_fid and
	 * dest_rfs_ring_idx can’t be set at the same time.
	 */
	#define HWRM_CFA_NTUPLE_FILTER_CFG_INPUT_FLAGS_DEST_RFS_RING_IDX	UINT32_C(0x2)
	/* This value is an opaque id into CFA data structures. */
	uint64_t	ntuple_filter_id;
	/*
	 * If set, this value shall represent the new
	 * Logical VNIC ID of the destination VNIC for the RX
	 * path and new network port id of the destination port for
	 * the TX path.
	 */
	uint32_t	new_dst_id;
	/*
	 * New Logical VNIC ID of the VNIC where traffic is
	 * mirrored.
	 */
	uint32_t	new_mirror_vnic_id;
	/*
	 * New meter to attach to the flow. Specifying the
	 * invalid instance ID is used to remove any existing
	 * meter from the flow.
	 */
	uint16_t	new_meter_instance_id;
	/*
	 * A value of 0xfff is considered invalid and implies the
	 * instance is not configured.
	 */
	#define HWRM_CFA_NTUPLE_FILTER_CFG_INPUT_NEW_METER_INSTANCE_ID_INVALID UINT32_C(0xffff)
	#define HWRM_CFA_NTUPLE_FILTER_CFG_INPUT_NEW_METER_INSTANCE_ID_LAST   HWRM_CFA_NTUPLE_FILTER_CFG_INPUT_NEW_METER_INSTANCE_ID_INVALID
	uint8_t	unused_1[6];
} hwrm_cfa_ntuple_filter_cfg_input_t, *phwrm_cfa_ntuple_filter_cfg_input_t;

/* hwrm_cfa_ntuple_filter_cfg_output (size:128b/16B) */

typedef struct hwrm_cfa_ntuple_filter_cfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_cfa_ntuple_filter_cfg_output_t, *phwrm_cfa_ntuple_filter_cfg_output_t;

/**************************
 * hwrm_cfa_em_flow_alloc *
 **************************/


/* hwrm_cfa_em_flow_alloc_input (size:896b/112B) */

typedef struct hwrm_cfa_em_flow_alloc_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	flags;
	/*
	 * Enumeration denoting the RX, TX type of the resource.
	 * This enumeration is used for resources that are similar for both
	 * TX and RX paths of the chip.
	 */
	#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_FLAGS_PATH	UINT32_C(0x1)
	/* tx path */
		#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_FLAGS_PATH_TX	UINT32_C(0x0)
	/* rx path */
		#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_FLAGS_PATH_RX	UINT32_C(0x1)
		#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_FLAGS_PATH_LAST	HWRM_CFA_EM_FLOW_ALLOC_INPUT_FLAGS_PATH_RX
	/*
	 * Setting of this flag indicates enabling of a byte counter for a
	 * given flow.
	 */
	#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_FLAGS_BYTE_CTR	UINT32_C(0x2)
	/*
	 * Setting of this flag indicates enabling of a packet counter for a
	 * given flow.
	 */
	#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_FLAGS_PKT_CTR	UINT32_C(0x4)
	/*
	 * Setting of this flag indicates de-capsulation action for the
	 * given flow.
	 */
	#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_FLAGS_DECAP	UINT32_C(0x8)
	/*
	 * Setting of this flag indicates encapsulation action for the
	 * given flow.
	 */
	#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_FLAGS_ENCAP	UINT32_C(0x10)
	/*
	 * Setting of this flag indicates drop action. If this flag is not
	 * set, then it should be considered accept action.
	 */
	#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_FLAGS_DROP	UINT32_C(0x20)
	/*
	 * Setting of this flag indicates that a meter is expected to be
	 * attached to this flow. This hint can be used when choosing the
	 * action record format required for the flow.
	 */
	#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_FLAGS_METER	UINT32_C(0x40)
	uint32_t	enables;
	/*
	 * This bit must be '1' for the l2_filter_id field to be
	 * configured.
	 */
	#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_ENABLES_L2_FILTER_ID	UINT32_C(0x1)
	/*
	 * This bit must be '1' for the tunnel_type field to be
	 * configured.
	 */
	#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_ENABLES_TUNNEL_TYPE	UINT32_C(0x2)
	/*
	 * This bit must be '1' for the tunnel_id field to be
	 * configured.
	 */
	#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_ENABLES_TUNNEL_ID		UINT32_C(0x4)
	/*
	 * This bit must be '1' for the src_macaddr field to be
	 * configured.
	 */
	#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_ENABLES_SRC_MACADDR	UINT32_C(0x8)
	/*
	 * This bit must be '1' for the dst_macaddr field to be
	 * configured.
	 */
	#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_ENABLES_DST_MACADDR	UINT32_C(0x10)
	/*
	 * This bit must be '1' for the ovlan_vid field to be
	 * configured.
	 */
	#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_ENABLES_OVLAN_VID		UINT32_C(0x20)
	/*
	 * This bit must be '1' for the ivlan_vid field to be
	 * configured.
	 */
	#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_ENABLES_IVLAN_VID		UINT32_C(0x40)
	/*
	 * This bit must be '1' for the ethertype field to be
	 * configured.
	 */
	#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_ENABLES_ETHERTYPE		UINT32_C(0x80)
	/*
	 * This bit must be '1' for the src_ipaddr field to be
	 * configured.
	 */
	#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_ENABLES_SRC_IPADDR		UINT32_C(0x100)
	/*
	 * This bit must be '1' for the dst_ipaddr field to be
	 * configured.
	 */
	#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_ENABLES_DST_IPADDR		UINT32_C(0x200)
	/*
	 * This bit must be '1' for the ipaddr_type field to be
	 * configured.
	 */
	#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_ENABLES_IPADDR_TYPE	UINT32_C(0x400)
	/*
	 * This bit must be '1' for the ip_protocol field to be
	 * configured.
	 */
	#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_ENABLES_IP_PROTOCOL	UINT32_C(0x800)
	/*
	 * This bit must be '1' for the src_port field to be
	 * configured.
	 */
	#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_ENABLES_SRC_PORT		UINT32_C(0x1000)
	/*
	 * This bit must be '1' for the dst_port field to be
	 * configured.
	 */
	#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_ENABLES_DST_PORT		UINT32_C(0x2000)
	/*
	 * This bit must be '1' for the dst_id field to be
	 * configured.
	 */
	#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_ENABLES_DST_ID		UINT32_C(0x4000)
	/*
	 * This bit must be '1' for the mirror_vnic_id field to be
	 * configured.
	 */
	#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_ENABLES_MIRROR_VNIC_ID	UINT32_C(0x8000)
	/*
	 * This bit must be '1' for the encap_record_id field to be
	 * configured.
	 */
	#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_ENABLES_ENCAP_RECORD_ID	UINT32_C(0x10000)
	/*
	 * This bit must be '1' for the meter_instance_id field to be
	 * configured.
	 */
	#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_ENABLES_METER_INSTANCE_ID	UINT32_C(0x20000)
	/*
	 * This value identifies a set of CFA data structures used for an L2
	 * context.
	 */
	uint64_t	l2_filter_id;
	/* Tunnel Type. */
	uint8_t	tunnel_type;
	/* Non-tunnel */
	#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_TUNNEL_TYPE_NONTUNNEL	UINT32_C(0x0)
	/* Virtual eXtensible Local Area Network (VXLAN) */
	#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_TUNNEL_TYPE_VXLAN	UINT32_C(0x1)
	/* Network Virtualization Generic Routing Encapsulation (NVGRE) */
	#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_TUNNEL_TYPE_NVGRE	UINT32_C(0x2)
	/* Generic Routing Encapsulation (GRE) inside Ethernet payload */
	#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_TUNNEL_TYPE_L2GRE	UINT32_C(0x3)
	/* IP in IP */
	#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_TUNNEL_TYPE_IPIP	UINT32_C(0x4)
	/* Generic Network Virtualization Encapsulation (Geneve) */
	#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_TUNNEL_TYPE_GENEVE	UINT32_C(0x5)
	/* Multi-Protocol Label Switching (MPLS) */
	#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_TUNNEL_TYPE_MPLS	UINT32_C(0x6)
	/* Stateless Transport Tunnel (STT) */
	#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_TUNNEL_TYPE_STT	UINT32_C(0x7)
	/* Generic Routing Encapsulation (GRE) inside IP datagram payload */
	#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_TUNNEL_TYPE_IPGRE	UINT32_C(0x8)
	/* IPV4 over virtual eXtensible Local Area Network (IPV4oVXLAN) */
	#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_TUNNEL_TYPE_VXLAN_V4	UINT32_C(0x9)
	/*
	 * Enhance Generic Routing Encapsulation (GRE version 1) inside IP
	 * datagram payload
	 */
	#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_TUNNEL_TYPE_IPGRE_V1	UINT32_C(0xa)
	/* Use fixed layer 2 ether type of 0xFFFF */
	#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_TUNNEL_TYPE_L2_ETYPE	UINT32_C(0xb)
	/*
	 * IPV6 over virtual eXtensible Local Area Network with GPE header
	 * (IPV6oVXLANGPE)
	 */
	#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_TUNNEL_TYPE_VXLAN_GPE_V6 UINT32_C(0xc)
	/* Any tunneled traffic */
	#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_TUNNEL_TYPE_ANYTUNNEL	UINT32_C(0xff)
	#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_TUNNEL_TYPE_LAST	HWRM_CFA_EM_FLOW_ALLOC_INPUT_TUNNEL_TYPE_ANYTUNNEL
	uint8_t	unused_0[3];
	/*
	 * Tunnel identifier.
	 * Virtual Network Identifier (VNI). Only valid with
	 * tunnel_types VXLAN, NVGRE, and Geneve.
	 * Only lower 24-bits of VNI field are used
	 * in setting up the filter.
	 */
	uint32_t	tunnel_id;
	/*
	 * This value indicates the source MAC address in
	 * the Ethernet header.
	 */
	uint8_t	src_macaddr[6];
	/* The meter instance to attach to the flow. */
	uint16_t	meter_instance_id;
	/*
	 * A value of 0xfff is considered invalid and implies the
	 * instance is not configured.
	 */
	#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_METER_INSTANCE_ID_INVALID UINT32_C(0xffff)
	#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_METER_INSTANCE_ID_LAST   HWRM_CFA_EM_FLOW_ALLOC_INPUT_METER_INSTANCE_ID_INVALID
	/*
	 * This value indicates the destination MAC address in
	 * the Ethernet header.
	 */
	uint8_t	dst_macaddr[6];
	/*
	 * This value indicates the VLAN ID of the outer VLAN tag
	 * in the Ethernet header.
	 */
	uint16_t	ovlan_vid;
	/*
	 * This value indicates the VLAN ID of the inner VLAN tag
	 * in the Ethernet header.
	 */
	uint16_t	ivlan_vid;
	/* This value indicates the ethertype in the Ethernet header. */
	uint16_t	ethertype;
	/*
	 * This value indicates the type of IP address.
	 * 4 - IPv4
	 * 6 - IPv6
	 * All others are invalid.
	 */
	uint8_t	ip_addr_type;
	/* invalid */
	#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_IP_ADDR_TYPE_UNKNOWN UINT32_C(0x0)
	/* IPv4 */
	#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_IP_ADDR_TYPE_IPV4	UINT32_C(0x4)
	/* IPv6 */
	#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_IP_ADDR_TYPE_IPV6	UINT32_C(0x6)
	#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_IP_ADDR_TYPE_LAST   HWRM_CFA_EM_FLOW_ALLOC_INPUT_IP_ADDR_TYPE_IPV6
	/*
	 * The value of protocol filed in IP header.
	 * Applies to UDP and TCP traffic.
	 * 6 - TCP
	 * 17 - UDP
	 */
	uint8_t	ip_protocol;
	/* invalid */
	#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_IP_PROTOCOL_UNKNOWN UINT32_C(0x0)
	/* TCP */
	#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_IP_PROTOCOL_TCP	UINT32_C(0x6)
	/* UDP */
	#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_IP_PROTOCOL_UDP	UINT32_C(0x11)
	#define HWRM_CFA_EM_FLOW_ALLOC_INPUT_IP_PROTOCOL_LAST   HWRM_CFA_EM_FLOW_ALLOC_INPUT_IP_PROTOCOL_UDP
	uint8_t	unused_1[2];
	/*
	 * The value of source IP address to be used in filtering.
	 * For IPv4, first four bytes represent the IP address.
	 */
	uint32_t	src_ipaddr[4];
	/*
	 * big_endian = True
	 *	The value of destination IP address to be used in filtering.
	 *	For IPv4, first four bytes represent the IP address.
	 */
	uint32_t	dst_ipaddr[4];
	/*
	 * The value of source port to be used in filtering.
	 * Applies to UDP and TCP traffic.
	 */
	uint16_t	src_port;
	/*
	 * The value of destination port to be used in filtering.
	 * Applies to UDP and TCP traffic.
	 */
	uint16_t	dst_port;
	/*
	 * If set, this value shall represent the
	 * Logical VNIC ID of the destination VNIC for the RX
	 * path and network port id of the destination port for
	 * the TX path.
	 */
	uint16_t	dst_id;
	/*
	 * Logical VNIC ID of the VNIC where traffic is
	 * mirrored.
	 */
	uint16_t	mirror_vnic_id;
	/* Logical ID of the encapsulation record. */
	uint32_t	encap_record_id;
	uint8_t	unused_2[4];
} hwrm_cfa_em_flow_alloc_input_t, *phwrm_cfa_em_flow_alloc_input_t;

/* hwrm_cfa_em_flow_alloc_output (size:192b/24B) */

typedef struct hwrm_cfa_em_flow_alloc_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* This value is an opaque id into CFA data structures. */
	uint64_t	em_filter_id;
	/*
	 * The flow id value in bit 0-29 is the actual ID of the flow
	 * associated with this filter and it shall be used to match
	 * and associate the flow identifier returned in completion
	 * records. A value of 0xFFFFFFFF in the 32-bit flow_id field
	 * shall indicate no valid flow id.
	 */
	uint32_t	flow_id;
	/* Indicate the flow id value. */
	#define HWRM_CFA_EM_FLOW_ALLOC_OUTPUT_FLOW_ID_VALUE_MASK UINT32_C(0x3fffffff)
	#define HWRM_CFA_EM_FLOW_ALLOC_OUTPUT_FLOW_ID_VALUE_SFT 0
	/* Indicate type of the flow. */
	#define HWRM_CFA_EM_FLOW_ALLOC_OUTPUT_FLOW_ID_TYPE	UINT32_C(0x40000000)
	/*
	 * If this bit set to 0, then it indicates that the flow is
	 * internal flow.
	 */
		#define HWRM_CFA_EM_FLOW_ALLOC_OUTPUT_FLOW_ID_TYPE_INT	(UINT32_C(0x0) << 30)
	/*
	 * If this bit is set to 1, then it indicates that the flow is
	 * external flow.
	 */
		#define HWRM_CFA_EM_FLOW_ALLOC_OUTPUT_FLOW_ID_TYPE_EXT	(UINT32_C(0x1) << 30)
		#define HWRM_CFA_EM_FLOW_ALLOC_OUTPUT_FLOW_ID_TYPE_LAST  HWRM_CFA_EM_FLOW_ALLOC_OUTPUT_FLOW_ID_TYPE_EXT
	/* Indicate the flow direction. */
	#define HWRM_CFA_EM_FLOW_ALLOC_OUTPUT_FLOW_ID_DIR	UINT32_C(0x80000000)
	/* If this bit set to 0, then it indicates rx flow. */
		#define HWRM_CFA_EM_FLOW_ALLOC_OUTPUT_FLOW_ID_DIR_RX	(UINT32_C(0x0) << 31)
	/* If this bit is set to 1, then it indicates that tx flow. */
		#define HWRM_CFA_EM_FLOW_ALLOC_OUTPUT_FLOW_ID_DIR_TX	(UINT32_C(0x1) << 31)
		#define HWRM_CFA_EM_FLOW_ALLOC_OUTPUT_FLOW_ID_DIR_LAST   HWRM_CFA_EM_FLOW_ALLOC_OUTPUT_FLOW_ID_DIR_TX
	uint8_t	unused_0[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_cfa_em_flow_alloc_output_t, *phwrm_cfa_em_flow_alloc_output_t;

/*************************
 * hwrm_cfa_em_flow_free *
 *************************/


/* hwrm_cfa_em_flow_free_input (size:192b/24B) */

typedef struct hwrm_cfa_em_flow_free_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* This value is an opaque id into CFA data structures. */
	uint64_t	em_filter_id;
} hwrm_cfa_em_flow_free_input_t, *phwrm_cfa_em_flow_free_input_t;

/* hwrm_cfa_em_flow_free_output (size:128b/16B) */

typedef struct hwrm_cfa_em_flow_free_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_cfa_em_flow_free_output_t, *phwrm_cfa_em_flow_free_output_t;

/************************
 * hwrm_cfa_meter_qcaps *
 ************************/


/* hwrm_cfa_meter_qcaps_input (size:128b/16B) */

typedef struct hwrm_cfa_meter_qcaps_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
} hwrm_cfa_meter_qcaps_input_t, *phwrm_cfa_meter_qcaps_input_t;

/* hwrm_cfa_meter_qcaps_output (size:320b/40B) */

typedef struct hwrm_cfa_meter_qcaps_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint32_t	flags;
	/*
	 * Enumeration denoting the clock at which the Meter is running
	 * with. This enumeration is used for resources that are similar
	 * for both TX and RX paths of the chip.
	 */
	#define HWRM_CFA_METER_QCAPS_OUTPUT_FLAGS_CLOCK_MASK  UINT32_C(0xf)
	#define HWRM_CFA_METER_QCAPS_OUTPUT_FLAGS_CLOCK_SFT   0
	/* 375 MHz */
		#define HWRM_CFA_METER_QCAPS_OUTPUT_FLAGS_CLOCK_375MHZ  UINT32_C(0x0)
	/* 625 MHz */
		#define HWRM_CFA_METER_QCAPS_OUTPUT_FLAGS_CLOCK_625MHZ  UINT32_C(0x1)
		#define HWRM_CFA_METER_QCAPS_OUTPUT_FLAGS_CLOCK_LAST   HWRM_CFA_METER_QCAPS_OUTPUT_FLAGS_CLOCK_625MHZ
	uint8_t	unused_0[4];
	/*
	 * The minimum guaranteed number of tx meter profiles supported
	 * for this function.
	 */
	uint16_t	min_tx_profile;
	/*
	 * The maximum non-guaranteed number of tx meter profiles supported
	 * for this function.
	 */
	uint16_t	max_tx_profile;
	/*
	 * The minimum guaranteed number of rx meter profiles supported
	 * for this function.
	 */
	uint16_t	min_rx_profile;
	/*
	 * The maximum non-guaranteed number of rx meter profiles supported
	 * for this function.
	 */
	uint16_t	max_rx_profile;
	/*
	 * The minimum guaranteed number of tx meter instances supported
	 * for this function.
	 */
	uint16_t	min_tx_instance;
	/*
	 * The maximum non-guaranteed number of tx meter instances supported
	 * for this function.
	 */
	uint16_t	max_tx_instance;
	/*
	 * The minimum guaranteed number of rx meter instances supported
	 * for this function.
	 */
	uint16_t	min_rx_instance;
	/*
	 * The maximum non-guaranteed number of rx meter instances supported
	 * for this function.
	 */
	uint16_t	max_rx_instance;
	uint8_t	unused_1[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_cfa_meter_qcaps_output_t, *phwrm_cfa_meter_qcaps_output_t;

/********************************
 * hwrm_cfa_meter_profile_alloc *
 ********************************/


/* hwrm_cfa_meter_profile_alloc_input (size:320b/40B) */

typedef struct hwrm_cfa_meter_profile_alloc_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint8_t	flags;
	/*
	 * Enumeration denoting the RX, TX type of the resource.
	 * This enumeration is used for resources that are similar for both
	 * TX and RX paths of the chip.
	 */
	#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_FLAGS_PATH	UINT32_C(0x1)
	/* tx path */
		#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_FLAGS_PATH_TX	UINT32_C(0x0)
	/* rx path */
		#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_FLAGS_PATH_RX	UINT32_C(0x1)
		#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_FLAGS_PATH_LAST HWRM_CFA_METER_PROFILE_ALLOC_INPUT_FLAGS_PATH_RX
	/* The meter algorithm type. */
	uint8_t	meter_type;
	/* RFC 2697 (srTCM) */
	#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_METER_TYPE_RFC2697 UINT32_C(0x0)
	/* RFC 2698 (trTCM) */
	#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_METER_TYPE_RFC2698 UINT32_C(0x1)
	/* RFC 4115 (trTCM) */
	#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_METER_TYPE_RFC4115 UINT32_C(0x2)
	#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_METER_TYPE_LAST   HWRM_CFA_METER_PROFILE_ALLOC_INPUT_METER_TYPE_RFC4115
	/*
	 * This field is reserved for the future use.
	 * It shall be set to 0.
	 */
	uint16_t	reserved1;
	/*
	 * This field is reserved for the future use.
	 * It shall be set to 0.
	 */
	uint32_t	reserved2;
	/* A meter rate specified in bytes-per-second. */
	uint32_t	commit_rate;
	/* The bandwidth value. */
	#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_COMMIT_RATE_BW_VALUE_MASK		UINT32_C(0xfffffff)
	#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_COMMIT_RATE_BW_VALUE_SFT		0
	/* The granularity of the value (bits or bytes). */
	#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_COMMIT_RATE_SCALE			UINT32_C(0x10000000)
	/* Value is in bits. */
		#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_COMMIT_RATE_SCALE_BITS		(UINT32_C(0x0) << 28)
	/* Value is in bytes. */
		#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_COMMIT_RATE_SCALE_BYTES		(UINT32_C(0x1) << 28)
		#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_COMMIT_RATE_SCALE_LAST		HWRM_CFA_METER_PROFILE_ALLOC_INPUT_COMMIT_RATE_SCALE_BYTES
	/* bw_value_unit is 3 b */
	#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_COMMIT_RATE_BW_VALUE_UNIT_MASK	UINT32_C(0xe0000000)
	#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_COMMIT_RATE_BW_VALUE_UNIT_SFT	29
	/* Value is in Mb or MB (base 10). */
		#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_COMMIT_RATE_BW_VALUE_UNIT_MEGA	(UINT32_C(0x0) << 29)
	/* Value is in Kb or KB (base 10). */
		#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_COMMIT_RATE_BW_VALUE_UNIT_KILO	(UINT32_C(0x2) << 29)
	/* Value is in bits or bytes. */
		#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_COMMIT_RATE_BW_VALUE_UNIT_BASE	(UINT32_C(0x4) << 29)
	/* Value is in Gb or GB (base 10). */
		#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_COMMIT_RATE_BW_VALUE_UNIT_GIGA	(UINT32_C(0x6) << 29)
	/* Value is in 1/100th of a percentage of total bandwidth. */
		#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_COMMIT_RATE_BW_VALUE_UNIT_PERCENT1_100  (UINT32_C(0x1) << 29)
	/* Raw value */
		#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_COMMIT_RATE_BW_VALUE_UNIT_RAW	(UINT32_C(0x7) << 29)
		#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_COMMIT_RATE_BW_VALUE_UNIT_LAST	HWRM_CFA_METER_PROFILE_ALLOC_INPUT_COMMIT_RATE_BW_VALUE_UNIT_RAW
	/* A meter burst size specified in bytes. */
	uint32_t	commit_burst;
	/* The bandwidth value. */
	#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_COMMIT_BURST_BW_VALUE_MASK		UINT32_C(0xfffffff)
	#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_COMMIT_BURST_BW_VALUE_SFT		0
	/* The granularity of the value (bits or bytes). */
	#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_COMMIT_BURST_SCALE			UINT32_C(0x10000000)
	/* Value is in bits. */
		#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_COMMIT_BURST_SCALE_BITS		(UINT32_C(0x0) << 28)
	/* Value is in bytes. */
		#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_COMMIT_BURST_SCALE_BYTES		(UINT32_C(0x1) << 28)
		#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_COMMIT_BURST_SCALE_LAST		HWRM_CFA_METER_PROFILE_ALLOC_INPUT_COMMIT_BURST_SCALE_BYTES
	/* bw_value_unit is 3 b */
	#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_COMMIT_BURST_BW_VALUE_UNIT_MASK	UINT32_C(0xe0000000)
	#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_COMMIT_BURST_BW_VALUE_UNIT_SFT	29
	/* Value is in Mb or MB (base 10). */
		#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_COMMIT_BURST_BW_VALUE_UNIT_MEGA	(UINT32_C(0x0) << 29)
	/* Value is in Kb or KB (base 10). */
		#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_COMMIT_BURST_BW_VALUE_UNIT_KILO	(UINT32_C(0x2) << 29)
	/* Value is in bits or bytes. */
		#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_COMMIT_BURST_BW_VALUE_UNIT_BASE	(UINT32_C(0x4) << 29)
	/* Value is in Gb or GB (base 10). */
		#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_COMMIT_BURST_BW_VALUE_UNIT_GIGA	(UINT32_C(0x6) << 29)
	/* Value is in 1/100th of a percentage of total bandwidth. */
		#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_COMMIT_BURST_BW_VALUE_UNIT_PERCENT1_100  (UINT32_C(0x1) << 29)
	/* Invalid value */
		#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_COMMIT_BURST_BW_VALUE_UNIT_INVALID	(UINT32_C(0x7) << 29)
		#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_COMMIT_BURST_BW_VALUE_UNIT_LAST	HWRM_CFA_METER_PROFILE_ALLOC_INPUT_COMMIT_BURST_BW_VALUE_UNIT_INVALID
	/* A meter rate specified in bytes-per-second. */
	uint32_t	excess_peak_rate;
	/* The bandwidth value. */
	#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_EXCESS_PEAK_RATE_BW_VALUE_MASK		UINT32_C(0xfffffff)
	#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_EXCESS_PEAK_RATE_BW_VALUE_SFT		0
	/* The granularity of the value (bits or bytes). */
	#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_EXCESS_PEAK_RATE_SCALE			UINT32_C(0x10000000)
	/* Value is in bits. */
		#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_EXCESS_PEAK_RATE_SCALE_BITS		(UINT32_C(0x0) << 28)
	/* Value is in bytes. */
		#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_EXCESS_PEAK_RATE_SCALE_BYTES		(UINT32_C(0x1) << 28)
		#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_EXCESS_PEAK_RATE_SCALE_LAST		HWRM_CFA_METER_PROFILE_ALLOC_INPUT_EXCESS_PEAK_RATE_SCALE_BYTES
	/* bw_value_unit is 3 b */
	#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_EXCESS_PEAK_RATE_BW_VALUE_UNIT_MASK	UINT32_C(0xe0000000)
	#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_EXCESS_PEAK_RATE_BW_VALUE_UNIT_SFT	29
	/* Value is in Mb or MB (base 10). */
		#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_EXCESS_PEAK_RATE_BW_VALUE_UNIT_MEGA	(UINT32_C(0x0) << 29)
	/* Value is in Kb or KB (base 10). */
		#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_EXCESS_PEAK_RATE_BW_VALUE_UNIT_KILO	(UINT32_C(0x2) << 29)
	/* Value is in bits or bytes. */
		#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_EXCESS_PEAK_RATE_BW_VALUE_UNIT_BASE	(UINT32_C(0x4) << 29)
	/* Value is in Gb or GB (base 10). */
		#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_EXCESS_PEAK_RATE_BW_VALUE_UNIT_GIGA	(UINT32_C(0x6) << 29)
	/* Value is in 1/100th of a percentage of total bandwidth. */
		#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_EXCESS_PEAK_RATE_BW_VALUE_UNIT_PERCENT1_100  (UINT32_C(0x1) << 29)
	/* Raw unit */
		#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_EXCESS_PEAK_RATE_BW_VALUE_UNIT_RAW	(UINT32_C(0x7) << 29)
		#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_EXCESS_PEAK_RATE_BW_VALUE_UNIT_LAST	HWRM_CFA_METER_PROFILE_ALLOC_INPUT_EXCESS_PEAK_RATE_BW_VALUE_UNIT_RAW
	/* A meter burst size specified in bytes. */
	uint32_t	excess_peak_burst;
	/* The bandwidth value. */
	#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_EXCESS_PEAK_BURST_BW_VALUE_MASK		UINT32_C(0xfffffff)
	#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_EXCESS_PEAK_BURST_BW_VALUE_SFT		0
	/* The granularity of the value (bits or bytes). */
	#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_EXCESS_PEAK_BURST_SCALE			UINT32_C(0x10000000)
	/* Value is in bits. */
		#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_EXCESS_PEAK_BURST_SCALE_BITS		(UINT32_C(0x0) << 28)
	/* Value is in bytes. */
		#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_EXCESS_PEAK_BURST_SCALE_BYTES		(UINT32_C(0x1) << 28)
		#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_EXCESS_PEAK_BURST_SCALE_LAST		HWRM_CFA_METER_PROFILE_ALLOC_INPUT_EXCESS_PEAK_BURST_SCALE_BYTES
	/* bw_value_unit is 3 b */
	#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_EXCESS_PEAK_BURST_BW_VALUE_UNIT_MASK	UINT32_C(0xe0000000)
	#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_EXCESS_PEAK_BURST_BW_VALUE_UNIT_SFT	29
	/* Value is in Mb or MB (base 10). */
		#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_EXCESS_PEAK_BURST_BW_VALUE_UNIT_MEGA	(UINT32_C(0x0) << 29)
	/* Value is in Kb or KB (base 10). */
		#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_EXCESS_PEAK_BURST_BW_VALUE_UNIT_KILO	(UINT32_C(0x2) << 29)
	/* Value is in bits or bytes. */
		#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_EXCESS_PEAK_BURST_BW_VALUE_UNIT_BASE	(UINT32_C(0x4) << 29)
	/* Value is in Gb or GB (base 10). */
		#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_EXCESS_PEAK_BURST_BW_VALUE_UNIT_GIGA	(UINT32_C(0x6) << 29)
	/* Value is in 1/100th of a percentage of total bandwidth. */
		#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_EXCESS_PEAK_BURST_BW_VALUE_UNIT_PERCENT1_100  (UINT32_C(0x1) << 29)
	/* Invalid unit */
		#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_EXCESS_PEAK_BURST_BW_VALUE_UNIT_INVALID	(UINT32_C(0x7) << 29)
		#define HWRM_CFA_METER_PROFILE_ALLOC_INPUT_EXCESS_PEAK_BURST_BW_VALUE_UNIT_LAST	HWRM_CFA_METER_PROFILE_ALLOC_INPUT_EXCESS_PEAK_BURST_BW_VALUE_UNIT_INVALID
} hwrm_cfa_meter_profile_alloc_input_t, *phwrm_cfa_meter_profile_alloc_input_t;

/* hwrm_cfa_meter_profile_alloc_output (size:128b/16B) */

typedef struct hwrm_cfa_meter_profile_alloc_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* This value identifies a meter profile in CFA. */
	uint16_t	meter_profile_id;
	/*
	 * A value of 0xfff is considered invalid and implies the
	 * profile is not configured.
	 */
	#define HWRM_CFA_METER_PROFILE_ALLOC_OUTPUT_METER_PROFILE_ID_INVALID UINT32_C(0xffff)
	#define HWRM_CFA_METER_PROFILE_ALLOC_OUTPUT_METER_PROFILE_ID_LAST   HWRM_CFA_METER_PROFILE_ALLOC_OUTPUT_METER_PROFILE_ID_INVALID
	uint8_t	unused_0[5];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_cfa_meter_profile_alloc_output_t, *phwrm_cfa_meter_profile_alloc_output_t;

/*******************************
 * hwrm_cfa_meter_profile_free *
 *******************************/


/* hwrm_cfa_meter_profile_free_input (size:192b/24B) */

typedef struct hwrm_cfa_meter_profile_free_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint8_t	flags;
	/*
	 * Enumeration denoting the RX, TX type of the resource.
	 * This enumeration is used for resources that are similar for both
	 * TX and RX paths of the chip.
	 */
	#define HWRM_CFA_METER_PROFILE_FREE_INPUT_FLAGS_PATH	UINT32_C(0x1)
	/* tx path */
		#define HWRM_CFA_METER_PROFILE_FREE_INPUT_FLAGS_PATH_TX	UINT32_C(0x0)
	/* rx path */
		#define HWRM_CFA_METER_PROFILE_FREE_INPUT_FLAGS_PATH_RX	UINT32_C(0x1)
		#define HWRM_CFA_METER_PROFILE_FREE_INPUT_FLAGS_PATH_LAST HWRM_CFA_METER_PROFILE_FREE_INPUT_FLAGS_PATH_RX
	uint8_t	unused_0;
	/* This value identifies a meter profile in CFA. */
	uint16_t	meter_profile_id;
	/*
	 * A value of 0xfff is considered invalid and implies the
	 * profile is not configured.
	 */
	#define HWRM_CFA_METER_PROFILE_FREE_INPUT_METER_PROFILE_ID_INVALID UINT32_C(0xffff)
	#define HWRM_CFA_METER_PROFILE_FREE_INPUT_METER_PROFILE_ID_LAST   HWRM_CFA_METER_PROFILE_FREE_INPUT_METER_PROFILE_ID_INVALID
	uint8_t	unused_1[4];
} hwrm_cfa_meter_profile_free_input_t, *phwrm_cfa_meter_profile_free_input_t;

/* hwrm_cfa_meter_profile_free_output (size:128b/16B) */

typedef struct hwrm_cfa_meter_profile_free_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_cfa_meter_profile_free_output_t, *phwrm_cfa_meter_profile_free_output_t;

/******************************
 * hwrm_cfa_meter_profile_cfg *
 ******************************/


/* hwrm_cfa_meter_profile_cfg_input (size:320b/40B) */

typedef struct hwrm_cfa_meter_profile_cfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint8_t	flags;
	/*
	 * Enumeration denoting the RX, TX type of the resource.
	 * This enumeration is used for resources that are similar for both
	 * TX and RX paths of the chip.
	 */
	#define HWRM_CFA_METER_PROFILE_CFG_INPUT_FLAGS_PATH	UINT32_C(0x1)
	/* tx path */
		#define HWRM_CFA_METER_PROFILE_CFG_INPUT_FLAGS_PATH_TX	UINT32_C(0x0)
	/* rx path */
		#define HWRM_CFA_METER_PROFILE_CFG_INPUT_FLAGS_PATH_RX	UINT32_C(0x1)
		#define HWRM_CFA_METER_PROFILE_CFG_INPUT_FLAGS_PATH_LAST HWRM_CFA_METER_PROFILE_CFG_INPUT_FLAGS_PATH_RX
	/* The meter algorithm type. */
	uint8_t	meter_type;
	/* RFC 2697 (srTCM) */
	#define HWRM_CFA_METER_PROFILE_CFG_INPUT_METER_TYPE_RFC2697 UINT32_C(0x0)
	/* RFC 2698 (trTCM) */
	#define HWRM_CFA_METER_PROFILE_CFG_INPUT_METER_TYPE_RFC2698 UINT32_C(0x1)
	/* RFC 4115 (trTCM) */
	#define HWRM_CFA_METER_PROFILE_CFG_INPUT_METER_TYPE_RFC4115 UINT32_C(0x2)
	#define HWRM_CFA_METER_PROFILE_CFG_INPUT_METER_TYPE_LAST   HWRM_CFA_METER_PROFILE_CFG_INPUT_METER_TYPE_RFC4115
	/* This value identifies a meter profile in CFA. */
	uint16_t	meter_profile_id;
	/*
	 * A value of 0xfff is considered invalid and implies the
	 * profile is not configured.
	 */
	#define HWRM_CFA_METER_PROFILE_CFG_INPUT_METER_PROFILE_ID_INVALID UINT32_C(0xffff)
	#define HWRM_CFA_METER_PROFILE_CFG_INPUT_METER_PROFILE_ID_LAST   HWRM_CFA_METER_PROFILE_CFG_INPUT_METER_PROFILE_ID_INVALID
	/*
	 * This field is reserved for the future use.
	 * It shall be set to 0.
	 */
	uint32_t	reserved;
	/* A meter rate specified in bytes-per-second. */
	uint32_t	commit_rate;
	/* The bandwidth value. */
	#define HWRM_CFA_METER_PROFILE_CFG_INPUT_COMMIT_RATE_BW_VALUE_MASK		UINT32_C(0xfffffff)
	#define HWRM_CFA_METER_PROFILE_CFG_INPUT_COMMIT_RATE_BW_VALUE_SFT		0
	/* The granularity of the value (bits or bytes). */
	#define HWRM_CFA_METER_PROFILE_CFG_INPUT_COMMIT_RATE_SCALE			UINT32_C(0x10000000)
	/* Value is in bits. */
		#define HWRM_CFA_METER_PROFILE_CFG_INPUT_COMMIT_RATE_SCALE_BITS		(UINT32_C(0x0) << 28)
	/* Value is in bytes. */
		#define HWRM_CFA_METER_PROFILE_CFG_INPUT_COMMIT_RATE_SCALE_BYTES		(UINT32_C(0x1) << 28)
		#define HWRM_CFA_METER_PROFILE_CFG_INPUT_COMMIT_RATE_SCALE_LAST		HWRM_CFA_METER_PROFILE_CFG_INPUT_COMMIT_RATE_SCALE_BYTES
	/* bw_value_unit is 3 b */
	#define HWRM_CFA_METER_PROFILE_CFG_INPUT_COMMIT_RATE_BW_VALUE_UNIT_MASK	UINT32_C(0xe0000000)
	#define HWRM_CFA_METER_PROFILE_CFG_INPUT_COMMIT_RATE_BW_VALUE_UNIT_SFT	29
	/* Value is in Mb or MB (base 10). */
		#define HWRM_CFA_METER_PROFILE_CFG_INPUT_COMMIT_RATE_BW_VALUE_UNIT_MEGA	(UINT32_C(0x0) << 29)
	/* Value is in Kb or KB (base 10). */
		#define HWRM_CFA_METER_PROFILE_CFG_INPUT_COMMIT_RATE_BW_VALUE_UNIT_KILO	(UINT32_C(0x2) << 29)
	/* Value is in bits or bytes. */
		#define HWRM_CFA_METER_PROFILE_CFG_INPUT_COMMIT_RATE_BW_VALUE_UNIT_BASE	(UINT32_C(0x4) << 29)
	/* Value is in Gb or GB (base 10). */
		#define HWRM_CFA_METER_PROFILE_CFG_INPUT_COMMIT_RATE_BW_VALUE_UNIT_GIGA	(UINT32_C(0x6) << 29)
	/* Value is in 1/100th of a percentage of total bandwidth. */
		#define HWRM_CFA_METER_PROFILE_CFG_INPUT_COMMIT_RATE_BW_VALUE_UNIT_PERCENT1_100  (UINT32_C(0x1) << 29)
	/* Raw value */
		#define HWRM_CFA_METER_PROFILE_CFG_INPUT_COMMIT_RATE_BW_VALUE_UNIT_RAW	(UINT32_C(0x7) << 29)
		#define HWRM_CFA_METER_PROFILE_CFG_INPUT_COMMIT_RATE_BW_VALUE_UNIT_LAST	HWRM_CFA_METER_PROFILE_CFG_INPUT_COMMIT_RATE_BW_VALUE_UNIT_RAW
	/* A meter burst size specified in bytes. */
	uint32_t	commit_burst;
	/* The bandwidth value. */
	#define HWRM_CFA_METER_PROFILE_CFG_INPUT_COMMIT_BURST_BW_VALUE_MASK		UINT32_C(0xfffffff)
	#define HWRM_CFA_METER_PROFILE_CFG_INPUT_COMMIT_BURST_BW_VALUE_SFT		0
	/* The granularity of the value (bits or bytes). */
	#define HWRM_CFA_METER_PROFILE_CFG_INPUT_COMMIT_BURST_SCALE			UINT32_C(0x10000000)
	/* Value is in bits. */
		#define HWRM_CFA_METER_PROFILE_CFG_INPUT_COMMIT_BURST_SCALE_BITS		(UINT32_C(0x0) << 28)
	/* Value is in bytes. */
		#define HWRM_CFA_METER_PROFILE_CFG_INPUT_COMMIT_BURST_SCALE_BYTES		(UINT32_C(0x1) << 28)
		#define HWRM_CFA_METER_PROFILE_CFG_INPUT_COMMIT_BURST_SCALE_LAST		HWRM_CFA_METER_PROFILE_CFG_INPUT_COMMIT_BURST_SCALE_BYTES
	/* bw_value_unit is 3 b */
	#define HWRM_CFA_METER_PROFILE_CFG_INPUT_COMMIT_BURST_BW_VALUE_UNIT_MASK	UINT32_C(0xe0000000)
	#define HWRM_CFA_METER_PROFILE_CFG_INPUT_COMMIT_BURST_BW_VALUE_UNIT_SFT	29
	/* Value is in Mb or MB (base 10). */
		#define HWRM_CFA_METER_PROFILE_CFG_INPUT_COMMIT_BURST_BW_VALUE_UNIT_MEGA	(UINT32_C(0x0) << 29)
	/* Value is in Kb or KB (base 10). */
		#define HWRM_CFA_METER_PROFILE_CFG_INPUT_COMMIT_BURST_BW_VALUE_UNIT_KILO	(UINT32_C(0x2) << 29)
	/* Value is in bits or bytes. */
		#define HWRM_CFA_METER_PROFILE_CFG_INPUT_COMMIT_BURST_BW_VALUE_UNIT_BASE	(UINT32_C(0x4) << 29)
	/* Value is in Gb or GB (base 10). */
		#define HWRM_CFA_METER_PROFILE_CFG_INPUT_COMMIT_BURST_BW_VALUE_UNIT_GIGA	(UINT32_C(0x6) << 29)
	/* Value is in 1/100th of a percentage of total bandwidth. */
		#define HWRM_CFA_METER_PROFILE_CFG_INPUT_COMMIT_BURST_BW_VALUE_UNIT_PERCENT1_100  (UINT32_C(0x1) << 29)
	/* Invalid value */
		#define HWRM_CFA_METER_PROFILE_CFG_INPUT_COMMIT_BURST_BW_VALUE_UNIT_INVALID	(UINT32_C(0x7) << 29)
		#define HWRM_CFA_METER_PROFILE_CFG_INPUT_COMMIT_BURST_BW_VALUE_UNIT_LAST	HWRM_CFA_METER_PROFILE_CFG_INPUT_COMMIT_BURST_BW_VALUE_UNIT_INVALID
	/* A meter rate specified in bytes-per-second. */
	uint32_t	excess_peak_rate;
	/* The bandwidth value. */
	#define HWRM_CFA_METER_PROFILE_CFG_INPUT_EXCESS_PEAK_RATE_BW_VALUE_MASK		UINT32_C(0xfffffff)
	#define HWRM_CFA_METER_PROFILE_CFG_INPUT_EXCESS_PEAK_RATE_BW_VALUE_SFT		0
	/* The granularity of the value (bits or bytes). */
	#define HWRM_CFA_METER_PROFILE_CFG_INPUT_EXCESS_PEAK_RATE_SCALE			UINT32_C(0x10000000)
	/* Value is in bits. */
		#define HWRM_CFA_METER_PROFILE_CFG_INPUT_EXCESS_PEAK_RATE_SCALE_BITS		(UINT32_C(0x0) << 28)
	/* Value is in bytes. */
		#define HWRM_CFA_METER_PROFILE_CFG_INPUT_EXCESS_PEAK_RATE_SCALE_BYTES		(UINT32_C(0x1) << 28)
		#define HWRM_CFA_METER_PROFILE_CFG_INPUT_EXCESS_PEAK_RATE_SCALE_LAST		HWRM_CFA_METER_PROFILE_CFG_INPUT_EXCESS_PEAK_RATE_SCALE_BYTES
	/* bw_value_unit is 3 b */
	#define HWRM_CFA_METER_PROFILE_CFG_INPUT_EXCESS_PEAK_RATE_BW_VALUE_UNIT_MASK	UINT32_C(0xe0000000)
	#define HWRM_CFA_METER_PROFILE_CFG_INPUT_EXCESS_PEAK_RATE_BW_VALUE_UNIT_SFT	29
	/* Value is in Mb or MB (base 10). */
		#define HWRM_CFA_METER_PROFILE_CFG_INPUT_EXCESS_PEAK_RATE_BW_VALUE_UNIT_MEGA	(UINT32_C(0x0) << 29)
	/* Value is in Kb or KB (base 10). */
		#define HWRM_CFA_METER_PROFILE_CFG_INPUT_EXCESS_PEAK_RATE_BW_VALUE_UNIT_KILO	(UINT32_C(0x2) << 29)
	/* Value is in bits or bytes. */
		#define HWRM_CFA_METER_PROFILE_CFG_INPUT_EXCESS_PEAK_RATE_BW_VALUE_UNIT_BASE	(UINT32_C(0x4) << 29)
	/* Value is in Gb or GB (base 10). */
		#define HWRM_CFA_METER_PROFILE_CFG_INPUT_EXCESS_PEAK_RATE_BW_VALUE_UNIT_GIGA	(UINT32_C(0x6) << 29)
	/* Value is in 1/100th of a percentage of total bandwidth. */
		#define HWRM_CFA_METER_PROFILE_CFG_INPUT_EXCESS_PEAK_RATE_BW_VALUE_UNIT_PERCENT1_100  (UINT32_C(0x1) << 29)
	/* Raw unit */
		#define HWRM_CFA_METER_PROFILE_CFG_INPUT_EXCESS_PEAK_RATE_BW_VALUE_UNIT_RAW	(UINT32_C(0x7) << 29)
		#define HWRM_CFA_METER_PROFILE_CFG_INPUT_EXCESS_PEAK_RATE_BW_VALUE_UNIT_LAST	HWRM_CFA_METER_PROFILE_CFG_INPUT_EXCESS_PEAK_RATE_BW_VALUE_UNIT_RAW
	/* A meter burst size specified in bytes. */
	uint32_t	excess_peak_burst;
	/* The bandwidth value. */
	#define HWRM_CFA_METER_PROFILE_CFG_INPUT_EXCESS_PEAK_BURST_BW_VALUE_MASK		UINT32_C(0xfffffff)
	#define HWRM_CFA_METER_PROFILE_CFG_INPUT_EXCESS_PEAK_BURST_BW_VALUE_SFT		0
	/* The granularity of the value (bits or bytes). */
	#define HWRM_CFA_METER_PROFILE_CFG_INPUT_EXCESS_PEAK_BURST_SCALE			UINT32_C(0x10000000)
	/* Value is in bits. */
		#define HWRM_CFA_METER_PROFILE_CFG_INPUT_EXCESS_PEAK_BURST_SCALE_BITS		(UINT32_C(0x0) << 28)
	/* Value is in bytes. */
		#define HWRM_CFA_METER_PROFILE_CFG_INPUT_EXCESS_PEAK_BURST_SCALE_BYTES		(UINT32_C(0x1) << 28)
		#define HWRM_CFA_METER_PROFILE_CFG_INPUT_EXCESS_PEAK_BURST_SCALE_LAST		HWRM_CFA_METER_PROFILE_CFG_INPUT_EXCESS_PEAK_BURST_SCALE_BYTES
	/* bw_value_unit is 3 b */
	#define HWRM_CFA_METER_PROFILE_CFG_INPUT_EXCESS_PEAK_BURST_BW_VALUE_UNIT_MASK	UINT32_C(0xe0000000)
	#define HWRM_CFA_METER_PROFILE_CFG_INPUT_EXCESS_PEAK_BURST_BW_VALUE_UNIT_SFT	29
	/* Value is in Mb or MB (base 10). */
		#define HWRM_CFA_METER_PROFILE_CFG_INPUT_EXCESS_PEAK_BURST_BW_VALUE_UNIT_MEGA	(UINT32_C(0x0) << 29)
	/* Value is in Kb or KB (base 10). */
		#define HWRM_CFA_METER_PROFILE_CFG_INPUT_EXCESS_PEAK_BURST_BW_VALUE_UNIT_KILO	(UINT32_C(0x2) << 29)
	/* Value is in bits or bytes. */
		#define HWRM_CFA_METER_PROFILE_CFG_INPUT_EXCESS_PEAK_BURST_BW_VALUE_UNIT_BASE	(UINT32_C(0x4) << 29)
	/* Value is in Gb or GB (base 10). */
		#define HWRM_CFA_METER_PROFILE_CFG_INPUT_EXCESS_PEAK_BURST_BW_VALUE_UNIT_GIGA	(UINT32_C(0x6) << 29)
	/* Value is in 1/100th of a percentage of total bandwidth. */
		#define HWRM_CFA_METER_PROFILE_CFG_INPUT_EXCESS_PEAK_BURST_BW_VALUE_UNIT_PERCENT1_100  (UINT32_C(0x1) << 29)
	/* Invalid unit */
		#define HWRM_CFA_METER_PROFILE_CFG_INPUT_EXCESS_PEAK_BURST_BW_VALUE_UNIT_INVALID	(UINT32_C(0x7) << 29)
		#define HWRM_CFA_METER_PROFILE_CFG_INPUT_EXCESS_PEAK_BURST_BW_VALUE_UNIT_LAST	HWRM_CFA_METER_PROFILE_CFG_INPUT_EXCESS_PEAK_BURST_BW_VALUE_UNIT_INVALID
} hwrm_cfa_meter_profile_cfg_input_t, *phwrm_cfa_meter_profile_cfg_input_t;

/* hwrm_cfa_meter_profile_cfg_output (size:128b/16B) */

typedef struct hwrm_cfa_meter_profile_cfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_cfa_meter_profile_cfg_output_t, *phwrm_cfa_meter_profile_cfg_output_t;

/*********************************
 * hwrm_cfa_meter_instance_alloc *
 *********************************/


/* hwrm_cfa_meter_instance_alloc_input (size:192b/24B) */

typedef struct hwrm_cfa_meter_instance_alloc_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint8_t	flags;
	/*
	 * Enumeration denoting the RX, TX type of the resource.
	 * This enumeration is used for resources that are similar for both
	 * TX and RX paths of the chip.
	 */
	#define HWRM_CFA_METER_INSTANCE_ALLOC_INPUT_FLAGS_PATH	UINT32_C(0x1)
	/* tx path */
		#define HWRM_CFA_METER_INSTANCE_ALLOC_INPUT_FLAGS_PATH_TX	UINT32_C(0x0)
	/* rx path */
		#define HWRM_CFA_METER_INSTANCE_ALLOC_INPUT_FLAGS_PATH_RX	UINT32_C(0x1)
		#define HWRM_CFA_METER_INSTANCE_ALLOC_INPUT_FLAGS_PATH_LAST HWRM_CFA_METER_INSTANCE_ALLOC_INPUT_FLAGS_PATH_RX
	uint8_t	unused_0;
	/* This value identifies a meter profile in CFA. */
	uint16_t	meter_profile_id;
	/*
	 * A value of 0xffff is considered invalid and implies the
	 * profile is not configured.
	 */
	#define HWRM_CFA_METER_INSTANCE_ALLOC_INPUT_METER_PROFILE_ID_INVALID UINT32_C(0xffff)
	#define HWRM_CFA_METER_INSTANCE_ALLOC_INPUT_METER_PROFILE_ID_LAST   HWRM_CFA_METER_INSTANCE_ALLOC_INPUT_METER_PROFILE_ID_INVALID
	uint8_t	unused_1[4];
} hwrm_cfa_meter_instance_alloc_input_t, *phwrm_cfa_meter_instance_alloc_input_t;

/* hwrm_cfa_meter_instance_alloc_output (size:128b/16B) */

typedef struct hwrm_cfa_meter_instance_alloc_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* This value identifies a meter instance in CFA. */
	uint16_t	meter_instance_id;
	/*
	 * A value of 0xffff is considered invalid and implies the
	 * instance is not configured.
	 */
	#define HWRM_CFA_METER_INSTANCE_ALLOC_OUTPUT_METER_INSTANCE_ID_INVALID UINT32_C(0xffff)
	#define HWRM_CFA_METER_INSTANCE_ALLOC_OUTPUT_METER_INSTANCE_ID_LAST   HWRM_CFA_METER_INSTANCE_ALLOC_OUTPUT_METER_INSTANCE_ID_INVALID
	uint8_t	unused_0[5];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_cfa_meter_instance_alloc_output_t, *phwrm_cfa_meter_instance_alloc_output_t;

/*******************************
 * hwrm_cfa_meter_instance_cfg *
 *******************************/


/* hwrm_cfa_meter_instance_cfg_input (size:192b/24B) */

typedef struct hwrm_cfa_meter_instance_cfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint8_t	flags;
	/*
	 * Enumeration denoting the RX, TX type of the resource.
	 * This enumeration is used for resources that are similar for both
	 * TX and RX paths of the chip.
	 */
	#define HWRM_CFA_METER_INSTANCE_CFG_INPUT_FLAGS_PATH	UINT32_C(0x1)
	/* tx path */
		#define HWRM_CFA_METER_INSTANCE_CFG_INPUT_FLAGS_PATH_TX	UINT32_C(0x0)
	/* rx path */
		#define HWRM_CFA_METER_INSTANCE_CFG_INPUT_FLAGS_PATH_RX	UINT32_C(0x1)
		#define HWRM_CFA_METER_INSTANCE_CFG_INPUT_FLAGS_PATH_LAST HWRM_CFA_METER_INSTANCE_CFG_INPUT_FLAGS_PATH_RX
	uint8_t	unused_0;
	/*
	 * This value identifies a new meter profile to be associated with
	 * the meter instance specified in this command.
	 */
	uint16_t	meter_profile_id;
	/*
	 * A value of 0xffff is considered invalid and implies the
	 * profile is not configured.
	 */
	#define HWRM_CFA_METER_INSTANCE_CFG_INPUT_METER_PROFILE_ID_INVALID UINT32_C(0xffff)
	#define HWRM_CFA_METER_INSTANCE_CFG_INPUT_METER_PROFILE_ID_LAST   HWRM_CFA_METER_INSTANCE_CFG_INPUT_METER_PROFILE_ID_INVALID
	/*
	 * This value identifies the ID of a meter instance that needs to be
	 * updated with a new meter profile specified in this command.
	 */
	uint16_t	meter_instance_id;
	uint8_t	unused_1[2];
} hwrm_cfa_meter_instance_cfg_input_t, *phwrm_cfa_meter_instance_cfg_input_t;

/* hwrm_cfa_meter_instance_cfg_output (size:128b/16B) */

typedef struct hwrm_cfa_meter_instance_cfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_cfa_meter_instance_cfg_output_t, *phwrm_cfa_meter_instance_cfg_output_t;

/********************************
 * hwrm_cfa_meter_instance_free *
 ********************************/


/* hwrm_cfa_meter_instance_free_input (size:192b/24B) */

typedef struct hwrm_cfa_meter_instance_free_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint8_t	flags;
	/*
	 * Enumeration denoting the RX, TX type of the resource.
	 * This enumeration is used for resources that are similar for both
	 * TX and RX paths of the chip.
	 */
	#define HWRM_CFA_METER_INSTANCE_FREE_INPUT_FLAGS_PATH	UINT32_C(0x1)
	/* tx path */
		#define HWRM_CFA_METER_INSTANCE_FREE_INPUT_FLAGS_PATH_TX	UINT32_C(0x0)
	/* rx path */
		#define HWRM_CFA_METER_INSTANCE_FREE_INPUT_FLAGS_PATH_RX	UINT32_C(0x1)
		#define HWRM_CFA_METER_INSTANCE_FREE_INPUT_FLAGS_PATH_LAST HWRM_CFA_METER_INSTANCE_FREE_INPUT_FLAGS_PATH_RX
	uint8_t	unused_0;
	/* This value identifies a meter instance in CFA. */
	uint16_t	meter_instance_id;
	/*
	 * A value of 0xfff is considered invalid and implies the
	 * instance is not configured.
	 */
	#define HWRM_CFA_METER_INSTANCE_FREE_INPUT_METER_INSTANCE_ID_INVALID UINT32_C(0xffff)
	#define HWRM_CFA_METER_INSTANCE_FREE_INPUT_METER_INSTANCE_ID_LAST   HWRM_CFA_METER_INSTANCE_FREE_INPUT_METER_INSTANCE_ID_INVALID
	uint8_t	unused_1[4];
} hwrm_cfa_meter_instance_free_input_t, *phwrm_cfa_meter_instance_free_input_t;

/* hwrm_cfa_meter_instance_free_output (size:128b/16B) */

typedef struct hwrm_cfa_meter_instance_free_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_cfa_meter_instance_free_output_t, *phwrm_cfa_meter_instance_free_output_t;

/*******************************
 * hwrm_cfa_decap_filter_alloc *
 *******************************/


/* hwrm_cfa_decap_filter_alloc_input (size:832b/104B) */

typedef struct hwrm_cfa_decap_filter_alloc_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	flags;
	/* ovs_tunnel is 1 b */
	#define HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_FLAGS_OVS_TUNNEL	UINT32_C(0x1)
	uint32_t	enables;
	/*
	 * This bit must be '1' for the tunnel_type field to be
	 * configured.
	 */
	#define HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_ENABLES_TUNNEL_TYPE	UINT32_C(0x1)
	/*
	 * This bit must be '1' for the tunnel_id field to be
	 * configured.
	 */
	#define HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_ENABLES_TUNNEL_ID	UINT32_C(0x2)
	/*
	 * This bit must be '1' for the src_macaddr field to be
	 * configured.
	 */
	#define HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_ENABLES_SRC_MACADDR	UINT32_C(0x4)
	/*
	 * This bit must be '1' for the dst_macaddr field to be
	 * configured.
	 */
	#define HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_ENABLES_DST_MACADDR	UINT32_C(0x8)
	/*
	 * This bit must be '1' for the ovlan_vid field to be
	 * configured.
	 */
	#define HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_ENABLES_OVLAN_VID	UINT32_C(0x10)
	/*
	 * This bit must be '1' for the ivlan_vid field to be
	 * configured.
	 */
	#define HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_ENABLES_IVLAN_VID	UINT32_C(0x20)
	/*
	 * This bit must be '1' for the t_ovlan_vid field to be
	 * configured.
	 */
	#define HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_ENABLES_T_OVLAN_VID	UINT32_C(0x40)
	/*
	 * This bit must be '1' for the t_ivlan_vid field to be
	 * configured.
	 */
	#define HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_ENABLES_T_IVLAN_VID	UINT32_C(0x80)
	/*
	 * This bit must be '1' for the ethertype field to be
	 * configured.
	 */
	#define HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_ENABLES_ETHERTYPE	UINT32_C(0x100)
	/*
	 * This bit must be '1' for the src_ipaddr field to be
	 * configured.
	 */
	#define HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_ENABLES_SRC_IPADDR	UINT32_C(0x200)
	/*
	 * This bit must be '1' for the dst_ipaddr field to be
	 * configured.
	 */
	#define HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_ENABLES_DST_IPADDR	UINT32_C(0x400)
	/*
	 * This bit must be '1' for the ipaddr_type field to be
	 * configured.
	 */
	#define HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_ENABLES_IPADDR_TYPE	UINT32_C(0x800)
	/*
	 * This bit must be '1' for the ip_protocol field to be
	 * configured.
	 */
	#define HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_ENABLES_IP_PROTOCOL	UINT32_C(0x1000)
	/*
	 * This bit must be '1' for the src_port field to be
	 * configured.
	 */
	#define HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_ENABLES_SRC_PORT	UINT32_C(0x2000)
	/*
	 * This bit must be '1' for the dst_port field to be
	 * configured.
	 */
	#define HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_ENABLES_DST_PORT	UINT32_C(0x4000)
	/*
	 * This bit must be '1' for the dst_id field to be
	 * configured.
	 */
	#define HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_ENABLES_DST_ID		UINT32_C(0x8000)
	/*
	 * This bit must be '1' for the mirror_vnic_id field to be
	 * configured.
	 */
	#define HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_ENABLES_MIRROR_VNIC_ID	UINT32_C(0x10000)
	/*
	 * Tunnel identifier.
	 * Virtual Network Identifier (VNI). Only valid with
	 * tunnel_types VXLAN, NVGRE, and Geneve.
	 * Only lower 24-bits of VNI field are used
	 * in setting up the filter.
	 */
	uint32_t	tunnel_id;
	/* Tunnel Type. */
	uint8_t	tunnel_type;
	/* Non-tunnel */
	#define HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_TUNNEL_TYPE_NONTUNNEL	UINT32_C(0x0)
	/* Virtual eXtensible Local Area Network (VXLAN) */
	#define HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_TUNNEL_TYPE_VXLAN	UINT32_C(0x1)
	/* Network Virtualization Generic Routing Encapsulation (NVGRE) */
	#define HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_TUNNEL_TYPE_NVGRE	UINT32_C(0x2)
	/* Generic Routing Encapsulation (GRE) inside Ethernet payload */
	#define HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_TUNNEL_TYPE_L2GRE	UINT32_C(0x3)
	/* IP in IP */
	#define HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_TUNNEL_TYPE_IPIP	UINT32_C(0x4)
	/* Generic Network Virtualization Encapsulation (Geneve) */
	#define HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_TUNNEL_TYPE_GENEVE	UINT32_C(0x5)
	/* Multi-Protocol Label Switching (MPLS) */
	#define HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_TUNNEL_TYPE_MPLS	UINT32_C(0x6)
	/* Stateless Transport Tunnel (STT) */
	#define HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_TUNNEL_TYPE_STT	UINT32_C(0x7)
	/* Generic Routing Encapsulation (GRE) inside IP datagram payload */
	#define HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_TUNNEL_TYPE_IPGRE	UINT32_C(0x8)
	/* IPV4 over virtual eXtensible Local Area Network (IPV4oVXLAN) */
	#define HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_TUNNEL_TYPE_VXLAN_V4	UINT32_C(0x9)
	/*
	 * Enhance Generic Routing Encapsulation (GRE version 1) inside IP
	 * datagram payload
	 */
	#define HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_TUNNEL_TYPE_IPGRE_V1	UINT32_C(0xa)
	/* Use fixed layer 2 ether type of 0xFFFF */
	#define HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_TUNNEL_TYPE_L2_ETYPE	UINT32_C(0xb)
	/*
	 * IPV6 over virtual eXtensible Local Area Network with GPE header
	 * (IPV6oVXLANGPE)
	 */
	#define HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_TUNNEL_TYPE_VXLAN_GPE_V6 UINT32_C(0xc)
	/* Any tunneled traffic */
	#define HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_TUNNEL_TYPE_ANYTUNNEL	UINT32_C(0xff)
	#define HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_TUNNEL_TYPE_LAST	HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_TUNNEL_TYPE_ANYTUNNEL
	uint8_t	unused_0;
	uint16_t	unused_1;
	/*
	 * This value indicates the source MAC address in
	 * the Ethernet header.
	 */
	uint8_t	src_macaddr[6];
	uint8_t	unused_2[2];
	/*
	 * This value indicates the destination MAC address in
	 * the Ethernet header.
	 */
	uint8_t	dst_macaddr[6];
	/*
	 * This value indicates the VLAN ID of the outer VLAN tag
	 * in the Ethernet header.
	 */
	uint16_t	ovlan_vid;
	/*
	 * This value indicates the VLAN ID of the inner VLAN tag
	 * in the Ethernet header.
	 */
	uint16_t	ivlan_vid;
	/*
	 * This value indicates the VLAN ID of the outer VLAN tag
	 * in the tunnel Ethernet header.
	 */
	uint16_t	t_ovlan_vid;
	/*
	 * This value indicates the VLAN ID of the inner VLAN tag
	 * in the tunnel Ethernet header.
	 */
	uint16_t	t_ivlan_vid;
	/* This value indicates the ethertype in the Ethernet header. */
	uint16_t	ethertype;
	/*
	 * This value indicates the type of IP address.
	 * 4 - IPv4
	 * 6 - IPv6
	 * All others are invalid.
	 */
	uint8_t	ip_addr_type;
	/* invalid */
	#define HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_IP_ADDR_TYPE_UNKNOWN UINT32_C(0x0)
	/* IPv4 */
	#define HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_IP_ADDR_TYPE_IPV4	UINT32_C(0x4)
	/* IPv6 */
	#define HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_IP_ADDR_TYPE_IPV6	UINT32_C(0x6)
	#define HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_IP_ADDR_TYPE_LAST   HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_IP_ADDR_TYPE_IPV6
	/*
	 * The value of protocol filed in IP header.
	 * Applies to UDP and TCP traffic.
	 * 6 - TCP
	 * 17 - UDP
	 */
	uint8_t	ip_protocol;
	/* invalid */
	#define HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_IP_PROTOCOL_UNKNOWN UINT32_C(0x0)
	/* TCP */
	#define HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_IP_PROTOCOL_TCP	UINT32_C(0x6)
	/* UDP */
	#define HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_IP_PROTOCOL_UDP	UINT32_C(0x11)
	#define HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_IP_PROTOCOL_LAST   HWRM_CFA_DECAP_FILTER_ALLOC_INPUT_IP_PROTOCOL_UDP
	uint16_t	unused_3;
	uint32_t	unused_4;
	/*
	 * The value of source IP address to be used in filtering.
	 * For IPv4, first four bytes represent the IP address.
	 */
	uint32_t	src_ipaddr[4];
	/*
	 * The value of destination IP address to be used in filtering.
	 * For IPv4, first four bytes represent the IP address.
	 */
	uint32_t	dst_ipaddr[4];
	/*
	 * The value of source port to be used in filtering.
	 * Applies to UDP and TCP traffic.
	 */
	uint16_t	src_port;
	/*
	 * The value of destination port to be used in filtering.
	 * Applies to UDP and TCP traffic.
	 */
	uint16_t	dst_port;
	/*
	 * If set, this value shall represent the
	 * Logical VNIC ID of the destination VNIC for the RX
	 * path.
	 */
	uint16_t	dst_id;
	/*
	 * If set, this value shall represent the L2 context that matches the
	 * L2 information of the decap filter.
	 */
	uint16_t	l2_ctxt_ref_id;
} hwrm_cfa_decap_filter_alloc_input_t, *phwrm_cfa_decap_filter_alloc_input_t;

/* hwrm_cfa_decap_filter_alloc_output (size:128b/16B) */

typedef struct hwrm_cfa_decap_filter_alloc_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* This value is an opaque id into CFA data structures. */
	uint32_t	decap_filter_id;
	uint8_t	unused_0[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_cfa_decap_filter_alloc_output_t, *phwrm_cfa_decap_filter_alloc_output_t;

/******************************
 * hwrm_cfa_decap_filter_free *
 ******************************/


/* hwrm_cfa_decap_filter_free_input (size:192b/24B) */

typedef struct hwrm_cfa_decap_filter_free_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* This value is an opaque id into CFA data structures. */
	uint32_t	decap_filter_id;
	uint8_t	unused_0[4];
} hwrm_cfa_decap_filter_free_input_t, *phwrm_cfa_decap_filter_free_input_t;

/* hwrm_cfa_decap_filter_free_output (size:128b/16B) */

typedef struct hwrm_cfa_decap_filter_free_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_cfa_decap_filter_free_output_t, *phwrm_cfa_decap_filter_free_output_t;

/***********************
 * hwrm_cfa_flow_alloc *
 ***********************/


/* hwrm_cfa_flow_alloc_input (size:1024b/128B) */

typedef struct hwrm_cfa_flow_alloc_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint16_t	flags;
	/* tunnel is 1 b */
	#define HWRM_CFA_FLOW_ALLOC_INPUT_FLAGS_TUNNEL		UINT32_C(0x1)
	/* num_vlan is 2 b */
	#define HWRM_CFA_FLOW_ALLOC_INPUT_FLAGS_NUM_VLAN_MASK	UINT32_C(0x6)
	#define HWRM_CFA_FLOW_ALLOC_INPUT_FLAGS_NUM_VLAN_SFT	1
	/* no tags */
		#define HWRM_CFA_FLOW_ALLOC_INPUT_FLAGS_NUM_VLAN_NONE		(UINT32_C(0x0) << 1)
	/* 1 tag */
		#define HWRM_CFA_FLOW_ALLOC_INPUT_FLAGS_NUM_VLAN_ONE		(UINT32_C(0x1) << 1)
	/* 2 tags */
		#define HWRM_CFA_FLOW_ALLOC_INPUT_FLAGS_NUM_VLAN_TWO		(UINT32_C(0x2) << 1)
		#define HWRM_CFA_FLOW_ALLOC_INPUT_FLAGS_NUM_VLAN_LAST	HWRM_CFA_FLOW_ALLOC_INPUT_FLAGS_NUM_VLAN_TWO
	/* Enumeration denoting the Flow Type. */
	#define HWRM_CFA_FLOW_ALLOC_INPUT_FLAGS_FLOWTYPE_MASK	UINT32_C(0x38)
	#define HWRM_CFA_FLOW_ALLOC_INPUT_FLAGS_FLOWTYPE_SFT	3
	/* L2 flow */
		#define HWRM_CFA_FLOW_ALLOC_INPUT_FLAGS_FLOWTYPE_L2		(UINT32_C(0x0) << 3)
	/* IPV4 flow */
		#define HWRM_CFA_FLOW_ALLOC_INPUT_FLAGS_FLOWTYPE_IPV4		(UINT32_C(0x1) << 3)
	/* IPV6 flow */
		#define HWRM_CFA_FLOW_ALLOC_INPUT_FLAGS_FLOWTYPE_IPV6		(UINT32_C(0x2) << 3)
		#define HWRM_CFA_FLOW_ALLOC_INPUT_FLAGS_FLOWTYPE_LAST	HWRM_CFA_FLOW_ALLOC_INPUT_FLAGS_FLOWTYPE_IPV6
	/*
	 * when set to 1, indicates TX flow offload for function specified
	 * in src_fid and the dst_fid should be set to invalid value. To
	 * indicate a VM to VM flow, both of the path_tx and path_rx flags
	 * need to be set. For virtio vSwitch offload case, the src_fid and
	 * dst_fid is set to the same fid value. For the SRIOV vSwitch
	 * offload case, the src_fid and dst_fid must be set to the same VF
	 * FID belong to the children VFs of the same PF to indicate VM to
	 * VM flow.
	 */
	#define HWRM_CFA_FLOW_ALLOC_INPUT_FLAGS_PATH_TX		UINT32_C(0x40)
	/*
	 * when set to 1, indicates RX flow offload for function specified
	 * in dst_fid and the src_fid should be set to invalid value.
	 */
	#define HWRM_CFA_FLOW_ALLOC_INPUT_FLAGS_PATH_RX		UINT32_C(0x80)
	/*
	 * Set to 1 to indicate matching of VXLAN VNI from the custom vxlan
	 * header is required and the VXLAN VNI value is stored in the first
	 * 24 bits of the dmac field. This flag is only valid when the flow
	 * direction is RX.
	 */
	#define HWRM_CFA_FLOW_ALLOC_INPUT_FLAGS_MATCH_VXLAN_IP_VNI	UINT32_C(0x100)
	/*
	 * Set to 1 to indicate vhost_id is specified in the outer_vlan_tci
	 * field.
	 */
	#define HWRM_CFA_FLOW_ALLOC_INPUT_FLAGS_VHOST_ID_USE_VLAN	UINT32_C(0x200)
	/*
	 * Tx Flow: vf fid.
	 * Rx Flow: pf fid.
	 */
	uint16_t	src_fid;
	/* Tunnel handle valid when tunnel flag is set. */
	uint32_t	tunnel_handle;
	uint16_t	action_flags;
	/*
	 * Setting of this flag indicates drop action. If this flag is not
	 * set, then it should be considered accept action.
	 */
	#define HWRM_CFA_FLOW_ALLOC_INPUT_ACTION_FLAGS_FWD			UINT32_C(0x1)
	/* recycle is 1 b */
	#define HWRM_CFA_FLOW_ALLOC_INPUT_ACTION_FLAGS_RECYCLE		UINT32_C(0x2)
	/*
	 * Setting of this flag indicates drop action. If this flag is not
	 * set, then it should be considered accept action.
	 */
	#define HWRM_CFA_FLOW_ALLOC_INPUT_ACTION_FLAGS_DROP			UINT32_C(0x4)
	/* meter is 1 b */
	#define HWRM_CFA_FLOW_ALLOC_INPUT_ACTION_FLAGS_METER			UINT32_C(0x8)
	/* tunnel is 1 b */
	#define HWRM_CFA_FLOW_ALLOC_INPUT_ACTION_FLAGS_TUNNEL			UINT32_C(0x10)
	/* nat_src is 1 b */
	#define HWRM_CFA_FLOW_ALLOC_INPUT_ACTION_FLAGS_NAT_SRC		UINT32_C(0x20)
	/* nat_dest is 1 b */
	#define HWRM_CFA_FLOW_ALLOC_INPUT_ACTION_FLAGS_NAT_DEST		UINT32_C(0x40)
	/* nat_ipv4_address is 1 b */
	#define HWRM_CFA_FLOW_ALLOC_INPUT_ACTION_FLAGS_NAT_IPV4_ADDRESS	UINT32_C(0x80)
	/* l2_header_rewrite is 1 b */
	#define HWRM_CFA_FLOW_ALLOC_INPUT_ACTION_FLAGS_L2_HEADER_REWRITE	UINT32_C(0x100)
	/* ttl_decrement is 1 b */
	#define HWRM_CFA_FLOW_ALLOC_INPUT_ACTION_FLAGS_TTL_DECREMENT		UINT32_C(0x200)
	/*
	 * If set to 1 and flow direction is TX, it indicates decap of L2
	 * header and encap of tunnel header. If set to 1 and flow direction
	 * is RX, it indicates decap of tunnel header and encap L2 header.
	 * The type of tunnel is specified in the tunnel_type field.
	 */
	#define HWRM_CFA_FLOW_ALLOC_INPUT_ACTION_FLAGS_TUNNEL_IP		UINT32_C(0x400)
	/* If set to 1, flow aging is enabled for this flow. */
	#define HWRM_CFA_FLOW_ALLOC_INPUT_ACTION_FLAGS_FLOW_AGING_ENABLED	UINT32_C(0x800)
	/*
	 * If set to 1 an attempt will be made to try to offload this flow
	 * to the most optimal flow table resource. If set to 0, the flow
	 * will be placed to the default flow table resource.
	 */
	#define HWRM_CFA_FLOW_ALLOC_INPUT_ACTION_FLAGS_PRI_HINT		UINT32_C(0x1000)
	/*
	 * If set to 1 there will be no attempt to allocate an on-chip try
	 * to offload this flow. If set to 0, which will keep compatibility
	 * with the older drivers, will cause the FW to attempt to allocate
	 * an on-chip flow counter for the newly created flow. This will
	 * keep the existing behavior with EM flows which always had an
	 * associated flow counter.
	 */
	#define HWRM_CFA_FLOW_ALLOC_INPUT_ACTION_FLAGS_NO_FLOW_COUNTER_ALLOC	UINT32_C(0x2000)
	/*
	 * Tx Flow: pf or vf fid.
	 * Rx Flow: vf fid.
	 */
	uint16_t	dst_fid;
	/* VLAN tpid, valid when push_vlan flag is set. */
	uint16_t	l2_rewrite_vlan_tpid;
	/* VLAN tci, valid when push_vlan flag is set. */
	uint16_t	l2_rewrite_vlan_tci;
	/* Meter id, valid when meter flag is set. */
	uint16_t	act_meter_id;
	/* Flow with the same l2 context tcam key. */
	uint16_t	ref_flow_handle;
	/* This value sets the match value for the ethertype. */
	uint16_t	ethertype;
	/* valid when num tags is 1 or 2. */
	uint16_t	outer_vlan_tci;
	/* This value sets the match value for the Destination MAC address. */
	uint16_t	dmac[3];
	/* valid when num tags is 2. */
	uint16_t	inner_vlan_tci;
	/* This value sets the match value for the Source MAC address. */
	uint16_t	smac[3];
	/* The bit length of destination IP address mask. */
	uint8_t	ip_dst_mask_len;
	/* The bit length of source IP address mask. */
	uint8_t	ip_src_mask_len;
	/* The value of destination IPv4/IPv6 address. */
	uint32_t	ip_dst[4];
	/* The source IPv4/IPv6 address. */
	uint32_t	ip_src[4];
	/*
	 * The value of source port.
	 * Applies to UDP and TCP traffic.
	 */
	uint16_t	l4_src_port;
	/*
	 * The value of source port mask.
	 * Applies to UDP and TCP traffic.
	 */
	uint16_t	l4_src_port_mask;
	/*
	 * The value of destination port.
	 * Applies to UDP and TCP traffic.
	 */
	uint16_t	l4_dst_port;
	/*
	 * The value of destination port mask.
	 * Applies to UDP and TCP traffic.
	 */
	uint16_t	l4_dst_port_mask;
	/*
	 * NAT IPv4/6 address based on address type flag.
	 * 0 values are ignored.
	 */
	uint32_t	nat_ip_address[4];
	/* L2 header re-write Destination MAC address. */
	uint16_t	l2_rewrite_dmac[3];
	/*
	 * The NAT source/destination port based on direction flag.
	 * Applies to UDP and TCP traffic.
	 * 0 values are ignored.
	 */
	uint16_t	nat_port;
	/* L2 header re-write Source MAC address. */
	uint16_t	l2_rewrite_smac[3];
	/* The value of ip protocol. */
	uint8_t	ip_proto;
	/* Tunnel Type. */
	uint8_t	tunnel_type;
	/* Non-tunnel */
	#define HWRM_CFA_FLOW_ALLOC_INPUT_TUNNEL_TYPE_NONTUNNEL	UINT32_C(0x0)
	/* Virtual eXtensible Local Area Network (VXLAN) */
	#define HWRM_CFA_FLOW_ALLOC_INPUT_TUNNEL_TYPE_VXLAN	UINT32_C(0x1)
	/* Network Virtualization Generic Routing Encapsulation (NVGRE) */
	#define HWRM_CFA_FLOW_ALLOC_INPUT_TUNNEL_TYPE_NVGRE	UINT32_C(0x2)
	/* Generic Routing Encapsulation (GRE) inside Ethernet payload */
	#define HWRM_CFA_FLOW_ALLOC_INPUT_TUNNEL_TYPE_L2GRE	UINT32_C(0x3)
	/* IP in IP */
	#define HWRM_CFA_FLOW_ALLOC_INPUT_TUNNEL_TYPE_IPIP	UINT32_C(0x4)
	/* Generic Network Virtualization Encapsulation (Geneve) */
	#define HWRM_CFA_FLOW_ALLOC_INPUT_TUNNEL_TYPE_GENEVE	UINT32_C(0x5)
	/* Multi-Protocol Label Switching (MPLS) */
	#define HWRM_CFA_FLOW_ALLOC_INPUT_TUNNEL_TYPE_MPLS	UINT32_C(0x6)
	/* Stateless Transport Tunnel (STT) */
	#define HWRM_CFA_FLOW_ALLOC_INPUT_TUNNEL_TYPE_STT	UINT32_C(0x7)
	/* Generic Routing Encapsulation (GRE) inside IP datagram payload */
	#define HWRM_CFA_FLOW_ALLOC_INPUT_TUNNEL_TYPE_IPGRE	UINT32_C(0x8)
	/* IPV4 over virtual eXtensible Local Area Network (IPV4oVXLAN) */
	#define HWRM_CFA_FLOW_ALLOC_INPUT_TUNNEL_TYPE_VXLAN_V4	UINT32_C(0x9)
	/*
	 * Enhance Generic Routing Encapsulation (GRE version 1) inside IP
	 * datagram payload
	 */
	#define HWRM_CFA_FLOW_ALLOC_INPUT_TUNNEL_TYPE_IPGRE_V1	UINT32_C(0xa)
	/* Use fixed layer 2 ether type of 0xFFFF */
	#define HWRM_CFA_FLOW_ALLOC_INPUT_TUNNEL_TYPE_L2_ETYPE	UINT32_C(0xb)
	/*
	 * IPV6 over virtual eXtensible Local Area Network with GPE header
	 * (IPV6oVXLANGPE)
	 */
	#define HWRM_CFA_FLOW_ALLOC_INPUT_TUNNEL_TYPE_VXLAN_GPE_V6 UINT32_C(0xc)
	/* Any tunneled traffic */
	#define HWRM_CFA_FLOW_ALLOC_INPUT_TUNNEL_TYPE_ANYTUNNEL	UINT32_C(0xff)
	#define HWRM_CFA_FLOW_ALLOC_INPUT_TUNNEL_TYPE_LAST	HWRM_CFA_FLOW_ALLOC_INPUT_TUNNEL_TYPE_ANYTUNNEL
} hwrm_cfa_flow_alloc_input_t, *phwrm_cfa_flow_alloc_input_t;

/* hwrm_cfa_flow_alloc_output (size:256b/32B) */

typedef struct hwrm_cfa_flow_alloc_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Flow record index. */
	uint16_t	flow_handle;
	uint8_t	unused_0[2];
	/*
	 * The flow id value in bit 0-29 is the actual ID of the flow
	 * associated with this filter and it shall be used to match
	 * and associate the flow identifier returned in completion
	 * records. A value of 0xFFFFFFFF in the 32-bit flow_id field
	 * shall indicate no valid flow id.
	 */
	uint32_t	flow_id;
	/* Indicate the flow id value. */
	#define HWRM_CFA_FLOW_ALLOC_OUTPUT_FLOW_ID_VALUE_MASK UINT32_C(0x3fffffff)
	#define HWRM_CFA_FLOW_ALLOC_OUTPUT_FLOW_ID_VALUE_SFT 0
	/* Indicate type of the flow. */
	#define HWRM_CFA_FLOW_ALLOC_OUTPUT_FLOW_ID_TYPE	UINT32_C(0x40000000)
	/*
	 * If this bit set to 0, then it indicates that the flow is
	 * internal flow.
	 */
		#define HWRM_CFA_FLOW_ALLOC_OUTPUT_FLOW_ID_TYPE_INT	(UINT32_C(0x0) << 30)
	/*
	 * If this bit is set to 1, then it indicates that the flow is
	 * external flow.
	 */
		#define HWRM_CFA_FLOW_ALLOC_OUTPUT_FLOW_ID_TYPE_EXT	(UINT32_C(0x1) << 30)
		#define HWRM_CFA_FLOW_ALLOC_OUTPUT_FLOW_ID_TYPE_LAST  HWRM_CFA_FLOW_ALLOC_OUTPUT_FLOW_ID_TYPE_EXT
	/* Indicate the flow direction. */
	#define HWRM_CFA_FLOW_ALLOC_OUTPUT_FLOW_ID_DIR	UINT32_C(0x80000000)
	/* If this bit set to 0, then it indicates rx flow. */
		#define HWRM_CFA_FLOW_ALLOC_OUTPUT_FLOW_ID_DIR_RX	(UINT32_C(0x0) << 31)
	/* If this bit is set to 1, then it indicates that tx flow. */
		#define HWRM_CFA_FLOW_ALLOC_OUTPUT_FLOW_ID_DIR_TX	(UINT32_C(0x1) << 31)
		#define HWRM_CFA_FLOW_ALLOC_OUTPUT_FLOW_ID_DIR_LAST   HWRM_CFA_FLOW_ALLOC_OUTPUT_FLOW_ID_DIR_TX
	/* This value identifies a set of CFA data structures used for a flow. */
	uint64_t	ext_flow_handle;
	uint32_t	flow_counter_id;
	uint8_t	unused_1[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_cfa_flow_alloc_output_t, *phwrm_cfa_flow_alloc_output_t;

/* hwrm_cfa_flow_alloc_cmd_err (size:64b/8B) */

typedef struct hwrm_cfa_flow_alloc_cmd_err {
	/*
	 * command specific error codes that goes to
	 * the cmd_err field in Common HWRM Error Response.
	 */
	uint8_t	code;
	/* Unknown error */
	#define HWRM_CFA_FLOW_ALLOC_CMD_ERR_CODE_UNKNOWN	UINT32_C(0x0)
	/* No more L2 Context TCAM */
	#define HWRM_CFA_FLOW_ALLOC_CMD_ERR_CODE_L2_CONTEXT_TCAM UINT32_C(0x1)
	/* No more action records */
	#define HWRM_CFA_FLOW_ALLOC_CMD_ERR_CODE_ACTION_RECORD   UINT32_C(0x2)
	/* No more flow counters */
	#define HWRM_CFA_FLOW_ALLOC_CMD_ERR_CODE_FLOW_COUNTER	UINT32_C(0x3)
	/* No more wild-card TCAM */
	#define HWRM_CFA_FLOW_ALLOC_CMD_ERR_CODE_WILD_CARD_TCAM  UINT32_C(0x4)
	/* Hash collsion in exact match tables */
	#define HWRM_CFA_FLOW_ALLOC_CMD_ERR_CODE_HASH_COLLISION  UINT32_C(0x5)
	/* Key is already installed */
	#define HWRM_CFA_FLOW_ALLOC_CMD_ERR_CODE_KEY_EXISTS	UINT32_C(0x6)
	/* Flow Context DB is out of resource */
	#define HWRM_CFA_FLOW_ALLOC_CMD_ERR_CODE_FLOW_CTXT_DB	UINT32_C(0x7)
	#define HWRM_CFA_FLOW_ALLOC_CMD_ERR_CODE_LAST	HWRM_CFA_FLOW_ALLOC_CMD_ERR_CODE_FLOW_CTXT_DB
	uint8_t	unused_0[7];
} hwrm_cfa_flow_alloc_cmd_err_t, *phwrm_cfa_flow_alloc_cmd_err_t;

/**********************
 * hwrm_cfa_flow_free *
 **********************/


/* hwrm_cfa_flow_free_input (size:256b/32B) */

typedef struct hwrm_cfa_flow_free_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Flow record index. */
	uint16_t	flow_handle;
	uint16_t	unused_0;
	/* Flow counter id to be freed. */
	uint32_t	flow_counter_id;
	/* This value identifies a set of CFA data structures used for a flow. */
	uint64_t	ext_flow_handle;
} hwrm_cfa_flow_free_input_t, *phwrm_cfa_flow_free_input_t;

/* hwrm_cfa_flow_free_output (size:256b/32B) */

typedef struct hwrm_cfa_flow_free_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* packet is 64 b */
	uint64_t	packet;
	/* byte is 64 b */
	uint64_t	byte;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_cfa_flow_free_output_t, *phwrm_cfa_flow_free_output_t;

/* hwrm_cfa_flow_action_data (size:960b/120B) */

typedef struct hwrm_cfa_flow_action_data {
	uint16_t	action_flags;
	/* Setting of this flag indicates accept action. */
	#define HWRM_CFA_FLOW_ACTION_DATA_ACTION_FLAGS_FWD			UINT32_C(0x1)
	/* Setting of this flag indicates recycle action. */
	#define HWRM_CFA_FLOW_ACTION_DATA_ACTION_FLAGS_RECYCLE		UINT32_C(0x2)
	/* Setting of this flag indicates drop action. */
	#define HWRM_CFA_FLOW_ACTION_DATA_ACTION_FLAGS_DROP		UINT32_C(0x4)
	/* Setting of this flag indicates meter action. */
	#define HWRM_CFA_FLOW_ACTION_DATA_ACTION_FLAGS_METER		UINT32_C(0x8)
	/* Setting of this flag indicates tunnel action. */
	#define HWRM_CFA_FLOW_ACTION_DATA_ACTION_FLAGS_TUNNEL		UINT32_C(0x10)
	/*
	 * If set to 1 and flow direction is TX, it indicates decap of L2
	 * header and encap of tunnel header. If set to 1 and flow direction
	 * is RX, it indicates decap of tunnel header and encap L2 header.
	 */
	#define HWRM_CFA_FLOW_ACTION_DATA_ACTION_FLAGS_TUNNEL_IP		UINT32_C(0x20)
	/* Setting of this flag indicates ttl decrement action. */
	#define HWRM_CFA_FLOW_ACTION_DATA_ACTION_FLAGS_TTL_DECREMENT	UINT32_C(0x40)
	/* If set to 1, flow aging is enabled for this flow. */
	#define HWRM_CFA_FLOW_ACTION_DATA_ACTION_FLAGS_FLOW_AGING_ENABLED	UINT32_C(0x80)
	/* Setting of this flag indicates encap action. */
	#define HWRM_CFA_FLOW_ACTION_DATA_ACTION_FLAGS_ENCAP		UINT32_C(0x100)
	/* Setting of this flag indicates decap action. */
	#define HWRM_CFA_FLOW_ACTION_DATA_ACTION_FLAGS_DECAP		UINT32_C(0x200)
	/* Meter id. */
	uint16_t	act_meter_id;
	/* VNIC id. */
	uint16_t	vnic_id;
	/* vport number. */
	uint16_t	vport_id;
	/* The NAT source/destination. */
	uint16_t	nat_port;
	uint16_t	unused_0[3];
	/* NAT IPv4/IPv6 address. */
	uint32_t	nat_ip_address[4];
	/* Encapsulation Type. */
	uint8_t	encap_type;
	/* Virtual eXtensible Local Area Network (VXLAN) */
	#define HWRM_CFA_FLOW_ACTION_DATA_ENCAP_TYPE_VXLAN	UINT32_C(0x1)
	/* Network Virtualization Generic Routing Encapsulation (NVGRE) */
	#define HWRM_CFA_FLOW_ACTION_DATA_ENCAP_TYPE_NVGRE	UINT32_C(0x2)
	/* Generic Routing Encapsulation (GRE) after inside Ethernet payload */
	#define HWRM_CFA_FLOW_ACTION_DATA_ENCAP_TYPE_L2GRE	UINT32_C(0x3)
	/* IP in IP */
	#define HWRM_CFA_FLOW_ACTION_DATA_ENCAP_TYPE_IPIP	UINT32_C(0x4)
	/* Generic Network Virtualization Encapsulation (Geneve) */
	#define HWRM_CFA_FLOW_ACTION_DATA_ENCAP_TYPE_GENEVE	UINT32_C(0x5)
	/* Multi-Protocol Label Switching (MPLS) */
	#define HWRM_CFA_FLOW_ACTION_DATA_ENCAP_TYPE_MPLS	UINT32_C(0x6)
	/* VLAN */
	#define HWRM_CFA_FLOW_ACTION_DATA_ENCAP_TYPE_VLAN	UINT32_C(0x7)
	/* Generic Routing Encapsulation (GRE) inside IP datagram payload */
	#define HWRM_CFA_FLOW_ACTION_DATA_ENCAP_TYPE_IPGRE	UINT32_C(0x8)
	/* IPV4 over virtual eXtensible Local Area Network (IPV4oVXLAN) */
	#define HWRM_CFA_FLOW_ACTION_DATA_ENCAP_TYPE_VXLAN_V4	UINT32_C(0x9)
	/*
	 * Enhance Generic Routing Encapsulation (GRE version 1) inside IP
	 * datagram payload
	 */
	#define HWRM_CFA_FLOW_ACTION_DATA_ENCAP_TYPE_IPGRE_V1	UINT32_C(0xa)
	/* Use fixed layer 2 ether type of 0xFFFF */
	#define HWRM_CFA_FLOW_ACTION_DATA_ENCAP_TYPE_L2_ETYPE	UINT32_C(0xb)
	/*
	 * IPV6 over virtual eXtensible Local Area Network with GPE header
	 * (IPV6oVXLANGPE)
	 */
	#define HWRM_CFA_FLOW_ACTION_DATA_ENCAP_TYPE_VXLAN_GPE_V6 UINT32_C(0xc)
	#define HWRM_CFA_FLOW_ACTION_DATA_ENCAP_TYPE_LAST	HWRM_CFA_FLOW_ACTION_DATA_ENCAP_TYPE_VXLAN_GPE_V6
	uint8_t	unused[7];
	/* This value is encap data for the associated encap type. */
	uint32_t	encap_data[20];
} hwrm_cfa_flow_action_data_t, *phwrm_cfa_flow_action_data_t;

/* hwrm_cfa_flow_tunnel_hdr_data (size:64b/8B) */

typedef struct hwrm_cfa_flow_tunnel_hdr_data {
	/* Tunnel Type. */
	uint8_t	tunnel_type;
	/* Non-tunnel */
	#define HWRM_CFA_FLOW_TUNNEL_HDR_DATA_TUNNEL_TYPE_NONTUNNEL	UINT32_C(0x0)
	/* Virtual eXtensible Local Area Network (VXLAN) */
	#define HWRM_CFA_FLOW_TUNNEL_HDR_DATA_TUNNEL_TYPE_VXLAN	UINT32_C(0x1)
	/* Network Virtualization Generic Routing Encapsulation (NVGRE) */
	#define HWRM_CFA_FLOW_TUNNEL_HDR_DATA_TUNNEL_TYPE_NVGRE	UINT32_C(0x2)
	/* Generic Routing Encapsulation (GRE) inside Ethernet payload */
	#define HWRM_CFA_FLOW_TUNNEL_HDR_DATA_TUNNEL_TYPE_L2GRE	UINT32_C(0x3)
	/* IP in IP */
	#define HWRM_CFA_FLOW_TUNNEL_HDR_DATA_TUNNEL_TYPE_IPIP	UINT32_C(0x4)
	/* Generic Network Virtualization Encapsulation (Geneve) */
	#define HWRM_CFA_FLOW_TUNNEL_HDR_DATA_TUNNEL_TYPE_GENEVE	UINT32_C(0x5)
	/* Multi-Protocol Label Switching (MPLS) */
	#define HWRM_CFA_FLOW_TUNNEL_HDR_DATA_TUNNEL_TYPE_MPLS	UINT32_C(0x6)
	/* Stateless Transport Tunnel (STT) */
	#define HWRM_CFA_FLOW_TUNNEL_HDR_DATA_TUNNEL_TYPE_STT	UINT32_C(0x7)
	/* Generic Routing Encapsulation (GRE) inside IP datagram payload */
	#define HWRM_CFA_FLOW_TUNNEL_HDR_DATA_TUNNEL_TYPE_IPGRE	UINT32_C(0x8)
	/* IPV4 over virtual eXtensible Local Area Network (IPV4oVXLAN) */
	#define HWRM_CFA_FLOW_TUNNEL_HDR_DATA_TUNNEL_TYPE_VXLAN_V4	UINT32_C(0x9)
	/*
	 * Enhance Generic Routing Encapsulation (GRE version 1) inside IP
	 * datagram payload
	 */
	#define HWRM_CFA_FLOW_TUNNEL_HDR_DATA_TUNNEL_TYPE_IPGRE_V1	UINT32_C(0xa)
	/* Use fixed layer 2 ether type of 0xFFFF */
	#define HWRM_CFA_FLOW_TUNNEL_HDR_DATA_TUNNEL_TYPE_L2_ETYPE	UINT32_C(0xb)
	/*
	 * IPV6 over virtual eXtensible Local Area Network with GPE header
	 * (IPV6oVXLANGPE)
	 */
	#define HWRM_CFA_FLOW_TUNNEL_HDR_DATA_TUNNEL_TYPE_VXLAN_GPE_V6 UINT32_C(0xc)
	/* Any tunneled traffic */
	#define HWRM_CFA_FLOW_TUNNEL_HDR_DATA_TUNNEL_TYPE_ANYTUNNEL	UINT32_C(0xff)
	#define HWRM_CFA_FLOW_TUNNEL_HDR_DATA_TUNNEL_TYPE_LAST	HWRM_CFA_FLOW_TUNNEL_HDR_DATA_TUNNEL_TYPE_ANYTUNNEL
	uint8_t	unused[3];
	/*
	 * Tunnel identifier.
	 * Virtual Network Identifier (VNI).
	 */
	uint32_t	tunnel_id;
} hwrm_cfa_flow_tunnel_hdr_data_t, *phwrm_cfa_flow_tunnel_hdr_data_t;

/* hwrm_cfa_flow_l4_key_data (size:64b/8B) */

typedef struct hwrm_cfa_flow_l4_key_data {
	/* The value of source port. */
	uint16_t	l4_src_port;
	/* The value of destination port. */
	uint16_t	l4_dst_port;
	uint32_t	unused;
} hwrm_cfa_flow_l4_key_data_t, *phwrm_cfa_flow_l4_key_data_t;

/* hwrm_cfa_flow_l3_key_data (size:512b/64B) */

typedef struct hwrm_cfa_flow_l3_key_data {
	/* The value of ip protocol. */
	uint8_t	ip_protocol;
	uint8_t	unused_0[7];
	/* The value of destination IPv4/IPv6 address. */
	uint32_t	ip_dst[4];
	/* The source IPv4/IPv6 address. */
	uint32_t	ip_src[4];
	/* NAT IPv4/IPv6 address. */
	uint32_t	nat_ip_address[4];
	uint64_t	unused;
} hwrm_cfa_flow_l3_key_data_t, *phwrm_cfa_flow_l3_key_data_t;

/* hwrm_cfa_flow_l2_key_data (size:448b/56B) */

typedef struct hwrm_cfa_flow_l2_key_data {
	/* Destination MAC address. */
	uint16_t	dmac[3];
	uint16_t	unused_0;
	/* Source MAC address. */
	uint16_t	smac[3];
	uint16_t	unused_1;
	/* L2 header re-write Destination MAC address. */
	uint16_t	l2_rewrite_dmac[3];
	uint16_t	unused_2;
	/* L2 header re-write Source MAC address. */
	uint16_t	l2_rewrite_smac[3];
	/* Ethertype. */
	uint16_t	ethertype;
	/* Number of VLAN tags. */
	uint16_t	num_vlan_tags;
	/* VLAN tpid. */
	uint16_t	l2_rewrite_vlan_tpid;
	/* VLAN tci. */
	uint16_t	l2_rewrite_vlan_tci;
	uint8_t	unused_3[2];
	/* Outer VLAN TPID. */
	uint16_t	ovlan_tpid;
	/* Outer VLAN TCI. */
	uint16_t	ovlan_tci;
	/* Inner VLAN TPID. */
	uint16_t	ivlan_tpid;
	/* Inner VLAN TCI. */
	uint16_t	ivlan_tci;
	uint8_t	unused[8];
} hwrm_cfa_flow_l2_key_data_t, *phwrm_cfa_flow_l2_key_data_t;

/* hwrm_cfa_flow_key_data (size:4160b/520B) */

typedef struct hwrm_cfa_flow_key_data {
	/* Flow associated tunnel L2 header key info. */
	uint32_t	t_l2_key_data[14];
	/* Flow associated tunnel L2 header mask info. */
	uint32_t	t_l2_key_mask[14];
	/* Flow associated tunnel L3 header key info. */
	uint32_t	t_l3_key_data[16];
	/* Flow associated tunnel L3 header mask info. */
	uint32_t	t_l3_key_mask[16];
	/* Flow associated tunnel L4 header key info. */
	uint64_t	t_l4_key_data;
	/* Flow associated tunnel L4 header mask info. */
	uint64_t	t_l4_key_mask;
	/* Flow associated tunnel header info. */
	uint64_t	tunnel_hdr;
	/* Flow associated L2 header key info. */
	uint32_t	l2_key_data[14];
	/* Flow associated L2 header mask info. */
	uint32_t	l2_key_mask[14];
	/* Flow associated L3 header key info. */
	uint32_t	l3_key_data[16];
	/* Flow associated L3 header mask info. */
	uint32_t	l3_key_mask[16];
	/* Flow associated L4 header key info. */
	uint64_t	l4_key_data;
	/* Flow associated L4 header mask info. */
	uint64_t	l4_key_mask;
} hwrm_cfa_flow_key_data_t, *phwrm_cfa_flow_key_data_t;

/**********************
 * hwrm_cfa_flow_info *
 **********************/


/* hwrm_cfa_flow_info_input (size:256b/32B) */

typedef struct hwrm_cfa_flow_info_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Flow record index. */
	uint16_t	flow_handle;
	/* Max flow handle */
	#define HWRM_CFA_FLOW_INFO_INPUT_FLOW_HANDLE_MAX_MASK	UINT32_C(0xfff)
	#define HWRM_CFA_FLOW_INFO_INPUT_FLOW_HANDLE_MAX_SFT	0
	/* CNP flow handle */
	#define HWRM_CFA_FLOW_INFO_INPUT_FLOW_HANDLE_CNP_CNT	UINT32_C(0x1000)
	/* RoCEv1 flow handle */
	#define HWRM_CFA_FLOW_INFO_INPUT_FLOW_HANDLE_ROCEV1_CNT	UINT32_C(0x2000)
	/* RoCEv2 flow handle */
	#define HWRM_CFA_FLOW_INFO_INPUT_FLOW_HANDLE_ROCEV2_CNT	UINT32_C(0x4000)
	/* Direction rx = 1 */
	#define HWRM_CFA_FLOW_INFO_INPUT_FLOW_HANDLE_DIR_RX	UINT32_C(0x8000)
	uint8_t	unused_0[6];
	/* This value identifies a set of CFA data structures used for a flow. */
	uint64_t	ext_flow_handle;
} hwrm_cfa_flow_info_input_t, *phwrm_cfa_flow_info_input_t;

/* hwrm_cfa_flow_info_output (size:5632b/704B) */

typedef struct hwrm_cfa_flow_info_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	flags;
	/* When set to 1, indicates the configuration is the TX flow. */
	#define HWRM_CFA_FLOW_INFO_OUTPUT_FLAGS_PATH_TX	UINT32_C(0x1)
	/* When set to 1, indicates the configuration is the RX flow. */
	#define HWRM_CFA_FLOW_INFO_OUTPUT_FLAGS_PATH_RX	UINT32_C(0x2)
	/* profile is 8 b */
	uint8_t	profile;
	/* src_fid is 16 b */
	uint16_t	src_fid;
	/* dst_fid is 16 b */
	uint16_t	dst_fid;
	/* l2_ctxt_id is 16 b */
	uint16_t	l2_ctxt_id;
	/* em_info is 64 b */
	uint64_t	em_info;
	/* tcam_info is 64 b */
	uint64_t	tcam_info;
	/* vfp_tcam_info is 64 b */
	uint64_t	vfp_tcam_info;
	/* ar_id is 16 b */
	uint16_t	ar_id;
	/* flow_handle is 16 b */
	uint16_t	flow_handle;
	/* tunnel_handle is 32 b */
	uint32_t	tunnel_handle;
	/* The flow aging timer for the flow, the unit is 100 milliseconds */
	uint16_t	flow_timer;
	uint8_t	unused_0[6];
	/* Flow associated L2, L3 and L4 headers info. */
	uint32_t	flow_key_data[130];
	/* Flow associated action record info. */
	uint32_t	flow_action_info[30];
	uint8_t	unused_1[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_cfa_flow_info_output_t, *phwrm_cfa_flow_info_output_t;

/***********************
 * hwrm_cfa_flow_flush *
 ***********************/


/* hwrm_cfa_flow_flush_input (size:256b/32B) */

typedef struct hwrm_cfa_flow_flush_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* flags is 32 b */
	uint32_t	flags;
	/*
	 * Set to 1 to indicate the page size, page layers, and
	 * flow_handle_table_dma_addr fields are valid. The flow flush
	 * operation should only flush the flows from the flow table
	 * specified. This flag is set to 0 by older driver. For older
	 * firmware, setting this flag has no effect.
	 */
	#define HWRM_CFA_FLOW_FLUSH_INPUT_FLAGS_FLOW_TABLE_VALID			UINT32_C(0x1)
	/*
	 * Set to 1 to indicate flow flush operation to cleanup all the
	 * flows, meters, CFA context memory tables etc. This flag is set to
	 * 0 by older driver. For older firmware, setting this flag has no
	 * effect.
	 */
	#define HWRM_CFA_FLOW_FLUSH_INPUT_FLAGS_FLOW_RESET_ALL			UINT32_C(0x2)
	/*
	 * Set to 1 to indicate flow flush operation to cleanup all the
	 * flows by the caller. This flag is set to 0 by older driver. For
	 * older firmware, setting this flag has no effect.
	 */
	#define HWRM_CFA_FLOW_FLUSH_INPUT_FLAGS_FLOW_RESET_PORT			UINT32_C(0x4)
	/*
	 * Set to 1 to indicate the flow counter IDs are included in the
	 * flow table.
	 */
	#define HWRM_CFA_FLOW_FLUSH_INPUT_FLAGS_FLOW_HANDLE_INCL_FC		UINT32_C(0x8000000)
	/*
	 * This specifies the size of flow handle entries provided by the
	 * driver in the flow table specified below. Only two flow handle
	 * size enums are defined.
	 */
	#define HWRM_CFA_FLOW_FLUSH_INPUT_FLAGS_FLOW_HANDLE_ENTRY_SIZE_MASK	UINT32_C(0xc0000000)
	#define HWRM_CFA_FLOW_FLUSH_INPUT_FLAGS_FLOW_HANDLE_ENTRY_SIZE_SFT	30
	/* The flow handle is 16bit */
		#define HWRM_CFA_FLOW_FLUSH_INPUT_FLAGS_FLOW_HANDLE_ENTRY_SIZE_FLOW_HND_16BIT  (UINT32_C(0x0) << 30)
	/* The flow handle is 64bit */
		#define HWRM_CFA_FLOW_FLUSH_INPUT_FLAGS_FLOW_HANDLE_ENTRY_SIZE_FLOW_HND_64BIT  (UINT32_C(0x1) << 30)
		#define HWRM_CFA_FLOW_FLUSH_INPUT_FLAGS_FLOW_HANDLE_ENTRY_SIZE_LAST	HWRM_CFA_FLOW_FLUSH_INPUT_FLAGS_FLOW_HANDLE_ENTRY_SIZE_FLOW_HND_64BIT
	/* Specify page size of the flow table memory. */
	uint8_t	page_size;
	/* The page size is 4K */
	#define HWRM_CFA_FLOW_FLUSH_INPUT_PAGE_SIZE_4K   UINT32_C(0x0)
	/* The page size is 8K */
	#define HWRM_CFA_FLOW_FLUSH_INPUT_PAGE_SIZE_8K   UINT32_C(0x1)
	/* The page size is 64K */
	#define HWRM_CFA_FLOW_FLUSH_INPUT_PAGE_SIZE_64K  UINT32_C(0x4)
	/* The page size is 256K */
	#define HWRM_CFA_FLOW_FLUSH_INPUT_PAGE_SIZE_256K UINT32_C(0x6)
	/* The page size is 1M */
	#define HWRM_CFA_FLOW_FLUSH_INPUT_PAGE_SIZE_1M   UINT32_C(0x8)
	/* The page size is 2M */
	#define HWRM_CFA_FLOW_FLUSH_INPUT_PAGE_SIZE_2M   UINT32_C(0x9)
	/* The page size is 4M */
	#define HWRM_CFA_FLOW_FLUSH_INPUT_PAGE_SIZE_4M   UINT32_C(0xa)
	/* The page size is 1G */
	#define HWRM_CFA_FLOW_FLUSH_INPUT_PAGE_SIZE_1G   UINT32_C(0x12)
	#define HWRM_CFA_FLOW_FLUSH_INPUT_PAGE_SIZE_LAST HWRM_CFA_FLOW_FLUSH_INPUT_PAGE_SIZE_1G
	/* FLow table memory indirect levels. */
	uint8_t	page_level;
	/* PBL pointer is physical start address. */
	#define HWRM_CFA_FLOW_FLUSH_INPUT_PAGE_LEVEL_LVL_0 UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
	#define HWRM_CFA_FLOW_FLUSH_INPUT_PAGE_LEVEL_LVL_1 UINT32_C(0x1)
	/*
	 * PBL pointer points to PDE table with each entry pointing to PTE
	 * tables.
	 */
	#define HWRM_CFA_FLOW_FLUSH_INPUT_PAGE_LEVEL_LVL_2 UINT32_C(0x2)
	#define HWRM_CFA_FLOW_FLUSH_INPUT_PAGE_LEVEL_LAST HWRM_CFA_FLOW_FLUSH_INPUT_PAGE_LEVEL_LVL_2
	/* number of flows in the flow table */
	uint16_t	num_flows;
	/* Pointer to the PBL, or PDL depending on number of levels */
	uint64_t	page_dir;
} hwrm_cfa_flow_flush_input_t, *phwrm_cfa_flow_flush_input_t;

/* hwrm_cfa_flow_flush_output (size:128b/16B) */

typedef struct hwrm_cfa_flow_flush_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_cfa_flow_flush_output_t, *phwrm_cfa_flow_flush_output_t;

/***********************
 * hwrm_cfa_flow_stats *
 ***********************/


/* hwrm_cfa_flow_stats_input (size:640b/80B) */

typedef struct hwrm_cfa_flow_stats_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Flow handle. */
	uint16_t	num_flows;
	/* Flow handle. */
	uint16_t	flow_handle_0;
	/* Flow handle. */
	uint16_t	flow_handle_1;
	/* Flow handle. */
	uint16_t	flow_handle_2;
	/* Flow handle. */
	uint16_t	flow_handle_3;
	/* Flow handle. */
	uint16_t	flow_handle_4;
	/* Flow handle. */
	uint16_t	flow_handle_5;
	/* Flow handle. */
	uint16_t	flow_handle_6;
	/* Flow handle. */
	uint16_t	flow_handle_7;
	/* Flow handle. */
	uint16_t	flow_handle_8;
	/* Flow handle. */
	uint16_t	flow_handle_9;
	uint8_t	unused_0[2];
	/* Flow ID of a flow. */
	uint32_t	flow_id_0;
	/* Flow ID of a flow. */
	uint32_t	flow_id_1;
	/* Flow ID of a flow. */
	uint32_t	flow_id_2;
	/* Flow ID of a flow. */
	uint32_t	flow_id_3;
	/* Flow ID of a flow. */
	uint32_t	flow_id_4;
	/* Flow ID of a flow. */
	uint32_t	flow_id_5;
	/* Flow ID of a flow. */
	uint32_t	flow_id_6;
	/* Flow ID of a flow. */
	uint32_t	flow_id_7;
	/* Flow ID of a flow. */
	uint32_t	flow_id_8;
	/* Flow ID of a flow. */
	uint32_t	flow_id_9;
} hwrm_cfa_flow_stats_input_t, *phwrm_cfa_flow_stats_input_t;

/* hwrm_cfa_flow_stats_output (size:1408b/176B) */

typedef struct hwrm_cfa_flow_stats_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* packet_0 is 64 b */
	uint64_t	packet_0;
	/* packet_1 is 64 b */
	uint64_t	packet_1;
	/* packet_2 is 64 b */
	uint64_t	packet_2;
	/* packet_3 is 64 b */
	uint64_t	packet_3;
	/* packet_4 is 64 b */
	uint64_t	packet_4;
	/* packet_5 is 64 b */
	uint64_t	packet_5;
	/* packet_6 is 64 b */
	uint64_t	packet_6;
	/* packet_7 is 64 b */
	uint64_t	packet_7;
	/* packet_8 is 64 b */
	uint64_t	packet_8;
	/* packet_9 is 64 b */
	uint64_t	packet_9;
	/* byte_0 is 64 b */
	uint64_t	byte_0;
	/* byte_1 is 64 b */
	uint64_t	byte_1;
	/* byte_2 is 64 b */
	uint64_t	byte_2;
	/* byte_3 is 64 b */
	uint64_t	byte_3;
	/* byte_4 is 64 b */
	uint64_t	byte_4;
	/* byte_5 is 64 b */
	uint64_t	byte_5;
	/* byte_6 is 64 b */
	uint64_t	byte_6;
	/* byte_7 is 64 b */
	uint64_t	byte_7;
	/* byte_8 is 64 b */
	uint64_t	byte_8;
	/* byte_9 is 64 b */
	uint64_t	byte_9;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_cfa_flow_stats_output_t, *phwrm_cfa_flow_stats_output_t;

/***********************************
 * hwrm_cfa_flow_aging_timer_reset *
 ***********************************/


/* hwrm_cfa_flow_aging_timer_reset_input (size:256b/32B) */

typedef struct hwrm_cfa_flow_aging_timer_reset_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Flow record index. */
	uint16_t	flow_handle;
	uint8_t	unused_0[2];
	/*
	 * New flow timer value for the flow specified in the ext_flow_handle.
	 * The flow timer unit is 100ms.
	 */
	uint32_t	flow_timer;
	/* This value identifies a set of CFA data structures used for a flow. */
	uint64_t	ext_flow_handle;
} hwrm_cfa_flow_aging_timer_reset_input_t, *phwrm_cfa_flow_aging_timer_reset_input_t;

/* hwrm_cfa_flow_aging_timer_reset_output (size:128b/16B) */

typedef struct hwrm_cfa_flow_aging_timer_reset_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_cfa_flow_aging_timer_reset_output_t, *phwrm_cfa_flow_aging_timer_reset_output_t;

/***************************
 * hwrm_cfa_flow_aging_cfg *
 ***************************/


/* hwrm_cfa_flow_aging_cfg_input (size:384b/48B) */

typedef struct hwrm_cfa_flow_aging_cfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* The bit field to enable per flow aging configuration. */
	uint16_t	enables;
	/*
	 * This bit must be '1' for the tcp flow timer field to be
	 * configured
	 */
	#define HWRM_CFA_FLOW_AGING_CFG_INPUT_ENABLES_TCP_FLOW_TIMER	UINT32_C(0x1)
	/*
	 * This bit must be '1' for the tcp finish timer field to be
	 * configured
	 */
	#define HWRM_CFA_FLOW_AGING_CFG_INPUT_ENABLES_TCP_FIN_TIMER	UINT32_C(0x2)
	/*
	 * This bit must be '1' for the udp flow timer field to be
	 * configured
	 */
	#define HWRM_CFA_FLOW_AGING_CFG_INPUT_ENABLES_UDP_FLOW_TIMER	UINT32_C(0x4)
	/*
	 * This bit must be '1' for the eem dma interval field to be
	 * configured
	 */
	#define HWRM_CFA_FLOW_AGING_CFG_INPUT_ENABLES_EEM_DMA_INTERVAL	UINT32_C(0x8)
	/*
	 * This bit must be '1' for the eem notice interval field to be
	 * configured
	 */
	#define HWRM_CFA_FLOW_AGING_CFG_INPUT_ENABLES_EEM_NOTICE_INTERVAL	UINT32_C(0x10)
	/*
	 * This bit must be '1' for the eem context memory maximum entries
	 * field to be configured
	 */
	#define HWRM_CFA_FLOW_AGING_CFG_INPUT_ENABLES_EEM_CTX_MAX_ENTRIES	UINT32_C(0x20)
	/*
	 * This bit must be '1' for the eem context memory ID field to be
	 * configured
	 */
	#define HWRM_CFA_FLOW_AGING_CFG_INPUT_ENABLES_EEM_CTX_ID		UINT32_C(0x40)
	/*
	 * This bit must be '1' for the eem context memory type field to be
	 * configured
	 */
	#define HWRM_CFA_FLOW_AGING_CFG_INPUT_ENABLES_EEM_CTX_MEM_TYPE	UINT32_C(0x80)
	uint8_t	flags;
	/* Enumeration denoting the RX, TX type of the resource. */
	#define HWRM_CFA_FLOW_AGING_CFG_INPUT_FLAGS_PATH	UINT32_C(0x1)
	/* tx path */
		#define HWRM_CFA_FLOW_AGING_CFG_INPUT_FLAGS_PATH_TX	UINT32_C(0x0)
	/* rx path */
		#define HWRM_CFA_FLOW_AGING_CFG_INPUT_FLAGS_PATH_RX	UINT32_C(0x1)
		#define HWRM_CFA_FLOW_AGING_CFG_INPUT_FLAGS_PATH_LAST   HWRM_CFA_FLOW_AGING_CFG_INPUT_FLAGS_PATH_RX
	/*
	 * Enumeration denoting the enable, disable eem flow aging
	 * configuration.
	 */
	#define HWRM_CFA_FLOW_AGING_CFG_INPUT_FLAGS_EEM	UINT32_C(0x2)
	/* tx path */
		#define HWRM_CFA_FLOW_AGING_CFG_INPUT_FLAGS_EEM_DISABLE  (UINT32_C(0x0) << 1)
	/* rx path */
		#define HWRM_CFA_FLOW_AGING_CFG_INPUT_FLAGS_EEM_ENABLE   (UINT32_C(0x1) << 1)
		#define HWRM_CFA_FLOW_AGING_CFG_INPUT_FLAGS_EEM_LAST	HWRM_CFA_FLOW_AGING_CFG_INPUT_FLAGS_EEM_ENABLE
	uint8_t	unused_0;
	/*
	 * The flow aging timer for all TCP flows, the unit is 100
	 * milliseconds.
	 */
	uint32_t	tcp_flow_timer;
	/*
	 * The TCP finished timer for all TCP flows, the unit is 100
	 * milliseconds.
	 */
	uint32_t	tcp_fin_timer;
	/*
	 * The flow aging timer for all UDP flows, the unit is 100
	 * milliseconds.
	 */
	uint32_t	udp_flow_timer;
	/*
	 * The interval to dma eem ejection data to host memory, the unit is
	 * milliseconds.
	 */
	uint16_t	eem_dma_interval;
	/*
	 * The interval to notify driver to read the eem ejection data, the
	 * unit is milliseconds.
	 */
	uint16_t	eem_notice_interval;
	/* The maximum entries number in the eem context memory. */
	uint32_t	eem_ctx_max_entries;
	/* The context memory ID for eem flow aging. */
	uint16_t	eem_ctx_id;
	uint16_t	eem_ctx_mem_type;
	/*
	 * The content of context memory is eem ejection data, the size of
	 * each entry is 4 bytes.
	 */
	#define HWRM_CFA_FLOW_AGING_CFG_INPUT_EEM_CTX_MEM_TYPE_EJECTION_DATA UINT32_C(0x0)
	#define HWRM_CFA_FLOW_AGING_CFG_INPUT_EEM_CTX_MEM_TYPE_LAST	HWRM_CFA_FLOW_AGING_CFG_INPUT_EEM_CTX_MEM_TYPE_EJECTION_DATA
	uint8_t	unused_1[4];
} hwrm_cfa_flow_aging_cfg_input_t, *phwrm_cfa_flow_aging_cfg_input_t;

/* hwrm_cfa_flow_aging_cfg_output (size:128b/16B) */

typedef struct hwrm_cfa_flow_aging_cfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_cfa_flow_aging_cfg_output_t, *phwrm_cfa_flow_aging_cfg_output_t;

/****************************
 * hwrm_cfa_flow_aging_qcfg *
 ****************************/


/* hwrm_cfa_flow_aging_qcfg_input (size:192b/24B) */

typedef struct hwrm_cfa_flow_aging_qcfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * The direction for the flow aging configuration, 1 is rx path, 2 is
	 * tx path.
	 */
	uint8_t	flags;
	/* Enumeration denoting the RX, TX type of the resource. */
	#define HWRM_CFA_FLOW_AGING_QCFG_INPUT_FLAGS_PATH	UINT32_C(0x1)
	/* tx path */
		#define HWRM_CFA_FLOW_AGING_QCFG_INPUT_FLAGS_PATH_TX	UINT32_C(0x0)
	/* rx path */
		#define HWRM_CFA_FLOW_AGING_QCFG_INPUT_FLAGS_PATH_RX	UINT32_C(0x1)
		#define HWRM_CFA_FLOW_AGING_QCFG_INPUT_FLAGS_PATH_LAST HWRM_CFA_FLOW_AGING_QCFG_INPUT_FLAGS_PATH_RX
	uint8_t	unused_0[7];
} hwrm_cfa_flow_aging_qcfg_input_t, *phwrm_cfa_flow_aging_qcfg_input_t;

/* hwrm_cfa_flow_aging_qcfg_output (size:320b/40B) */

typedef struct hwrm_cfa_flow_aging_qcfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * The current flow aging timer for all TCP flows, the unit is 100
	 * millisecond.
	 */
	uint32_t	tcp_flow_timer;
	/*
	 * The current TCP finished timer for all TCP flows, the unit is 100
	 * millisecond.
	 */
	uint32_t	tcp_fin_timer;
	/*
	 * The current flow aging timer for all UDP flows, the unit is 100
	 * millisecond.
	 */
	uint32_t	udp_flow_timer;
	/*
	 * The interval to dma eem ejection data to host memory, the unit is
	 * milliseconds.
	 */
	uint16_t	eem_dma_interval;
	/*
	 * The interval to notify driver to read the eem ejection data, the
	 * unit is milliseconds.
	 */
	uint16_t	eem_notice_interval;
	/* The maximum entries number in the eem context memory. */
	uint32_t	eem_ctx_max_entries;
	/* The context memory ID for eem flow aging. */
	uint16_t	eem_ctx_id;
	/* The context memory type for eem flow aging. */
	uint16_t	eem_ctx_mem_type;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_cfa_flow_aging_qcfg_output_t, *phwrm_cfa_flow_aging_qcfg_output_t;

/*****************************
 * hwrm_cfa_flow_aging_qcaps *
 *****************************/


/* hwrm_cfa_flow_aging_qcaps_input (size:192b/24B) */

typedef struct hwrm_cfa_flow_aging_qcaps_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * The direction for the flow aging configuration, 1 is rx path, 2 is
	 * tx path.
	 */
	uint8_t	flags;
	/* Enumeration denoting the RX, TX type of the resource. */
	#define HWRM_CFA_FLOW_AGING_QCAPS_INPUT_FLAGS_PATH	UINT32_C(0x1)
	/* tx path */
		#define HWRM_CFA_FLOW_AGING_QCAPS_INPUT_FLAGS_PATH_TX	UINT32_C(0x0)
	/* rx path */
		#define HWRM_CFA_FLOW_AGING_QCAPS_INPUT_FLAGS_PATH_RX	UINT32_C(0x1)
		#define HWRM_CFA_FLOW_AGING_QCAPS_INPUT_FLAGS_PATH_LAST HWRM_CFA_FLOW_AGING_QCAPS_INPUT_FLAGS_PATH_RX
	uint8_t	unused_0[7];
} hwrm_cfa_flow_aging_qcaps_input_t, *phwrm_cfa_flow_aging_qcaps_input_t;

/* hwrm_cfa_flow_aging_qcaps_output (size:256b/32B) */

typedef struct hwrm_cfa_flow_aging_qcaps_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * The maximum flow aging timer for all TCP flows, the unit is 100
	 * millisecond.
	 */
	uint32_t	max_tcp_flow_timer;
	/*
	 * The maximum TCP finished timer for all TCP flows, the unit is 100
	 * millisecond.
	 */
	uint32_t	max_tcp_fin_timer;
	/*
	 * The maximum flow aging timer for all UDP flows, the unit is 100
	 * millisecond.
	 */
	uint32_t	max_udp_flow_timer;
	/* The maximum aging flows that HW can support. */
	uint32_t	max_aging_flows;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_cfa_flow_aging_qcaps_output_t, *phwrm_cfa_flow_aging_qcaps_output_t;

/**********************************
 * hwrm_cfa_tcp_flag_process_qcfg *
 **********************************/


/* hwrm_cfa_tcp_flag_process_qcfg_input (size:128b/16B) */

typedef struct hwrm_cfa_tcp_flag_process_qcfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
} hwrm_cfa_tcp_flag_process_qcfg_input_t, *phwrm_cfa_tcp_flag_process_qcfg_input_t;

/* hwrm_cfa_tcp_flag_process_qcfg_output (size:192b/24B) */

typedef struct hwrm_cfa_tcp_flag_process_qcfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* The port 0 RX mirror action record ID. */
	uint16_t	rx_ar_id_port0;
	/* The port 1 RX mirror action record ID. */
	uint16_t	rx_ar_id_port1;
	/*
	 * The port 0 RX action record ID for TX TCP flag packets from
	 * loopback path.
	 */
	uint16_t	tx_ar_id_port0;
	/*
	 * The port 1 RX action record ID for TX TCP flag packets from
	 * loopback path.
	 */
	uint16_t	tx_ar_id_port1;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_cfa_tcp_flag_process_qcfg_output_t, *phwrm_cfa_tcp_flag_process_qcfg_output_t;

/**************************
 * hwrm_cfa_vf_pair_alloc *
 **************************/


/* hwrm_cfa_vf_pair_alloc_input (size:448b/56B) */

typedef struct hwrm_cfa_vf_pair_alloc_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Logical VF number (range: 0 -> MAX_VFS -1). */
	uint16_t	vf_a_id;
	/* Logical VF number (range: 0 -> MAX_VFS -1). */
	uint16_t	vf_b_id;
	uint8_t	unused_0[4];
	/* VF Pair name (32 byte string). */
	char	pair_name[32];
} hwrm_cfa_vf_pair_alloc_input_t, *phwrm_cfa_vf_pair_alloc_input_t;

/* hwrm_cfa_vf_pair_alloc_output (size:128b/16B) */

typedef struct hwrm_cfa_vf_pair_alloc_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_cfa_vf_pair_alloc_output_t, *phwrm_cfa_vf_pair_alloc_output_t;

/*************************
 * hwrm_cfa_vf_pair_free *
 *************************/


/* hwrm_cfa_vf_pair_free_input (size:384b/48B) */

typedef struct hwrm_cfa_vf_pair_free_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* VF Pair name (32 byte string). */
	char	pair_name[32];
} hwrm_cfa_vf_pair_free_input_t, *phwrm_cfa_vf_pair_free_input_t;

/* hwrm_cfa_vf_pair_free_output (size:128b/16B) */

typedef struct hwrm_cfa_vf_pair_free_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_cfa_vf_pair_free_output_t, *phwrm_cfa_vf_pair_free_output_t;

/*************************
 * hwrm_cfa_vf_pair_info *
 *************************/


/* hwrm_cfa_vf_pair_info_input (size:448b/56B) */

typedef struct hwrm_cfa_vf_pair_info_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	flags;
	/* If this flag is set, lookup by name else lookup by index. */
	#define HWRM_CFA_VF_PAIR_INFO_INPUT_FLAGS_LOOKUP_TYPE	UINT32_C(0x1)
	/* vf pair table index. */
	uint16_t	vf_pair_index;
	uint8_t	unused_0[2];
	/* VF Pair name (32 byte string). */
	char	vf_pair_name[32];
} hwrm_cfa_vf_pair_info_input_t, *phwrm_cfa_vf_pair_info_input_t;

/* hwrm_cfa_vf_pair_info_output (size:512b/64B) */

typedef struct hwrm_cfa_vf_pair_info_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* vf pair table index. */
	uint16_t	next_vf_pair_index;
	/* vf pair member a's vf_fid. */
	uint16_t	vf_a_fid;
	/* vf pair member a's Linux logical VF number. */
	uint16_t	vf_a_index;
	/* vf pair member b's vf_fid. */
	uint16_t	vf_b_fid;
	/* vf pair member a's Linux logical VF number. */
	uint16_t	vf_b_index;
	/* vf pair state. */
	uint8_t	pair_state;
	/* Pair has been allocated */
	#define HWRM_CFA_VF_PAIR_INFO_OUTPUT_PAIR_STATE_ALLOCATED UINT32_C(0x1)
	/* Both pair members are active */
	#define HWRM_CFA_VF_PAIR_INFO_OUTPUT_PAIR_STATE_ACTIVE	UINT32_C(0x2)
	#define HWRM_CFA_VF_PAIR_INFO_OUTPUT_PAIR_STATE_LAST	HWRM_CFA_VF_PAIR_INFO_OUTPUT_PAIR_STATE_ACTIVE
	uint8_t	unused_0[5];
	/* VF Pair name (32 byte string). */
	char	pair_name[32];
	uint8_t	unused_1[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_cfa_vf_pair_info_output_t, *phwrm_cfa_vf_pair_info_output_t;

/***********************
 * hwrm_cfa_pair_alloc *
 ***********************/


/* hwrm_cfa_pair_alloc_input (size:576b/72B) */

typedef struct hwrm_cfa_pair_alloc_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * Pair mode (0-vf2fn, 1-rep2fn, 2-rep2rep, 3-proxy, 4-pfpair,
	 *		5-rep2fn_mod, 6-rep2fn_modall, 7-rep2fn_truflow).
	 */
	uint16_t	pair_mode;
	/* Pair between VF on local host with PF or VF on specified host. */
	#define HWRM_CFA_PAIR_ALLOC_INPUT_PAIR_MODE_VF2FN	UINT32_C(0x0)
	/* Pair between REP on local host with PF or VF on specified host. */
	#define HWRM_CFA_PAIR_ALLOC_INPUT_PAIR_MODE_REP2FN	UINT32_C(0x1)
	/* Pair between REP on local host with REP on specified host. */
	#define HWRM_CFA_PAIR_ALLOC_INPUT_PAIR_MODE_REP2REP	UINT32_C(0x2)
	/* Pair for the proxy interface. */
	#define HWRM_CFA_PAIR_ALLOC_INPUT_PAIR_MODE_PROXY	UINT32_C(0x3)
	/* Pair for the PF interface. */
	#define HWRM_CFA_PAIR_ALLOC_INPUT_PAIR_MODE_PFPAIR	UINT32_C(0x4)
	/* Modify existing rep2fn pair and move pair to new PF. */
	#define HWRM_CFA_PAIR_ALLOC_INPUT_PAIR_MODE_REP2FN_MOD	UINT32_C(0x5)
	/*
	 * Modify existing rep2fn pairs paired with same PF and move pairs
	 * to new PF.
	 */
	#define HWRM_CFA_PAIR_ALLOC_INPUT_PAIR_MODE_REP2FN_MODALL  UINT32_C(0x6)
	/*
	 * Truflow pair between REP on local host with PF or VF on specified
	 * host.
	 */
	#define HWRM_CFA_PAIR_ALLOC_INPUT_PAIR_MODE_REP2FN_TRUFLOW UINT32_C(0x7)
	#define HWRM_CFA_PAIR_ALLOC_INPUT_PAIR_MODE_LAST	HWRM_CFA_PAIR_ALLOC_INPUT_PAIR_MODE_REP2FN_TRUFLOW
	/* Logical VF number (range: 0 -> MAX_VFS -1). */
	uint16_t	vf_a_id;
	/* Logical Host (0xff-local host). */
	uint8_t	host_b_id;
	/* Logical PF (0xff-PF for command channel). */
	uint8_t	pf_b_id;
	/* Logical VF number (range: 0 -> MAX_VFS -1). */
	uint16_t	vf_b_id;
	/* Loopback port (0xff-internal loopback), valid for mode-3. */
	uint8_t	port_id;
	/* Priority used for encap of loopback packets valid for mode-3. */
	uint8_t	pri;
	/* New PF for rep2fn modify, valid for mode 5. */
	uint16_t	new_pf_fid;
	uint32_t	enables;
	/*
	 * This bit must be '1' for the q_ab field to be
	 * configured.
	 */
	#define HWRM_CFA_PAIR_ALLOC_INPUT_ENABLES_Q_AB_VALID	UINT32_C(0x1)
	/*
	 * This bit must be '1' for the q_ba field to be
	 * configured.
	 */
	#define HWRM_CFA_PAIR_ALLOC_INPUT_ENABLES_Q_BA_VALID	UINT32_C(0x2)
	/*
	 * This bit must be '1' for the fc_ab field to be
	 * configured.
	 */
	#define HWRM_CFA_PAIR_ALLOC_INPUT_ENABLES_FC_AB_VALID	UINT32_C(0x4)
	/*
	 * This bit must be '1' for the fc_ba field to be
	 * configured.
	 */
	#define HWRM_CFA_PAIR_ALLOC_INPUT_ENABLES_FC_BA_VALID	UINT32_C(0x8)
	/* VF Pair name (32 byte string). */
	char	pair_name[32];
	/*
	 * The q_ab value specifies the logical index of the TX/RX CoS
	 * queue to be assigned for traffic in the A to B direction of
	 * the interface pair. The default value is 0.
	 */
	uint8_t	q_ab;
	/*
	 * The q_ba value specifies the logical index of the TX/RX CoS
	 * queue to be assigned for traffic in the B to A direction of
	 * the interface pair. The default value is 1.
	 */
	uint8_t	q_ba;
	/*
	 * Specifies whether RX ring flow control is disabled (0) or enabled
	 * (1) in the A to B direction. The default value is 0, meaning that
	 * packets will be dropped when the B-side RX rings are full.
	 */
	uint8_t	fc_ab;
	/*
	 * Specifies whether RX ring flow control is disabled (0) or enabled
	 * (1) in the B to A direction. The default value is 1, meaning that
	 * the RX CoS queue will be flow controlled when the A-side RX rings
	 * are full.
	 */
	uint8_t	fc_ba;
	uint8_t	unused_1[4];
} hwrm_cfa_pair_alloc_input_t, *phwrm_cfa_pair_alloc_input_t;

/* hwrm_cfa_pair_alloc_output (size:192b/24B) */

typedef struct hwrm_cfa_pair_alloc_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Only valid for modes 1 and 2. */
	uint16_t	rx_cfa_code_a;
	/* Only valid for modes 1 and 2. */
	uint16_t	tx_cfa_action_a;
	/* Only valid for mode 2. */
	uint16_t	rx_cfa_code_b;
	/* Only valid for mode 2. */
	uint16_t	tx_cfa_action_b;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_cfa_pair_alloc_output_t, *phwrm_cfa_pair_alloc_output_t;

/**********************
 * hwrm_cfa_pair_free *
 **********************/


/* hwrm_cfa_pair_free_input (size:448b/56B) */

typedef struct hwrm_cfa_pair_free_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* VF Pair name (32 byte string). */
	char	pair_name[32];
	/* Logical PF (0xff-PF for command channel). */
	uint8_t	pf_b_id;
	uint8_t	unused_0[3];
	/* Logical VF number (range: 0 -> MAX_VFS -1). */
	uint16_t	vf_id;
	/*
	 * Pair mode (0-vf2fn, 1-rep2fn, 2-rep2rep, 3-proxy, 4-pfpair,
	 *		5-rep2fn_mod, 6-rep2fn_modall, 7-rep2fn_truflow).
	 */
	uint16_t	pair_mode;
	/* Pair between VF on local host with PF or VF on specified host. */
	#define HWRM_CFA_PAIR_FREE_INPUT_PAIR_MODE_VF2FN	UINT32_C(0x0)
	/* Pair between REP on local host with PF or VF on specified host. */
	#define HWRM_CFA_PAIR_FREE_INPUT_PAIR_MODE_REP2FN	UINT32_C(0x1)
	/* Pair between REP on local host with REP on specified host. */
	#define HWRM_CFA_PAIR_FREE_INPUT_PAIR_MODE_REP2REP	UINT32_C(0x2)
	/* Pair for the proxy interface. */
	#define HWRM_CFA_PAIR_FREE_INPUT_PAIR_MODE_PROXY	UINT32_C(0x3)
	/* Pair for the PF interface. */
	#define HWRM_CFA_PAIR_FREE_INPUT_PAIR_MODE_PFPAIR	UINT32_C(0x4)
	/* Modify existing rep2fn pair and move pair to new PF. */
	#define HWRM_CFA_PAIR_FREE_INPUT_PAIR_MODE_REP2FN_MOD	UINT32_C(0x5)
	/*
	 * Modify existing rep2fn pairs paired with same PF and move pairs
	 * to new PF.
	 */
	#define HWRM_CFA_PAIR_FREE_INPUT_PAIR_MODE_REP2FN_MODALL  UINT32_C(0x6)
	/*
	 * Truflow pair between REP on local host with PF or VF on
	 * specified host.
	 */
	#define HWRM_CFA_PAIR_FREE_INPUT_PAIR_MODE_REP2FN_TRUFLOW UINT32_C(0x7)
	#define HWRM_CFA_PAIR_FREE_INPUT_PAIR_MODE_LAST	HWRM_CFA_PAIR_FREE_INPUT_PAIR_MODE_REP2FN_TRUFLOW
} hwrm_cfa_pair_free_input_t, *phwrm_cfa_pair_free_input_t;

/* hwrm_cfa_pair_free_output (size:128b/16B) */

typedef struct hwrm_cfa_pair_free_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_cfa_pair_free_output_t, *phwrm_cfa_pair_free_output_t;

/**********************
 * hwrm_cfa_pair_info *
 **********************/


/* hwrm_cfa_pair_info_input (size:448b/56B) */

typedef struct hwrm_cfa_pair_info_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	flags;
	/* If this flag is set, lookup by name else lookup by index. */
	#define HWRM_CFA_PAIR_INFO_INPUT_FLAGS_LOOKUP_TYPE	UINT32_C(0x1)
	/* If this flag is set, lookup by PF id and VF id. */
	#define HWRM_CFA_PAIR_INFO_INPUT_FLAGS_LOOKUP_REPRE	UINT32_C(0x2)
	/* Pair table index. */
	uint16_t	pair_index;
	/* Pair pf index. */
	uint8_t	pair_pfid;
	/* Pair vf index. */
	uint8_t	pair_vfid;
	/* Pair name (32 byte string). */
	char	pair_name[32];
} hwrm_cfa_pair_info_input_t, *phwrm_cfa_pair_info_input_t;

/* hwrm_cfa_pair_info_output (size:576b/72B) */

typedef struct hwrm_cfa_pair_info_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Pair table index. */
	uint16_t	next_pair_index;
	/* Pair member a's fid. */
	uint16_t	a_fid;
	/* Logical host number. */
	uint8_t	host_a_index;
	/* Logical PF number. */
	uint8_t	pf_a_index;
	/* Pair member a's Linux logical VF number. */
	uint16_t	vf_a_index;
	/* Rx CFA code. */
	uint16_t	rx_cfa_code_a;
	/* Tx CFA action. */
	uint16_t	tx_cfa_action_a;
	/* Pair member b's fid. */
	uint16_t	b_fid;
	/* Logical host number. */
	uint8_t	host_b_index;
	/* Logical PF number. */
	uint8_t	pf_b_index;
	/* Pair member a's Linux logical VF number. */
	uint16_t	vf_b_index;
	/* Rx CFA code. */
	uint16_t	rx_cfa_code_b;
	/* Tx CFA action. */
	uint16_t	tx_cfa_action_b;
	/* Pair mode (0-vf2fn, 1-rep2fn, 2-rep2rep, 3-proxy, 4-pfpair). */
	uint8_t	pair_mode;
	/* Pair between VF on local host with PF or VF on specified host. */
	#define HWRM_CFA_PAIR_INFO_OUTPUT_PAIR_MODE_VF2FN   UINT32_C(0x0)
	/* Pair between REP on local host with PF or VF on specified host. */
	#define HWRM_CFA_PAIR_INFO_OUTPUT_PAIR_MODE_REP2FN  UINT32_C(0x1)
	/* Pair between REP on local host with REP on specified host. */
	#define HWRM_CFA_PAIR_INFO_OUTPUT_PAIR_MODE_REP2REP UINT32_C(0x2)
	/* Pair for the proxy interface. */
	#define HWRM_CFA_PAIR_INFO_OUTPUT_PAIR_MODE_PROXY   UINT32_C(0x3)
	/* Pair for the PF interface. */
	#define HWRM_CFA_PAIR_INFO_OUTPUT_PAIR_MODE_PFPAIR  UINT32_C(0x4)
	#define HWRM_CFA_PAIR_INFO_OUTPUT_PAIR_MODE_LAST   HWRM_CFA_PAIR_INFO_OUTPUT_PAIR_MODE_PFPAIR
	/* Pair state. */
	uint8_t	pair_state;
	/* Pair has been allocated */
	#define HWRM_CFA_PAIR_INFO_OUTPUT_PAIR_STATE_ALLOCATED UINT32_C(0x1)
	/* Both pair members are active */
	#define HWRM_CFA_PAIR_INFO_OUTPUT_PAIR_STATE_ACTIVE	UINT32_C(0x2)
	#define HWRM_CFA_PAIR_INFO_OUTPUT_PAIR_STATE_LAST	HWRM_CFA_PAIR_INFO_OUTPUT_PAIR_STATE_ACTIVE
	/* Pair name (32 byte string). */
	char	pair_name[32];
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_cfa_pair_info_output_t, *phwrm_cfa_pair_info_output_t;

/**********************
 * hwrm_cfa_vfr_alloc *
 **********************/


/* hwrm_cfa_vfr_alloc_input (size:448b/56B) */

typedef struct hwrm_cfa_vfr_alloc_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Logical VF number (range: 0 -> MAX_VFS -1). */
	uint16_t	vf_id;
	/*
	 * This field is reserved for the future use.
	 * It shall be set to 0.
	 */
	uint16_t	reserved;
	uint8_t	unused_0[4];
	/* VF Representor name (32 byte string). */
	char	vfr_name[32];
} hwrm_cfa_vfr_alloc_input_t, *phwrm_cfa_vfr_alloc_input_t;

/* hwrm_cfa_vfr_alloc_output (size:128b/16B) */

typedef struct hwrm_cfa_vfr_alloc_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Rx CFA code. */
	uint16_t	rx_cfa_code;
	/* Tx CFA action. */
	uint16_t	tx_cfa_action;
	uint8_t	unused_0[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_cfa_vfr_alloc_output_t, *phwrm_cfa_vfr_alloc_output_t;

/*********************
 * hwrm_cfa_vfr_free *
 *********************/


/* hwrm_cfa_vfr_free_input (size:448b/56B) */

typedef struct hwrm_cfa_vfr_free_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* VF Representor name (32 byte string). */
	char	vfr_name[32];
	/* Logical VF number (range: 0 -> MAX_VFS -1). */
	uint16_t	vf_id;
	/*
	 * This field is reserved for the future use.
	 * It shall be set to 0.
	 */
	uint16_t	reserved;
	uint8_t	unused_0[4];
} hwrm_cfa_vfr_free_input_t, *phwrm_cfa_vfr_free_input_t;

/* hwrm_cfa_vfr_free_output (size:128b/16B) */

typedef struct hwrm_cfa_vfr_free_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_cfa_vfr_free_output_t, *phwrm_cfa_vfr_free_output_t;

/***************************************
 * hwrm_cfa_redirect_query_tunnel_type *
 ***************************************/


/* hwrm_cfa_redirect_query_tunnel_type_input (size:192b/24B) */

typedef struct hwrm_cfa_redirect_query_tunnel_type_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* The source function id. */
	uint16_t	src_fid;
	uint8_t	unused_0[6];
} hwrm_cfa_redirect_query_tunnel_type_input_t, *phwrm_cfa_redirect_query_tunnel_type_input_t;

/* hwrm_cfa_redirect_query_tunnel_type_output (size:128b/16B) */

typedef struct hwrm_cfa_redirect_query_tunnel_type_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Tunnel Mask. */
	uint32_t	tunnel_mask;
	/* Non-tunnel */
	#define HWRM_CFA_REDIRECT_QUERY_TUNNEL_TYPE_OUTPUT_TUNNEL_MASK_NONTUNNEL	UINT32_C(0x1)
	/* Virtual eXtensible Local Area Network (VXLAN) */
	#define HWRM_CFA_REDIRECT_QUERY_TUNNEL_TYPE_OUTPUT_TUNNEL_MASK_VXLAN		UINT32_C(0x2)
	/* Network Virtualization Generic Routing Encapsulation (NVGRE) */
	#define HWRM_CFA_REDIRECT_QUERY_TUNNEL_TYPE_OUTPUT_TUNNEL_MASK_NVGRE		UINT32_C(0x4)
	/* Generic Routing Encapsulation (GRE) inside Ethernet payload */
	#define HWRM_CFA_REDIRECT_QUERY_TUNNEL_TYPE_OUTPUT_TUNNEL_MASK_L2GRE		UINT32_C(0x8)
	/* IP in IP */
	#define HWRM_CFA_REDIRECT_QUERY_TUNNEL_TYPE_OUTPUT_TUNNEL_MASK_IPIP		UINT32_C(0x10)
	/* Generic Network Virtualization Encapsulation (Geneve) */
	#define HWRM_CFA_REDIRECT_QUERY_TUNNEL_TYPE_OUTPUT_TUNNEL_MASK_GENEVE	UINT32_C(0x20)
	/* Multi-Protocol Label Switching (MPLS) */
	#define HWRM_CFA_REDIRECT_QUERY_TUNNEL_TYPE_OUTPUT_TUNNEL_MASK_MPLS		UINT32_C(0x40)
	/* Stateless Transport Tunnel (STT) */
	#define HWRM_CFA_REDIRECT_QUERY_TUNNEL_TYPE_OUTPUT_TUNNEL_MASK_STT		UINT32_C(0x80)
	/* Generic Routing Encapsulation (GRE) inside IP datagram payload */
	#define HWRM_CFA_REDIRECT_QUERY_TUNNEL_TYPE_OUTPUT_TUNNEL_MASK_IPGRE		UINT32_C(0x100)
	/* IPV4 over virtual eXtensible Local Area Network (IPV4oVXLAN) */
	#define HWRM_CFA_REDIRECT_QUERY_TUNNEL_TYPE_OUTPUT_TUNNEL_MASK_VXLAN_V4	UINT32_C(0x200)
	/*
	 * Enhance Generic Routing Encapsulation (GRE version 1) inside IP
	 * datagram payload
	 */
	#define HWRM_CFA_REDIRECT_QUERY_TUNNEL_TYPE_OUTPUT_TUNNEL_MASK_IPGRE_V1	UINT32_C(0x400)
	/* Any tunneled traffic */
	#define HWRM_CFA_REDIRECT_QUERY_TUNNEL_TYPE_OUTPUT_TUNNEL_MASK_ANYTUNNEL	UINT32_C(0x800)
	/* Use fixed layer 2 ether type of 0xFFFF */
	#define HWRM_CFA_REDIRECT_QUERY_TUNNEL_TYPE_OUTPUT_TUNNEL_MASK_L2_ETYPE	UINT32_C(0x1000)
	/*
	 * IPV6 over virtual eXtensible Local Area Network with GPE header
	 * (IPV6oVXLANGPE)
	 */
	#define HWRM_CFA_REDIRECT_QUERY_TUNNEL_TYPE_OUTPUT_TUNNEL_MASK_VXLAN_GPE_V6	UINT32_C(0x2000)
	uint8_t	unused_0[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_cfa_redirect_query_tunnel_type_output_t, *phwrm_cfa_redirect_query_tunnel_type_output_t;

/*************************
 * hwrm_cfa_ctx_mem_rgtr *
 *************************/


/* hwrm_cfa_ctx_mem_rgtr_input (size:256b/32B) */

typedef struct hwrm_cfa_ctx_mem_rgtr_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint16_t	flags;
	/* Counter PBL indirect levels. */
	uint8_t	page_level;
	/* PBL pointer is physical start address. */
	#define HWRM_CFA_CTX_MEM_RGTR_INPUT_PAGE_LEVEL_LVL_0 UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
	#define HWRM_CFA_CTX_MEM_RGTR_INPUT_PAGE_LEVEL_LVL_1 UINT32_C(0x1)
	/*
	 * PBL pointer points to PDE table with each entry pointing to PTE
	 * tables.
	 */
	#define HWRM_CFA_CTX_MEM_RGTR_INPUT_PAGE_LEVEL_LVL_2 UINT32_C(0x2)
	#define HWRM_CFA_CTX_MEM_RGTR_INPUT_PAGE_LEVEL_LAST HWRM_CFA_CTX_MEM_RGTR_INPUT_PAGE_LEVEL_LVL_2
	/* Page size. */
	uint8_t	page_size;
	/* 4KB page size. */
	#define HWRM_CFA_CTX_MEM_RGTR_INPUT_PAGE_SIZE_4K   UINT32_C(0x0)
	/* 8KB page size. */
	#define HWRM_CFA_CTX_MEM_RGTR_INPUT_PAGE_SIZE_8K   UINT32_C(0x1)
	/* 64KB page size. */
	#define HWRM_CFA_CTX_MEM_RGTR_INPUT_PAGE_SIZE_64K  UINT32_C(0x4)
	/* 256KB page size. */
	#define HWRM_CFA_CTX_MEM_RGTR_INPUT_PAGE_SIZE_256K UINT32_C(0x6)
	/* 1MB page size. */
	#define HWRM_CFA_CTX_MEM_RGTR_INPUT_PAGE_SIZE_1M   UINT32_C(0x8)
	/* 2MB page size. */
	#define HWRM_CFA_CTX_MEM_RGTR_INPUT_PAGE_SIZE_2M   UINT32_C(0x9)
	/* 4MB page size. */
	#define HWRM_CFA_CTX_MEM_RGTR_INPUT_PAGE_SIZE_4M   UINT32_C(0xa)
	/* 1GB page size. */
	#define HWRM_CFA_CTX_MEM_RGTR_INPUT_PAGE_SIZE_1G   UINT32_C(0x12)
	#define HWRM_CFA_CTX_MEM_RGTR_INPUT_PAGE_SIZE_LAST HWRM_CFA_CTX_MEM_RGTR_INPUT_PAGE_SIZE_1G
	uint32_t	unused_0;
	/* Pointer to the PBL, or PDL depending on number of levels */
	uint64_t	page_dir;
} hwrm_cfa_ctx_mem_rgtr_input_t, *phwrm_cfa_ctx_mem_rgtr_input_t;

/* hwrm_cfa_ctx_mem_rgtr_output (size:128b/16B) */

typedef struct hwrm_cfa_ctx_mem_rgtr_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * Id/Handle to the recently register context memory. This handle is
	 * passed to the CFA feature.
	 */
	uint16_t	ctx_id;
	uint8_t	unused_0[5];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_cfa_ctx_mem_rgtr_output_t, *phwrm_cfa_ctx_mem_rgtr_output_t;

/***************************
 * hwrm_cfa_ctx_mem_unrgtr *
 ***************************/


/* hwrm_cfa_ctx_mem_unrgtr_input (size:192b/24B) */

typedef struct hwrm_cfa_ctx_mem_unrgtr_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * Id/Handle to the recently register context memory. This handle is
	 * passed to the CFA feature.
	 */
	uint16_t	ctx_id;
	uint8_t	unused_0[6];
} hwrm_cfa_ctx_mem_unrgtr_input_t, *phwrm_cfa_ctx_mem_unrgtr_input_t;

/* hwrm_cfa_ctx_mem_unrgtr_output (size:128b/16B) */

typedef struct hwrm_cfa_ctx_mem_unrgtr_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_cfa_ctx_mem_unrgtr_output_t, *phwrm_cfa_ctx_mem_unrgtr_output_t;

/*************************
 * hwrm_cfa_ctx_mem_qctx *
 *************************/


/* hwrm_cfa_ctx_mem_qctx_input (size:192b/24B) */

typedef struct hwrm_cfa_ctx_mem_qctx_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * Id/Handle to the recently register context memory. This handle is
	 * passed to the CFA feature.
	 */
	uint16_t	ctx_id;
	uint8_t	unused_0[6];
} hwrm_cfa_ctx_mem_qctx_input_t, *phwrm_cfa_ctx_mem_qctx_input_t;

/* hwrm_cfa_ctx_mem_qctx_output (size:256b/32B) */

typedef struct hwrm_cfa_ctx_mem_qctx_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint16_t	flags;
	/* Counter PBL indirect levels. */
	uint8_t	page_level;
	/* PBL pointer is physical start address. */
	#define HWRM_CFA_CTX_MEM_QCTX_OUTPUT_PAGE_LEVEL_LVL_0 UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
	#define HWRM_CFA_CTX_MEM_QCTX_OUTPUT_PAGE_LEVEL_LVL_1 UINT32_C(0x1)
	/*
	 * PBL pointer points to PDE table with each entry pointing to PTE
	 * tables.
	 */
	#define HWRM_CFA_CTX_MEM_QCTX_OUTPUT_PAGE_LEVEL_LVL_2 UINT32_C(0x2)
	#define HWRM_CFA_CTX_MEM_QCTX_OUTPUT_PAGE_LEVEL_LAST HWRM_CFA_CTX_MEM_QCTX_OUTPUT_PAGE_LEVEL_LVL_2
	/* Page size. */
	uint8_t	page_size;
	/* 4KB page size. */
	#define HWRM_CFA_CTX_MEM_QCTX_OUTPUT_PAGE_SIZE_4K   UINT32_C(0x0)
	/* 8KB page size. */
	#define HWRM_CFA_CTX_MEM_QCTX_OUTPUT_PAGE_SIZE_8K   UINT32_C(0x1)
	/* 64KB page size. */
	#define HWRM_CFA_CTX_MEM_QCTX_OUTPUT_PAGE_SIZE_64K  UINT32_C(0x4)
	/* 256KB page size. */
	#define HWRM_CFA_CTX_MEM_QCTX_OUTPUT_PAGE_SIZE_256K UINT32_C(0x6)
	/* 1MB page size. */
	#define HWRM_CFA_CTX_MEM_QCTX_OUTPUT_PAGE_SIZE_1M   UINT32_C(0x8)
	/* 2MB page size. */
	#define HWRM_CFA_CTX_MEM_QCTX_OUTPUT_PAGE_SIZE_2M   UINT32_C(0x9)
	/* 4MB page size. */
	#define HWRM_CFA_CTX_MEM_QCTX_OUTPUT_PAGE_SIZE_4M   UINT32_C(0xa)
	/* 1GB page size. */
	#define HWRM_CFA_CTX_MEM_QCTX_OUTPUT_PAGE_SIZE_1G   UINT32_C(0x12)
	#define HWRM_CFA_CTX_MEM_QCTX_OUTPUT_PAGE_SIZE_LAST HWRM_CFA_CTX_MEM_QCTX_OUTPUT_PAGE_SIZE_1G
	uint8_t	unused_0[4];
	/* Pointer to the PBL, or PDL depending on number of levels */
	uint64_t	page_dir;
	uint8_t	unused_1[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_cfa_ctx_mem_qctx_output_t, *phwrm_cfa_ctx_mem_qctx_output_t;

/**************************
 * hwrm_cfa_ctx_mem_qcaps *
 **************************/


/* hwrm_cfa_ctx_mem_qcaps_input (size:128b/16B) */

typedef struct hwrm_cfa_ctx_mem_qcaps_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
} hwrm_cfa_ctx_mem_qcaps_input_t, *phwrm_cfa_ctx_mem_qcaps_input_t;

/* hwrm_cfa_ctx_mem_qcaps_output (size:128b/16B) */

typedef struct hwrm_cfa_ctx_mem_qcaps_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * Indicates the maximum number of context memory which can be
	 * registered.
	 */
	uint16_t	max_entries;
	uint8_t	unused_0[5];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_cfa_ctx_mem_qcaps_output_t, *phwrm_cfa_ctx_mem_qcaps_output_t;

/**************************
 * hwrm_cfa_counter_qcaps *
 **************************/


/* hwrm_cfa_counter_qcaps_input (size:128b/16B) */

typedef struct hwrm_cfa_counter_qcaps_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
} hwrm_cfa_counter_qcaps_input_t, *phwrm_cfa_counter_qcaps_input_t;

/* hwrm_cfa_counter_qcaps_output (size:576b/72B) */

typedef struct hwrm_cfa_counter_qcaps_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint32_t	flags;
	/* Enumeration denoting the supported CFA counter format. */
	#define HWRM_CFA_COUNTER_QCAPS_OUTPUT_FLAGS_COUNTER_FORMAT	UINT32_C(0x1)
	/* CFA counter types are not supported. */
		#define HWRM_CFA_COUNTER_QCAPS_OUTPUT_FLAGS_COUNTER_FORMAT_NONE	UINT32_C(0x0)
	/* 64-bit packet counters followed by 64-bit byte counters format. */
		#define HWRM_CFA_COUNTER_QCAPS_OUTPUT_FLAGS_COUNTER_FORMAT_64_BIT  UINT32_C(0x1)
		#define HWRM_CFA_COUNTER_QCAPS_OUTPUT_FLAGS_COUNTER_FORMAT_LAST   HWRM_CFA_COUNTER_QCAPS_OUTPUT_FLAGS_COUNTER_FORMAT_64_BIT
	uint32_t	unused_0;
	/*
	 * Minimum guaranteed number of flow counters supported for this
	 * function, in RX direction.
	 */
	uint32_t	min_rx_fc;
	/*
	 * Maximum non-guaranteed number of flow counters supported for this
	 * function, in RX direction.
	 */
	uint32_t	max_rx_fc;
	/*
	 * Minimum guaranteed number of flow counters supported for this
	 * function, in TX direction.
	 */
	uint32_t	min_tx_fc;
	/*
	 * Maximum non-guaranteed number of flow counters supported for this
	 * function, in TX direction.
	 */
	uint32_t	max_tx_fc;
	/*
	 * Minimum guaranteed number of extension flow counters supported for
	 * this function, in RX direction.
	 */
	uint32_t	min_rx_efc;
	/*
	 * Maximum non-guaranteed number of extension flow counters supported
	 * for this function, in RX direction.
	 */
	uint32_t	max_rx_efc;
	/*
	 * Minimum guaranteed number of extension flow counters supported for
	 * this function, in TX direction.
	 */
	uint32_t	min_tx_efc;
	/*
	 * Maximum non-guaranteed number of extension flow counters supported
	 * for this function, in TX direction.
	 */
	uint32_t	max_tx_efc;
	/*
	 * Minimum guaranteed number of meter drop counters supported for
	 * this function, in RX direction.
	 */
	uint32_t	min_rx_mdc;
	/*
	 * Maximum non-guaranteed number of meter drop counters supported for
	 * this function, in RX direction.
	 */
	uint32_t	max_rx_mdc;
	/*
	 * Minimum guaranteed number of meter drop counters supported for this
	 * function, in TX direction.
	 */
	uint32_t	min_tx_mdc;
	/*
	 * Maximum non-guaranteed number of meter drop counters supported for
	 * this function, in TX direction.
	 */
	uint32_t	max_tx_mdc;
	/*
	 * Maximum guaranteed number of flow counters which can be used during
	 * flow alloc.
	 */
	uint32_t	max_flow_alloc_fc;
	uint8_t	unused_1[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_cfa_counter_qcaps_output_t, *phwrm_cfa_counter_qcaps_output_t;

/************************
 * hwrm_cfa_counter_cfg *
 ************************/


/* hwrm_cfa_counter_cfg_input (size:256b/32B) */

typedef struct hwrm_cfa_counter_cfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint16_t	flags;
	/* Enumeration denoting the configuration mode. */
	#define HWRM_CFA_COUNTER_CFG_INPUT_FLAGS_CFG_MODE			UINT32_C(0x1)
	/* Disable the configuration mode. */
		#define HWRM_CFA_COUNTER_CFG_INPUT_FLAGS_CFG_MODE_DISABLE		UINT32_C(0x0)
	/* Enable the configuration mode. */
		#define HWRM_CFA_COUNTER_CFG_INPUT_FLAGS_CFG_MODE_ENABLE		UINT32_C(0x1)
		#define HWRM_CFA_COUNTER_CFG_INPUT_FLAGS_CFG_MODE_LAST		HWRM_CFA_COUNTER_CFG_INPUT_FLAGS_CFG_MODE_ENABLE
	/* Enumeration denoting the RX, TX type of the resource. */
	#define HWRM_CFA_COUNTER_CFG_INPUT_FLAGS_PATH			UINT32_C(0x2)
	/* Tx path. */
		#define HWRM_CFA_COUNTER_CFG_INPUT_FLAGS_PATH_TX			(UINT32_C(0x0) << 1)
	/* Rx path. */
		#define HWRM_CFA_COUNTER_CFG_INPUT_FLAGS_PATH_RX			(UINT32_C(0x1) << 1)
		#define HWRM_CFA_COUNTER_CFG_INPUT_FLAGS_PATH_LAST			HWRM_CFA_COUNTER_CFG_INPUT_FLAGS_PATH_RX
	/* Enumeration denoting the data transfer mode. */
	#define HWRM_CFA_COUNTER_CFG_INPUT_FLAGS_DATA_TRANSFER_MODE_MASK	UINT32_C(0xc)
	#define HWRM_CFA_COUNTER_CFG_INPUT_FLAGS_DATA_TRANSFER_MODE_SFT	2
	/* Push mode. */
		#define HWRM_CFA_COUNTER_CFG_INPUT_FLAGS_DATA_TRANSFER_MODE_PUSH	(UINT32_C(0x0) << 2)
	/* Pull mode. */
		#define HWRM_CFA_COUNTER_CFG_INPUT_FLAGS_DATA_TRANSFER_MODE_PULL	(UINT32_C(0x1) << 2)
	/* Pull on async update. */
		#define HWRM_CFA_COUNTER_CFG_INPUT_FLAGS_DATA_TRANSFER_MODE_PULL_ASYNC  (UINT32_C(0x2) << 2)
		#define HWRM_CFA_COUNTER_CFG_INPUT_FLAGS_DATA_TRANSFER_MODE_LAST	HWRM_CFA_COUNTER_CFG_INPUT_FLAGS_DATA_TRANSFER_MODE_PULL_ASYNC
	uint16_t	counter_type;
	/* Flow counters. */
	#define HWRM_CFA_COUNTER_CFG_INPUT_COUNTER_TYPE_FC  UINT32_C(0x0)
	/* Extended flow counters. */
	#define HWRM_CFA_COUNTER_CFG_INPUT_COUNTER_TYPE_EFC UINT32_C(0x1)
	/* Meter drop counters. */
	#define HWRM_CFA_COUNTER_CFG_INPUT_COUNTER_TYPE_MDC UINT32_C(0x2)
	#define HWRM_CFA_COUNTER_CFG_INPUT_COUNTER_TYPE_LAST HWRM_CFA_COUNTER_CFG_INPUT_COUNTER_TYPE_MDC
	/* Ctx memory handle to be used for the counter. */
	uint16_t	ctx_id;
	/* Counter update cadence hint (only in Push mode). */
	uint16_t	update_tmr_ms;
	/* Total number of entries. */
	uint32_t	num_entries;
	uint32_t	unused_0;
} hwrm_cfa_counter_cfg_input_t, *phwrm_cfa_counter_cfg_input_t;

/* hwrm_cfa_counter_cfg_output (size:128b/16B) */

typedef struct hwrm_cfa_counter_cfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_cfa_counter_cfg_output_t, *phwrm_cfa_counter_cfg_output_t;

/***************************
 * hwrm_cfa_counter_qstats *
 ***************************/


/* hwrm_cfa_counter_qstats_input (size:320b/40B) */

typedef struct hwrm_cfa_counter_qstats_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint16_t	flags;
	/* Enumeration denoting the RX, TX type of the resource. */
	#define HWRM_CFA_COUNTER_QSTATS_INPUT_FLAGS_PATH	UINT32_C(0x1)
	/* Tx path. */
		#define HWRM_CFA_COUNTER_QSTATS_INPUT_FLAGS_PATH_TX	UINT32_C(0x0)
	/* Rx path. */
		#define HWRM_CFA_COUNTER_QSTATS_INPUT_FLAGS_PATH_RX	UINT32_C(0x1)
		#define HWRM_CFA_COUNTER_QSTATS_INPUT_FLAGS_PATH_LAST HWRM_CFA_COUNTER_QSTATS_INPUT_FLAGS_PATH_RX
	uint16_t	counter_type;
	uint16_t	input_flow_ctx_id;
	uint16_t	num_entries;
	uint16_t	delta_time_ms;
	uint16_t	meter_instance_id;
	uint16_t	mdc_ctx_id;
	uint8_t	unused_0[2];
	uint64_t	expected_count;
} hwrm_cfa_counter_qstats_input_t, *phwrm_cfa_counter_qstats_input_t;

/* hwrm_cfa_counter_qstats_output (size:128b/16B) */

typedef struct hwrm_cfa_counter_qstats_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_cfa_counter_qstats_output_t, *phwrm_cfa_counter_qstats_output_t;

/**********************
 * hwrm_cfa_eem_qcaps *
 **********************/


/* hwrm_cfa_eem_qcaps_input (size:192b/24B) */

typedef struct hwrm_cfa_eem_qcaps_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	flags;
	/*
	 * When set to 1, indicates the configuration will apply to TX flows
	 * which are to be offloaded.
	 * Note if this bit is set then the path_rx bit can't be set.
	 */
	#define HWRM_CFA_EEM_QCAPS_INPUT_FLAGS_PATH_TX		UINT32_C(0x1)
	/*
	 * When set to 1, indicates the configuration will apply to RX flows
	 * which are to be offloaded.
	 * Note if this bit is set then the path_tx bit can't be set.
	 */
	#define HWRM_CFA_EEM_QCAPS_INPUT_FLAGS_PATH_RX		UINT32_C(0x2)
	/* When set to 1, all offloaded flows will be sent to EEM. */
	#define HWRM_CFA_EEM_QCAPS_INPUT_FLAGS_PREFERRED_OFFLOAD	UINT32_C(0x4)
	uint32_t	unused_0;
} hwrm_cfa_eem_qcaps_input_t, *phwrm_cfa_eem_qcaps_input_t;

/* hwrm_cfa_eem_qcaps_output (size:320b/40B) */

typedef struct hwrm_cfa_eem_qcaps_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint32_t	flags;
	/*
	 * When set to 1, indicates the configuration will apply to TX flows
	 * which are to be offloaded.
	 * Note if this bit is set then the path_rx bit can't be set.
	 */
	#define HWRM_CFA_EEM_QCAPS_OUTPUT_FLAGS_PATH_TX					UINT32_C(0x1)
	/*
	 * When set to 1, indicates the configuration will apply to RX flows
	 * which are to be offloaded.
	 * Note if this bit is set then the path_tx bit can't be set.
	 */
	#define HWRM_CFA_EEM_QCAPS_OUTPUT_FLAGS_PATH_RX					UINT32_C(0x2)
	/*
	 * When set to 1, indicates the the FW supports the Centralized
	 * Memory Model. The concept designates one entity for the
	 * memory allocation while all others ‘subscribe’ to it.
	 */
	#define HWRM_CFA_EEM_QCAPS_OUTPUT_FLAGS_CENTRALIZED_MEMORY_MODEL_SUPPORTED		UINT32_C(0x4)
	/*
	 * When set to 1, indicates the the FW supports the Detached
	 * Centralized Memory Model. The memory is allocated and managed
	 * as a separate entity. All PFs and VFs will be granted direct
	 * or semi-direct access to the allocated memory while none of
	 * which can interfere with the management of the memory.
	 */
	#define HWRM_CFA_EEM_QCAPS_OUTPUT_FLAGS_DETACHED_CENTRALIZED_MEMORY_MODEL_SUPPORTED	UINT32_C(0x8)
	uint32_t	unused_0;
	uint32_t	supported;
	/*
	 * If set to 1, then EEM KEY0 table is supported using crc32 hash.
	 * If set to 0, EEM KEY0 table is not supported.
	 */
	#define HWRM_CFA_EEM_QCAPS_OUTPUT_SUPPORTED_KEY0_TABLE			UINT32_C(0x1)
	/*
	 * If set to 1, then EEM KEY1 table is supported using lookup3 hash.
	 * If set to 0, EEM KEY1 table is not supported.
	 */
	#define HWRM_CFA_EEM_QCAPS_OUTPUT_SUPPORTED_KEY1_TABLE			UINT32_C(0x2)
	/*
	 * If set to 1, then EEM External Record table is supported.
	 * If set to 0, EEM External Record table is not supported.
	 * (This table includes action record, EFC pointers, encap pointers)
	 */
	#define HWRM_CFA_EEM_QCAPS_OUTPUT_SUPPORTED_EXTERNAL_RECORD_TABLE		UINT32_C(0x4)
	/*
	 * If set to 1, then EEM External Flow Counters table is supported.
	 * If set to 0, EEM External Flow Counters table is not supported.
	 */
	#define HWRM_CFA_EEM_QCAPS_OUTPUT_SUPPORTED_EXTERNAL_FLOW_COUNTERS_TABLE	UINT32_C(0x8)
	/*
	 * If set to 1, then FID table used for implicit flow flush is
	 * supported.
	 * If set to 0, then FID table used for implicit flow flush is
	 * not supported.
	 */
	#define HWRM_CFA_EEM_QCAPS_OUTPUT_SUPPORTED_FID_TABLE			UINT32_C(0x10)
	/*
	 * The maximum number of entries supported by EEM. When configuring
	 * the host memory, the number of numbers of entries that can
	 * supported are:
	 *	32k, 64k 128k, 256k, 512k, 1M, 2M, 4M, 8M, 32M, 64M, 128M
	 *	entries.
	 * Any value that are not these values, the FW will round down to the
	 * closest support number of entries.
	 */
	uint32_t	max_entries_supported;
	/* The entry size in bytes of each entry in the EEM KEY0/KEY1 tables. */
	uint16_t	key_entry_size;
	/* The entry size in bytes of each entry in the EEM RECORD tables. */
	uint16_t	record_entry_size;
	/* The entry size in bytes of each entry in the EEM EFC tables. */
	uint16_t	efc_entry_size;
	/* The FID size in bytes of each entry in the EEM FID tables. */
	uint16_t	fid_entry_size;
	uint8_t	unused_1[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_cfa_eem_qcaps_output_t, *phwrm_cfa_eem_qcaps_output_t;

/********************
 * hwrm_cfa_eem_cfg *
 ********************/


/* hwrm_cfa_eem_cfg_input (size:384b/48B) */

typedef struct hwrm_cfa_eem_cfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	flags;
	/*
	 * When set to 1, indicates the configuration will apply to TX flows
	 * which are to be offloaded.
	 * Note if this bit is set then the path_rx bit can't be set.
	 */
	#define HWRM_CFA_EEM_CFG_INPUT_FLAGS_PATH_TX		UINT32_C(0x1)
	/*
	 * When set to 1, indicates the configuration will apply to RX flows
	 * which are to be offloaded.
	 * Note if this bit is set then the path_tx bit can't be set.
	 */
	#define HWRM_CFA_EEM_CFG_INPUT_FLAGS_PATH_RX		UINT32_C(0x2)
	/* When set to 1, all offloaded flows will be sent to EEM. */
	#define HWRM_CFA_EEM_CFG_INPUT_FLAGS_PREFERRED_OFFLOAD	UINT32_C(0x4)
	/* When set to 1, secondary, 0 means primary. */
	#define HWRM_CFA_EEM_CFG_INPUT_FLAGS_SECONDARY_PF	UINT32_C(0x8)
	/*
	 * Group_id which used by Firmware to identify memory pools belonging
	 * to certain group.
	 */
	uint16_t	group_id;
	uint16_t	unused_0;
	/*
	 * Configured EEM with the given number of entries. All the EEM tables
	 * KEY0, KEY1, RECORD, EFC all have the same number of entries and all
	 * tables will be configured using this value. Current minimum value
	 * is 32k. Current maximum value is 128M.
	 */
	uint32_t	num_entries;
	uint32_t	unused_1;
	/* Configured EEM with the given context if for KEY0 table. */
	uint16_t	key0_ctx_id;
	/* Configured EEM with the given context if for KEY1 table. */
	uint16_t	key1_ctx_id;
	/* Configured EEM with the given context if for RECORD table. */
	uint16_t	record_ctx_id;
	/* Configured EEM with the given context if for EFC table. */
	uint16_t	efc_ctx_id;
	/* Configured EEM with the given context if for EFC table. */
	uint16_t	fid_ctx_id;
	uint16_t	unused_2;
	uint32_t	unused_3;
} hwrm_cfa_eem_cfg_input_t, *phwrm_cfa_eem_cfg_input_t;

/* hwrm_cfa_eem_cfg_output (size:128b/16B) */

typedef struct hwrm_cfa_eem_cfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_cfa_eem_cfg_output_t, *phwrm_cfa_eem_cfg_output_t;

/*********************
 * hwrm_cfa_eem_qcfg *
 *********************/


/* hwrm_cfa_eem_qcfg_input (size:192b/24B) */

typedef struct hwrm_cfa_eem_qcfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	flags;
	/* When set to 1, indicates the configuration is the TX flow. */
	#define HWRM_CFA_EEM_QCFG_INPUT_FLAGS_PATH_TX	UINT32_C(0x1)
	/* When set to 1, indicates the configuration is the RX flow. */
	#define HWRM_CFA_EEM_QCFG_INPUT_FLAGS_PATH_RX	UINT32_C(0x2)
	uint32_t	unused_0;
} hwrm_cfa_eem_qcfg_input_t, *phwrm_cfa_eem_qcfg_input_t;

/* hwrm_cfa_eem_qcfg_output (size:256b/32B) */

typedef struct hwrm_cfa_eem_qcfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint32_t	flags;
	/* When set to 1, indicates the configuration is the TX flow. */
	#define HWRM_CFA_EEM_QCFG_OUTPUT_FLAGS_PATH_TX		UINT32_C(0x1)
	/* When set to 1, indicates the configuration is the RX flow. */
	#define HWRM_CFA_EEM_QCFG_OUTPUT_FLAGS_PATH_RX		UINT32_C(0x2)
	/* When set to 1, all offloaded flows will be sent to EEM. */
	#define HWRM_CFA_EEM_QCFG_OUTPUT_FLAGS_PREFERRED_OFFLOAD	UINT32_C(0x4)
	/* The number of entries the FW has configured for EEM. */
	uint32_t	num_entries;
	/* Configured EEM with the given context if for KEY0 table. */
	uint16_t	key0_ctx_id;
	/* Configured EEM with the given context if for KEY1 table. */
	uint16_t	key1_ctx_id;
	/* Configured EEM with the given context if for RECORD table. */
	uint16_t	record_ctx_id;
	/* Configured EEM with the given context if for EFC table. */
	uint16_t	efc_ctx_id;
	/* Configured EEM with the given context if for EFC table. */
	uint16_t	fid_ctx_id;
	uint8_t	unused_2[5];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_cfa_eem_qcfg_output_t, *phwrm_cfa_eem_qcfg_output_t;

/*******************
 * hwrm_cfa_eem_op *
 *******************/


/* hwrm_cfa_eem_op_input (size:192b/24B) */

typedef struct hwrm_cfa_eem_op_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	flags;
	/*
	 * When set to 1, indicates the host memory which is passed will be
	 * used for the TX flow offload function specified in fid.
	 * Note if this bit is set then the path_rx bit can't be set.
	 */
	#define HWRM_CFA_EEM_OP_INPUT_FLAGS_PATH_TX	UINT32_C(0x1)
	/*
	 * When set to 1, indicates the host memory which is passed will be
	 * used for the RX flow offload function specified in fid.
	 * Note if this bit is set then the path_tx bit can't be set.
	 */
	#define HWRM_CFA_EEM_OP_INPUT_FLAGS_PATH_RX	UINT32_C(0x2)
	uint16_t	unused_0;
	/* The number of EEM key table entries to be configured. */
	uint16_t	op;
	/* This value is reserved and should not be used. */
	#define HWRM_CFA_EEM_OP_INPUT_OP_RESERVED	UINT32_C(0x0)
	/*
	 * To properly stop EEM and ensure there are no DMA's, the caller
	 * must disable EEM for the given PF, using this call. This will
	 * safely disable EEM and ensure that all DMA'ed to the
	 * keys/records/efc have been completed.
	 */
	#define HWRM_CFA_EEM_OP_INPUT_OP_EEM_DISABLE UINT32_C(0x1)
	/*
	 * Once the EEM host memory has been configured, EEM options have
	 * been configured. Then the caller should enable EEM for the given
	 * PF. Note once this call has been made, then the EEM mechanism
	 * will be active and DMA's will occur as packets are processed.
	 */
	#define HWRM_CFA_EEM_OP_INPUT_OP_EEM_ENABLE  UINT32_C(0x2)
	/*
	 * Clear EEM settings for the given PF so that the register values
	 * are reset back to there initial state.
	 */
	#define HWRM_CFA_EEM_OP_INPUT_OP_EEM_CLEANUP UINT32_C(0x3)
	#define HWRM_CFA_EEM_OP_INPUT_OP_LAST	HWRM_CFA_EEM_OP_INPUT_OP_EEM_CLEANUP
} hwrm_cfa_eem_op_input_t, *phwrm_cfa_eem_op_input_t;

/* hwrm_cfa_eem_op_output (size:128b/16B) */

typedef struct hwrm_cfa_eem_op_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_cfa_eem_op_output_t, *phwrm_cfa_eem_op_output_t;

/********************************
 * hwrm_cfa_adv_flow_mgnt_qcaps *
 ********************************/


/* hwrm_cfa_adv_flow_mgnt_qcaps_input (size:256b/32B) */

typedef struct hwrm_cfa_adv_flow_mgnt_qcaps_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	unused_0[4];
} hwrm_cfa_adv_flow_mgnt_qcaps_input_t, *phwrm_cfa_adv_flow_mgnt_qcaps_input_t;

/* hwrm_cfa_adv_flow_mgnt_qcaps_output (size:128b/16B) */

typedef struct hwrm_cfa_adv_flow_mgnt_qcaps_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint32_t	flags;
	/*
	 * Value of 1 to indicate firmware support 16-bit flow handle.
	 * Value of 0 to indicate firmware not support 16-bit flow handle.
	 */
	#define HWRM_CFA_ADV_FLOW_MGNT_QCAPS_OUTPUT_FLAGS_FLOW_HND_16BIT_SUPPORTED			UINT32_C(0x1)
	/*
	 * Value of 1 to indicate firmware support 64-bit flow handle.
	 * Value of 0 to indicate firmware not support 64-bit flow handle.
	 */
	#define HWRM_CFA_ADV_FLOW_MGNT_QCAPS_OUTPUT_FLAGS_FLOW_HND_64BIT_SUPPORTED			UINT32_C(0x2)
	/*
	 * Value of 1 to indicate firmware support flow batch delete
	 * operation through HWRM_CFA_FLOW_FLUSH command.
	 * Value of 0 to indicate that the firmware does not support flow
	 * batch delete operation.
	 */
	#define HWRM_CFA_ADV_FLOW_MGNT_QCAPS_OUTPUT_FLAGS_FLOW_BATCH_DELETE_SUPPORTED		UINT32_C(0x4)
	/*
	 * Value of 1 to indicate that the firmware support flow reset all
	 * operation through HWRM_CFA_FLOW_FLUSH command.
	 * Value of 0 indicates firmware does not support flow reset all
	 * operation.
	 */
	#define HWRM_CFA_ADV_FLOW_MGNT_QCAPS_OUTPUT_FLAGS_FLOW_RESET_ALL_SUPPORTED			UINT32_C(0x8)
	/*
	 * Value of 1 to indicate that firmware supports use of FID as
	 * dest_id in HWRM_CFA_NTUPLE_ALLOC/CFG commands.
	 * Value of 0 indicates firmware does not support use of FID as
	 * dest_id.
	 */
	#define HWRM_CFA_ADV_FLOW_MGNT_QCAPS_OUTPUT_FLAGS_NTUPLE_FLOW_DEST_FUNC_SUPPORTED		UINT32_C(0x10)
	/*
	 * Value of 1 to indicate that firmware supports TX EEM flows.
	 * Value of 0 indicates firmware does not support TX EEM flows.
	 */
	#define HWRM_CFA_ADV_FLOW_MGNT_QCAPS_OUTPUT_FLAGS_TX_EEM_FLOW_SUPPORTED			UINT32_C(0x20)
	/*
	 * Value of 1 to indicate that firmware supports RX EEM flows.
	 * Value of 0 indicates firmware does not support RX EEM flows.
	 */
	#define HWRM_CFA_ADV_FLOW_MGNT_QCAPS_OUTPUT_FLAGS_RX_EEM_FLOW_SUPPORTED			UINT32_C(0x40)
	/*
	 * Value of 1 to indicate that firmware supports the dynamic
	 * allocation of an on-chip flow counter which can be used for EEM
	 * flows. Value of 0 indicates firmware does not support the dynamic
	 * allocation of an on-chip flow counter.
	 */
	#define HWRM_CFA_ADV_FLOW_MGNT_QCAPS_OUTPUT_FLAGS_FLOW_COUNTER_ALLOC_SUPPORTED		UINT32_C(0x80)
	/*
	 * Value of 1 to indicate that firmware supports setting of
	 * rfs_ring_tbl_idx in HWRM_CFA_NTUPLE_ALLOC command.
	 * Value of 0 indicates firmware does not support rfs_ring_tbl_idx.
	 */
	#define HWRM_CFA_ADV_FLOW_MGNT_QCAPS_OUTPUT_FLAGS_RFS_RING_TBL_IDX_SUPPORTED		UINT32_C(0x100)
	/*
	 * Value of 1 to indicate that firmware supports untagged matching
	 * criteria on HWRM_CFA_L2_FILTER_ALLOC command. Value of 0
	 * indicates firmware does not support untagged matching.
	 */
	#define HWRM_CFA_ADV_FLOW_MGNT_QCAPS_OUTPUT_FLAGS_UNTAGGED_VLAN_SUPPORTED			UINT32_C(0x200)
	/*
	 * Value of 1 to indicate that firmware supports XDP filter. Value
	 * of 0 indicates firmware does not support XDP filter.
	 */
	#define HWRM_CFA_ADV_FLOW_MGNT_QCAPS_OUTPUT_FLAGS_XDP_SUPPORTED				UINT32_C(0x400)
	/*
	 * Value of 1 to indicate that the firmware support L2 header source
	 * fields matching criteria on HWRM_CFA_L2_FILTER_ALLOC command.
	 * Value of 0 indicates firmware does not support L2 header source
	 * fields matching.
	 */
	#define HWRM_CFA_ADV_FLOW_MGNT_QCAPS_OUTPUT_FLAGS_L2_HEADER_SOURCE_FIELDS_SUPPORTED		UINT32_C(0x800)
	/*
	 * If set to 1, firmware is capable of supporting ARP ethertype as
	 * matching criteria for HWRM_CFA_NTUPLE_FILTER_ALLOC command on the
	 * RX direction. By default, this flag should be 0 for older version
	 * of firmware.
	 */
	#define HWRM_CFA_ADV_FLOW_MGNT_QCAPS_OUTPUT_FLAGS_NTUPLE_FLOW_RX_ARP_SUPPORTED		UINT32_C(0x1000)
	/*
	 * Value of 1 to indicate that firmware supports setting of
	 * rfs_ring_tbl_idx in dst_id field of the HWRM_CFA_NTUPLE_ALLOC
	 * command. Value of 0 indicates firmware does not support
	 * rfs_ring_tbl_idx in dst_id field.
	 */
	#define HWRM_CFA_ADV_FLOW_MGNT_QCAPS_OUTPUT_FLAGS_RFS_RING_TBL_IDX_V2_SUPPORTED		UINT32_C(0x2000)
	/*
	 * If set to 1, firmware is capable of supporting IPv4/IPv6 as
	 * ethertype in HWRM_CFA_NTUPLE_FILTER_ALLOC command on the RX
	 * direction. By default, this flag should be 0 for older version
	 * of firmware.
	 */
	#define HWRM_CFA_ADV_FLOW_MGNT_QCAPS_OUTPUT_FLAGS_NTUPLE_FLOW_RX_ETHERTYPE_IP_SUPPORTED	UINT32_C(0x4000)
	/*
	 * When this bit is '1', it indicates that core firmware is
	 * capable of TruFlow. Driver can restrict sending HWRM CFA_FLOW_XXX
	 * and CFA_ENCAP_XXX, CFA_DECAP_XXX commands.
	 */
	#define HWRM_CFA_ADV_FLOW_MGNT_QCAPS_OUTPUT_FLAGS_TRUFLOW_CAPABLE				UINT32_C(0x8000)
	/*
	 * If set to 1, firmware is capable of supporting L2/ROCE as
	 * traffic type in flags field of HWRM_CFA_L2_FILTER_ALLOC command.
	 * By default, this flag should be 0 for older version of firmware.
	 */
	#define HWRM_CFA_ADV_FLOW_MGNT_QCAPS_OUTPUT_FLAGS_L2_FILTER_TRAFFIC_TYPE_L2_ROCE_SUPPORTED	UINT32_C(0x10000)
	/*
	 * If set to 1, firmware is capable of HW LAG. This bit is only
	 * advertised if the calling function is a PAXC function.
	 */
	#define HWRM_CFA_ADV_FLOW_MGNT_QCAPS_OUTPUT_FLAGS_LAG_SUPPORTED				UINT32_C(0x20000)
	uint8_t	unused_0[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_cfa_adv_flow_mgnt_qcaps_output_t, *phwrm_cfa_adv_flow_mgnt_qcaps_output_t;

/******************
 * hwrm_cfa_tflib *
 ******************/


/* hwrm_cfa_tflib_input (size:1024b/128B) */

typedef struct hwrm_cfa_tflib_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* TFLIB message type. */
	uint16_t	tf_type;
	/* TFLIB message subtype. */
	uint16_t	tf_subtype;
	/* unused. */
	uint8_t	unused0[4];
	/* TFLIB request data. */
	uint32_t	tf_req[26];
} hwrm_cfa_tflib_input_t, *phwrm_cfa_tflib_input_t;

/* hwrm_cfa_tflib_output (size:5632b/704B) */

typedef struct hwrm_cfa_tflib_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* TFLIB message type. */
	uint16_t	tf_type;
	/* TFLIB message subtype. */
	uint16_t	tf_subtype;
	/* TFLIB response code */
	uint32_t	tf_resp_code;
	/* TFLIB response data. */
	uint32_t	tf_resp[170];
	/* unused. */
	uint8_t	unused1[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_cfa_tflib_output_t, *phwrm_cfa_tflib_output_t;

/**********************************
 * hwrm_cfa_lag_group_member_rgtr *
 **********************************/


/* hwrm_cfa_lag_group_member_rgtr_input (size:192b/24B) */

typedef struct hwrm_cfa_lag_group_member_rgtr_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint8_t	mode;
	/*
	 * Transmit only on the active port. Automatically failover
	 * to backup port.
	 */
	#define HWRM_CFA_LAG_GROUP_MEMBER_RGTR_INPUT_MODE_ACTIVE_BACKUP UINT32_C(0x1)
	/*
	 * Transmit based on packet header ntuple hash. Packet with only
	 * layer 2 headers will hash using the destination MAC, source MAC
	 * and Ethertype fields.  Packets with layer 3 (IP) headers will
	 * hash using the destination MAC, source MAC, IP protocol/next
	 * header, source IP address and destination IP address. Packets
	 * with layer 4 (TCP/UDP) headers will hash using the destination
	 * MAC, source MAC, IP protocol/next header, source IP address,
	 * destination IP address, source port and destination port fields.
	 */
	#define HWRM_CFA_LAG_GROUP_MEMBER_RGTR_INPUT_MODE_BALANCE_XOR   UINT32_C(0x2)
	/* Transmit packets on all specified ports. */
	#define HWRM_CFA_LAG_GROUP_MEMBER_RGTR_INPUT_MODE_BROADCAST	UINT32_C(0x3)
	#define HWRM_CFA_LAG_GROUP_MEMBER_RGTR_INPUT_MODE_LAST	HWRM_CFA_LAG_GROUP_MEMBER_RGTR_INPUT_MODE_BROADCAST
	/*
	 * Supports up to 5 ports. bit0 = port 0, bit1 = port 1,
	 * bit2 = port 2, bit3 = port 4, bit4 = loopback port
	 */
	uint8_t	port_bitmap;
	/* Specify the active port when active-backup mode is specified */
	uint8_t	active_port;
	uint8_t	unused_0[5];
} hwrm_cfa_lag_group_member_rgtr_input_t, *phwrm_cfa_lag_group_member_rgtr_input_t;

/* hwrm_cfa_lag_group_member_rgtr_output (size:128b/16B) */

typedef struct hwrm_cfa_lag_group_member_rgtr_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* lag group ID configured for the function */
	uint16_t	lag_id;
	uint8_t	unused_0[5];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_cfa_lag_group_member_rgtr_output_t, *phwrm_cfa_lag_group_member_rgtr_output_t;

/************************************
 * hwrm_cfa_lag_group_member_unrgtr *
 ************************************/


/* hwrm_cfa_lag_group_member_unrgtr_input (size:192b/24B) */

typedef struct hwrm_cfa_lag_group_member_unrgtr_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* lag group ID configured for the function */
	uint16_t	lag_id;
	uint8_t	unused_0[6];
} hwrm_cfa_lag_group_member_unrgtr_input_t, *phwrm_cfa_lag_group_member_unrgtr_input_t;

/* hwrm_cfa_lag_group_member_unrgtr_output (size:128b/16B) */

typedef struct hwrm_cfa_lag_group_member_unrgtr_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_cfa_lag_group_member_unrgtr_output_t, *phwrm_cfa_lag_group_member_unrgtr_output_t;

/***********
 * hwrm_tf *
 ***********/


/* hwrm_tf_input (size:1024b/128B) */

typedef struct hwrm_tf_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* TF message type. */
	uint16_t	type;
	/* TF message subtype. */
	uint16_t	subtype;
	/* unused. */
	uint8_t	unused0[4];
	/* TF request data. */
	uint32_t	req[26];
} hwrm_tf_input_t, *phwrm_tf_input_t;

/* hwrm_tf_output (size:5632b/704B) */

typedef struct hwrm_tf_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* TF message type. */
	uint16_t	type;
	/* TF message subtype. */
	uint16_t	subtype;
	/* TF response code */
	uint32_t	resp_code;
	/* TF response data. */
	uint32_t	resp[170];
	/* unused. */
	uint8_t	unused1[7];
	/*
	 * This field is used in Output records to indicate that the
	 * output is completely written to RAM. This field should be
	 * read as '1' to indicate that the output has been
	 * completely written.  When writing a command completion or
	 * response to an internal processor, the order of writes has
	 * to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_tf_output_t, *phwrm_tf_output_t;

/***********************
 * hwrm_tf_version_get *
 ***********************/


/* hwrm_tf_version_get_input (size:128b/16B) */

typedef struct hwrm_tf_version_get_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
} hwrm_tf_version_get_input_t, *phwrm_tf_version_get_input_t;

/* hwrm_tf_version_get_output (size:128b/16B) */

typedef struct hwrm_tf_version_get_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Version Major number. */
	uint8_t	major;
	/* Version Minor number. */
	uint8_t	minor;
	/* Version Update number. */
	uint8_t	update;
	/* unused. */
	uint8_t	unused0[4];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_tf_version_get_output_t, *phwrm_tf_version_get_output_t;

/************************
 * hwrm_tf_session_open *
 ************************/


/* hwrm_tf_session_open_input (size:640b/80B) */

typedef struct hwrm_tf_session_open_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Name of the session. */
	uint8_t	session_name[64];
} hwrm_tf_session_open_input_t, *phwrm_tf_session_open_input_t;

/* hwrm_tf_session_open_output (size:192b/24B) */

typedef struct hwrm_tf_session_open_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * Unique session identifier for the session created by the
	 * firmware.
	 */
	uint32_t	fw_session_id;
	/*
	 * Unique session client identifier for the first client on
	 * the newly created session.
	 */
	uint32_t	fw_session_client_id;
	/* This field is used to return the status of fw session to host. */
	uint32_t	flags;
	/*
	 * Indicates if the shared session has been created. Shared seesion
	 * should be the first session created ever. Its fw_rm_client_id
	 * should be 1. The AFM session's fw_rm_client_id is 0.
	 */
	#define HWRM_TF_SESSION_OPEN_OUTPUT_FLAGS_SHARED_SESSION		UINT32_C(0x1)
	/*
	 * If this bit set to 0, then it indicates the shared session
	 * has been created by another session.
	 */
		#define HWRM_TF_SESSION_OPEN_OUTPUT_FLAGS_SHARED_SESSION_NOT_CREATOR  UINT32_C(0x0)
	/*
	 * If this bit is set to 1, then it indicates the shared session
	 * is created by this session.
	 */
		#define HWRM_TF_SESSION_OPEN_OUTPUT_FLAGS_SHARED_SESSION_CREATOR	UINT32_C(0x1)
		#define HWRM_TF_SESSION_OPEN_OUTPUT_FLAGS_SHARED_SESSION_LAST	HWRM_TF_SESSION_OPEN_OUTPUT_FLAGS_SHARED_SESSION_CREATOR
	/* unused. */
	uint8_t	unused1[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_tf_session_open_output_t, *phwrm_tf_session_open_output_t;

/**************************
 * hwrm_tf_session_attach *
 **************************/


/* hwrm_tf_session_attach_input (size:704b/88B) */

typedef struct hwrm_tf_session_attach_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * Unique session identifier for the session that the attach
	 * request want to attach to. This value originates from the
	 * shared session memory that the attach request opened by
	 * way of the 'attach name' that was passed in to the core
	 * attach API.
	 * The fw_session_id of the attach session includes PCIe bus
	 * info to distinguish the PF and session info to identify
	 * the associated TruFlow session.
	 */
	uint32_t	attach_fw_session_id;
	/* unused. */
	uint32_t	unused0;
	/* Name of the session it self. */
	uint8_t	session_name[64];
} hwrm_tf_session_attach_input_t, *phwrm_tf_session_attach_input_t;

/* hwrm_tf_session_attach_output (size:128b/16B) */

typedef struct hwrm_tf_session_attach_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * Unique session identifier for the session created by the
	 * firmware. It includes PCIe bus info to distinguish the PF
	 * and session info to identify the associated TruFlow
	 * session. This fw_session_id is unique to the attach
	 * request.
	 */
	uint32_t	fw_session_id;
	/* unused. */
	uint8_t	unused0[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_tf_session_attach_output_t, *phwrm_tf_session_attach_output_t;

/****************************
 * hwrm_tf_session_register *
 ****************************/


/* hwrm_tf_session_register_input (size:704b/88B) */

typedef struct hwrm_tf_session_register_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * Unique session identifier for the session that the
	 * register request want to create a new client on. This
	 * value originates from the first open request.
	 * The fw_session_id of the attach session includes PCIe bus
	 * info to distinguish the PF and session info to identify
	 * the associated TruFlow session.
	 */
	uint32_t	fw_session_id;
	/* unused. */
	uint32_t	unused0;
	/* Name of the session client. */
	uint8_t	session_client_name[64];
} hwrm_tf_session_register_input_t, *phwrm_tf_session_register_input_t;

/* hwrm_tf_session_register_output (size:128b/16B) */

typedef struct hwrm_tf_session_register_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * Unique session client identifier for the session created
	 * by the firmware. It includes the session the client it
	 * attached to and session client info.
	 */
	uint32_t	fw_session_client_id;
	/* unused. */
	uint8_t	unused0[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_tf_session_register_output_t, *phwrm_tf_session_register_output_t;

/******************************
 * hwrm_tf_session_unregister *
 ******************************/


/* hwrm_tf_session_unregister_input (size:192b/24B) */

typedef struct hwrm_tf_session_unregister_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * Unique session identifier for the session that the
	 * unregister request want to close a session client on.
	 */
	uint32_t	fw_session_id;
	/*
	 * Unique session client identifier for the session that the
	 * unregister request want to close.
	 */
	uint32_t	fw_session_client_id;
} hwrm_tf_session_unregister_input_t, *phwrm_tf_session_unregister_input_t;

/* hwrm_tf_session_unregister_output (size:128b/16B) */

typedef struct hwrm_tf_session_unregister_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* unused. */
	uint8_t	unused0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_tf_session_unregister_output_t, *phwrm_tf_session_unregister_output_t;

/*************************
 * hwrm_tf_session_close *
 *************************/


/* hwrm_tf_session_close_input (size:192b/24B) */

typedef struct hwrm_tf_session_close_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Firmware session id returned when HWRM_TF_SESSION_OPEN is sent. */
	uint32_t	fw_session_id;
	/* unused. */
	uint8_t	unused0[4];
} hwrm_tf_session_close_input_t, *phwrm_tf_session_close_input_t;

/* hwrm_tf_session_close_output (size:128b/16B) */

typedef struct hwrm_tf_session_close_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* unused. */
	uint8_t	unused0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field
	 * is written last.
	 */
	uint8_t	valid;
} hwrm_tf_session_close_output_t, *phwrm_tf_session_close_output_t;

/************************
 * hwrm_tf_session_qcfg *
 ************************/


/* hwrm_tf_session_qcfg_input (size:192b/24B) */

typedef struct hwrm_tf_session_qcfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Firmware session id returned when HWRM_TF_SESSION_OPEN is sent. */
	uint32_t	fw_session_id;
	/* unused. */
	uint8_t	unused0[4];
} hwrm_tf_session_qcfg_input_t, *phwrm_tf_session_qcfg_input_t;

/* hwrm_tf_session_qcfg_output (size:128b/16B) */

typedef struct hwrm_tf_session_qcfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* RX action control settings flags. */
	uint8_t	rx_act_flags;
	/*
	 * A value of 1 in this field indicates that Global Flow ID
	 * reporting into cfa_code and cfa_metadata is enabled.
	 */
	#define HWRM_TF_SESSION_QCFG_OUTPUT_RX_ACT_FLAGS_ABCR_GFID_EN		UINT32_C(0x1)
	/*
	 * A value of 1 in this field indicates that both inner and outer
	 * are stripped and inner tag is passed.
	 * Enabled.
	 */
	#define HWRM_TF_SESSION_QCFG_OUTPUT_RX_ACT_FLAGS_ABCR_VTAG_DLT_BOTH	UINT32_C(0x2)
	/*
	 * A value of 1 in this field indicates that the re-use of
	 * existing tunnel L2 header SMAC is enabled for
	 * Non-tunnel L2, L2-L3 and IP-IP tunnel.
	 */
	#define HWRM_TF_SESSION_QCFG_OUTPUT_RX_ACT_FLAGS_TECT_SMAC_OVR_RUTNSL2	UINT32_C(0x4)
	/* TX Action control settings flags. */
	uint8_t	tx_act_flags;
	/* Disabled. */
	#define HWRM_TF_SESSION_QCFG_OUTPUT_TX_ACT_FLAGS_ABCR_VEB_EN	UINT32_C(0x1)
	/*
	 * When set to 1 any GRE tunnels will include the
	 * optional Key field.
	 */
	#define HWRM_TF_SESSION_QCFG_OUTPUT_TX_ACT_FLAGS_TECT_GRE_SET_K	UINT32_C(0x2)
	/*
	 * When set to 1, for GRE tunnels, the IPV6 Traffic Class (TC)
	 * field of the outer header is inherited from the inner header
	 * (if present) or the fixed value as taken from the encap
	 * record.
	 */
	#define HWRM_TF_SESSION_QCFG_OUTPUT_TX_ACT_FLAGS_TECT_IPV6_TC_IH	UINT32_C(0x4)
	/*
	 * When set to 1, for GRE tunnels, the IPV4 Type Of Service (TOS)
	 * field of the outer header is inherited from the inner header
	 * (if present) or the fixed value as taken from the encap record.
	 */
	#define HWRM_TF_SESSION_QCFG_OUTPUT_TX_ACT_FLAGS_TECT_IPV4_TOS_IH	UINT32_C(0x8)
	/* unused. */
	uint8_t	unused0[5];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field
	 * is written last.
	 */
	uint8_t	valid;
} hwrm_tf_session_qcfg_output_t, *phwrm_tf_session_qcfg_output_t;

/******************************
 * hwrm_tf_session_resc_qcaps *
 ******************************/


/* hwrm_tf_session_resc_qcaps_input (size:256b/32B) */

typedef struct hwrm_tf_session_resc_qcaps_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Firmware session id returned when HWRM_TF_SESSION_OPEN is sent. */
	uint32_t	fw_session_id;
	/* Control flags. */
	uint16_t	flags;
	/* Indicates the flow direction. */
	#define HWRM_TF_SESSION_RESC_QCAPS_INPUT_FLAGS_DIR	UINT32_C(0x1)
	/* If this bit set to 0, then it indicates rx flow. */
		#define HWRM_TF_SESSION_RESC_QCAPS_INPUT_FLAGS_DIR_RX	UINT32_C(0x0)
	/* If this bit is set to 1, then it indicates tx flow. */
		#define HWRM_TF_SESSION_RESC_QCAPS_INPUT_FLAGS_DIR_TX	UINT32_C(0x1)
		#define HWRM_TF_SESSION_RESC_QCAPS_INPUT_FLAGS_DIR_LAST HWRM_TF_SESSION_RESC_QCAPS_INPUT_FLAGS_DIR_TX
	/*
	 * Defines the size of the provided qcaps_addr array
	 * buffer. The size should be set to the Resource Manager
	 * provided max number of qcaps entries which is device
	 * specific. Resource Manager gets the max size from HCAPI
	 * RM.
	 */
	uint16_t	qcaps_size;
	/*
	 * This is the DMA address for the qcaps output data array
	 * buffer. Array is of tf_rm_resc_req_entry type and is
	 * device specific.
	 */
	uint64_t	qcaps_addr;
} hwrm_tf_session_resc_qcaps_input_t, *phwrm_tf_session_resc_qcaps_input_t;

/* hwrm_tf_session_resc_qcaps_output (size:192b/24B) */

typedef struct hwrm_tf_session_resc_qcaps_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Control flags. */
	uint32_t	flags;
	/* Session reservation strategy. */
	#define HWRM_TF_SESSION_RESC_QCAPS_OUTPUT_FLAGS_SESS_RESV_STRATEGY_MASK  UINT32_C(0x3)
	#define HWRM_TF_SESSION_RESC_QCAPS_OUTPUT_FLAGS_SESS_RESV_STRATEGY_SFT   0
	/* Static partitioning. */
		#define HWRM_TF_SESSION_RESC_QCAPS_OUTPUT_FLAGS_SESS_RESV_STRATEGY_STATIC  UINT32_C(0x0)
	/* Strategy 1. */
		#define HWRM_TF_SESSION_RESC_QCAPS_OUTPUT_FLAGS_SESS_RESV_STRATEGY_1	UINT32_C(0x1)
	/* Strategy 2. */
		#define HWRM_TF_SESSION_RESC_QCAPS_OUTPUT_FLAGS_SESS_RESV_STRATEGY_2	UINT32_C(0x2)
	/* Strategy 3. */
		#define HWRM_TF_SESSION_RESC_QCAPS_OUTPUT_FLAGS_SESS_RESV_STRATEGY_3	UINT32_C(0x3)
		#define HWRM_TF_SESSION_RESC_QCAPS_OUTPUT_FLAGS_SESS_RESV_STRATEGY_LAST   HWRM_TF_SESSION_RESC_QCAPS_OUTPUT_FLAGS_SESS_RESV_STRATEGY_3
	/*
	 * Size of the returned qcaps_addr data array buffer. The
	 * value cannot exceed the size defined by the input msg,
	 * qcaps_size.
	 */
	uint16_t	size;
	/* unused. */
	uint16_t	unused0;
	/* unused. */
	uint8_t	unused1[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_tf_session_resc_qcaps_output_t, *phwrm_tf_session_resc_qcaps_output_t;

/******************************
 * hwrm_tf_session_resc_alloc *
 ******************************/


/* hwrm_tf_session_resc_alloc_input (size:320b/40B) */

typedef struct hwrm_tf_session_resc_alloc_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Firmware session id returned when HWRM_TF_SESSION_OPEN is sent. */
	uint32_t	fw_session_id;
	/* Control flags. */
	uint16_t	flags;
	/* Indicates the flow direction. */
	#define HWRM_TF_SESSION_RESC_ALLOC_INPUT_FLAGS_DIR	UINT32_C(0x1)
	/* If this bit set to 0, then it indicates rx flow. */
		#define HWRM_TF_SESSION_RESC_ALLOC_INPUT_FLAGS_DIR_RX	UINT32_C(0x0)
	/* If this bit is set to 1, then it indicates tx flow. */
		#define HWRM_TF_SESSION_RESC_ALLOC_INPUT_FLAGS_DIR_TX	UINT32_C(0x1)
		#define HWRM_TF_SESSION_RESC_ALLOC_INPUT_FLAGS_DIR_LAST HWRM_TF_SESSION_RESC_ALLOC_INPUT_FLAGS_DIR_TX
	/*
	 * Defines the array size of the provided req_addr and
	 * resv_addr array buffers. Should be set to the number of
	 * request entries.
	 */
	uint16_t	req_size;
	/*
	 * This is the DMA address for the request input data array
	 * buffer. Array is of tf_rm_resc_req_entry type. Size of the
	 * array buffer is provided by the 'req_size' field in this
	 * message.
	 */
	uint64_t	req_addr;
	/*
	 * This is the DMA address for the resc output data array
	 * buffer. Array is of tf_rm_resc_entry type. Size of the array
	 * buffer is provided by the 'req_size' field in this
	 * message.
	 */
	uint64_t	resc_addr;
} hwrm_tf_session_resc_alloc_input_t, *phwrm_tf_session_resc_alloc_input_t;

/* hwrm_tf_session_resc_alloc_output (size:128b/16B) */

typedef struct hwrm_tf_session_resc_alloc_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * Size of the returned tf_rm_resc_entry data array. The value
	 * cannot exceed the req_size defined by the input msg. The data
	 * array is returned using the resv_addr specified DMA
	 * address also provided by the input msg.
	 */
	uint16_t	size;
	/* unused. */
	uint8_t	unused0[5];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_tf_session_resc_alloc_output_t, *phwrm_tf_session_resc_alloc_output_t;

/*****************************
 * hwrm_tf_session_resc_free *
 *****************************/


/* hwrm_tf_session_resc_free_input (size:256b/32B) */

typedef struct hwrm_tf_session_resc_free_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Firmware session id returned when HWRM_TF_SESSION_OPEN is sent. */
	uint32_t	fw_session_id;
	/* Control flags. */
	uint16_t	flags;
	/* Indicates the flow direction. */
	#define HWRM_TF_SESSION_RESC_FREE_INPUT_FLAGS_DIR	UINT32_C(0x1)
	/* If this bit set to 0, then it indicates rx flow. */
		#define HWRM_TF_SESSION_RESC_FREE_INPUT_FLAGS_DIR_RX	UINT32_C(0x0)
	/* If this bit is set to 1, then it indicates tx flow. */
		#define HWRM_TF_SESSION_RESC_FREE_INPUT_FLAGS_DIR_TX	UINT32_C(0x1)
		#define HWRM_TF_SESSION_RESC_FREE_INPUT_FLAGS_DIR_LAST HWRM_TF_SESSION_RESC_FREE_INPUT_FLAGS_DIR_TX
	/*
	 * Defines the size, in bytes, of the provided free_addr
	 * buffer.
	 */
	uint16_t	free_size;
	/*
	 * This is the DMA address for the free input data array
	 * buffer.  Array is of tf_rm_resc_entry type. Size of the
	 * buffer is provided by the 'free_size' field of this
	 * message.
	 */
	uint64_t	free_addr;
} hwrm_tf_session_resc_free_input_t, *phwrm_tf_session_resc_free_input_t;

/* hwrm_tf_session_resc_free_output (size:128b/16B) */

typedef struct hwrm_tf_session_resc_free_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* unused. */
	uint8_t	unused0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_tf_session_resc_free_output_t, *phwrm_tf_session_resc_free_output_t;

/******************************
 * hwrm_tf_session_resc_flush *
 ******************************/


/* hwrm_tf_session_resc_flush_input (size:256b/32B) */

typedef struct hwrm_tf_session_resc_flush_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Firmware session id returned when HWRM_TF_SESSION_OPEN is sent. */
	uint32_t	fw_session_id;
	/* Control flags. */
	uint16_t	flags;
	/* Indicates the flow direction. */
	#define HWRM_TF_SESSION_RESC_FLUSH_INPUT_FLAGS_DIR	UINT32_C(0x1)
	/* If this bit set to 0, then it indicates rx flow. */
		#define HWRM_TF_SESSION_RESC_FLUSH_INPUT_FLAGS_DIR_RX	UINT32_C(0x0)
	/* If this bit is set to 1, then it indicates tx flow. */
		#define HWRM_TF_SESSION_RESC_FLUSH_INPUT_FLAGS_DIR_TX	UINT32_C(0x1)
		#define HWRM_TF_SESSION_RESC_FLUSH_INPUT_FLAGS_DIR_LAST HWRM_TF_SESSION_RESC_FLUSH_INPUT_FLAGS_DIR_TX
	/*
	 * Defines the size, in bytes, of the provided flush_addr
	 * buffer.
	 */
	uint16_t	flush_size;
	/*
	 * This is the DMA address for the flush input data array
	 * buffer.  Array of tf_rm_resc_entry type. Size of the
	 * buffer is provided by the 'flush_size' field in this
	 * message.
	 */
	uint64_t	flush_addr;
} hwrm_tf_session_resc_flush_input_t, *phwrm_tf_session_resc_flush_input_t;

/* hwrm_tf_session_resc_flush_output (size:128b/16B) */

typedef struct hwrm_tf_session_resc_flush_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* unused. */
	uint8_t	unused0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_tf_session_resc_flush_output_t, *phwrm_tf_session_resc_flush_output_t;

/*****************************
 * hwrm_tf_session_resc_info *
 *****************************/


/* hwrm_tf_session_resc_info_input (size:320b/40B) */

typedef struct hwrm_tf_session_resc_info_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Firmware session id returned when HWRM_TF_SESSION_OPEN is sent. */
	uint32_t	fw_session_id;
	/* Control flags. */
	uint16_t	flags;
	/* Indicates the flow direction. */
	#define HWRM_TF_SESSION_RESC_INFO_INPUT_FLAGS_DIR	UINT32_C(0x1)
	/* If this bit set to 0, then it indicates rx flow. */
		#define HWRM_TF_SESSION_RESC_INFO_INPUT_FLAGS_DIR_RX	UINT32_C(0x0)
	/* If this bit is set to 1, then it indicates tx flow. */
		#define HWRM_TF_SESSION_RESC_INFO_INPUT_FLAGS_DIR_TX	UINT32_C(0x1)
		#define HWRM_TF_SESSION_RESC_INFO_INPUT_FLAGS_DIR_LAST HWRM_TF_SESSION_RESC_INFO_INPUT_FLAGS_DIR_TX
	/*
	 * Defines the array size of the provided req_addr and
	 * resv_addr array buffers. Should be set to the number of
	 * request entries.
	 */
	uint16_t	req_size;
	/*
	 * This is the DMA address for the request input data array
	 * buffer. Array is of tf_rm_resc_req_entry type. Size of the
	 * array buffer is provided by the 'req_size' field in this
	 * message.
	 */
	uint64_t	req_addr;
	/*
	 * This is the DMA address for the resc output data array
	 * buffer. Array is of tf_rm_resc_entry type. Size of the array
	 * buffer is provided by the 'req_size' field in this
	 * message.
	 */
	uint64_t	resc_addr;
} hwrm_tf_session_resc_info_input_t, *phwrm_tf_session_resc_info_input_t;

/* hwrm_tf_session_resc_info_output (size:128b/16B) */

typedef struct hwrm_tf_session_resc_info_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * Size of the returned tf_rm_resc_entry data array. The value
	 * cannot exceed the req_size defined by the input msg. The data
	 * array is returned using the resv_addr specified DMA
	 * address also provided by the input msg.
	 */
	uint16_t	size;
	/* unused. */
	uint8_t	unused0[5];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_tf_session_resc_info_output_t, *phwrm_tf_session_resc_info_output_t;

/* TruFlow RM capability of a resource. */
/* tf_rm_resc_req_entry (size:64b/8B) */

typedef struct tf_rm_resc_req_entry {
	/* Type of the resource, defined globally in HCAPI RM. */
	uint32_t	type;
	/* Minimum value. */
	uint16_t	min;
	/* Maximum value. */
	uint16_t	max;
} tf_rm_resc_req_entry_t, *ptf_rm_resc_req_entry_t;

/* TruFlow RM reservation information. */
/* tf_rm_resc_entry (size:64b/8B) */

typedef struct tf_rm_resc_entry {
	/* Type of the resource, defined globally in HCAPI RM. */
	uint32_t	type;
	/* Start offset. */
	uint16_t	start;
	/* Number of resources. */
	uint16_t	stride;
} tf_rm_resc_entry_t, *ptf_rm_resc_entry_t;

/************************
 * hwrm_tf_tbl_type_get *
 ************************/


/* hwrm_tf_tbl_type_get_input (size:256b/32B) */

typedef struct hwrm_tf_tbl_type_get_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Firmware session id returned when HWRM_TF_SESSION_OPEN is sent. */
	uint32_t	fw_session_id;
	/* Control flags. */
	uint16_t	flags;
	/* Indicates the flow direction. */
	#define HWRM_TF_TBL_TYPE_GET_INPUT_FLAGS_DIR	UINT32_C(0x1)
	/* If this bit set to 0, then it indicates rx flow. */
		#define HWRM_TF_TBL_TYPE_GET_INPUT_FLAGS_DIR_RX	UINT32_C(0x0)
	/* If this bit is set to 1, then it indicates tx flow. */
		#define HWRM_TF_TBL_TYPE_GET_INPUT_FLAGS_DIR_TX	UINT32_C(0x1)
		#define HWRM_TF_TBL_TYPE_GET_INPUT_FLAGS_DIR_LAST HWRM_TF_TBL_TYPE_GET_INPUT_FLAGS_DIR_TX
	/* unused. */
	uint8_t	unused0[2];
	/*
	 * Type of the resource, defined globally in the
	 * hwrm_tf_resc_type enum.
	 */
	uint32_t	type;
	/* Index of the type to retrieve. */
	uint32_t	index;
} hwrm_tf_tbl_type_get_input_t, *phwrm_tf_tbl_type_get_input_t;

/* hwrm_tf_tbl_type_get_output (size:1216b/152B) */

typedef struct hwrm_tf_tbl_type_get_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Response code. */
	uint32_t	resp_code;
	/* Response size. */
	uint16_t	size;
	/* unused */
	uint16_t	unused0;
	/* Response data. */
	uint8_t	data[128];
	/* unused */
	uint8_t	unused1[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field
	 * is written last.
	 */
	uint8_t	valid;
} hwrm_tf_tbl_type_get_output_t, *phwrm_tf_tbl_type_get_output_t;

/************************
 * hwrm_tf_tbl_type_set *
 ************************/


/* hwrm_tf_tbl_type_set_input (size:1024b/128B) */

typedef struct hwrm_tf_tbl_type_set_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Firmware session id returned when HWRM_TF_SESSION_OPEN is sent. */
	uint32_t	fw_session_id;
	/* Control flags. */
	uint16_t	flags;
	/* Indicates the flow direction. */
	#define HWRM_TF_TBL_TYPE_SET_INPUT_FLAGS_DIR	UINT32_C(0x1)
	/* If this bit set to 0, then it indicates rx flow. */
		#define HWRM_TF_TBL_TYPE_SET_INPUT_FLAGS_DIR_RX	UINT32_C(0x0)
	/* If this bit is set to 1, then it indicates tx flow. */
		#define HWRM_TF_TBL_TYPE_SET_INPUT_FLAGS_DIR_TX	UINT32_C(0x1)
		#define HWRM_TF_TBL_TYPE_SET_INPUT_FLAGS_DIR_LAST HWRM_TF_TBL_TYPE_SET_INPUT_FLAGS_DIR_TX
	/* unused. */
	uint8_t	unused0[2];
	/*
	 * Type of the resource, defined globally in the
	 * hwrm_tf_resc_type enum.
	 */
	uint32_t	type;
	/* Index of the type to retrieve. */
	uint32_t	index;
	/* Size of the data to set. */
	uint16_t	size;
	/* unused */
	uint8_t	unused1[6];
	/* Data to be set. */
	uint8_t	data[88];
} hwrm_tf_tbl_type_set_input_t, *phwrm_tf_tbl_type_set_input_t;

/* hwrm_tf_tbl_type_set_output (size:128b/16B) */

typedef struct hwrm_tf_tbl_type_set_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* unused. */
	uint8_t	unused0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field
	 * is written last.
	 */
	uint8_t	valid;
} hwrm_tf_tbl_type_set_output_t, *phwrm_tf_tbl_type_set_output_t;

/**************************
 * hwrm_tf_ctxt_mem_alloc *
 **************************/


/* hwrm_tf_ctxt_mem_alloc_input (size:192b/24B) */

typedef struct hwrm_tf_ctxt_mem_alloc_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Size in KB of memory to be allocated. */
	uint32_t	mem_size;
	/* Firmware session id returned when HWRM_TF_SESSION_OPEN is sent. */
	uint32_t	fw_session_id;
} hwrm_tf_ctxt_mem_alloc_input_t, *phwrm_tf_ctxt_mem_alloc_input_t;

/* hwrm_tf_ctxt_mem_alloc_output (size:192b/24B) */

typedef struct hwrm_tf_ctxt_mem_alloc_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Pointer to the PBL, or PDL depending on number of levels */
	uint64_t	page_dir;
	/* Size of memory allocated. */
	uint32_t	mem_size;
	/* Counter PBL indirect levels. */
	uint8_t	page_level;
	/* PBL pointer is physical start address. */
	#define HWRM_TF_CTXT_MEM_ALLOC_OUTPUT_PAGE_LEVEL_LVL_0 UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
	#define HWRM_TF_CTXT_MEM_ALLOC_OUTPUT_PAGE_LEVEL_LVL_1 UINT32_C(0x1)
	/*
	 * PBL pointer points to PDE table with each entry pointing
	 * to PTE tables.
	 */
	#define HWRM_TF_CTXT_MEM_ALLOC_OUTPUT_PAGE_LEVEL_LVL_2 UINT32_C(0x2)
	#define HWRM_TF_CTXT_MEM_ALLOC_OUTPUT_PAGE_LEVEL_LAST HWRM_TF_CTXT_MEM_ALLOC_OUTPUT_PAGE_LEVEL_LVL_2
	/* Page size. */
	uint8_t	page_size;
	/* 4KB page size. */
	#define HWRM_TF_CTXT_MEM_ALLOC_OUTPUT_PAGE_SIZE_4K   UINT32_C(0x0)
	/* 8KB page size. */
	#define HWRM_TF_CTXT_MEM_ALLOC_OUTPUT_PAGE_SIZE_8K   UINT32_C(0x1)
	/* 64KB page size. */
	#define HWRM_TF_CTXT_MEM_ALLOC_OUTPUT_PAGE_SIZE_64K  UINT32_C(0x4)
	/* 128KB page size. */
	#define HWRM_TF_CTXT_MEM_ALLOC_OUTPUT_PAGE_SIZE_128K UINT32_C(0x5)
	/* 256KB page size. */
	#define HWRM_TF_CTXT_MEM_ALLOC_OUTPUT_PAGE_SIZE_256K UINT32_C(0x6)
	/* 512KB page size. */
	#define HWRM_TF_CTXT_MEM_ALLOC_OUTPUT_PAGE_SIZE_512K UINT32_C(0x7)
	/* 1MB page size. */
	#define HWRM_TF_CTXT_MEM_ALLOC_OUTPUT_PAGE_SIZE_1M   UINT32_C(0x8)
	/* 2MB page size. */
	#define HWRM_TF_CTXT_MEM_ALLOC_OUTPUT_PAGE_SIZE_2M   UINT32_C(0x9)
	/* 4MB page size. */
	#define HWRM_TF_CTXT_MEM_ALLOC_OUTPUT_PAGE_SIZE_4M   UINT32_C(0xa)
	/* 8MB page size. */
	#define HWRM_TF_CTXT_MEM_ALLOC_OUTPUT_PAGE_SIZE_8M   UINT32_C(0xb)
	/* 1GB page size. */
	#define HWRM_TF_CTXT_MEM_ALLOC_OUTPUT_PAGE_SIZE_1G   UINT32_C(0x12)
	#define HWRM_TF_CTXT_MEM_ALLOC_OUTPUT_PAGE_SIZE_LAST HWRM_TF_CTXT_MEM_ALLOC_OUTPUT_PAGE_SIZE_1G
	/* unused. */
	uint8_t	unused0;
	/*
	 * This field is used in Output records to indicate that the
	 * output is completely written to RAM. This field should be
	 * read as '1' to indicate that the output has been
	 * completely written.  When writing a command completion or
	 * response to an internal processor, the order of writes has
	 * to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_tf_ctxt_mem_alloc_output_t, *phwrm_tf_ctxt_mem_alloc_output_t;

/*************************
 * hwrm_tf_ctxt_mem_free *
 *************************/


/* hwrm_tf_ctxt_mem_free_input (size:320b/40B) */

typedef struct hwrm_tf_ctxt_mem_free_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Firmware session id returned when HWRM_TF_SESSION_OPEN is sent. */
	uint32_t	fw_session_id;
	/* Counter PBL indirect levels. */
	uint8_t	page_level;
	/* PBL pointer is physical start address. */
	#define HWRM_TF_CTXT_MEM_FREE_INPUT_PAGE_LEVEL_LVL_0 UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
	#define HWRM_TF_CTXT_MEM_FREE_INPUT_PAGE_LEVEL_LVL_1 UINT32_C(0x1)
	/*
	 * PBL pointer points to PDE table with each entry pointing
	 * to PTE tables.
	 */
	#define HWRM_TF_CTXT_MEM_FREE_INPUT_PAGE_LEVEL_LVL_2 UINT32_C(0x2)
	#define HWRM_TF_CTXT_MEM_FREE_INPUT_PAGE_LEVEL_LAST HWRM_TF_CTXT_MEM_FREE_INPUT_PAGE_LEVEL_LVL_2
	/* Page size. */
	uint8_t	page_size;
	/* 4KB page size. */
	#define HWRM_TF_CTXT_MEM_FREE_INPUT_PAGE_SIZE_4K   UINT32_C(0x0)
	/* 8KB page size. */
	#define HWRM_TF_CTXT_MEM_FREE_INPUT_PAGE_SIZE_8K   UINT32_C(0x1)
	/* 64KB page size. */
	#define HWRM_TF_CTXT_MEM_FREE_INPUT_PAGE_SIZE_64K  UINT32_C(0x4)
	/* 128KB page size. */
	#define HWRM_TF_CTXT_MEM_FREE_INPUT_PAGE_SIZE_128K UINT32_C(0x5)
	/* 256KB page size. */
	#define HWRM_TF_CTXT_MEM_FREE_INPUT_PAGE_SIZE_256K UINT32_C(0x6)
	/* 512KB page size. */
	#define HWRM_TF_CTXT_MEM_FREE_INPUT_PAGE_SIZE_512K UINT32_C(0x7)
	/* 1MB page size. */
	#define HWRM_TF_CTXT_MEM_FREE_INPUT_PAGE_SIZE_1M   UINT32_C(0x8)
	/* 2MB page size. */
	#define HWRM_TF_CTXT_MEM_FREE_INPUT_PAGE_SIZE_2M   UINT32_C(0x9)
	/* 4MB page size. */
	#define HWRM_TF_CTXT_MEM_FREE_INPUT_PAGE_SIZE_4M   UINT32_C(0xa)
	/* 8MB page size. */
	#define HWRM_TF_CTXT_MEM_FREE_INPUT_PAGE_SIZE_8M   UINT32_C(0xb)
	/* 1GB page size. */
	#define HWRM_TF_CTXT_MEM_FREE_INPUT_PAGE_SIZE_1G   UINT32_C(0x12)
	#define HWRM_TF_CTXT_MEM_FREE_INPUT_PAGE_SIZE_LAST HWRM_TF_CTXT_MEM_FREE_INPUT_PAGE_SIZE_1G
	/* unused. */
	uint8_t	unused0[2];
	/* Pointer to the PBL, or PDL depending on number of levels */
	uint64_t	page_dir;
	/* Size of memory allocated. */
	uint32_t	mem_size;
	/* unused. */
	uint8_t	unused1[4];
} hwrm_tf_ctxt_mem_free_input_t, *phwrm_tf_ctxt_mem_free_input_t;

/* hwrm_tf_ctxt_mem_free_output (size:128b/16B) */

typedef struct hwrm_tf_ctxt_mem_free_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* unused. */
	uint8_t	unused0[7];
	/*
	 * This field is used in Output records to indicate that the
	 * output is completely written to RAM. This field should be
	 * read as '1' to indicate that the output has been
	 * completely written.  When writing a command completion or
	 * response to an internal processor, the order of writes has
	 * to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_tf_ctxt_mem_free_output_t, *phwrm_tf_ctxt_mem_free_output_t;

/*************************
 * hwrm_tf_ctxt_mem_rgtr *
 *************************/


/* hwrm_tf_ctxt_mem_rgtr_input (size:256b/32B) */

typedef struct hwrm_tf_ctxt_mem_rgtr_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Control flags. */
	uint16_t	flags;
	/* Counter PBL indirect levels. */
	uint8_t	page_level;
	/* PBL pointer is physical start address. */
	#define HWRM_TF_CTXT_MEM_RGTR_INPUT_PAGE_LEVEL_LVL_0 UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
	#define HWRM_TF_CTXT_MEM_RGTR_INPUT_PAGE_LEVEL_LVL_1 UINT32_C(0x1)
	/*
	 * PBL pointer points to PDE table with each entry pointing
	 * to PTE tables.
	 */
	#define HWRM_TF_CTXT_MEM_RGTR_INPUT_PAGE_LEVEL_LVL_2 UINT32_C(0x2)
	#define HWRM_TF_CTXT_MEM_RGTR_INPUT_PAGE_LEVEL_LAST HWRM_TF_CTXT_MEM_RGTR_INPUT_PAGE_LEVEL_LVL_2
	/* Page size. */
	uint8_t	page_size;
	/* 4KB page size. */
	#define HWRM_TF_CTXT_MEM_RGTR_INPUT_PAGE_SIZE_4K   UINT32_C(0x0)
	/* 8KB page size. */
	#define HWRM_TF_CTXT_MEM_RGTR_INPUT_PAGE_SIZE_8K   UINT32_C(0x1)
	/* 64KB page size. */
	#define HWRM_TF_CTXT_MEM_RGTR_INPUT_PAGE_SIZE_64K  UINT32_C(0x4)
	/* 128KB page size. */
	#define HWRM_TF_CTXT_MEM_RGTR_INPUT_PAGE_SIZE_128K UINT32_C(0x5)
	/* 256KB page size. */
	#define HWRM_TF_CTXT_MEM_RGTR_INPUT_PAGE_SIZE_256K UINT32_C(0x6)
	/* 512KB page size. */
	#define HWRM_TF_CTXT_MEM_RGTR_INPUT_PAGE_SIZE_512K UINT32_C(0x7)
	/* 1MB page size. */
	#define HWRM_TF_CTXT_MEM_RGTR_INPUT_PAGE_SIZE_1M   UINT32_C(0x8)
	/* 2MB page size. */
	#define HWRM_TF_CTXT_MEM_RGTR_INPUT_PAGE_SIZE_2M   UINT32_C(0x9)
	/* 4MB page size. */
	#define HWRM_TF_CTXT_MEM_RGTR_INPUT_PAGE_SIZE_4M   UINT32_C(0xa)
	/* 8MB page size. */
	#define HWRM_TF_CTXT_MEM_RGTR_INPUT_PAGE_SIZE_8M   UINT32_C(0xb)
	/* 1GB page size. */
	#define HWRM_TF_CTXT_MEM_RGTR_INPUT_PAGE_SIZE_1G   UINT32_C(0x12)
	#define HWRM_TF_CTXT_MEM_RGTR_INPUT_PAGE_SIZE_LAST HWRM_TF_CTXT_MEM_RGTR_INPUT_PAGE_SIZE_1G
	/* Firmware session id returned when HWRM_TF_SESSION_OPEN is sent. */
	uint32_t	fw_session_id;
	/* Pointer to the PBL, or PDL depending on number of levels */
	uint64_t	page_dir;
} hwrm_tf_ctxt_mem_rgtr_input_t, *phwrm_tf_ctxt_mem_rgtr_input_t;

/* hwrm_tf_ctxt_mem_rgtr_output (size:128b/16B) */

typedef struct hwrm_tf_ctxt_mem_rgtr_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * Id/Handle to the recently register context memory. This
	 * handle is passed to the TF session.
	 */
	uint16_t	ctx_id;
	/* unused. */
	uint8_t	unused0[5];
	/*
	 * This field is used in Output records to indicate that the
	 * output is completely written to RAM. This field should be
	 * read as '1' to indicate that the output has been
	 * completely written.  When writing a command completion or
	 * response to an internal processor, the order of writes has
	 * to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_tf_ctxt_mem_rgtr_output_t, *phwrm_tf_ctxt_mem_rgtr_output_t;

/***************************
 * hwrm_tf_ctxt_mem_unrgtr *
 ***************************/


/* hwrm_tf_ctxt_mem_unrgtr_input (size:192b/24B) */

typedef struct hwrm_tf_ctxt_mem_unrgtr_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * Id/Handle to the recently register context memory. This
	 * handle is passed to the TF session.
	 */
	uint16_t	ctx_id;
	/* unused. */
	uint8_t	unused0[2];
	/* Firmware session id returned when HWRM_TF_SESSION_OPEN is sent. */
	uint32_t	fw_session_id;
} hwrm_tf_ctxt_mem_unrgtr_input_t, *phwrm_tf_ctxt_mem_unrgtr_input_t;

/* hwrm_tf_ctxt_mem_unrgtr_output (size:128b/16B) */

typedef struct hwrm_tf_ctxt_mem_unrgtr_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* unused. */
	uint8_t	unused0[7];
	/*
	 * This field is used in Output records to indicate that the
	 * output is completely written to RAM. This field should be
	 * read as '1' to indicate that the output has been
	 * completely written.  When writing a command completion or
	 * response to an internal processor, the order of writes has
	 * to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_tf_ctxt_mem_unrgtr_output_t, *phwrm_tf_ctxt_mem_unrgtr_output_t;

/************************
 * hwrm_tf_ext_em_qcaps *
 ************************/


/* hwrm_tf_ext_em_qcaps_input (size:192b/24B) */

typedef struct hwrm_tf_ext_em_qcaps_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Control flags. */
	uint32_t	flags;
	/* Indicates the flow direction. */
	#define HWRM_TF_EXT_EM_QCAPS_INPUT_FLAGS_DIR		UINT32_C(0x1)
	/* If this bit set to 0, then it indicates rx flow. */
		#define HWRM_TF_EXT_EM_QCAPS_INPUT_FLAGS_DIR_RX		UINT32_C(0x0)
	/* If this bit is set to 1, then it indicates tx flow. */
		#define HWRM_TF_EXT_EM_QCAPS_INPUT_FLAGS_DIR_TX		UINT32_C(0x1)
		#define HWRM_TF_EXT_EM_QCAPS_INPUT_FLAGS_DIR_LAST		HWRM_TF_EXT_EM_QCAPS_INPUT_FLAGS_DIR_TX
	/* When set to 1, all offloaded flows will be sent to EXT EM. */
	#define HWRM_TF_EXT_EM_QCAPS_INPUT_FLAGS_PREFERRED_OFFLOAD	UINT32_C(0x2)
	/* Firmware session id returned when HWRM_TF_SESSION_OPEN is sent. */
	uint32_t	fw_session_id;
} hwrm_tf_ext_em_qcaps_input_t, *phwrm_tf_ext_em_qcaps_input_t;

/* hwrm_tf_ext_em_qcaps_output (size:384b/48B) */

typedef struct hwrm_tf_ext_em_qcaps_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint32_t	flags;
	/*
	 * When set to 1, indicates the the FW supports the Centralized
	 * Memory Model. The concept designates one entity for the
	 * memory allocation while all others ‘subscribe’ to it.
	 */
	#define HWRM_TF_EXT_EM_QCAPS_OUTPUT_FLAGS_CENTRALIZED_MEMORY_MODEL_SUPPORTED		UINT32_C(0x1)
	/*
	 * When set to 1, indicates the the FW supports the Detached
	 * Centralized Memory Model. The memory is allocated and managed
	 * as a separate entity. All PFs and VFs will be granted direct
	 * or semi-direct access to the allocated memory while none of
	 * which can interfere with the management of the memory.
	 */
	#define HWRM_TF_EXT_EM_QCAPS_OUTPUT_FLAGS_DETACHED_CENTRALIZED_MEMORY_MODEL_SUPPORTED	UINT32_C(0x2)
	/* When set to 1, indicates FW support for host based EEM memory. */
	#define HWRM_TF_EXT_EM_QCAPS_OUTPUT_FLAGS_HOST_MEMORY_SUPPORTED			UINT32_C(0x4)
	/* When set to 1, indicates FW support for on-chip based EEM memory. */
	#define HWRM_TF_EXT_EM_QCAPS_OUTPUT_FLAGS_FW_MEMORY_SUPPORTED				UINT32_C(0x8)
	/* unused. */
	uint32_t	unused0;
	/* Support flags. */
	uint32_t	supported;
	/*
	 * If set to 1, then EXT EM KEY0 table is supported using
	 * crc32 hash.
	 * If set to 0, EXT EM KEY0 table is not supported.
	 */
	#define HWRM_TF_EXT_EM_QCAPS_OUTPUT_SUPPORTED_KEY0_TABLE			UINT32_C(0x1)
	/*
	 * If set to 1, then EXT EM KEY1 table is supported using
	 * lookup3 hash.
	 * If set to 0, EXT EM KEY1 table is not supported.
	 */
	#define HWRM_TF_EXT_EM_QCAPS_OUTPUT_SUPPORTED_KEY1_TABLE			UINT32_C(0x2)
	/*
	 * If set to 1, then EXT EM External Record table is supported.
	 * If set to 0, EXT EM External Record table is not
	 * supported.  (This table includes action record, EFC
	 * pointers, encap pointers)
	 */
	#define HWRM_TF_EXT_EM_QCAPS_OUTPUT_SUPPORTED_EXTERNAL_RECORD_TABLE		UINT32_C(0x4)
	/*
	 * If set to 1, then EXT EM External Flow Counters table is
	 * supported.
	 * If set to 0, EXT EM External Flow Counters table is not
	 * supported.
	 */
	#define HWRM_TF_EXT_EM_QCAPS_OUTPUT_SUPPORTED_EXTERNAL_FLOW_COUNTERS_TABLE	UINT32_C(0x8)
	/*
	 * If set to 1, then FID table used for implicit flow flush
	 * is supported.
	 * If set to 0, then FID table used for implicit flow flush
	 * is not supported.
	 */
	#define HWRM_TF_EXT_EM_QCAPS_OUTPUT_SUPPORTED_FID_TABLE			UINT32_C(0x10)
	/*
	 * If set to 1, then table scopes are supported.
	 * If set to 0, then table scopes are not supported.
	 */
	#define HWRM_TF_EXT_EM_QCAPS_OUTPUT_SUPPORTED_TBL_SCOPES			UINT32_C(0x20)
	/*
	 * The maximum number of entries supported by EXT EM. When
	 * configuring the host memory the number of numbers of
	 * entries that can supported are -
	 *	32k, 64k 128k, 256k, 512k, 1M, 2M, 4M, 8M, 32M, 64M,
	 *	128M entries.
	 * Any value that are not these values, the FW will round
	 * down to the closest support number of entries.
	 */
	uint32_t	max_entries_supported;
	/*
	 * The entry size in bytes of each entry in the EXT EM
	 * KEY0/KEY1 tables.
	 */
	uint16_t	key_entry_size;
	/*
	 * The entry size in bytes of each entry in the EXT EM RECORD
	 * tables.
	 */
	uint16_t	record_entry_size;
	/* The entry size in bytes of each entry in the EXT EM EFC tables. */
	uint16_t	efc_entry_size;
	/* The FID size in bytes of each entry in the EXT EM FID tables. */
	uint16_t	fid_entry_size;
	/* Maximum number of ctxt mem allocations allowed. */
	uint32_t	max_ctxt_mem_allocs;
	/*
	 * Maximum number of static buckets that can be assigned to lookup
	 * table scopes.
	 */
	uint32_t	max_static_buckets;
	/* unused. */
	uint8_t	unused1[7];
	/*
	 * This field is used in Output records to indicate that the
	 * output is completely written to RAM. This field should be
	 * read as '1' to indicate that the output has been
	 * completely written.  When writing a command completion or
	 * response to an internal processor, the order of writes has
	 * to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_tf_ext_em_qcaps_output_t, *phwrm_tf_ext_em_qcaps_output_t;

/*********************
 * hwrm_tf_ext_em_op *
 *********************/


/* hwrm_tf_ext_em_op_input (size:256b/32B) */

typedef struct hwrm_tf_ext_em_op_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Control flags. */
	uint16_t	flags;
	/* Indicates the flow direction. */
	#define HWRM_TF_EXT_EM_OP_INPUT_FLAGS_DIR	UINT32_C(0x1)
	/* If this bit set to 0, then it indicates rx flow. */
		#define HWRM_TF_EXT_EM_OP_INPUT_FLAGS_DIR_RX	UINT32_C(0x0)
	/* If this bit is set to 1, then it indicates tx flow. */
		#define HWRM_TF_EXT_EM_OP_INPUT_FLAGS_DIR_TX	UINT32_C(0x1)
		#define HWRM_TF_EXT_EM_OP_INPUT_FLAGS_DIR_LAST HWRM_TF_EXT_EM_OP_INPUT_FLAGS_DIR_TX
	/* unused. */
	uint16_t	unused0;
	/* The number of EXT EM key table entries to be configured. */
	uint16_t	op;
	/* This value is reserved and should not be used. */
	#define HWRM_TF_EXT_EM_OP_INPUT_OP_RESERVED	UINT32_C(0x0)
	/*
	 * To properly stop EXT EM and ensure there are no DMA's,
	 * the caller must disable EXT EM for the given PF, using
	 * this call. This will safely disable EXT EM and ensure
	 * that all DMA'ed to the keys/records/efc have been
	 * completed.
	 */
	#define HWRM_TF_EXT_EM_OP_INPUT_OP_EXT_EM_DISABLE UINT32_C(0x1)
	/*
	 * Once the EXT EM host memory has been configured, EXT EM
	 * options have been configured. Then the caller should
	 * enable EXT EM for the given PF. Note once this call has
	 * been made, then the EXT EM mechanism will be active and
	 * DMA's will occur as packets are processed.
	 */
	#define HWRM_TF_EXT_EM_OP_INPUT_OP_EXT_EM_ENABLE  UINT32_C(0x2)
	/*
	 * Clear EXT EM settings for the given PF so that the
	 * register values are reset back to their initial state.
	 */
	#define HWRM_TF_EXT_EM_OP_INPUT_OP_EXT_EM_CLEANUP UINT32_C(0x3)
	#define HWRM_TF_EXT_EM_OP_INPUT_OP_LAST	HWRM_TF_EXT_EM_OP_INPUT_OP_EXT_EM_CLEANUP
	/* unused. */
	uint16_t	unused1;
	/* Firmware session id returned when HWRM_TF_SESSION_OPEN is sent. */
	uint32_t	fw_session_id;
	/* unused. */
	uint32_t	unused2;
} hwrm_tf_ext_em_op_input_t, *phwrm_tf_ext_em_op_input_t;

/* hwrm_tf_ext_em_op_output (size:128b/16B) */

typedef struct hwrm_tf_ext_em_op_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* unused. */
	uint8_t	unused0[7];
	/*
	 * This field is used in Output records to indicate that the
	 * output is completely written to RAM. This field should be
	 * read as '1' to indicate that the output has been
	 * completely written.  When writing a command completion or
	 * response to an internal processor, the order of writes has
	 * to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_tf_ext_em_op_output_t, *phwrm_tf_ext_em_op_output_t;

/**********************
 * hwrm_tf_ext_em_cfg *
 **********************/


/* hwrm_tf_ext_em_cfg_input (size:512b/64B) */

typedef struct hwrm_tf_ext_em_cfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Control flags. */
	uint32_t	flags;
	/* Indicates the flow direction. */
	#define HWRM_TF_EXT_EM_CFG_INPUT_FLAGS_DIR		UINT32_C(0x1)
	/* If this bit set to 0, then it indicates rx flow. */
		#define HWRM_TF_EXT_EM_CFG_INPUT_FLAGS_DIR_RX		UINT32_C(0x0)
	/* If this bit is set to 1, then it indicates tx flow. */
		#define HWRM_TF_EXT_EM_CFG_INPUT_FLAGS_DIR_TX		UINT32_C(0x1)
		#define HWRM_TF_EXT_EM_CFG_INPUT_FLAGS_DIR_LAST		HWRM_TF_EXT_EM_CFG_INPUT_FLAGS_DIR_TX
	/* When set to 1, all offloaded flows will be sent to EXT EM. */
	#define HWRM_TF_EXT_EM_CFG_INPUT_FLAGS_PREFERRED_OFFLOAD	UINT32_C(0x2)
	/* When set to 1, secondary, 0 means primary. */
	#define HWRM_TF_EXT_EM_CFG_INPUT_FLAGS_SECONDARY_PF	UINT32_C(0x4)
	/*
	 * Group_id which used by Firmware to identify memory pools belonging
	 * to certain group.
	 */
	uint16_t	group_id;
	/*
	 * Dynamically reconfigure EEM pending cache every 1/10th of second.
	 * If set to 0 it will disable the EEM HW flush of the pending cache.
	 */
	uint8_t	flush_interval;
	/* unused. */
	uint8_t	unused0;
	/*
	 * Configured EXT EM with the given number of entries. All
	 * the EXT EM tables KEY0, KEY1, RECORD, EFC all have the
	 * same number of entries and all tables will be configured
	 * using this value. Current minimum value is 32k. Current
	 * maximum value is 128M.
	 */
	uint32_t	num_entries;
	uint32_t	enables;
	/*
	 * This bit must be '1' for the group_id field to be
	 * configured.
	 */
	#define HWRM_TF_EXT_EM_CFG_INPUT_ENABLES_GROUP_ID		UINT32_C(0x1)
	/*
	 * This bit must be '1' for the flush_interval field to be
	 * configured.
	 */
	#define HWRM_TF_EXT_EM_CFG_INPUT_ENABLES_FLUSH_INTERVAL	UINT32_C(0x2)
	/*
	 * This bit must be '1' for the num_entries field to be
	 * configured.
	 */
	#define HWRM_TF_EXT_EM_CFG_INPUT_ENABLES_NUM_ENTRIES		UINT32_C(0x4)
	/*
	 * This bit must be '1' for the key0_ctx_id field to be
	 * configured.
	 */
	#define HWRM_TF_EXT_EM_CFG_INPUT_ENABLES_KEY0_CTX_ID		UINT32_C(0x8)
	/*
	 * This bit must be '1' for the key1_ctx_id field to be
	 * configured.
	 */
	#define HWRM_TF_EXT_EM_CFG_INPUT_ENABLES_KEY1_CTX_ID		UINT32_C(0x10)
	/*
	 * This bit must be '1' for the record_ctx_id field to be
	 * configured.
	 */
	#define HWRM_TF_EXT_EM_CFG_INPUT_ENABLES_RECORD_CTX_ID	UINT32_C(0x20)
	/*
	 * This bit must be '1' for the efc_ctx_id field to be
	 * configured.
	 */
	#define HWRM_TF_EXT_EM_CFG_INPUT_ENABLES_EFC_CTX_ID		UINT32_C(0x40)
	/*
	 * This bit must be '1' for the fid_ctx_id field to be
	 * configured.
	 */
	#define HWRM_TF_EXT_EM_CFG_INPUT_ENABLES_FID_CTX_ID		UINT32_C(0x80)
	/*
	 * This bit must be '1' for the action_ctx_id field to be
	 * configured.
	 */
	#define HWRM_TF_EXT_EM_CFG_INPUT_ENABLES_ACTION_CTX_ID	UINT32_C(0x100)
	/*
	 * This bit must be '1' for the action_tbl_scope field to be
	 * configured.
	 */
	#define HWRM_TF_EXT_EM_CFG_INPUT_ENABLES_ACTION_TBL_SCOPE	UINT32_C(0x200)
	/*
	 * This bit must be '1' for the lkup_ctx_id field to be
	 * configured.
	 */
	#define HWRM_TF_EXT_EM_CFG_INPUT_ENABLES_LKUP_CTX_ID		UINT32_C(0x400)
	/*
	 * This bit must be '1' for the lkup_tbl_scope field to be
	 * configured.
	 */
	#define HWRM_TF_EXT_EM_CFG_INPUT_ENABLES_LKUP_TBL_SCOPE	UINT32_C(0x800)
	/*
	 * This bit must be '1' for the lkup_static_buckets field to be
	 * configured.
	 */
	#define HWRM_TF_EXT_EM_CFG_INPUT_ENABLES_LKUP_STATIC_BUCKETS	UINT32_C(0x1000)
	/* Configured EXT EM with the given context if for KEY0 table. */
	uint16_t	key0_ctx_id;
	/* Configured EXT EM with the given context if for KEY1 table. */
	uint16_t	key1_ctx_id;
	/* Configured EXT EM with the given context if for RECORD table. */
	uint16_t	record_ctx_id;
	/* Configured EXT EM with the given context if for EFC table. */
	uint16_t	efc_ctx_id;
	/* Configured EXT EM with the given context if for EFC table. */
	uint16_t	fid_ctx_id;
	/* Context id of action table scope. */
	uint16_t	action_ctx_id;
	/* Table scope id used for action record entries. */
	uint16_t	action_tbl_scope;
	/* Context id of lookup table scope. */
	uint16_t	lkup_ctx_id;
	/* Table scope id used for EM lookup entries. */
	uint16_t	lkup_tbl_scope;
	/* unused. */
	uint16_t	unused1;
	/*
	 * Number of 32B static buckets to be allocated at the beginning
	 * of table scope.
	 */
	uint32_t	lkup_static_buckets;
	/* Firmware session id returned when HWRM_TF_SESSION_OPEN is sent. */
	uint32_t	fw_session_id;
	/* unused. */
	uint32_t	unused2;
} hwrm_tf_ext_em_cfg_input_t, *phwrm_tf_ext_em_cfg_input_t;

/* hwrm_tf_ext_em_cfg_output (size:128b/16B) */

typedef struct hwrm_tf_ext_em_cfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* unused. */
	uint8_t	unused0[7];
	/*
	 * This field is used in Output records to indicate that the
	 * output is completely written to RAM. This field should be
	 * read as '1' to indicate that the output has been
	 * completely written.  When writing a command completion or
	 * response to an internal processor, the order of writes has
	 * to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_tf_ext_em_cfg_output_t, *phwrm_tf_ext_em_cfg_output_t;

/***********************
 * hwrm_tf_ext_em_qcfg *
 ***********************/


/* hwrm_tf_ext_em_qcfg_input (size:192b/24B) */

typedef struct hwrm_tf_ext_em_qcfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Control flags. */
	uint32_t	flags;
	/* Indicates the flow direction. */
	#define HWRM_TF_EXT_EM_QCFG_INPUT_FLAGS_DIR	UINT32_C(0x1)
	/* If this bit set to 0, then it indicates rx flow. */
		#define HWRM_TF_EXT_EM_QCFG_INPUT_FLAGS_DIR_RX	UINT32_C(0x0)
	/* If this bit is set to 1, then it indicates tx flow. */
		#define HWRM_TF_EXT_EM_QCFG_INPUT_FLAGS_DIR_TX	UINT32_C(0x1)
		#define HWRM_TF_EXT_EM_QCFG_INPUT_FLAGS_DIR_LAST HWRM_TF_EXT_EM_QCFG_INPUT_FLAGS_DIR_TX
	/* Firmware session id returned when HWRM_TF_SESSION_OPEN is sent. */
	uint32_t	fw_session_id;
} hwrm_tf_ext_em_qcfg_input_t, *phwrm_tf_ext_em_qcfg_input_t;

/* hwrm_tf_ext_em_qcfg_output (size:448b/56B) */

typedef struct hwrm_tf_ext_em_qcfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Control flags. */
	uint32_t	flags;
	/* Indicates the flow direction. */
	#define HWRM_TF_EXT_EM_QCFG_OUTPUT_FLAGS_DIR		UINT32_C(0x1)
	/* If this bit set to 0, then it indicates rx flow. */
		#define HWRM_TF_EXT_EM_QCFG_OUTPUT_FLAGS_DIR_RX		UINT32_C(0x0)
	/* If this bit is set to 1, then it indicates tx flow. */
		#define HWRM_TF_EXT_EM_QCFG_OUTPUT_FLAGS_DIR_TX		UINT32_C(0x1)
		#define HWRM_TF_EXT_EM_QCFG_OUTPUT_FLAGS_DIR_LAST		HWRM_TF_EXT_EM_QCFG_OUTPUT_FLAGS_DIR_TX
	/* When set to 1, all offloaded flows will be sent to EXT EM. */
	#define HWRM_TF_EXT_EM_QCFG_OUTPUT_FLAGS_PREFERRED_OFFLOAD	UINT32_C(0x2)
	/* The number of entries the FW has configured for EXT EM. */
	uint32_t	num_entries;
	/* Configured EXT EM with the given context if for KEY0 table. */
	uint16_t	key0_ctx_id;
	/* Configured EXT EM with the given context if for KEY1 table. */
	uint16_t	key1_ctx_id;
	/* Configured EXT EM with the given context if for RECORD table. */
	uint16_t	record_ctx_id;
	/* Configured EXT EM with the given context if for EFC table. */
	uint16_t	efc_ctx_id;
	/* Configured EXT EM with the given context if for EFC table. */
	uint16_t	fid_ctx_id;
	/* unused. */
	uint16_t	unused0;
	uint32_t	supported;
	/* This bit must be '1' for the group_id field is set. */
	#define HWRM_TF_EXT_EM_QCFG_OUTPUT_SUPPORTED_GROUP_ID		UINT32_C(0x1)
	/* This bit must be '1' for the flush_interval field is set. */
	#define HWRM_TF_EXT_EM_QCFG_OUTPUT_SUPPORTED_FLUSH_INTERVAL	UINT32_C(0x2)
	/* This bit must be '1' for the num_entries field is set. */
	#define HWRM_TF_EXT_EM_QCFG_OUTPUT_SUPPORTED_NUM_ENTRIES		UINT32_C(0x4)
	/* This bit must be '1' for the key0_ctx_id field is set. */
	#define HWRM_TF_EXT_EM_QCFG_OUTPUT_SUPPORTED_KEY0_CTX_ID		UINT32_C(0x8)
	/* This bit must be '1' for the key1_ctx_id field is set. */
	#define HWRM_TF_EXT_EM_QCFG_OUTPUT_SUPPORTED_KEY1_CTX_ID		UINT32_C(0x10)
	/* This bit must be '1' for the record_ctx_id field is set. */
	#define HWRM_TF_EXT_EM_QCFG_OUTPUT_SUPPORTED_RECORD_CTX_ID	UINT32_C(0x20)
	/* This bit must be '1' for the efc_ctx_id field is set. */
	#define HWRM_TF_EXT_EM_QCFG_OUTPUT_SUPPORTED_EFC_CTX_ID		UINT32_C(0x40)
	/* This bit must be '1' for the fid_ctx_id field is set. */
	#define HWRM_TF_EXT_EM_QCFG_OUTPUT_SUPPORTED_FID_CTX_ID		UINT32_C(0x80)
	/* This bit must be '1' for the action_ctx_id field is set. */
	#define HWRM_TF_EXT_EM_QCFG_OUTPUT_SUPPORTED_ACTION_CTX_ID	UINT32_C(0x100)
	/* This bit must be '1' for the action_tbl_scope field is set. */
	#define HWRM_TF_EXT_EM_QCFG_OUTPUT_SUPPORTED_ACTION_TBL_SCOPE	UINT32_C(0x200)
	/* This bit must be '1' for the lkup_ctx_id field is set. */
	#define HWRM_TF_EXT_EM_QCFG_OUTPUT_SUPPORTED_LKUP_CTX_ID		UINT32_C(0x400)
	/* This bit must be '1' for the lkup_tbl_scope field is set. */
	#define HWRM_TF_EXT_EM_QCFG_OUTPUT_SUPPORTED_LKUP_TBL_SCOPE	UINT32_C(0x800)
	/* This bit must be '1' for the lkup_static_buckets field is set. */
	#define HWRM_TF_EXT_EM_QCFG_OUTPUT_SUPPORTED_LKUP_STATIC_BUCKETS	UINT32_C(0x1000)
	/*
	 * Group id is used by firmware to identify memory pools belonging
	 * to certain group.
	 */
	uint16_t	group_id;
	/* EEM pending cache flush interval in 1/10th of second. */
	uint8_t	flush_interval;
	/* unused. */
	uint8_t	unused1;
	/* Context id of action table scope. */
	uint16_t	action_ctx_id;
	/* Table scope id used for action record entries. */
	uint16_t	action_tbl_scope;
	/* Context id of lookup table scope. */
	uint16_t	lkup_ctx_id;
	/* Table scope id used for EM lookup entries. */
	uint16_t	lkup_tbl_scope;
	/*
	 * Number of 32B static buckets to be allocated at the beginning
	 * of table scope.
	 */
	uint32_t	lkup_static_buckets;
	/* unused. */
	uint8_t	unused2[7];
	/*
	 * This field is used in Output records to indicate that the
	 * output is completely written to RAM. This field should be
	 * read as '1' to indicate that the output has been
	 * completely written.  When writing a command completion or
	 * response to an internal processor, the order of writes has
	 * to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_tf_ext_em_qcfg_output_t, *phwrm_tf_ext_em_qcfg_output_t;

/*********************
 * hwrm_tf_em_insert *
 *********************/


/* hwrm_tf_em_insert_input (size:832b/104B) */

typedef struct hwrm_tf_em_insert_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Firmware Session Id. */
	uint32_t	fw_session_id;
	/* Control Flags. */
	uint16_t	flags;
	/* Indicates the flow direction. */
	#define HWRM_TF_EM_INSERT_INPUT_FLAGS_DIR	UINT32_C(0x1)
	/* If this bit set to 0, then it indicates rx flow. */
		#define HWRM_TF_EM_INSERT_INPUT_FLAGS_DIR_RX	UINT32_C(0x0)
	/* If this bit is set to 1, then it indicates tx flow. */
		#define HWRM_TF_EM_INSERT_INPUT_FLAGS_DIR_TX	UINT32_C(0x1)
		#define HWRM_TF_EM_INSERT_INPUT_FLAGS_DIR_LAST HWRM_TF_EM_INSERT_INPUT_FLAGS_DIR_TX
	/* Reported match strength. */
	uint16_t	strength;
	/* Index to action. */
	uint32_t	action_ptr;
	/* Index of EM record. */
	uint32_t	em_record_idx;
	/* EM Key value. */
	uint64_t	em_key[8];
	/* Number of bits in em_key. */
	uint16_t	em_key_bitlen;
	/* unused. */
	uint16_t	unused0[3];
} hwrm_tf_em_insert_input_t, *phwrm_tf_em_insert_input_t;

/* hwrm_tf_em_insert_output (size:128b/16B) */

typedef struct hwrm_tf_em_insert_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* EM record pointer index. */
	uint16_t	rptr_index;
	/* EM record offset 0~3. */
	uint8_t	rptr_entry;
	/* Number of word entries consumed by the key. */
	uint8_t	num_of_entries;
	/* unused. */
	uint32_t	unused0;
} hwrm_tf_em_insert_output_t, *phwrm_tf_em_insert_output_t;

/**************************
 * hwrm_tf_em_hash_insert *
 **************************/


/* hwrm_tf_em_hash_insert_input (size:1024b/128B) */

typedef struct hwrm_tf_em_hash_insert_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Firmware Session Id. */
	uint32_t	fw_session_id;
	/* Control Flags. */
	uint16_t	flags;
	/* Indicates the flow direction. */
	#define HWRM_TF_EM_HASH_INSERT_INPUT_FLAGS_DIR	UINT32_C(0x1)
	/* If this bit set to 0, then it indicates rx flow. */
		#define HWRM_TF_EM_HASH_INSERT_INPUT_FLAGS_DIR_RX	UINT32_C(0x0)
	/* If this bit is set to 1, then it indicates tx flow. */
		#define HWRM_TF_EM_HASH_INSERT_INPUT_FLAGS_DIR_TX	UINT32_C(0x1)
		#define HWRM_TF_EM_HASH_INSERT_INPUT_FLAGS_DIR_LAST HWRM_TF_EM_HASH_INSERT_INPUT_FLAGS_DIR_TX
	/* Number of bits in the EM record. */
	uint16_t	em_record_size_bits;
	/* CRC32 hash of key. */
	uint32_t	key0_hash;
	/* Lookup3 hash of key. */
	uint32_t	key1_hash;
	/* Index of EM record. */
	uint32_t	em_record_idx;
	/* Unused. */
	uint32_t	unused0;
	/* EM record. */
	uint64_t	em_record[11];
} hwrm_tf_em_hash_insert_input_t, *phwrm_tf_em_hash_insert_input_t;

/* hwrm_tf_em_hash_insert_output (size:128b/16B) */

typedef struct hwrm_tf_em_hash_insert_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* EM record pointer index. */
	uint16_t	rptr_index;
	/* EM record offset 0~3. */
	uint8_t	rptr_entry;
	/* Number of word entries consumed by the key. */
	uint8_t	num_of_entries;
	/* unused. */
	uint32_t	unused0;
} hwrm_tf_em_hash_insert_output_t, *phwrm_tf_em_hash_insert_output_t;

/*********************
 * hwrm_tf_em_delete *
 *********************/


/* hwrm_tf_em_delete_input (size:832b/104B) */

typedef struct hwrm_tf_em_delete_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Session Id. */
	uint32_t	fw_session_id;
	/* Control flags. */
	uint16_t	flags;
	/* Indicates the flow direction. */
	#define HWRM_TF_EM_DELETE_INPUT_FLAGS_DIR	UINT32_C(0x1)
	/* If this bit set to 0, then it indicates rx flow. */
		#define HWRM_TF_EM_DELETE_INPUT_FLAGS_DIR_RX	UINT32_C(0x0)
	/* If this bit is set to 1, then it indicates tx flow. */
		#define HWRM_TF_EM_DELETE_INPUT_FLAGS_DIR_TX	UINT32_C(0x1)
		#define HWRM_TF_EM_DELETE_INPUT_FLAGS_DIR_LAST HWRM_TF_EM_DELETE_INPUT_FLAGS_DIR_TX
	/* Unused0 */
	uint16_t	unused0;
	/* EM internal flow handle. */
	uint64_t	flow_handle;
	/* EM Key value */
	uint64_t	em_key[8];
	/* Number of bits in em_key. */
	uint16_t	em_key_bitlen;
	/* unused. */
	uint16_t	unused1[3];
} hwrm_tf_em_delete_input_t, *phwrm_tf_em_delete_input_t;

/* hwrm_tf_em_delete_output (size:128b/16B) */

typedef struct hwrm_tf_em_delete_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Original stack allocation index. */
	uint16_t	em_index;
	/* unused. */
	uint16_t	unused0[3];
} hwrm_tf_em_delete_output_t, *phwrm_tf_em_delete_output_t;

/*******************
 * hwrm_tf_em_move *
 *******************/


/* hwrm_tf_em_move_input (size:320b/40B) */

typedef struct hwrm_tf_em_move_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Session Id. */
	uint32_t	fw_session_id;
	/* Control flags. */
	uint16_t	flags;
	/* Indicates the flow direction. */
	#define HWRM_TF_EM_MOVE_INPUT_FLAGS_DIR	UINT32_C(0x1)
	/* If this bit set to 0, then it indicates rx flow. */
		#define HWRM_TF_EM_MOVE_INPUT_FLAGS_DIR_RX	UINT32_C(0x0)
	/* If this bit is set to 1, then it indicates tx flow. */
		#define HWRM_TF_EM_MOVE_INPUT_FLAGS_DIR_TX	UINT32_C(0x1)
		#define HWRM_TF_EM_MOVE_INPUT_FLAGS_DIR_LAST HWRM_TF_EM_MOVE_INPUT_FLAGS_DIR_TX
	/* Number of EM entry blocks */
	uint16_t	num_blocks;
	/* New index for entry */
	uint32_t	new_index;
	/* Unused */
	uint32_t	unused0;
	/* EM internal flow handle. */
	uint64_t	flow_handle;
} hwrm_tf_em_move_input_t, *phwrm_tf_em_move_input_t;

/* hwrm_tf_em_move_output (size:128b/16B) */

typedef struct hwrm_tf_em_move_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Index of old entry. */
	uint16_t	em_index;
	/* unused. */
	uint16_t	unused0[3];
} hwrm_tf_em_move_output_t, *phwrm_tf_em_move_output_t;

/********************
 * hwrm_tf_tcam_set *
 ********************/


/* hwrm_tf_tcam_set_input (size:1024b/128B) */

typedef struct hwrm_tf_tcam_set_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Firmware session id returned when HWRM_TF_SESSION_OPEN is sent. */
	uint32_t	fw_session_id;
	/* Control flags. */
	uint32_t	flags;
	/* Indicates the flow direction. */
	#define HWRM_TF_TCAM_SET_INPUT_FLAGS_DIR	UINT32_C(0x1)
	/* If this bit set to 0, then it indicates rx flow. */
		#define HWRM_TF_TCAM_SET_INPUT_FLAGS_DIR_RX	UINT32_C(0x0)
	/* If this bit is set to 1, then it indicates tx flow. */
		#define HWRM_TF_TCAM_SET_INPUT_FLAGS_DIR_TX	UINT32_C(0x1)
		#define HWRM_TF_TCAM_SET_INPUT_FLAGS_DIR_LAST HWRM_TF_TCAM_SET_INPUT_FLAGS_DIR_TX
	/*
	 * Indicate device data is being sent via DMA, the device
	 * data is packing does not change.
	 */
	#define HWRM_TF_TCAM_SET_INPUT_FLAGS_DMA	UINT32_C(0x2)
	/*
	 * TCAM type of the resource, defined globally in the
	 * hwrm_tf_resc_type enum.
	 */
	uint32_t	type;
	/* Index of TCAM entry. */
	uint16_t	idx;
	/* Number of bytes in the TCAM key. */
	uint8_t	key_size;
	/* Number of bytes in the TCAM result. */
	uint8_t	result_size;
	/*
	 * Offset from which the mask bytes start in the device data
	 * array, key offset is always 0.
	 */
	uint8_t	mask_offset;
	/* Offset from which the result bytes start in the device data array. */
	uint8_t	result_offset;
	/* unused. */
	uint8_t	unused0[6];
	/*
	 * TCAM key located at offset 0, mask located at mask_offsec
	 * and result at result_offsec for the device.
	 */
	uint8_t	dev_data[88];
} hwrm_tf_tcam_set_input_t, *phwrm_tf_tcam_set_input_t;

/* hwrm_tf_tcam_set_output (size:128b/16B) */

typedef struct hwrm_tf_tcam_set_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* unused. */
	uint8_t	unused0[7];
	/*
	 * This field is used in Output records to indicate that the
	 * output is completely written to RAM. This field should be
	 * read as '1' to indicate that the output has been
	 * completely written.  When writing a command completion or
	 * response to an internal processor, the order of writes has
	 * to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_tf_tcam_set_output_t, *phwrm_tf_tcam_set_output_t;

/********************
 * hwrm_tf_tcam_get *
 ********************/


/* hwrm_tf_tcam_get_input (size:256b/32B) */

typedef struct hwrm_tf_tcam_get_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Firmware session id returned when HWRM_TF_SESSION_OPEN is sent. */
	uint32_t	fw_session_id;
	/* Control flags. */
	uint32_t	flags;
	/* Indicates the flow direction. */
	#define HWRM_TF_TCAM_GET_INPUT_FLAGS_DIR	UINT32_C(0x1)
	/* If this bit set to 0, then it indicates rx flow. */
		#define HWRM_TF_TCAM_GET_INPUT_FLAGS_DIR_RX	UINT32_C(0x0)
	/* If this bit is set to 1, then it indicates tx flow. */
		#define HWRM_TF_TCAM_GET_INPUT_FLAGS_DIR_TX	UINT32_C(0x1)
		#define HWRM_TF_TCAM_GET_INPUT_FLAGS_DIR_LAST HWRM_TF_TCAM_GET_INPUT_FLAGS_DIR_TX
	/*
	 * TCAM type of the resource, defined globally in the
	 * hwrm_tf_resc_type enum.
	 */
	uint32_t	type;
	/* Index of a TCAM entry. */
	uint16_t	idx;
	/* unused. */
	uint16_t	unused0;
} hwrm_tf_tcam_get_input_t, *phwrm_tf_tcam_get_input_t;

/* hwrm_tf_tcam_get_output (size:2368b/296B) */

typedef struct hwrm_tf_tcam_get_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Number of bytes in the TCAM key. */
	uint8_t	key_size;
	/* Number of bytes in the TCAM entry. */
	uint8_t	result_size;
	/* Offset from which the mask bytes start in the device data array. */
	uint8_t	mask_offset;
	/* Offset from which the result bytes start in the device data array. */
	uint8_t	result_offset;
	/* unused. */
	uint8_t	unused0[4];
	/*
	 * TCAM key located at offset 0, mask located at mask_offsec
	 * and result at result_offsec for the device.
	 */
	uint8_t	dev_data[272];
	/* unused. */
	uint8_t	unused1[7];
	/*
	 * This field is used in Output records to indicate that the
	 * output is completely written to RAM. This field should be
	 * read as '1' to indicate that the output has been
	 * completely written.  When writing a command completion or
	 * response to an internal processor, the order of writes has
	 * to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_tf_tcam_get_output_t, *phwrm_tf_tcam_get_output_t;

/*********************
 * hwrm_tf_tcam_move *
 *********************/


/* hwrm_tf_tcam_move_input (size:1024b/128B) */

typedef struct hwrm_tf_tcam_move_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Firmware session id returned when HWRM_TF_SESSION_OPEN is sent. */
	uint32_t	fw_session_id;
	/* Control flags. */
	uint32_t	flags;
	/* Indicates the flow direction. */
	#define HWRM_TF_TCAM_MOVE_INPUT_FLAGS_DIR	UINT32_C(0x1)
	/* If this bit set to 0, then it indicates rx flow. */
		#define HWRM_TF_TCAM_MOVE_INPUT_FLAGS_DIR_RX	UINT32_C(0x0)
	/* If this bit is set to 1, then it indicates tx flow. */
		#define HWRM_TF_TCAM_MOVE_INPUT_FLAGS_DIR_TX	UINT32_C(0x1)
		#define HWRM_TF_TCAM_MOVE_INPUT_FLAGS_DIR_LAST HWRM_TF_TCAM_MOVE_INPUT_FLAGS_DIR_TX
	/*
	 * TCAM type of the resource, defined globally in the
	 * hwrm_tf_resc_type enum.
	 */
	uint32_t	type;
	/* Number of TCAM index pairs to be swapped for the device. */
	uint16_t	count;
	/* unused. */
	uint16_t	unused0;
	/* TCAM index pairs to be swapped for the device. */
	uint16_t	idx_pairs[48];
} hwrm_tf_tcam_move_input_t, *phwrm_tf_tcam_move_input_t;

/* hwrm_tf_tcam_move_output (size:128b/16B) */

typedef struct hwrm_tf_tcam_move_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* unused. */
	uint8_t	unused0[7];
	/*
	 * This field is used in Output records to indicate that the
	 * output is completely written to RAM. This field should be
	 * read as '1' to indicate that the output has been
	 * completely written.  When writing a command completion or
	 * response to an internal processor, the order of writes has
	 * to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_tf_tcam_move_output_t, *phwrm_tf_tcam_move_output_t;

/*********************
 * hwrm_tf_tcam_free *
 *********************/


/* hwrm_tf_tcam_free_input (size:1024b/128B) */

typedef struct hwrm_tf_tcam_free_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Firmware session id returned when HWRM_TF_SESSION_OPEN is sent. */
	uint32_t	fw_session_id;
	/* Control flags. */
	uint32_t	flags;
	/* Indicates the flow direction. */
	#define HWRM_TF_TCAM_FREE_INPUT_FLAGS_DIR	UINT32_C(0x1)
	/* If this bit set to 0, then it indicates rx flow. */
		#define HWRM_TF_TCAM_FREE_INPUT_FLAGS_DIR_RX	UINT32_C(0x0)
	/* If this bit is set to 1, then it indicates tx flow. */
		#define HWRM_TF_TCAM_FREE_INPUT_FLAGS_DIR_TX	UINT32_C(0x1)
		#define HWRM_TF_TCAM_FREE_INPUT_FLAGS_DIR_LAST HWRM_TF_TCAM_FREE_INPUT_FLAGS_DIR_TX
	/*
	 * TCAM type of the resource, defined globally in the
	 * hwrm_tf_resc_type enum.
	 */
	uint32_t	type;
	/* Number of TCAM index to be deleted for the device. */
	uint16_t	count;
	/* unused. */
	uint16_t	unused0;
	/* TCAM index list to be deleted for the device. */
	uint16_t	idx_list[48];
} hwrm_tf_tcam_free_input_t, *phwrm_tf_tcam_free_input_t;

/* hwrm_tf_tcam_free_output (size:128b/16B) */

typedef struct hwrm_tf_tcam_free_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* unused. */
	uint8_t	unused0[7];
	/*
	 * This field is used in Output records to indicate that the
	 * output is completely written to RAM. This field should be
	 * read as '1' to indicate that the output has been
	 * completely written.  When writing a command completion or
	 * response to an internal processor, the order of writes has
	 * to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_tf_tcam_free_output_t, *phwrm_tf_tcam_free_output_t;

/**************************
 * hwrm_tf_global_cfg_set *
 **************************/


/* hwrm_tf_global_cfg_set_input (size:448b/56B) */

typedef struct hwrm_tf_global_cfg_set_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Firmware session id returned when HWRM_TF_SESSION_OPEN is sent. */
	uint32_t	fw_session_id;
	/* Control flags. */
	uint32_t	flags;
	/* Indicates the flow direction. */
	#define HWRM_TF_GLOBAL_CFG_SET_INPUT_FLAGS_DIR	UINT32_C(0x1)
	/* If this bit set to 0, then it indicates rx flow. */
		#define HWRM_TF_GLOBAL_CFG_SET_INPUT_FLAGS_DIR_RX	UINT32_C(0x0)
	/* If this bit is set to 1, then it indicates tx flow. */
		#define HWRM_TF_GLOBAL_CFG_SET_INPUT_FLAGS_DIR_TX	UINT32_C(0x1)
		#define HWRM_TF_GLOBAL_CFG_SET_INPUT_FLAGS_DIR_LAST HWRM_TF_GLOBAL_CFG_SET_INPUT_FLAGS_DIR_TX
	/* Global Cfg type */
	uint32_t	type;
	/* Offset of the type */
	uint32_t	offset;
	/* Size of the data to set in bytes */
	uint16_t	size;
	/* unused. */
	uint8_t	unused0[6];
	/* Data to set */
	uint8_t	data[8];
	/* Mask of data to set, 0 indicates no mask */
	uint8_t	mask[8];
} hwrm_tf_global_cfg_set_input_t, *phwrm_tf_global_cfg_set_input_t;

/* hwrm_tf_global_cfg_set_output (size:128b/16B) */

typedef struct hwrm_tf_global_cfg_set_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* unused. */
	uint8_t	unused0[7];
	/*
	 * This field is used in Output records to indicate that the
	 * output is completely written to RAM. This field should be
	 * read as '1' to indicate that the output has been
	 * completely written.  When writing a command completion or
	 * response to an internal processor, the order of writes has
	 * to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_tf_global_cfg_set_output_t, *phwrm_tf_global_cfg_set_output_t;

/**************************
 * hwrm_tf_global_cfg_get *
 **************************/


/* hwrm_tf_global_cfg_get_input (size:320b/40B) */

typedef struct hwrm_tf_global_cfg_get_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Firmware session id returned when HWRM_TF_SESSION_OPEN is sent. */
	uint32_t	fw_session_id;
	/* Control flags. */
	uint32_t	flags;
	/* Indicates the flow direction. */
	#define HWRM_TF_GLOBAL_CFG_GET_INPUT_FLAGS_DIR	UINT32_C(0x1)
	/* If this bit set to 0, then it indicates rx flow. */
		#define HWRM_TF_GLOBAL_CFG_GET_INPUT_FLAGS_DIR_RX	UINT32_C(0x0)
	/* If this bit is set to 1, then it indicates tx flow. */
		#define HWRM_TF_GLOBAL_CFG_GET_INPUT_FLAGS_DIR_TX	UINT32_C(0x1)
		#define HWRM_TF_GLOBAL_CFG_GET_INPUT_FLAGS_DIR_LAST HWRM_TF_GLOBAL_CFG_GET_INPUT_FLAGS_DIR_TX
	/* Global Cfg type */
	uint32_t	type;
	/* Offset of the type */
	uint32_t	offset;
	/* Size of the data to set in bytes */
	uint16_t	size;
	/* unused. */
	uint8_t	unused0[6];
} hwrm_tf_global_cfg_get_input_t, *phwrm_tf_global_cfg_get_input_t;

/* hwrm_tf_global_cfg_get_output (size:256b/32B) */

typedef struct hwrm_tf_global_cfg_get_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Size of the data read in bytes */
	uint16_t	size;
	/* unused. */
	uint8_t	unused0[6];
	/* Data to set */
	uint8_t	data[16];
} hwrm_tf_global_cfg_get_output_t, *phwrm_tf_global_cfg_get_output_t;

/**********************
 * hwrm_tf_if_tbl_get *
 **********************/


/* hwrm_tf_if_tbl_get_input (size:256b/32B) */

typedef struct hwrm_tf_if_tbl_get_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Firmware session id returned when HWRM_TF_SESSION_OPEN is sent. */
	uint32_t	fw_session_id;
	/* Control flags. */
	uint16_t	flags;
	/* Indicates the flow direction. */
	#define HWRM_TF_IF_TBL_GET_INPUT_FLAGS_DIR	UINT32_C(0x1)
	/* If this bit set to 0, then it indicates rx flow. */
		#define HWRM_TF_IF_TBL_GET_INPUT_FLAGS_DIR_RX	UINT32_C(0x0)
	/* If this bit is set to 1, then it indicates tx flow. */
		#define HWRM_TF_IF_TBL_GET_INPUT_FLAGS_DIR_TX	UINT32_C(0x1)
		#define HWRM_TF_IF_TBL_GET_INPUT_FLAGS_DIR_LAST HWRM_TF_IF_TBL_GET_INPUT_FLAGS_DIR_TX
	/* Size of the data to set. */
	uint16_t	size;
	/*
	 * Type of the resource, defined globally in the
	 * hwrm_tf_resc_type enum.
	 */
	uint32_t	type;
	/* Index of the type to retrieve. */
	uint32_t	index;
} hwrm_tf_if_tbl_get_input_t, *phwrm_tf_if_tbl_get_input_t;

/* hwrm_tf_if_tbl_get_output (size:256b/32B) */

typedef struct hwrm_tf_if_tbl_get_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Response code. */
	uint32_t	resp_code;
	/* Response size. */
	uint16_t	size;
	/* unused */
	uint16_t	unused0;
	/* Response data. */
	uint8_t	data[8];
	/* unused */
	uint8_t	unused1[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field
	 * is written last.
	 */
	uint8_t	valid;
} hwrm_tf_if_tbl_get_output_t, *phwrm_tf_if_tbl_get_output_t;

/***************************
 * hwrm_tf_if_tbl_type_set *
 ***************************/


/* hwrm_tf_if_tbl_set_input (size:384b/48B) */

typedef struct hwrm_tf_if_tbl_set_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Firmware session id returned when HWRM_TF_SESSION_OPEN is sent. */
	uint32_t	fw_session_id;
	/* Control flags. */
	uint16_t	flags;
	/* Indicates the flow direction. */
	#define HWRM_TF_IF_TBL_SET_INPUT_FLAGS_DIR	UINT32_C(0x1)
	/* If this bit set to 0, then it indicates rx flow. */
		#define HWRM_TF_IF_TBL_SET_INPUT_FLAGS_DIR_RX	UINT32_C(0x0)
	/* If this bit is set to 1, then it indicates tx flow. */
		#define HWRM_TF_IF_TBL_SET_INPUT_FLAGS_DIR_TX	UINT32_C(0x1)
		#define HWRM_TF_IF_TBL_SET_INPUT_FLAGS_DIR_LAST HWRM_TF_IF_TBL_SET_INPUT_FLAGS_DIR_TX
	/* unused. */
	uint8_t	unused0[2];
	/*
	 * Type of the resource, defined globally in the
	 * hwrm_tf_resc_type enum.
	 */
	uint32_t	type;
	/* Index of the type to set. */
	uint32_t	index;
	/* Size of the data to set. */
	uint16_t	size;
	/* unused */
	uint8_t	unused1[6];
	/* Data to be set. */
	uint8_t	data[8];
} hwrm_tf_if_tbl_set_input_t, *phwrm_tf_if_tbl_set_input_t;

/* hwrm_tf_if_tbl_set_output (size:128b/16B) */

typedef struct hwrm_tf_if_tbl_set_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* unused. */
	uint8_t	unused0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field
	 * is written last.
	 */
	uint8_t	valid;
} hwrm_tf_if_tbl_set_output_t, *phwrm_tf_if_tbl_set_output_t;

/*****************************
 * hwrm_tf_tbl_type_bulk_get *
 *****************************/


/* hwrm_tf_tbl_type_bulk_get_input (size:384b/48B) */

typedef struct hwrm_tf_tbl_type_bulk_get_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Firmware session id returned when HWRM_TF_SESSION_OPEN is sent. */
	uint32_t	fw_session_id;
	/* Control flags. */
	uint16_t	flags;
	/* Indicates the flow direction. */
	#define HWRM_TF_TBL_TYPE_BULK_GET_INPUT_FLAGS_DIR	UINT32_C(0x1)
	/* If this bit set to 0, then it indicates rx flow. */
		#define HWRM_TF_TBL_TYPE_BULK_GET_INPUT_FLAGS_DIR_RX	UINT32_C(0x0)
	/* If this bit is set to 1, then it indicates tx flow. */
		#define HWRM_TF_TBL_TYPE_BULK_GET_INPUT_FLAGS_DIR_TX	UINT32_C(0x1)
		#define HWRM_TF_TBL_TYPE_BULK_GET_INPUT_FLAGS_DIR_LAST HWRM_TF_TBL_TYPE_BULK_GET_INPUT_FLAGS_DIR_TX
	/* unused. */
	uint8_t	unused0[2];
	/*
	 * Type of the resource, defined globally in the
	 * hwrm_tf_resc_type enum.
	 */
	uint32_t	type;
	/* Starting index of the type to retrieve. */
	uint32_t	start_index;
	/* Number of entries to retrieve. */
	uint32_t	num_entries;
	/* Number of entries to retrieve. */
	uint32_t	unused1;
	/* Host memory where data will be stored. */
	uint64_t	host_addr;
} hwrm_tf_tbl_type_bulk_get_input_t, *phwrm_tf_tbl_type_bulk_get_input_t;

/* hwrm_tf_tbl_type_bulk_get_output (size:128b/16B) */

typedef struct hwrm_tf_tbl_type_bulk_get_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Response code. */
	uint32_t	resp_code;
	/* Response size. */
	uint16_t	size;
	/* unused */
	uint8_t	unused0;
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field
	 * is written last.
	 */
	uint8_t	valid;
} hwrm_tf_tbl_type_bulk_get_output_t, *phwrm_tf_tbl_type_bulk_get_output_t;

/******************************
 * hwrm_tunnel_dst_port_query *
 ******************************/


/* hwrm_tunnel_dst_port_query_input (size:192b/24B) */

typedef struct hwrm_tunnel_dst_port_query_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Tunnel Type. */
	uint8_t	tunnel_type;
	/* Virtual eXtensible Local Area Network (VXLAN) */
	#define HWRM_TUNNEL_DST_PORT_QUERY_INPUT_TUNNEL_TYPE_VXLAN	UINT32_C(0x1)
	/* Generic Network Virtualization Encapsulation (Geneve) */
	#define HWRM_TUNNEL_DST_PORT_QUERY_INPUT_TUNNEL_TYPE_GENEVE	UINT32_C(0x5)
	/* IPV4 over virtual eXtensible Local Area Network (IPV4oVXLAN) */
	#define HWRM_TUNNEL_DST_PORT_QUERY_INPUT_TUNNEL_TYPE_VXLAN_V4	UINT32_C(0x9)
	/* Enhance Generic Routing Encapsulation (GRE version 1) inside IP datagram payload */
	#define HWRM_TUNNEL_DST_PORT_QUERY_INPUT_TUNNEL_TYPE_IPGRE_V1	UINT32_C(0xa)
	/* Use fixed layer 2 ether type of 0xFFFF */
	#define HWRM_TUNNEL_DST_PORT_QUERY_INPUT_TUNNEL_TYPE_L2_ETYPE	UINT32_C(0xb)
	/* IPV6 over virtual eXtensible Local Area Network with GPE header (IPV6oVXLANGPE) */
	#define HWRM_TUNNEL_DST_PORT_QUERY_INPUT_TUNNEL_TYPE_VXLAN_GPE_V6 UINT32_C(0xc)
	#define HWRM_TUNNEL_DST_PORT_QUERY_INPUT_TUNNEL_TYPE_LAST	HWRM_TUNNEL_DST_PORT_QUERY_INPUT_TUNNEL_TYPE_VXLAN_GPE_V6
	uint8_t	unused_0[7];
} hwrm_tunnel_dst_port_query_input_t, *phwrm_tunnel_dst_port_query_input_t;

/* hwrm_tunnel_dst_port_query_output (size:128b/16B) */

typedef struct hwrm_tunnel_dst_port_query_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * This field represents the identifier of L4 destination port
	 * used for the given tunnel type. This field is valid for
	 * specific tunnel types that use layer 4 (e.g. UDP)
	 * transports for tunneling.
	 */
	uint16_t	tunnel_dst_port_id;
	/*
	 * This field represents the value of L4 destination port
	 * identified by tunnel_dst_port_id. This field is valid for
	 * specific tunnel types that use layer 4 (e.g. UDP)
	 * transports for tunneling.
	 * This field is in network byte order.
	 *
	 * A value of 0 means that the destination port is not
	 * configured.
	 */
	uint16_t	tunnel_dst_port_val;
	uint8_t	unused_0[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_tunnel_dst_port_query_output_t, *phwrm_tunnel_dst_port_query_output_t;

/******************************
 * hwrm_tunnel_dst_port_alloc *
 ******************************/


/* hwrm_tunnel_dst_port_alloc_input (size:192b/24B) */

typedef struct hwrm_tunnel_dst_port_alloc_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Tunnel Type. */
	uint8_t	tunnel_type;
	/* Virtual eXtensible Local Area Network (VXLAN) */
	#define HWRM_TUNNEL_DST_PORT_ALLOC_INPUT_TUNNEL_TYPE_VXLAN	UINT32_C(0x1)
	/* Generic Network Virtualization Encapsulation (Geneve) */
	#define HWRM_TUNNEL_DST_PORT_ALLOC_INPUT_TUNNEL_TYPE_GENEVE	UINT32_C(0x5)
	/* IPV4 over virtual eXtensible Local Area Network (IPV4oVXLAN) */
	#define HWRM_TUNNEL_DST_PORT_ALLOC_INPUT_TUNNEL_TYPE_VXLAN_V4	UINT32_C(0x9)
	/* Enhance Generic Routing Encapsulation (GRE version 1) inside IP datagram payload */
	#define HWRM_TUNNEL_DST_PORT_ALLOC_INPUT_TUNNEL_TYPE_IPGRE_V1	UINT32_C(0xa)
	/* Use fixed layer 2 ether type of 0xFFFF */
	#define HWRM_TUNNEL_DST_PORT_ALLOC_INPUT_TUNNEL_TYPE_L2_ETYPE	UINT32_C(0xb)
	/* IPV6 over virtual eXtensible Local Area Network with GPE header (IPV6oVXLANGPE) */
	#define HWRM_TUNNEL_DST_PORT_ALLOC_INPUT_TUNNEL_TYPE_VXLAN_GPE_V6 UINT32_C(0xc)
	#define HWRM_TUNNEL_DST_PORT_ALLOC_INPUT_TUNNEL_TYPE_LAST	HWRM_TUNNEL_DST_PORT_ALLOC_INPUT_TUNNEL_TYPE_VXLAN_GPE_V6
	uint8_t	unused_0;
	/*
	 * This field represents the value of L4 destination port used
	 * for the given tunnel type. This field is valid for
	 * specific tunnel types that use layer 4 (e.g. UDP)
	 * transports for tunneling.
	 *
	 * This field is in network byte order.
	 *
	 * A value of 0 shall fail the command.
	 */
	uint16_t	tunnel_dst_port_val;
	uint8_t	unused_1[4];
} hwrm_tunnel_dst_port_alloc_input_t, *phwrm_tunnel_dst_port_alloc_input_t;

/* hwrm_tunnel_dst_port_alloc_output (size:128b/16B) */

typedef struct hwrm_tunnel_dst_port_alloc_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * Identifier of a tunnel L4 destination port value. Only applies to tunnel
	 * types that has l4 destination port parameters.
	 */
	uint16_t	tunnel_dst_port_id;
	uint8_t	unused_0[5];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_tunnel_dst_port_alloc_output_t, *phwrm_tunnel_dst_port_alloc_output_t;

/*****************************
 * hwrm_tunnel_dst_port_free *
 *****************************/


/* hwrm_tunnel_dst_port_free_input (size:192b/24B) */

typedef struct hwrm_tunnel_dst_port_free_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Tunnel Type. */
	uint8_t	tunnel_type;
	/* Virtual eXtensible Local Area Network (VXLAN) */
	#define HWRM_TUNNEL_DST_PORT_FREE_INPUT_TUNNEL_TYPE_VXLAN	UINT32_C(0x1)
	/* Generic Network Virtualization Encapsulation (Geneve) */
	#define HWRM_TUNNEL_DST_PORT_FREE_INPUT_TUNNEL_TYPE_GENEVE	UINT32_C(0x5)
	/* IPV4 over virtual eXtensible Local Area Network (IPV4oVXLAN) */
	#define HWRM_TUNNEL_DST_PORT_FREE_INPUT_TUNNEL_TYPE_VXLAN_V4	UINT32_C(0x9)
	/* Enhance Generic Routing Encapsulation (GRE version 1) inside IP datagram payload */
	#define HWRM_TUNNEL_DST_PORT_FREE_INPUT_TUNNEL_TYPE_IPGRE_V1	UINT32_C(0xa)
	/* Use fixed layer 2 ether type of 0xFFFF */
	#define HWRM_TUNNEL_DST_PORT_FREE_INPUT_TUNNEL_TYPE_L2_ETYPE	UINT32_C(0xb)
	/* IPV6 over virtual eXtensible Local Area Network with GPE header (IPV6oVXLANGPE) */
	#define HWRM_TUNNEL_DST_PORT_FREE_INPUT_TUNNEL_TYPE_VXLAN_GPE_V6 UINT32_C(0xc)
	#define HWRM_TUNNEL_DST_PORT_FREE_INPUT_TUNNEL_TYPE_LAST	HWRM_TUNNEL_DST_PORT_FREE_INPUT_TUNNEL_TYPE_VXLAN_GPE_V6
	uint8_t	unused_0;
	/*
	 * Identifier of a tunnel L4 destination port value. Only applies to tunnel
	 * types that has l4 destination port parameters.
	 */
	uint16_t	tunnel_dst_port_id;
	uint8_t	unused_1[4];
} hwrm_tunnel_dst_port_free_input_t, *phwrm_tunnel_dst_port_free_input_t;

/* hwrm_tunnel_dst_port_free_output (size:128b/16B) */

typedef struct hwrm_tunnel_dst_port_free_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_1[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_tunnel_dst_port_free_output_t, *phwrm_tunnel_dst_port_free_output_t;

/* Periodic statistics context DMA to host. */
/* ctx_hw_stats (size:1280b/160B) */

typedef struct ctx_hw_stats {
	/* Number of received unicast packets */
	uint64_t	rx_ucast_pkts;
	/* Number of received multicast packets */
	uint64_t	rx_mcast_pkts;
	/* Number of received broadcast packets */
	uint64_t	rx_bcast_pkts;
	/* Number of discarded packets on receive path */
	uint64_t	rx_discard_pkts;
	/* Number of packets on receive path with error */
	uint64_t	rx_error_pkts;
	/* Number of received bytes for unicast traffic */
	uint64_t	rx_ucast_bytes;
	/* Number of received bytes for multicast traffic */
	uint64_t	rx_mcast_bytes;
	/* Number of received bytes for broadcast traffic */
	uint64_t	rx_bcast_bytes;
	/* Number of transmitted unicast packets */
	uint64_t	tx_ucast_pkts;
	/* Number of transmitted multicast packets */
	uint64_t	tx_mcast_pkts;
	/* Number of transmitted broadcast packets */
	uint64_t	tx_bcast_pkts;
	/* Number of packets on transmit path with error */
	uint64_t	tx_error_pkts;
	/* Number of discarded packets on transmit path */
	uint64_t	tx_discard_pkts;
	/* Number of transmitted bytes for unicast traffic */
	uint64_t	tx_ucast_bytes;
	/* Number of transmitted bytes for multicast traffic */
	uint64_t	tx_mcast_bytes;
	/* Number of transmitted bytes for broadcast traffic */
	uint64_t	tx_bcast_bytes;
	/* Number of TPA packets */
	uint64_t	tpa_pkts;
	/* Number of TPA bytes */
	uint64_t	tpa_bytes;
	/* Number of TPA events */
	uint64_t	tpa_events;
	/* Number of TPA aborts */
	uint64_t	tpa_aborts;
} ctx_hw_stats_t, *pctx_hw_stats_t;

/*
 * Extended periodic statistics context DMA to host. On cards that
 * support TPA v2, additional TPA related stats exist and can be retrieved
 * by DMA of ctx_hw_stats_ext, rather than legacy ctx_hw_stats structure.
 */
/* ctx_hw_stats_ext (size:1408b/176B) */

typedef struct ctx_hw_stats_ext {
	/* Number of received unicast packets */
	uint64_t	rx_ucast_pkts;
	/* Number of received multicast packets */
	uint64_t	rx_mcast_pkts;
	/* Number of received broadcast packets */
	uint64_t	rx_bcast_pkts;
	/* Number of discarded packets on receive path */
	uint64_t	rx_discard_pkts;
	/* Number of packets on receive path with error */
	uint64_t	rx_error_pkts;
	/* Number of received bytes for unicast traffic */
	uint64_t	rx_ucast_bytes;
	/* Number of received bytes for multicast traffic */
	uint64_t	rx_mcast_bytes;
	/* Number of received bytes for broadcast traffic */
	uint64_t	rx_bcast_bytes;
	/* Number of transmitted unicast packets */
	uint64_t	tx_ucast_pkts;
	/* Number of transmitted multicast packets */
	uint64_t	tx_mcast_pkts;
	/* Number of transmitted broadcast packets */
	uint64_t	tx_bcast_pkts;
	/* Number of packets on transmit path with error */
	uint64_t	tx_error_pkts;
	/* Number of discarded packets on transmit path */
	uint64_t	tx_discard_pkts;
	/* Number of transmitted bytes for unicast traffic */
	uint64_t	tx_ucast_bytes;
	/* Number of transmitted bytes for multicast traffic */
	uint64_t	tx_mcast_bytes;
	/* Number of transmitted bytes for broadcast traffic */
	uint64_t	tx_bcast_bytes;
	/* Number of TPA eligible packets */
	uint64_t	rx_tpa_eligible_pkt;
	/* Number of TPA eligible bytes */
	uint64_t	rx_tpa_eligible_bytes;
	/* Number of TPA packets */
	uint64_t	rx_tpa_pkt;
	/* Number of TPA bytes */
	uint64_t	rx_tpa_bytes;
	/* Number of TPA errors */
	uint64_t	rx_tpa_errors;
	/* Number of TPA events */
	uint64_t	rx_tpa_events;
} ctx_hw_stats_ext_t, *pctx_hw_stats_ext_t;

/* Periodic Engine statistics context DMA to host. */
/* ctx_eng_stats (size:512b/64B) */

typedef struct ctx_eng_stats {
	/*
	 * Count of data bytes into the Engine.
	 * This includes any user supplied prefix,
	 * but does not include any predefined
	 * prefix data.
	 */
	uint64_t	eng_bytes_in;
	/* Count of data bytes out of the Engine. */
	uint64_t	eng_bytes_out;
	/*
	 * Count, in 4-byte (dword) units, of bytes
	 * that are input as auxiliary data.
	 * This includes the aux_cmd data.
	 */
	uint64_t	aux_bytes_in;
	/*
	 * Count, in 4-byte (dword) units, of bytes
	 * that are output as auxiliary data.
	 * This count is the buffer space for aux_data
	 * output provided in the RQE, not the actual
	 * aux_data written
	 */
	uint64_t	aux_bytes_out;
	/* Count of number of commands executed. */
	uint64_t	commands;
	/*
	 * Count of number of error commands.
	 * These are the commands with a
	 * non-zero status value.
	 */
	uint64_t	error_commands;
	/*
	 * Compression/Encryption Engine usage,
	 * the unit is count of clock cycles
	 */
	uint64_t	cce_engine_usage;
	/*
	 * De-Compression/De-cryption Engine usage,
	 * the unit is count of clock cycles
	 */
	uint64_t	cdd_engine_usage;
} ctx_eng_stats_t, *pctx_eng_stats_t;

/***********************
 * hwrm_stat_ctx_alloc *
 ***********************/


/* hwrm_stat_ctx_alloc_input (size:256b/32B) */

typedef struct hwrm_stat_ctx_alloc_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * This is the address for statistic block.
	 * > For new versions of the chip, this address should be 128B
	 * > aligned.
	 */
	uint64_t	stats_dma_addr;
	/*
	 * The statistic block update period in ms.
	 * e.g. 250ms, 500ms, 750ms, 1000ms.
	 * If update_period_ms is 0, then the stats update
	 * shall be never done and the DMA address shall not be used.
	 * In this case, the stat block can only be read by
	 * hwrm_stat_ctx_query command.
	 * On Ethernet/L2 based devices:
	 *   if tpa v2 supported (hwrm_vnic_qcaps[max_aggs_supported]>0),
	 *	ctx_hw_stats_ext is used for DMA,
	 *   else
	 *	ctx_hw_stats is used for DMA.
	 */
	uint32_t	update_period_ms;
	/*
	 * This field is used to specify statistics context specific
	 * configuration flags.
	 */
	uint8_t	stat_ctx_flags;
	/*
	 * When this bit is set to '1', the statistics context shall be
	 * allocated for RoCE traffic only. In this case, traffic other
	 * than offloaded RoCE traffic shall not be included in this
	 * statistic context.
	 * When this bit is set to '0', the statistics context shall be
	 * used for network traffic or engine traffic.
	 */
	#define HWRM_STAT_CTX_ALLOC_INPUT_STAT_CTX_FLAGS_ROCE	UINT32_C(0x1)
	uint8_t	unused_0;
	/*
	 * This is the size of the structure (ctx_hw_stats or
	 * ctx_hw_stats_ext) that the driver has allocated to be used
	 * for the periodic DMA updates.
	 */
	uint16_t	stats_dma_length;
} hwrm_stat_ctx_alloc_input_t, *phwrm_stat_ctx_alloc_input_t;

/* hwrm_stat_ctx_alloc_output (size:128b/16B) */

typedef struct hwrm_stat_ctx_alloc_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* This is the statistics context ID value. */
	uint32_t	stat_ctx_id;
	uint8_t	unused_0[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_stat_ctx_alloc_output_t, *phwrm_stat_ctx_alloc_output_t;

/**********************
 * hwrm_stat_ctx_free *
 **********************/


/* hwrm_stat_ctx_free_input (size:192b/24B) */

typedef struct hwrm_stat_ctx_free_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* ID of the statistics context that is being queried. */
	uint32_t	stat_ctx_id;
	uint8_t	unused_0[4];
} hwrm_stat_ctx_free_input_t, *phwrm_stat_ctx_free_input_t;

/* hwrm_stat_ctx_free_output (size:128b/16B) */

typedef struct hwrm_stat_ctx_free_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* This is the statistics context ID value. */
	uint32_t	stat_ctx_id;
	uint8_t	unused_0[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_stat_ctx_free_output_t, *phwrm_stat_ctx_free_output_t;

/***********************
 * hwrm_stat_ctx_query *
 ***********************/


/* hwrm_stat_ctx_query_input (size:192b/24B) */

typedef struct hwrm_stat_ctx_query_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* ID of the statistics context that is being queried. */
	uint32_t	stat_ctx_id;
	uint8_t	flags;
	/*
	 * This bit is set to 1 when request is for a counter mask,
	 * representing the width of each of the stats counters, rather
	 * than counters themselves.
	 */
	#define HWRM_STAT_CTX_QUERY_INPUT_FLAGS_COUNTER_MASK	UINT32_C(0x1)
	uint8_t	unused_0[3];
} hwrm_stat_ctx_query_input_t, *phwrm_stat_ctx_query_input_t;

/* hwrm_stat_ctx_query_output (size:1408b/176B) */

typedef struct hwrm_stat_ctx_query_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Number of transmitted unicast packets */
	uint64_t	tx_ucast_pkts;
	/* Number of transmitted multicast packets */
	uint64_t	tx_mcast_pkts;
	/* Number of transmitted broadcast packets */
	uint64_t	tx_bcast_pkts;
	/* Number of packets discarded in transmit path */
	uint64_t	tx_discard_pkts;
	/* Number of packets in transmit path with error */
	uint64_t	tx_error_pkts;
	/* Number of transmitted bytes for unicast traffic */
	uint64_t	tx_ucast_bytes;
	/* Number of transmitted bytes for multicast traffic */
	uint64_t	tx_mcast_bytes;
	/* Number of transmitted bytes for broadcast traffic */
	uint64_t	tx_bcast_bytes;
	/* Number of received unicast packets */
	uint64_t	rx_ucast_pkts;
	/* Number of received multicast packets */
	uint64_t	rx_mcast_pkts;
	/* Number of received broadcast packets */
	uint64_t	rx_bcast_pkts;
	/* Number of packets discarded in receive path */
	uint64_t	rx_discard_pkts;
	/* Number of packets in receive path with errors */
	uint64_t	rx_error_pkts;
	/* Number of received bytes for unicast traffic */
	uint64_t	rx_ucast_bytes;
	/* Number of received bytes for multicast traffic */
	uint64_t	rx_mcast_bytes;
	/* Number of received bytes for broadcast traffic */
	uint64_t	rx_bcast_bytes;
	/* Number of aggregated unicast packets */
	uint64_t	rx_agg_pkts;
	/* Number of aggregated unicast bytes */
	uint64_t	rx_agg_bytes;
	/* Number of aggregation events */
	uint64_t	rx_agg_events;
	/* Number of aborted aggregations */
	uint64_t	rx_agg_aborts;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_stat_ctx_query_output_t, *phwrm_stat_ctx_query_output_t;

/***************************
 * hwrm_stat_ext_ctx_query *
 ***************************/


/* hwrm_stat_ext_ctx_query_input (size:192b/24B) */

typedef struct hwrm_stat_ext_ctx_query_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* ID of the extended statistics context that is being queried. */
	uint32_t	stat_ctx_id;
	uint8_t	flags;
	/*
	 * This bit is set to 1 when request is for a counter mask,
	 * representing the width of each of the stats counters, rather
	 * than counters themselves.
	 */
	#define HWRM_STAT_EXT_CTX_QUERY_INPUT_FLAGS_COUNTER_MASK	UINT32_C(0x1)
	uint8_t	unused_0[3];
} hwrm_stat_ext_ctx_query_input_t, *phwrm_stat_ext_ctx_query_input_t;

/* hwrm_stat_ext_ctx_query_output (size:1536b/192B) */

typedef struct hwrm_stat_ext_ctx_query_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Number of received unicast packets */
	uint64_t	rx_ucast_pkts;
	/* Number of received multicast packets */
	uint64_t	rx_mcast_pkts;
	/* Number of received broadcast packets */
	uint64_t	rx_bcast_pkts;
	/* Number of discarded packets on receive path */
	uint64_t	rx_discard_pkts;
	/* Number of packets on receive path with error */
	uint64_t	rx_error_pkts;
	/* Number of received bytes for unicast traffic */
	uint64_t	rx_ucast_bytes;
	/* Number of received bytes for multicast traffic */
	uint64_t	rx_mcast_bytes;
	/* Number of received bytes for broadcast traffic */
	uint64_t	rx_bcast_bytes;
	/* Number of transmitted unicast packets */
	uint64_t	tx_ucast_pkts;
	/* Number of transmitted multicast packets */
	uint64_t	tx_mcast_pkts;
	/* Number of transmitted broadcast packets */
	uint64_t	tx_bcast_pkts;
	/* Number of packets on transmit path with error */
	uint64_t	tx_error_pkts;
	/* Number of discarded packets on transmit path */
	uint64_t	tx_discard_pkts;
	/* Number of transmitted bytes for unicast traffic */
	uint64_t	tx_ucast_bytes;
	/* Number of transmitted bytes for multicast traffic */
	uint64_t	tx_mcast_bytes;
	/* Number of transmitted bytes for broadcast traffic */
	uint64_t	tx_bcast_bytes;
	/* Number of TPA eligible packets */
	uint64_t	rx_tpa_eligible_pkt;
	/* Number of TPA eligible bytes */
	uint64_t	rx_tpa_eligible_bytes;
	/* Number of TPA packets */
	uint64_t	rx_tpa_pkt;
	/* Number of TPA bytes */
	uint64_t	rx_tpa_bytes;
	/* Number of TPA errors */
	uint64_t	rx_tpa_errors;
	/* Number of TPA events */
	uint64_t	rx_tpa_events;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_stat_ext_ctx_query_output_t, *phwrm_stat_ext_ctx_query_output_t;

/***************************
 * hwrm_stat_ctx_eng_query *
 ***************************/


/* hwrm_stat_ctx_eng_query_input (size:192b/24B) */

typedef struct hwrm_stat_ctx_eng_query_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* ID of the statistics context that is being queried. */
	uint32_t	stat_ctx_id;
	uint8_t	unused_0[4];
} hwrm_stat_ctx_eng_query_input_t, *phwrm_stat_ctx_eng_query_input_t;

/* hwrm_stat_ctx_eng_query_output (size:640b/80B) */

typedef struct hwrm_stat_ctx_eng_query_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * Count of data bytes into the Engine.
	 * This includes any user supplied prefix,
	 * but does not include any predefined
	 * prefix data.
	 */
	uint64_t	eng_bytes_in;
	/* Count of data bytes out of the Engine. */
	uint64_t	eng_bytes_out;
	/*
	 * Count, in 4-byte (dword) units, of bytes
	 * that are input as auxiliary data.
	 * This includes the aux_cmd data.
	 */
	uint64_t	aux_bytes_in;
	/*
	 * Count, in 4-byte (dword) units, of bytes
	 * that are output as auxiliary data.
	 * This count is the buffer space for aux_data
	 * output provided in the RQE, not the actual
	 * aux_data written
	 */
	uint64_t	aux_bytes_out;
	/* Count of number of commands executed. */
	uint64_t	commands;
	/*
	 * Count of number of error commands.
	 * These are the commands with a
	 * non-zero status value.
	 */
	uint64_t	error_commands;
	/*
	 * Compression/Encryption Engine usage,
	 * the unit is count of clock cycles
	 */
	uint64_t	cce_engine_usage;
	/*
	 * De-Compression/De-cryption Engine usage,
	 * the unit is count of clock cycles
	 */
	uint64_t	cdd_engine_usage;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_stat_ctx_eng_query_output_t, *phwrm_stat_ctx_eng_query_output_t;

/***************************
 * hwrm_stat_ctx_clr_stats *
 ***************************/


/* hwrm_stat_ctx_clr_stats_input (size:192b/24B) */

typedef struct hwrm_stat_ctx_clr_stats_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* ID of the statistics context that is being queried. */
	uint32_t	stat_ctx_id;
	uint8_t	unused_0[4];
} hwrm_stat_ctx_clr_stats_input_t, *phwrm_stat_ctx_clr_stats_input_t;

/* hwrm_stat_ctx_clr_stats_output (size:128b/16B) */

typedef struct hwrm_stat_ctx_clr_stats_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_stat_ctx_clr_stats_output_t, *phwrm_stat_ctx_clr_stats_output_t;

/********************
 * hwrm_pcie_qstats *
 ********************/


/* hwrm_pcie_qstats_input (size:256b/32B) */

typedef struct hwrm_pcie_qstats_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * The size of PCIe statistics block in bytes.
	 * Firmware will DMA the PCIe statistics to
	 * the host with this field size in the response.
	 */
	uint16_t	pcie_stat_size;
	uint8_t	unused_0[6];
	/*
	 * This is the host address where
	 * PCIe statistics will be stored
	 */
	uint64_t	pcie_stat_host_addr;
} hwrm_pcie_qstats_input_t, *phwrm_pcie_qstats_input_t;

/* hwrm_pcie_qstats_output (size:128b/16B) */

typedef struct hwrm_pcie_qstats_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* The size of PCIe statistics block in bytes. */
	uint16_t	pcie_stat_size;
	uint8_t	unused_0[5];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_pcie_qstats_output_t, *phwrm_pcie_qstats_output_t;

/* PCIe Statistics Formats */
/* pcie_ctx_hw_stats (size:768b/96B) */

typedef struct pcie_ctx_hw_stats {
	/* Number of physical layer receiver errors */
	uint64_t	pcie_pl_signal_integrity;
	/* Number of DLLP CRC errors detected by Data Link Layer */
	uint64_t	pcie_dl_signal_integrity;
	/*
	 * Number of TLP LCRC and sequence number errors detected
	 * by Data Link Layer
	 */
	uint64_t	pcie_tl_signal_integrity;
	/* Number of times LTSSM entered Recovery state */
	uint64_t	pcie_link_integrity;
	/* Report number of TLP bits that have been transmitted in Mbps */
	uint64_t	pcie_tx_traffic_rate;
	/* Report number of TLP bits that have been received in Mbps */
	uint64_t	pcie_rx_traffic_rate;
	/* Number of DLLP bytes that have been transmitted */
	uint64_t	pcie_tx_dllp_statistics;
	/* Number of DLLP bytes that have been received */
	uint64_t	pcie_rx_dllp_statistics;
	/*
	 * Number of times spent in each phase of gen3
	 * equalization
	 */
	uint64_t	pcie_equalization_time;
	/* Records the last 16 transitions of the LTSSM */
	uint32_t	pcie_ltssm_histogram[4];
	/*
	 * Record the last 8 reasons on why LTSSM transitioned
	 * to Recovery
	 */
	uint64_t	pcie_recovery_histogram;
} pcie_ctx_hw_stats_t, *ppcie_ctx_hw_stats_t;

/*****************
 * hwrm_fw_reset *
 *****************/


/* hwrm_fw_reset_input (size:192b/24B) */

typedef struct hwrm_fw_reset_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Type of embedded processor. */
	uint8_t	embedded_proc_type;
	/* Boot Processor */
	#define HWRM_FW_RESET_INPUT_EMBEDDED_PROC_TYPE_BOOT		UINT32_C(0x0)
	/* Management Processor */
	#define HWRM_FW_RESET_INPUT_EMBEDDED_PROC_TYPE_MGMT		UINT32_C(0x1)
	/* Network control processor */
	#define HWRM_FW_RESET_INPUT_EMBEDDED_PROC_TYPE_NETCTRL		UINT32_C(0x2)
	/* RoCE control processor */
	#define HWRM_FW_RESET_INPUT_EMBEDDED_PROC_TYPE_ROCE		UINT32_C(0x3)
	/*
	 * Host (in multi-host environment): This is only valid if requester is IPC.
	 * Reinit host hardware resources and PCIe.
	 */
	#define HWRM_FW_RESET_INPUT_EMBEDDED_PROC_TYPE_HOST		UINT32_C(0x4)
	/* AP processor complex (in multi-host environment). Use host_idx to control which core is reset */
	#define HWRM_FW_RESET_INPUT_EMBEDDED_PROC_TYPE_AP			UINT32_C(0x5)
	/* Reset all blocks of the chip (including all processors) */
	#define HWRM_FW_RESET_INPUT_EMBEDDED_PROC_TYPE_CHIP		UINT32_C(0x6)
	/*
	 * Host (in multi-host environment): This is only valid if requester is IPC.
	 * Reinit host hardware resources.
	 */
	#define HWRM_FW_RESET_INPUT_EMBEDDED_PROC_TYPE_HOST_RESOURCE_REINIT  UINT32_C(0x7)
	/*
	 * Activate firmware that has been programmed to NVM.  The
	 * activation is done in an impactless manner as part of the scheme
	 * where hwrm_fw_state_backup precedes the call, and
	 * hwrm_fw_state_restore follows it.  Before this call returns, FW
	 * status is set to a non-0x8000 value to disambiguate reset pending
	 * from reset complete.  The reset process begins after this call
	 * returns to ensure this HWRM has completed before reset begins.
	 */
	#define HWRM_FW_RESET_INPUT_EMBEDDED_PROC_TYPE_IMPACTLESS_ACTIVATION UINT32_C(0x8)
	#define HWRM_FW_RESET_INPUT_EMBEDDED_PROC_TYPE_LAST		HWRM_FW_RESET_INPUT_EMBEDDED_PROC_TYPE_IMPACTLESS_ACTIVATION
	/* Type of self reset. */
	uint8_t	selfrst_status;
	/* No Self Reset */
	#define HWRM_FW_RESET_INPUT_SELFRST_STATUS_SELFRSTNONE	UINT32_C(0x0)
	/* Self Reset as soon as possible to do so safely */
	#define HWRM_FW_RESET_INPUT_SELFRST_STATUS_SELFRSTASAP	UINT32_C(0x1)
	/* Self Reset on PCIe Reset */
	#define HWRM_FW_RESET_INPUT_SELFRST_STATUS_SELFRSTPCIERST   UINT32_C(0x2)
	/* Self Reset immediately after notification to all clients. */
	#define HWRM_FW_RESET_INPUT_SELFRST_STATUS_SELFRSTIMMEDIATE UINT32_C(0x3)
	#define HWRM_FW_RESET_INPUT_SELFRST_STATUS_LAST		HWRM_FW_RESET_INPUT_SELFRST_STATUS_SELFRSTIMMEDIATE
	/*
	 * Indicate which host is being reset. 0 means first host.
	 * Only valid when embedded_proc_type is host in multihost
	 * environment
	 */
	uint8_t	host_idx;
	uint8_t	flags;
	/*
	 * When this bit is '1', then the core firmware initiates
	 * the reset only after graceful shut down of all registered instances.
	 * If not, the device will continue with the existing firmware.
	 */
	#define HWRM_FW_RESET_INPUT_FLAGS_RESET_GRACEFUL	UINT32_C(0x1)
	uint8_t	unused_0[4];
} hwrm_fw_reset_input_t, *phwrm_fw_reset_input_t;

/* hwrm_fw_reset_output (size:128b/16B) */

typedef struct hwrm_fw_reset_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Type of self reset. */
	uint8_t	selfrst_status;
	/* No Self Reset */
	#define HWRM_FW_RESET_OUTPUT_SELFRST_STATUS_SELFRSTNONE	UINT32_C(0x0)
	/* Self Reset as soon as possible to do so safely */
	#define HWRM_FW_RESET_OUTPUT_SELFRST_STATUS_SELFRSTASAP	UINT32_C(0x1)
	/* Self Reset on PCIe Reset */
	#define HWRM_FW_RESET_OUTPUT_SELFRST_STATUS_SELFRSTPCIERST   UINT32_C(0x2)
	/* Self Reset immediately after notification to all clients. */
	#define HWRM_FW_RESET_OUTPUT_SELFRST_STATUS_SELFRSTIMMEDIATE UINT32_C(0x3)
	#define HWRM_FW_RESET_OUTPUT_SELFRST_STATUS_LAST		HWRM_FW_RESET_OUTPUT_SELFRST_STATUS_SELFRSTIMMEDIATE
	uint8_t	unused_0[6];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_fw_reset_output_t, *phwrm_fw_reset_output_t;

/*******************
 * hwrm_fw_qstatus *
 *******************/


/* hwrm_fw_qstatus_input (size:192b/24B) */

typedef struct hwrm_fw_qstatus_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Type of embedded processor. */
	uint8_t	embedded_proc_type;
	/* Boot Processor */
	#define HWRM_FW_QSTATUS_INPUT_EMBEDDED_PROC_TYPE_BOOT	UINT32_C(0x0)
	/* Management Processor */
	#define HWRM_FW_QSTATUS_INPUT_EMBEDDED_PROC_TYPE_MGMT	UINT32_C(0x1)
	/* Network control processor */
	#define HWRM_FW_QSTATUS_INPUT_EMBEDDED_PROC_TYPE_NETCTRL UINT32_C(0x2)
	/* RoCE control processor */
	#define HWRM_FW_QSTATUS_INPUT_EMBEDDED_PROC_TYPE_ROCE	UINT32_C(0x3)
	/* Host (in multi-host environment): This is only valid if requester is IPC */
	#define HWRM_FW_QSTATUS_INPUT_EMBEDDED_PROC_TYPE_HOST	UINT32_C(0x4)
	/* AP processor complex (in multi-host environment). Use host_idx to control which core is reset */
	#define HWRM_FW_QSTATUS_INPUT_EMBEDDED_PROC_TYPE_AP	UINT32_C(0x5)
	/* Reset all blocks of the chip (including all processors) */
	#define HWRM_FW_QSTATUS_INPUT_EMBEDDED_PROC_TYPE_CHIP	UINT32_C(0x6)
	#define HWRM_FW_QSTATUS_INPUT_EMBEDDED_PROC_TYPE_LAST   HWRM_FW_QSTATUS_INPUT_EMBEDDED_PROC_TYPE_CHIP
	uint8_t	unused_0[7];
} hwrm_fw_qstatus_input_t, *phwrm_fw_qstatus_input_t;

/* hwrm_fw_qstatus_output (size:128b/16B) */

typedef struct hwrm_fw_qstatus_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Type of self reset. */
	uint8_t	selfrst_status;
	/* No Self Reset */
	#define HWRM_FW_QSTATUS_OUTPUT_SELFRST_STATUS_SELFRSTNONE	UINT32_C(0x0)
	/* Self Reset as soon as possible to do so safely */
	#define HWRM_FW_QSTATUS_OUTPUT_SELFRST_STATUS_SELFRSTASAP	UINT32_C(0x1)
	/* Self Reset on PCIe Reset */
	#define HWRM_FW_QSTATUS_OUTPUT_SELFRST_STATUS_SELFRSTPCIERST UINT32_C(0x2)
	/* NIC power cycle (system cold boot) required */
	#define HWRM_FW_QSTATUS_OUTPUT_SELFRST_STATUS_SELFRSTPOWER   UINT32_C(0x3)
	#define HWRM_FW_QSTATUS_OUTPUT_SELFRST_STATUS_LAST	HWRM_FW_QSTATUS_OUTPUT_SELFRST_STATUS_SELFRSTPOWER
	/*
	 * The action needed to apply any pend nvm option changes.
	 * If multiple options have been set the highest level
	 * action is reported.
	 */
	uint8_t	nvm_option_action_status;
	/* No Action needed */
	#define HWRM_FW_QSTATUS_OUTPUT_NVM_OPTION_ACTION_STATUS_NVMOPT_ACTION_NONE	UINT32_C(0x0)
	/* Hot reset needed to apply nvm options */
	#define HWRM_FW_QSTATUS_OUTPUT_NVM_OPTION_ACTION_STATUS_NVMOPT_ACTION_HOTRESET UINT32_C(0x1)
	/* Warm boot needed to apply nvm options */
	#define HWRM_FW_QSTATUS_OUTPUT_NVM_OPTION_ACTION_STATUS_NVMOPT_ACTION_WARMBOOT UINT32_C(0x2)
	/* Cold boot needed to apply nvm options */
	#define HWRM_FW_QSTATUS_OUTPUT_NVM_OPTION_ACTION_STATUS_NVMOPT_ACTION_COLDBOOT UINT32_C(0x3)
	#define HWRM_FW_QSTATUS_OUTPUT_NVM_OPTION_ACTION_STATUS_LAST		HWRM_FW_QSTATUS_OUTPUT_NVM_OPTION_ACTION_STATUS_NVMOPT_ACTION_COLDBOOT
	uint8_t	unused_0[5];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_fw_qstatus_output_t, *phwrm_fw_qstatus_output_t;

/********************
 * hwrm_fw_set_time *
 ********************/


/* hwrm_fw_set_time_input (size:256b/32B) */

typedef struct hwrm_fw_set_time_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Current year */
	uint16_t	year;
	/* Date/time is not known */
	#define HWRM_FW_SET_TIME_INPUT_YEAR_UNKNOWN UINT32_C(0x0)
	#define HWRM_FW_SET_TIME_INPUT_YEAR_LAST   HWRM_FW_SET_TIME_INPUT_YEAR_UNKNOWN
	/* Current month of year (1-12) */
	uint8_t	month;
	/* Current day of month (1-31) */
	uint8_t	day;
	/* Current hour (0-23) */
	uint8_t	hour;
	/* Current minute (0-59) */
	uint8_t	minute;
	/* Current second (0-59) */
	uint8_t	second;
	uint8_t	unused_0;
	/* Current millisecond (0-999) */
	uint16_t	millisecond;
	/* Minutes east of UTC, 0xffff if TZ is not known */
	int16_t	zone;
	/* Time zone is Coordinated Universal Time (UTC) */
	#define HWRM_FW_SET_TIME_INPUT_ZONE_UTC	0
	/* Time zone is not known */
	#define HWRM_FW_SET_TIME_INPUT_ZONE_UNKNOWN 65535
	#define HWRM_FW_SET_TIME_INPUT_ZONE_LAST   HWRM_FW_SET_TIME_INPUT_ZONE_UNKNOWN
	uint8_t	unused_1[4];
} hwrm_fw_set_time_input_t, *phwrm_fw_set_time_input_t;

/* hwrm_fw_set_time_output (size:128b/16B) */

typedef struct hwrm_fw_set_time_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_fw_set_time_output_t, *phwrm_fw_set_time_output_t;

/********************
 * hwrm_fw_get_time *
 ********************/


/* hwrm_fw_get_time_input (size:128b/16B) */

typedef struct hwrm_fw_get_time_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
} hwrm_fw_get_time_input_t, *phwrm_fw_get_time_input_t;

/* hwrm_fw_get_time_output (size:192b/24B) */

typedef struct hwrm_fw_get_time_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Current year */
	uint16_t	year;
	/* Date/time is not known */
	#define HWRM_FW_GET_TIME_OUTPUT_YEAR_UNKNOWN UINT32_C(0x0)
	#define HWRM_FW_GET_TIME_OUTPUT_YEAR_LAST   HWRM_FW_GET_TIME_OUTPUT_YEAR_UNKNOWN
	/* Current month of year (1-12) */
	uint8_t	month;
	/* Current day of month (1-31) */
	uint8_t	day;
	/* Current hour (0-23) */
	uint8_t	hour;
	/* Current minute (0-59) */
	uint8_t	minute;
	/* Current second (0-59) */
	uint8_t	second;
	uint8_t	unused_0;
	/* Current millisecond (0-999) */
	uint16_t	millisecond;
	/* Minutes east of UTC, 0xffff if TZ is not known */
	int16_t	zone;
	/* Time zone is Coordinated Universal Time (UTC) */
	#define HWRM_FW_GET_TIME_OUTPUT_ZONE_UTC	0
	/* Time zone is not known */
	#define HWRM_FW_GET_TIME_OUTPUT_ZONE_UNKNOWN 65535
	#define HWRM_FW_GET_TIME_OUTPUT_ZONE_LAST   HWRM_FW_GET_TIME_OUTPUT_ZONE_UNKNOWN
	uint8_t	unused_1[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_fw_get_time_output_t, *phwrm_fw_get_time_output_t;

/* hwrm_struct_hdr (size:128b/16B) */

typedef struct hwrm_struct_hdr {
	/* This value indicates the structured data ID. */
	uint16_t	struct_id;
	/* LLDP configuration structured data ID. */
	#define HWRM_STRUCT_HDR_STRUCT_ID_LLDP_CFG	UINT32_C(0x41b)
	/* DCBX ETS configuration structured data ID. */
	#define HWRM_STRUCT_HDR_STRUCT_ID_DCBX_ETS	UINT32_C(0x41d)
	/* DCBX PFC configuration structured data ID. */
	#define HWRM_STRUCT_HDR_STRUCT_ID_DCBX_PFC	UINT32_C(0x41f)
	/* DCBX APP configuration structured data ID. */
	#define HWRM_STRUCT_HDR_STRUCT_ID_DCBX_APP	UINT32_C(0x421)
	/* DCBX state configuration structured data ID for all DCBX features. */
	#define HWRM_STRUCT_HDR_STRUCT_ID_DCBX_FEATURE_STATE UINT32_C(0x422)
	/* LLDP generic structured data ID. This is used with GET_STRUCTURED_DATA only. */
	#define HWRM_STRUCT_HDR_STRUCT_ID_LLDP_GENERIC	UINT32_C(0x424)
	/* LLDP device structured data ID. This is used with GET_STRUCTURED_DATA only. */
	#define HWRM_STRUCT_HDR_STRUCT_ID_LLDP_DEVICE	UINT32_C(0x426)
	/* Power Backup info */
	#define HWRM_STRUCT_HDR_STRUCT_ID_POWER_BKUP	UINT32_C(0x427)
	/* reserved for AFM usage. */
	#define HWRM_STRUCT_HDR_STRUCT_ID_AFM_OPAQUE	UINT32_C(0x1)
	/* Port description. */
	#define HWRM_STRUCT_HDR_STRUCT_ID_PORT_DESCRIPTION   UINT32_C(0xa)
	/* RSSv2 Configuration. */
	#define HWRM_STRUCT_HDR_STRUCT_ID_RSS_V2		UINT32_C(0x64)
	/* MSI-X vectors per VF table. */
	#define HWRM_STRUCT_HDR_STRUCT_ID_MSIX_PER_VF	UINT32_C(0xc8)
	#define HWRM_STRUCT_HDR_STRUCT_ID_LAST		HWRM_STRUCT_HDR_STRUCT_ID_MSIX_PER_VF
	/* This value indicates the length of structured data. */
	uint16_t	len;
	/* This value indicates the version of structured data. */
	uint8_t	version;
	/* This value indicates the number of structured data elements. */
	uint8_t	count;
	/* This value indicates the subtype. */
	uint16_t	subtype;
	/*
	 * This value indicates the count of 64-bit values that point to the next header.
	 * A value of 0 means that this is the last element.  The value is a count of 64-bit
	 * words from the beginning of the current header.
	 */
	uint16_t	next_offset;
	/* This value indicates this is the last element */
	#define HWRM_STRUCT_HDR_NEXT_OFFSET_LAST UINT32_C(0x0)
	uint8_t	unused_0[6];
} hwrm_struct_hdr_t, *phwrm_struct_hdr_t;

/* hwrm_struct_data_dcbx_ets (size:256b/32B) */

typedef struct hwrm_struct_data_dcbx_ets {
	/*
	 * This field indicates if this configuration is ETS recommendation or ETS configuration.
	 * A value 1 means it is ETS configuration, A value of 2 means it is a ETS recommendation.
	 */
	uint8_t	destination;
	/* ETS configuration */
	#define HWRM_STRUCT_DATA_DCBX_ETS_DESTINATION_CONFIGURATION   UINT32_C(0x1)
	/* ETS recommendation */
	#define HWRM_STRUCT_DATA_DCBX_ETS_DESTINATION_RECOMMMENDATION UINT32_C(0x2)
	#define HWRM_STRUCT_DATA_DCBX_ETS_DESTINATION_LAST	HWRM_STRUCT_DATA_DCBX_ETS_DESTINATION_RECOMMMENDATION
	/* This value indicates maximum ETS TCs supported. */
	uint8_t	max_tcs;
	/* unused. */
	uint16_t	unused1;
	/* ETS priority 0 to TC map. */
	uint8_t	pri0_to_tc_map;
	/* ETS priority 1 to TC map. */
	uint8_t	pri1_to_tc_map;
	/* ETS priority 2 to TC map. */
	uint8_t	pri2_to_tc_map;
	/* ETS priority 3 to TC map. */
	uint8_t	pri3_to_tc_map;
	/* ETS priority 4 to TC map. */
	uint8_t	pri4_to_tc_map;
	/* ETS priority 5 to TC map. */
	uint8_t	pri5_to_tc_map;
	/* ETS priority 6 to TC map. */
	uint8_t	pri6_to_tc_map;
	/* ETS priority 7 to TC map. */
	uint8_t	pri7_to_tc_map;
	/* ETS TC 0 to bandwidth map. */
	uint8_t	tc0_to_bw_map;
	/* ETS TC 1 to bandwidth map. */
	uint8_t	tc1_to_bw_map;
	/* ETS TC 2 to bandwidth map. */
	uint8_t	tc2_to_bw_map;
	/* ETS TC 3 to bandwidth map. */
	uint8_t	tc3_to_bw_map;
	/* ETS TC 4 to bandwidth map. */
	uint8_t	tc4_to_bw_map;
	/* ETS TC 5 to bandwidth map. */
	uint8_t	tc5_to_bw_map;
	/* ETS TC 6 to bandwidth map. */
	uint8_t	tc6_to_bw_map;
	/* ETS TC 7 to bandwidth map. */
	uint8_t	tc7_to_bw_map;
	/* ETS TC 0 to TSA map. */
	uint8_t	tc0_to_tsa_map;
	/* strict priority */
	#define HWRM_STRUCT_DATA_DCBX_ETS_TC0_TO_TSA_MAP_TSA_TYPE_SP		UINT32_C(0x0)
	/* credit based shaper */
	#define HWRM_STRUCT_DATA_DCBX_ETS_TC0_TO_TSA_MAP_TSA_TYPE_CBS		UINT32_C(0x1)
	/* ETS */
	#define HWRM_STRUCT_DATA_DCBX_ETS_TC0_TO_TSA_MAP_TSA_TYPE_ETS		UINT32_C(0x2)
	/* vendor specific */
	#define HWRM_STRUCT_DATA_DCBX_ETS_TC0_TO_TSA_MAP_TSA_TYPE_VENDOR_SPECIFIC UINT32_C(0xff)
	#define HWRM_STRUCT_DATA_DCBX_ETS_TC0_TO_TSA_MAP_LAST			HWRM_STRUCT_DATA_DCBX_ETS_TC0_TO_TSA_MAP_TSA_TYPE_VENDOR_SPECIFIC
	/* ETS TC 1 to TSA map. */
	uint8_t	tc1_to_tsa_map;
	/* ETS TC 2 to TSA map. */
	uint8_t	tc2_to_tsa_map;
	/* ETS TC 3 to TSA map. */
	uint8_t	tc3_to_tsa_map;
	/* ETS TC 4 to TSA map. */
	uint8_t	tc4_to_tsa_map;
	/* ETS TC 5 to TSA map. */
	uint8_t	tc5_to_tsa_map;
	/* ETS TC 6 to TSA map. */
	uint8_t	tc6_to_tsa_map;
	/* ETS TC 7 to TSA map. */
	uint8_t	tc7_to_tsa_map;
	uint8_t	unused_0[4];
} hwrm_struct_data_dcbx_ets_t, *phwrm_struct_data_dcbx_ets_t;

/* hwrm_struct_data_dcbx_pfc (size:64b/8B) */

typedef struct hwrm_struct_data_dcbx_pfc {
	/*
	 * This field indicates PFC priority bit map. A value of '0' indicates PFC
	 * 		is disabled. A value of '1' indicates PFC is enabled on that priority.
	 */
	uint8_t	pfc_priority_bitmap;
	/*
	 * This field indicates max PFC TCs supported. Each PFC TC will map to
	 * a lossless CoS queue.
	 */
	uint8_t	max_pfc_tcs;
	/*
	 * This field indicates if MACSec bypass capability is enabled. A value
	 * of '1' indicates MBC is enabled. A value of '0' indicates MBC is disabled.
	 */
	uint8_t	mbc;
	uint8_t	unused_0[5];
} hwrm_struct_data_dcbx_pfc_t, *phwrm_struct_data_dcbx_pfc_t;

/* hwrm_struct_data_dcbx_app (size:64b/8B) */

typedef struct hwrm_struct_data_dcbx_app {
	/*
	 * This field indicates the protocol identifier. This should be specified
	 *		in big endian format.
	 */
	uint16_t	protocol_id;
	/*
	 * This field indicates the protocol selector. The valid values are
	 *		mentioned below.
	 */
	uint8_t	protocol_selector;
	/* ether type */
	#define HWRM_STRUCT_DATA_DCBX_APP_PROTOCOL_SELECTOR_ETHER_TYPE   UINT32_C(0x1)
	/* TCP port */
	#define HWRM_STRUCT_DATA_DCBX_APP_PROTOCOL_SELECTOR_TCP_PORT	UINT32_C(0x2)
	/* UDP port */
	#define HWRM_STRUCT_DATA_DCBX_APP_PROTOCOL_SELECTOR_UDP_PORT	UINT32_C(0x3)
	/* TCP & UDP port */
	#define HWRM_STRUCT_DATA_DCBX_APP_PROTOCOL_SELECTOR_TCP_UDP_PORT UINT32_C(0x4)
	#define HWRM_STRUCT_DATA_DCBX_APP_PROTOCOL_SELECTOR_LAST	HWRM_STRUCT_DATA_DCBX_APP_PROTOCOL_SELECTOR_TCP_UDP_PORT
	/* This field indicates application priority. */
	uint8_t	priority;
	/* This field indicates this entry is valid. */
	uint8_t	valid;
	uint8_t	unused_0[3];
} hwrm_struct_data_dcbx_app_t, *phwrm_struct_data_dcbx_app_t;

/* hwrm_struct_data_dcbx_feature_state (size:64b/8B) */

typedef struct hwrm_struct_data_dcbx_feature_state {
	/* DCBX mode - IEEE or CEE. This is read only field. */
	uint8_t	dcbx_mode;
	/* DCBX disabled mode. */
	#define HWRM_STRUCT_DATA_DCBX_FEATURE_STATE_DCBX_MODE_DCBX_DISABLED UINT32_C(0x0)
	/* DCBX IEEE mode. */
	#define HWRM_STRUCT_DATA_DCBX_FEATURE_STATE_DCBX_MODE_DCBX_IEEE	UINT32_C(0x1)
	/* DCBX CEE mode. */
	#define HWRM_STRUCT_DATA_DCBX_FEATURE_STATE_DCBX_MODE_DCBX_CEE	UINT32_C(0x2)
	#define HWRM_STRUCT_DATA_DCBX_FEATURE_STATE_DCBX_MODE_LAST	HWRM_STRUCT_DATA_DCBX_FEATURE_STATE_DCBX_MODE_DCBX_CEE
	/* ETS TLV state. */
	uint8_t	ets_state;
	/* PFC TLV state. */
	uint8_t	pfc_state;
	/* App TLV state. */
	uint8_t	app_state;
	/* Feature enable bit position. */
	#define HWRM_STRUCT_DATA_DCBX_FEATURE_STATE_APP_STATE_ENABLE_BIT_POS	UINT32_C(0x7)
	/* Feature willing bit position. */
	#define HWRM_STRUCT_DATA_DCBX_FEATURE_STATE_APP_STATE_WILLING_BIT_POS   UINT32_C(0x6)
	/* Feature advertise bit position. */
	#define HWRM_STRUCT_DATA_DCBX_FEATURE_STATE_APP_STATE_ADVERTISE_BIT_POS UINT32_C(0x5)
	#define HWRM_STRUCT_DATA_DCBX_FEATURE_STATE_APP_STATE_LAST		HWRM_STRUCT_DATA_DCBX_FEATURE_STATE_APP_STATE_ADVERTISE_BIT_POS
	/* unused. */
	uint8_t	unused[3];
	/* This field is used to reset the DCBX configuration to factory defaults. */
	uint8_t	resets;
	/* reset ETS configuration. */
	#define HWRM_STRUCT_DATA_DCBX_FEATURE_STATE_RESETS_RESET_ETS   UINT32_C(0x1)
	/* reset PFC configuration. */
	#define HWRM_STRUCT_DATA_DCBX_FEATURE_STATE_RESETS_RESET_PFC   UINT32_C(0x2)
	/* reset application configuration. */
	#define HWRM_STRUCT_DATA_DCBX_FEATURE_STATE_RESETS_RESET_APP   UINT32_C(0x4)
	/* reset DCBX state configuration. */
	#define HWRM_STRUCT_DATA_DCBX_FEATURE_STATE_RESETS_RESET_STATE UINT32_C(0x8)
	#define HWRM_STRUCT_DATA_DCBX_FEATURE_STATE_RESETS_LAST	HWRM_STRUCT_DATA_DCBX_FEATURE_STATE_RESETS_RESET_STATE
} hwrm_struct_data_dcbx_feature_state_t, *phwrm_struct_data_dcbx_feature_state_t;

/* hwrm_struct_data_lldp (size:64b/8B) */

typedef struct hwrm_struct_data_lldp {
	/* Port admin state */
	uint8_t	admin_state;
	/* Disable both Tx and Rx */
	#define HWRM_STRUCT_DATA_LLDP_ADMIN_STATE_DISABLE UINT32_C(0x0)
	/* Enable Tx only */
	#define HWRM_STRUCT_DATA_LLDP_ADMIN_STATE_TX	UINT32_C(0x1)
	/* Enable Rx only */
	#define HWRM_STRUCT_DATA_LLDP_ADMIN_STATE_RX	UINT32_C(0x2)
	/* Enable both Tx and Rx */
	#define HWRM_STRUCT_DATA_LLDP_ADMIN_STATE_ENABLE  UINT32_C(0x3)
	#define HWRM_STRUCT_DATA_LLDP_ADMIN_STATE_LAST   HWRM_STRUCT_DATA_LLDP_ADMIN_STATE_ENABLE
	/* Port description TLV transmit state (enable(1)/disable(0)). */
	uint8_t	port_description_state;
	/* Disable */
	#define HWRM_STRUCT_DATA_LLDP_PORT_DESCRIPTION_STATE_DISABLE UINT32_C(0x0)
	/* Enable. */
	#define HWRM_STRUCT_DATA_LLDP_PORT_DESCRIPTION_STATE_ENABLE  UINT32_C(0x1)
	#define HWRM_STRUCT_DATA_LLDP_PORT_DESCRIPTION_STATE_LAST   HWRM_STRUCT_DATA_LLDP_PORT_DESCRIPTION_STATE_ENABLE
	/* System name TLV transmit state (enable(1)/disable(0)). */
	uint8_t	system_name_state;
	/* Disable */
	#define HWRM_STRUCT_DATA_LLDP_SYSTEM_NAME_STATE_DISABLE UINT32_C(0x0)
	/* Enable. */
	#define HWRM_STRUCT_DATA_LLDP_SYSTEM_NAME_STATE_ENABLE  UINT32_C(0x1)
	#define HWRM_STRUCT_DATA_LLDP_SYSTEM_NAME_STATE_LAST   HWRM_STRUCT_DATA_LLDP_SYSTEM_NAME_STATE_ENABLE
	/* System description TLV transmit state (enable(1)/disable(0)). */
	uint8_t	system_desc_state;
	/* Disable */
	#define HWRM_STRUCT_DATA_LLDP_SYSTEM_DESC_STATE_DISABLE UINT32_C(0x0)
	/* Enable. */
	#define HWRM_STRUCT_DATA_LLDP_SYSTEM_DESC_STATE_ENABLE  UINT32_C(0x1)
	#define HWRM_STRUCT_DATA_LLDP_SYSTEM_DESC_STATE_LAST   HWRM_STRUCT_DATA_LLDP_SYSTEM_DESC_STATE_ENABLE
	/* System capabilities TLV transmit state (enable(1)/disable(0)). */
	uint8_t	system_cap_state;
	/* Disable */
	#define HWRM_STRUCT_DATA_LLDP_SYSTEM_CAP_STATE_DISABLE UINT32_C(0x0)
	/* Enable. */
	#define HWRM_STRUCT_DATA_LLDP_SYSTEM_CAP_STATE_ENABLE  UINT32_C(0x1)
	#define HWRM_STRUCT_DATA_LLDP_SYSTEM_CAP_STATE_LAST   HWRM_STRUCT_DATA_LLDP_SYSTEM_CAP_STATE_ENABLE
	/* Management address TLV transmit state (enable(1)/disable(0)). */
	uint8_t	mgmt_addr_state;
	/* Disable */
	#define HWRM_STRUCT_DATA_LLDP_MGMT_ADDR_STATE_DISABLE UINT32_C(0x0)
	/* Enable. */
	#define HWRM_STRUCT_DATA_LLDP_MGMT_ADDR_STATE_ENABLE  UINT32_C(0x1)
	#define HWRM_STRUCT_DATA_LLDP_MGMT_ADDR_STATE_LAST   HWRM_STRUCT_DATA_LLDP_MGMT_ADDR_STATE_ENABLE
	/* Async event notification state (enable(1)/disable(0)). */
	uint8_t	async_event_notification_state;
	/* Disable */
	#define HWRM_STRUCT_DATA_LLDP_ASYNC_EVENT_NOTIFICATION_STATE_DISABLE UINT32_C(0x0)
	/* Enable. */
	#define HWRM_STRUCT_DATA_LLDP_ASYNC_EVENT_NOTIFICATION_STATE_ENABLE  UINT32_C(0x1)
	#define HWRM_STRUCT_DATA_LLDP_ASYNC_EVENT_NOTIFICATION_STATE_LAST   HWRM_STRUCT_DATA_LLDP_ASYNC_EVENT_NOTIFICATION_STATE_ENABLE
	uint8_t	unused_0;
} hwrm_struct_data_lldp_t, *phwrm_struct_data_lldp_t;

/* hwrm_struct_data_lldp_generic (size:2112b/264B) */

typedef struct hwrm_struct_data_lldp_generic {
	/* TLV type. */
	uint8_t	tlv_type;
	/* Chassis ID TLV */
	#define HWRM_STRUCT_DATA_LLDP_GENERIC_TLV_TYPE_CHASSIS		UINT32_C(0x1)
	/* Port ID TLV */
	#define HWRM_STRUCT_DATA_LLDP_GENERIC_TLV_TYPE_PORT		UINT32_C(0x2)
	/* System name TLV */
	#define HWRM_STRUCT_DATA_LLDP_GENERIC_TLV_TYPE_SYSTEM_NAME	UINT32_C(0x3)
	/* System description TLV */
	#define HWRM_STRUCT_DATA_LLDP_GENERIC_TLV_TYPE_SYSTEM_DESCRIPTION UINT32_C(0x4)
	/* Port name TLV */
	#define HWRM_STRUCT_DATA_LLDP_GENERIC_TLV_TYPE_PORT_NAME	UINT32_C(0x5)
	/* Port description TLV */
	#define HWRM_STRUCT_DATA_LLDP_GENERIC_TLV_TYPE_PORT_DESCRIPTION   UINT32_C(0x6)
	#define HWRM_STRUCT_DATA_LLDP_GENERIC_TLV_TYPE_LAST		HWRM_STRUCT_DATA_LLDP_GENERIC_TLV_TYPE_PORT_DESCRIPTION
	/* TLV sub-type. */
	uint8_t	subtype;
	/* Length. */
	uint8_t	length;
	/* unused. */
	uint8_t	unused1[5];
	/* TLV value. */
	uint32_t	tlv_value[64];
} hwrm_struct_data_lldp_generic_t, *phwrm_struct_data_lldp_generic_t;

/* hwrm_struct_data_lldp_device (size:1472b/184B) */

typedef struct hwrm_struct_data_lldp_device {
	/* Time to Live. */
	uint16_t	ttl;
	/* Management address length. */
	uint8_t	mgmt_addr_len;
	/* Management address type. */
	uint8_t	mgmt_addr_type;
	uint8_t	unused_3[4];
	/* Management address. */
	uint32_t	mgmt_addr[8];
	/* System capabilities. */
	uint32_t	system_caps;
	/* Interface number type. */
	uint8_t	intf_num_type;
	/* Management address OID length. */
	uint8_t	mgmt_addr_oid_length;
	uint8_t	unused_4[2];
	/* Interface number. */
	uint32_t	intf_num;
	uint8_t	unused_5[4];
	/* Management address OID. */
	uint32_t	mgmt_addr_oid[32];
} hwrm_struct_data_lldp_device_t, *phwrm_struct_data_lldp_device_t;

/* hwrm_struct_data_port_description (size:64b/8B) */

typedef struct hwrm_struct_data_port_description {
	/*
	 * Port #.  Port number starts at 0 and anything greater than number of ports
	 *		minus 1 is an error.
	 */
	uint8_t	port_id;
	uint8_t	unused_0[7];
} hwrm_struct_data_port_description_t, *phwrm_struct_data_port_description_t;

/* hwrm_struct_data_rss_v2 (size:128b/16B) */

typedef struct hwrm_struct_data_rss_v2 {
	uint16_t	flags;
	/* When this bit is '1', the hash type and hash key are included. */
	#define HWRM_STRUCT_DATA_RSS_V2_FLAGS_HASH_VALID	UINT32_C(0x1)
	/* RSS Context index. */
	uint16_t	rss_ctx_id;
	/* Number ring group IDs. */
	uint16_t	num_ring_groups;
	uint16_t	hash_type;
	/*
	 * When this bit is '1', the RSS hash shall be computed
	 * over source and destination IPv4 addresses of IPv4
	 * packets.
	 */
	#define HWRM_STRUCT_DATA_RSS_V2_HASH_TYPE_IPV4	UINT32_C(0x1)
	/*
	 * When this bit is '1', the RSS hash shall be computed
	 * over source/destination IPv4 addresses and
	 * source/destination ports of TCP/IPv4 packets.
	 */
	#define HWRM_STRUCT_DATA_RSS_V2_HASH_TYPE_TCP_IPV4	UINT32_C(0x2)
	/*
	 * When this bit is '1', the RSS hash shall be computed
	 * over source/destination IPv4 addresses and
	 * source/destination ports of UDP/IPv4 packets.
	 */
	#define HWRM_STRUCT_DATA_RSS_V2_HASH_TYPE_UDP_IPV4	UINT32_C(0x4)
	/*
	 * When this bit is '1', the RSS hash shall be computed
	 * over source and destination IPv4 addresses of IPv6
	 * packets.
	 */
	#define HWRM_STRUCT_DATA_RSS_V2_HASH_TYPE_IPV6	UINT32_C(0x8)
	/*
	 * When this bit is '1', the RSS hash shall be computed
	 * over source/destination IPv6 addresses and
	 * source/destination ports of TCP/IPv6 packets.
	 */
	#define HWRM_STRUCT_DATA_RSS_V2_HASH_TYPE_TCP_IPV6	UINT32_C(0x10)
	/*
	 * When this bit is '1', the RSS hash shall be computed
	 * over source/destination IPv6 addresses and
	 * source/destination ports of UDP/IPv6 packets.
	 */
	#define HWRM_STRUCT_DATA_RSS_V2_HASH_TYPE_UDP_IPV6	UINT32_C(0x20)
	/* Hash key. This field is optional. */
	uint64_t	hash_key_ring_group_ids;
} hwrm_struct_data_rss_v2_t, *phwrm_struct_data_rss_v2_t;

/* hwrm_struct_data_power_information (size:192b/24B) */

typedef struct hwrm_struct_data_power_information {
	/* Backup power information version */
	uint32_t	bkup_power_info_ver;
	/* Platform backup power count */
	uint32_t	platform_bkup_power_count;
	/* Load in milli Watt */
	uint32_t	load_milli_watt;
	/* Backup time in milli seconds */
	uint32_t	bkup_time_milli_seconds;
	/* Backup power status */
	uint32_t	bkup_power_status;
	/* Backup power charge time */
	uint32_t	bkup_power_charge_time;
} hwrm_struct_data_power_information_t, *phwrm_struct_data_power_information_t;

/* hwrm_struct_data_msix_per_vf (size:320b/40B) */

typedef struct hwrm_struct_data_msix_per_vf {
	/* PF ID */
	uint16_t	pf_id;
	/* Number of rows in table. */
	uint16_t	count;
	uint32_t	unused_0;
	/* Starting VF for row 0 */
	uint16_t	start_vf_0;
	/* MSI-X vectors per VF for row 0 */
	uint16_t	msix_0;
	/* Starting VF for row 1 */
	uint16_t	start_vf_1;
	/* MSI-X vectors per VF for row 1 */
	uint16_t	msix_1;
	/* Starting VF for row 2 */
	uint16_t	start_vf_2;
	/* MSI-X vectors per VF for row 2 */
	uint16_t	msix_2;
	/* Starting VF for row 3 */
	uint16_t	start_vf_3;
	/* MSI-X vectors per VF for row 3 */
	uint16_t	msix_3;
	/* Starting VF for row 4 */
	uint16_t	start_vf_4;
	/* MSI-X vectors per VF for row 4 */
	uint16_t	msix_4;
	/* Starting VF for row 5 */
	uint16_t	start_vf_5;
	/* MSI-X vectors per VF for row 5 */
	uint16_t	msix_5;
	/* Starting VF for row 6 */
	uint16_t	start_vf_6;
	/* MSI-X vectors per VF for row 6 */
	uint16_t	msix_6;
	/* Starting VF for row 7 */
	uint16_t	start_vf_7;
	/* MSI-X vectors per VF for row 7 */
	uint16_t	msix_7;
} hwrm_struct_data_msix_per_vf_t, *phwrm_struct_data_msix_per_vf_t;

/*******************
 * hwrm_fw_ecn_cfg *
 *******************/


/* hwrm_fw_ecn_cfg_input (size:192b/24B) */

typedef struct hwrm_fw_ecn_cfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint16_t	flags;
	/*
	 * When this bit is '1', Explicit Congestion Notification (ECN) is
	 * enabled device-wide. When ECN is enabled on a multi-host system,
	 * it is enabled for all hosts. This setting takes effect
	 * immediately. When ECN is enabled, the firmware activates
	 * additional receive Class of Service (CoS) queues that are enabled
	 * for ECN marking and steers ECN-capable packets to those queues.
	 * This setting is not saved persistently. To enable ECN
	 * persistently, set NVM option 173, ENABLE_ECN.
	 * Setting this bit to '0' disables ECN immediately.
	 */
	#define HWRM_FW_ECN_CFG_INPUT_FLAGS_ENABLE_ECN	UINT32_C(0x1)
	uint8_t	unused_0[6];
} hwrm_fw_ecn_cfg_input_t, *phwrm_fw_ecn_cfg_input_t;

/* hwrm_fw_ecn_cfg_output (size:128b/16B) */

typedef struct hwrm_fw_ecn_cfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_fw_ecn_cfg_output_t, *phwrm_fw_ecn_cfg_output_t;

/********************
 * hwrm_fw_ecn_qcfg *
 ********************/


/* hwrm_fw_ecn_qcfg_input (size:128b/16B) */

typedef struct hwrm_fw_ecn_qcfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
} hwrm_fw_ecn_qcfg_input_t, *phwrm_fw_ecn_qcfg_input_t;

/* hwrm_fw_ecn_qcfg_output (size:128b/16B) */

typedef struct hwrm_fw_ecn_qcfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint16_t	flags;
	/* When this bit is '1', ECN is enabled device-wide. */
	#define HWRM_FW_ECN_QCFG_OUTPUT_FLAGS_ENABLE_ECN	UINT32_C(0x1)
	uint8_t	unused_0[5];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_fw_ecn_qcfg_output_t, *phwrm_fw_ecn_qcfg_output_t;

/************************
 * hwrm_fw_health_check *
 ************************/


/* hwrm_fw_health_check_input (size:128b/16B) */

typedef struct hwrm_fw_health_check_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
} hwrm_fw_health_check_input_t, *phwrm_fw_health_check_input_t;

/* hwrm_fw_health_check_output (size:128b/16B) */

typedef struct hwrm_fw_health_check_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint32_t	fw_status;
	/*
	 * This bit is '0' if the primary SBI was used this boot,
	 * or '1' if the secondary SBI was used.
	 */
	#define HWRM_FW_HEALTH_CHECK_OUTPUT_FW_STATUS_SBI_BOOTED	UINT32_C(0x1)
	/*
	 * This bit is '0' if the primary and secondary SBI images
	 * match, or '1' if they do not match.
	 */
	#define HWRM_FW_HEALTH_CHECK_OUTPUT_FW_STATUS_SBI_MISMATCH	UINT32_C(0x2)
	/*
	 * This bit is '0' if the primary SRT was used this boot,
	 * or '1' if the secondary SRT was used.
	 */
	#define HWRM_FW_HEALTH_CHECK_OUTPUT_FW_STATUS_SRT_BOOTED	UINT32_C(0x4)
	/*
	 * This bit is '0' if the primary and secondary SRT images
	 * match, or '1' if they do not match.
	 */
	#define HWRM_FW_HEALTH_CHECK_OUTPUT_FW_STATUS_SRT_MISMATCH	UINT32_C(0x8)
	/*
	 * This bit is '0' if the primary CRT (or second stage SRT)
	 * was used this boot, or '1' if the secondary CRT (or
	 * second stage SRT) was used.
	 */
	#define HWRM_FW_HEALTH_CHECK_OUTPUT_FW_STATUS_CRT_BOOTED	UINT32_C(0x10)
	/*
	 * This bit is '0' if the primary and secondary CRT images
	 * (or second stage SRT images) match, or '1' if they do not
	 * match.
	 */
	#define HWRM_FW_HEALTH_CHECK_OUTPUT_FW_STATUS_CRT_MISMATCH	UINT32_C(0x20)
	/*
	 * This bit is '0' if the the second stage RT image is a CRT,
	 * or '1' if the second stage RT image is an SRT.
	 */
	#define HWRM_FW_HEALTH_CHECK_OUTPUT_FW_STATUS_SECOND_RT		UINT32_C(0x40)
	/*
	 * This bit is '0' if the the image was loaded from flash,
	 * or '1' if the image was fastbooted.
	 */
	#define HWRM_FW_HEALTH_CHECK_OUTPUT_FW_STATUS_FASTBOOTED	UINT32_C(0x80)
	/*
	 * This bit is '0' if the primary dir_hdr was used to locate
	 * the firmware, or '1' if the secondary dir_hdr was used.
	 */
	#define HWRM_FW_HEALTH_CHECK_OUTPUT_FW_STATUS_DIR_HDR_BOOTED	UINT32_C(0x100)
	/*
	 * This bit is '0' if the primary and secondary dir_hdr match,
	 * or '1' if they do not match.
	 */
	#define HWRM_FW_HEALTH_CHECK_OUTPUT_FW_STATUS_DIR_HDR_MISMATCH	UINT32_C(0x200)
	/*
	 * This bit is '0' if the Master Boot Record is in good condition,
	 * or '1' if it is corrupted.
	 */
	#define HWRM_FW_HEALTH_CHECK_OUTPUT_FW_STATUS_MBR_CORRUPT	UINT32_C(0x400)
	uint8_t	unused_0[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_fw_health_check_output_t, *phwrm_fw_health_check_output_t;

/***************************
 * hwrm_fw_livepatch_query *
 ***************************/


/* hwrm_fw_livepatch_query_input (size:192b/24B) */

typedef struct hwrm_fw_livepatch_query_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Firmware target to which to apply the livepatch query */
	uint8_t	fw_target;
	/* Common firmware livepatch query. */
	#define HWRM_FW_LIVEPATCH_QUERY_INPUT_FW_TARGET_COMMON_FW UINT32_C(0x1)
	/* Secure firmware livepatch query. */
	#define HWRM_FW_LIVEPATCH_QUERY_INPUT_FW_TARGET_SECURE_FW UINT32_C(0x2)
	#define HWRM_FW_LIVEPATCH_QUERY_INPUT_FW_TARGET_LAST	HWRM_FW_LIVEPATCH_QUERY_INPUT_FW_TARGET_SECURE_FW
	uint8_t	unused_0[7];
} hwrm_fw_livepatch_query_input_t, *phwrm_fw_livepatch_query_input_t;

/* hwrm_fw_livepatch_query_output (size:640b/80B) */

typedef struct hwrm_fw_livepatch_query_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * This field represents the patch version string of the NVM installed
	 * livepatch.  (ASCII chars with NULL at the end).
	 */
	char	install_ver[32];
	/*
	 * This field represents the patch version string of the active
	 * livepatch.  (ASCII chars with NULL at the end).
	 */
	char	active_ver[32];
	uint16_t	status_flags;
	/* This bit is '1' if a livepatch image is installed to NVM. */
	#define HWRM_FW_LIVEPATCH_QUERY_OUTPUT_STATUS_FLAGS_INSTALL	UINT32_C(0x1)
	/* This bit is '1' if firmware livepatch is active. */
	#define HWRM_FW_LIVEPATCH_QUERY_OUTPUT_STATUS_FLAGS_ACTIVE	UINT32_C(0x2)
	uint8_t	unused_0[5];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_fw_livepatch_query_output_t, *phwrm_fw_livepatch_query_output_t;

/*********************
 * hwrm_fw_livepatch *
 *********************/


/* hwrm_fw_livepatch_input (size:256b/32B) */

typedef struct hwrm_fw_livepatch_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Livepatch operation */
	uint8_t	opcode;
	/*
	 * Activate a livepatch that is NVM installed or via direct load
	 * from host memory.   Activate will authenticate a signed patch,
	 * verify the patch version for compatibility and apply the
	 * livepatch to existing firmware at run-time.
	 */
	#define HWRM_FW_LIVEPATCH_INPUT_OPCODE_ACTIVATE   UINT32_C(0x1)
	/*
	 * Deactivate a livepatch and restore to the original firmware
	 * operation state.
	 */
	#define HWRM_FW_LIVEPATCH_INPUT_OPCODE_DEACTIVATE UINT32_C(0x2)
	#define HWRM_FW_LIVEPATCH_INPUT_OPCODE_LAST	HWRM_FW_LIVEPATCH_INPUT_OPCODE_DEACTIVATE
	/* Firmware target to which to apply the livepatch operation. */
	uint8_t	fw_target;
	/* Common firmware livepatch. */
	#define HWRM_FW_LIVEPATCH_INPUT_FW_TARGET_COMMON_FW UINT32_C(0x1)
	/* Secure firmware livepatch. */
	#define HWRM_FW_LIVEPATCH_INPUT_FW_TARGET_SECURE_FW UINT32_C(0x2)
	#define HWRM_FW_LIVEPATCH_INPUT_FW_TARGET_LAST	HWRM_FW_LIVEPATCH_INPUT_FW_TARGET_SECURE_FW
	/* Load method for livepatch. */
	uint8_t	loadtype;
	/* Load a livepatch currently installed on NVM. */
	#define HWRM_FW_LIVEPATCH_INPUT_LOADTYPE_NVM_INSTALL   UINT32_C(0x1)
	/*
	 * Load a livepatch directly from host memory.  The livepatch image
	 * is available at host_addr.
	 */
	#define HWRM_FW_LIVEPATCH_INPUT_LOADTYPE_MEMORY_DIRECT UINT32_C(0x2)
	#define HWRM_FW_LIVEPATCH_INPUT_LOADTYPE_LAST	HWRM_FW_LIVEPATCH_INPUT_LOADTYPE_MEMORY_DIRECT
	/* Reserved for future use. */
	uint8_t	flags;
	/* Length of livepatch image for memory direct loading, in bytes. */
	uint32_t	patch_len;
	/* 64-bit Host address of livepatch image for memory direct loading. */
	uint64_t	host_addr;
} hwrm_fw_livepatch_input_t, *phwrm_fw_livepatch_input_t;

/* hwrm_fw_livepatch_output (size:128b/16B) */

typedef struct hwrm_fw_livepatch_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_fw_livepatch_output_t, *phwrm_fw_livepatch_output_t;

/* hwrm_fw_livepatch_cmd_err (size:64b/8B) */

typedef struct hwrm_fw_livepatch_cmd_err {
	/*
	 * command specific error codes that goes to
	 * the cmd_err field in Common HWRM Error Response.
	 */
	uint8_t	code;
	/* Unknown error. */
	#define HWRM_FW_LIVEPATCH_CMD_ERR_CODE_UNKNOWN	UINT32_C(0x0)
	/* Opcode invalid. */
	#define HWRM_FW_LIVEPATCH_CMD_ERR_CODE_INVALID_OPCODE  UINT32_C(0x1)
	/* Firmware target invalid. */
	#define HWRM_FW_LIVEPATCH_CMD_ERR_CODE_INVALID_TARGET  UINT32_C(0x2)
	/* Livepatch operation not supported. */
	#define HWRM_FW_LIVEPATCH_CMD_ERR_CODE_NOT_SUPPORTED   UINT32_C(0x3)
	/* Livepatch image is not installed in NVRAM. */
	#define HWRM_FW_LIVEPATCH_CMD_ERR_CODE_NOT_INSTALLED   UINT32_C(0x4)
	/* Deactivate failed.  Firmware is not currently patched. */
	#define HWRM_FW_LIVEPATCH_CMD_ERR_CODE_NOT_PATCHED	UINT32_C(0x5)
	/* Authentication of a signed livepatch failed. */
	#define HWRM_FW_LIVEPATCH_CMD_ERR_CODE_AUTH_FAIL	UINT32_C(0x6)
	/* Livepatch header check failed.  Patch incompatible. */
	#define HWRM_FW_LIVEPATCH_CMD_ERR_CODE_INVALID_HEADER  UINT32_C(0x7)
	/* Livepatch size incompatible. */
	#define HWRM_FW_LIVEPATCH_CMD_ERR_CODE_INVALID_SIZE	UINT32_C(0x8)
	/*
	 * Activate failed.  Firmware has already been patched.  Deactivate
	 * existing livepatch before proceeding.
	 */
	#define HWRM_FW_LIVEPATCH_CMD_ERR_CODE_ALREADY_PATCHED UINT32_C(0x9)
	#define HWRM_FW_LIVEPATCH_CMD_ERR_CODE_LAST	HWRM_FW_LIVEPATCH_CMD_ERR_CODE_ALREADY_PATCHED
	uint8_t	unused_0[7];
} hwrm_fw_livepatch_cmd_err_t, *phwrm_fw_livepatch_cmd_err_t;

/****************
 * hwrm_fw_sync *
 ****************/


/* hwrm_fw_sync_input (size:192b/24B) */

typedef struct hwrm_fw_sync_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	sync_action;
	/*
	 * If action is '1' (sync) and this bit is set, the SBI
	 * images will be synchronized, copying from the instance
	 * used for boot to the other instance, if they currently
	 * do not match.
	 */
	#define HWRM_FW_SYNC_INPUT_SYNC_ACTION_SYNC_SBI	UINT32_C(0x1)
	/*
	 * If action is '1' (sync) and this bit is set, the SRT
	 * images will be synchronized, copying from the instance
	 * used for boot to the other instance, if they currently
	 * do not match.
	 */
	#define HWRM_FW_SYNC_INPUT_SYNC_ACTION_SYNC_SRT	UINT32_C(0x2)
	/*
	 * If action is '1' (sync) and this bit is set, the CRT
	 * images will be synchronized (or second stage SRT if that
	 * is used in place of CRT), copying from the instance
	 * used for boot to the other instance, if they currently
	 * do not match.
	 */
	#define HWRM_FW_SYNC_INPUT_SYNC_ACTION_SYNC_CRT	UINT32_C(0x4)
	/*
	 * If action is '1' (sync) and this bit is set, the dir_hdr
	 * partition will be synchronized, copying from the instance
	 * used for boot to the other instance, if they currently
	 * do not match.
	 */
	#define HWRM_FW_SYNC_INPUT_SYNC_ACTION_SYNC_DIR_HDR	UINT32_C(0x8)
	/*
	 * If action is '1' (sync) and this bit is set, the MBR
	 * will be erased and reprogrammed with valid content.
	 */
	#define HWRM_FW_SYNC_INPUT_SYNC_ACTION_WRITE_MBR	UINT32_C(0x10)
	/*
	 * A value of '1' instructs the firmware to perform an image
	 * synchronization of the firmware types denoted by the
	 * sync_sbi, sync_srt, sync_crt bits.  A value of '0' just
	 * requests the status for the previously requested sync
	 * operation.
	 */
	#define HWRM_FW_SYNC_INPUT_SYNC_ACTION_ACTION	UINT32_C(0x80000000)
	uint8_t	unused_0[4];
} hwrm_fw_sync_input_t, *phwrm_fw_sync_input_t;

/* hwrm_fw_sync_output (size:128b/16B) */

typedef struct hwrm_fw_sync_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint32_t	sync_status;
	/* This bit field indicates the error if 'sync_err' bit is set. */
	#define HWRM_FW_SYNC_OUTPUT_SYNC_STATUS_ERR_CODE_MASK	UINT32_C(0xff)
	#define HWRM_FW_SYNC_OUTPUT_SYNC_STATUS_ERR_CODE_SFT	0
	/* Success, no error */
		#define HWRM_FW_SYNC_OUTPUT_SYNC_STATUS_ERR_CODE_SUCCESS	UINT32_C(0x0)
	/*
	 * A previously requested synchronization command is still
	 * in progress.
	 */
		#define HWRM_FW_SYNC_OUTPUT_SYNC_STATUS_ERR_CODE_IN_PROGRESS  UINT32_C(0x1)
	/* An NVRAM operation has timed out. */
		#define HWRM_FW_SYNC_OUTPUT_SYNC_STATUS_ERR_CODE_TIMEOUT	UINT32_C(0x2)
	/* General NVRAM error code. */
		#define HWRM_FW_SYNC_OUTPUT_SYNC_STATUS_ERR_CODE_GENERAL	UINT32_C(0x3)
		#define HWRM_FW_SYNC_OUTPUT_SYNC_STATUS_ERR_CODE_LAST	HWRM_FW_SYNC_OUTPUT_SYNC_STATUS_ERR_CODE_GENERAL
	/*
	 * This bit is '1' if the syncronization request has completed
	 * with an error; the 'err_code' field can be used to obtain
	 * information about error type.
	 */
	#define HWRM_FW_SYNC_OUTPUT_SYNC_STATUS_SYNC_ERR		UINT32_C(0x40000000)
	/*
	 * This bit is '0' if the previously requested synchronization
	 * command is still in progress, or '1' if the previously
	 * requested sync command has completed.  If '1', the 'sync_err'
	 * field will indicate if it completed successfully or with
	 * an error.
	 */
	#define HWRM_FW_SYNC_OUTPUT_SYNC_STATUS_SYNC_COMPLETE	UINT32_C(0x80000000)
	uint8_t	unused_0[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_fw_sync_output_t, *phwrm_fw_sync_output_t;

/***********************
 * hwrm_fw_state_qcaps *
 ***********************/


/* hwrm_fw_state_qcaps_input (size:128b/16B) */

typedef struct hwrm_fw_state_qcaps_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
} hwrm_fw_state_qcaps_input_t, *phwrm_fw_state_qcaps_input_t;

/* hwrm_fw_state_qcaps_output (size:256b/32B) */

typedef struct hwrm_fw_state_qcaps_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * This field indicates the size in bytes required by host backup
	 * memory.  Host software should allocate memory according to this
	 * size requirement and pass the allocated memory to the
	 * HWRM_FW_STATE_BACKUP and HWRM_FW_STATE_RESTORE commands in the form
	 * of PBL data as specified in those commands.
	 */
	uint32_t	backup_memory;
	/*
	 * This field indicates the max time in milliseconds that firmware
	 * waits for quiesce to complete. Firmware indicates successful
	 * quiesce completion if the quiesce operation completes within this
	 * timeout. If firmware is still waiting for the quiesce operation
	 * to complete when this timeout is reached, firmware stops waiting
	 * (without cancelling any quiesce action such as pausing or
	 * clearing meter profiles) and indicates a timeout status result
	 * via NQE completion notification. This timeout value may also be
	 * used by the driver to know the max time to wait for any NQE
	 * notification response to the HWRM_FW_STATE_QUIESCE command. After
	 * a timeout, the driver may elect to invoke HWRM_FW_STATE_QUIESCE
	 * again to keep trying or to invoke HWRM_FW_STATE_UNQUIESCE to
	 * revert the operation. Since there is no identifier correlating
	 * each HWRM_FW_STATE_QUIESCE command with its NQE response, it is
	 * important for the driver to wait for the NQE response before
	 * issuing a subsequent HWRM_FW_STATE_QUIESCE command.
	 */
	uint32_t	quiesce_timeout;
	/*
	 * This field indicates time in milliseconds that the driver should
	 * wait after return from HWRM_FW_RESET to begin polling the device
	 * for status 0x8000.
	 */
	uint32_t	fw_status_blackout;
	/*
	 * This field indicates a max time for firmware to poll for status
	 * 0x8000 before assuming a reset failure occurred.  This time does
	 * not include fw_status_blackout time which would immediately precede
	 * this wait.
	 */
	uint32_t	fw_status_max_wait;
	uint8_t	unused_0[4];
	uint8_t	unused_1[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_fw_state_qcaps_output_t, *phwrm_fw_state_qcaps_output_t;

/*************************
 * hwrm_fw_state_quiesce *
 *************************/


/* hwrm_fw_state_quiesce_input (size:192b/24B) */

typedef struct hwrm_fw_state_quiesce_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint8_t	flags;
	/*
	 * Setting this bit to '1', indicates impactless firmware update
	 * is in a recovery mode where hardware is in an error state and
	 * where recovery is desired with reasonably minimial impact to
	 * connected clients. The quiesce operation may require separate
	 * steps to handle quiescing when hardware is in a hung or locked
	 * state. For example, quiesce via draining may not be possible
	 * depending on the type of error. This flag's state would be kept
	 * in firmware if recovery-specific steps are also needed for the
	 * HWRM_FW_STATE_BACKUP. Note this option is available only for
	 * specific recovery scenarios and may not be operational across
	 * all controllers.
	 */
	#define HWRM_FW_STATE_QUIESCE_INPUT_FLAGS_ERROR_RECOVERY	UINT32_C(0x1)
	uint8_t	unused_0[7];
} hwrm_fw_state_quiesce_input_t, *phwrm_fw_state_quiesce_input_t;

/* hwrm_fw_state_quiesce_output (size:192b/24B) */

typedef struct hwrm_fw_state_quiesce_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint32_t	quiesce_status;
	/*
	 * This bit is '1' if the quiesce request has been successfully
	 * initiated.
	 */
	#define HWRM_FW_STATE_QUIESCE_OUTPUT_QUIESCE_STATUS_INITIATED	UINT32_C(0x80000000)
	uint8_t	unused_0[4];
	uint8_t	unused_1[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM. This field should be read as '1' to
	 * indicate that the output has been completely written. When
	 * writing a command completion or response to an internal
	 * processor, the order of writes has to be such that this field is
	 * written last.
	 */
	uint8_t	valid;
} hwrm_fw_state_quiesce_output_t, *phwrm_fw_state_quiesce_output_t;

/***************************
 * hwrm_fw_state_unquiesce *
 ***************************/


/* hwrm_fw_state_unquiesce_input (size:128b/16B) */

typedef struct hwrm_fw_state_unquiesce_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
} hwrm_fw_state_unquiesce_input_t, *phwrm_fw_state_unquiesce_input_t;

/* hwrm_fw_state_unquiesce_output (size:192b/24B) */

typedef struct hwrm_fw_state_unquiesce_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint32_t	unquiesce_status;
	/* This bit is '1' if the unquiesce request has fully completed. */
	#define HWRM_FW_STATE_UNQUIESCE_OUTPUT_UNQUIESCE_STATUS_COMPLETE	UINT32_C(0x80000000)
	uint8_t	unused_0[4];
	uint8_t	unused_1[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_fw_state_unquiesce_output_t, *phwrm_fw_state_unquiesce_output_t;

/************************
 * hwrm_fw_state_backup *
 ************************/


/* hwrm_fw_state_backup_input (size:256b/32B) */

typedef struct hwrm_fw_state_backup_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* State backup page size and level. */
	uint8_t	backup_pg_size_backup_lvl;
	/* State backup PBL indirect levels. */
	#define HWRM_FW_STATE_BACKUP_INPUT_BACKUP_LVL_MASK	UINT32_C(0xf)
	#define HWRM_FW_STATE_BACKUP_INPUT_BACKUP_LVL_SFT	0
	/* PBL pointer is physical start address. */
		#define HWRM_FW_STATE_BACKUP_INPUT_BACKUP_LVL_LVL_0	UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
		#define HWRM_FW_STATE_BACKUP_INPUT_BACKUP_LVL_LVL_1	UINT32_C(0x1)
	/*
	 * PBL pointer points to PDE table with each entry pointing to PTE
	 * tables.
	 */
		#define HWRM_FW_STATE_BACKUP_INPUT_BACKUP_LVL_LVL_2	UINT32_C(0x2)
		#define HWRM_FW_STATE_BACKUP_INPUT_BACKUP_LVL_LAST	HWRM_FW_STATE_BACKUP_INPUT_BACKUP_LVL_LVL_2
	/* State backup page size. */
	#define HWRM_FW_STATE_BACKUP_INPUT_BACKUP_PG_SIZE_MASK  UINT32_C(0xf0)
	#define HWRM_FW_STATE_BACKUP_INPUT_BACKUP_PG_SIZE_SFT   4
	/* 4KB. */
		#define HWRM_FW_STATE_BACKUP_INPUT_BACKUP_PG_SIZE_PG_4K   (UINT32_C(0x0) << 4)
	/* 8KB. */
		#define HWRM_FW_STATE_BACKUP_INPUT_BACKUP_PG_SIZE_PG_8K   (UINT32_C(0x1) << 4)
	/* 64KB. */
		#define HWRM_FW_STATE_BACKUP_INPUT_BACKUP_PG_SIZE_PG_64K  (UINT32_C(0x2) << 4)
	/* 2MB. */
		#define HWRM_FW_STATE_BACKUP_INPUT_BACKUP_PG_SIZE_PG_2M   (UINT32_C(0x3) << 4)
	/* 8MB. */
		#define HWRM_FW_STATE_BACKUP_INPUT_BACKUP_PG_SIZE_PG_8M   (UINT32_C(0x4) << 4)
	/* 1GB. */
		#define HWRM_FW_STATE_BACKUP_INPUT_BACKUP_PG_SIZE_PG_1G   (UINT32_C(0x5) << 4)
		#define HWRM_FW_STATE_BACKUP_INPUT_BACKUP_PG_SIZE_LAST   HWRM_FW_STATE_BACKUP_INPUT_BACKUP_PG_SIZE_PG_1G
	uint8_t	unused_0[7];
	/* State backup page directory. */
	uint64_t	backup_page_dir;
} hwrm_fw_state_backup_input_t, *phwrm_fw_state_backup_input_t;

/* hwrm_fw_state_backup_output (size:192b/24B) */

typedef struct hwrm_fw_state_backup_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint32_t	backup_status;
	/*
	 * This bit field provides additional information if the error if
	 * error_code in the common HWRM header is set.
	 */
	#define HWRM_FW_STATE_BACKUP_OUTPUT_BACKUP_STATUS_ERR_CODE_MASK	UINT32_C(0xff)
	#define HWRM_FW_STATE_BACKUP_OUTPUT_BACKUP_STATUS_ERR_CODE_SFT	0
	/* Success, no error */
		#define HWRM_FW_STATE_BACKUP_OUTPUT_BACKUP_STATUS_ERR_CODE_SUCCESS	UINT32_C(0x0)
	/* Data or control plane detected as non-quiesced */
		#define HWRM_FW_STATE_BACKUP_OUTPUT_BACKUP_STATUS_ERR_CODE_QUIESCE_ERROR  UINT32_C(0x1)
	/* General backup error */
		#define HWRM_FW_STATE_BACKUP_OUTPUT_BACKUP_STATUS_ERR_CODE_GENERAL	UINT32_C(0x3)
		#define HWRM_FW_STATE_BACKUP_OUTPUT_BACKUP_STATUS_ERR_CODE_LAST	HWRM_FW_STATE_BACKUP_OUTPUT_BACKUP_STATUS_ERR_CODE_GENERAL
	/*
	 * This bit is '0' if the backout was done in a way that firmware
	 * may continue running normally after the backup, for example if
	 * the host elects to skip the subsequent reset and restore for any
	 * reason.  A value of '1' indicates the act of backing up has left
	 * the firmware/device in a state where subsequent reset is
	 * required, for example of probing state of a queue leaves changes
	 * state in a way that is detectable by users.
	 */
	#define HWRM_FW_STATE_BACKUP_OUTPUT_BACKUP_STATUS_RESET_REQUIRED	UINT32_C(0x40000000)
	/* This bit is '1' if the backup request has fully completed. */
	#define HWRM_FW_STATE_BACKUP_OUTPUT_BACKUP_STATUS_COMPLETE		UINT32_C(0x80000000)
	uint8_t	unused_0[4];
	uint8_t	unused_1[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_fw_state_backup_output_t, *phwrm_fw_state_backup_output_t;

/*************************
 * hwrm_fw_state_restore *
 *************************/


/* hwrm_fw_state_restore_input (size:256b/32B) */

typedef struct hwrm_fw_state_restore_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* State restore page size and level. */
	uint8_t	restore_pg_size_restore_lvl;
	/* State restore PBL indirect levels. */
	#define HWRM_FW_STATE_RESTORE_INPUT_RESTORE_LVL_MASK	UINT32_C(0xf)
	#define HWRM_FW_STATE_RESTORE_INPUT_RESTORE_LVL_SFT	0
	/* PBL pointer is physical start address. */
		#define HWRM_FW_STATE_RESTORE_INPUT_RESTORE_LVL_LVL_0	UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
		#define HWRM_FW_STATE_RESTORE_INPUT_RESTORE_LVL_LVL_1	UINT32_C(0x1)
	/*
	 * PBL pointer points to PDE table with each entry pointing to PTE
	 * tables.
	 */
		#define HWRM_FW_STATE_RESTORE_INPUT_RESTORE_LVL_LVL_2	UINT32_C(0x2)
		#define HWRM_FW_STATE_RESTORE_INPUT_RESTORE_LVL_LAST	HWRM_FW_STATE_RESTORE_INPUT_RESTORE_LVL_LVL_2
	/* State restore page size. */
	#define HWRM_FW_STATE_RESTORE_INPUT_RESTORE_PG_SIZE_MASK  UINT32_C(0xf0)
	#define HWRM_FW_STATE_RESTORE_INPUT_RESTORE_PG_SIZE_SFT   4
	/* 4KB. */
		#define HWRM_FW_STATE_RESTORE_INPUT_RESTORE_PG_SIZE_PG_4K   (UINT32_C(0x0) << 4)
	/* 8KB. */
		#define HWRM_FW_STATE_RESTORE_INPUT_RESTORE_PG_SIZE_PG_8K   (UINT32_C(0x1) << 4)
	/* 64KB. */
		#define HWRM_FW_STATE_RESTORE_INPUT_RESTORE_PG_SIZE_PG_64K  (UINT32_C(0x2) << 4)
	/* 2MB. */
		#define HWRM_FW_STATE_RESTORE_INPUT_RESTORE_PG_SIZE_PG_2M   (UINT32_C(0x3) << 4)
	/* 8MB. */
		#define HWRM_FW_STATE_RESTORE_INPUT_RESTORE_PG_SIZE_PG_8M   (UINT32_C(0x4) << 4)
	/* 1GB. */
		#define HWRM_FW_STATE_RESTORE_INPUT_RESTORE_PG_SIZE_PG_1G   (UINT32_C(0x5) << 4)
		#define HWRM_FW_STATE_RESTORE_INPUT_RESTORE_PG_SIZE_LAST   HWRM_FW_STATE_RESTORE_INPUT_RESTORE_PG_SIZE_PG_1G
	uint8_t	unused_0[7];
	/* State restore page directory. */
	uint64_t	restore_page_dir;
} hwrm_fw_state_restore_input_t, *phwrm_fw_state_restore_input_t;

/* hwrm_fw_state_restore_output (size:128b/16B) */

typedef struct hwrm_fw_state_restore_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint32_t	restore_status;
	/*
	 * This bit field provides additional information if the error if
	 * error_code in the common HWRM header is set.
	 */
	#define HWRM_FW_STATE_RESTORE_OUTPUT_RESTORE_STATUS_ERR_CODE_MASK		UINT32_C(0xff)
	#define HWRM_FW_STATE_RESTORE_OUTPUT_RESTORE_STATUS_ERR_CODE_SFT		0
	/* Success, no error */
		#define HWRM_FW_STATE_RESTORE_OUTPUT_RESTORE_STATUS_ERR_CODE_SUCCESS		UINT32_C(0x0)
	/* General restore error */
		#define HWRM_FW_STATE_RESTORE_OUTPUT_RESTORE_STATUS_ERR_CODE_GENERAL		UINT32_C(0x1)
	/* Format parse error */
		#define HWRM_FW_STATE_RESTORE_OUTPUT_RESTORE_STATUS_ERR_CODE_FORMAT_PARSE		UINT32_C(0x2)
	/* Integrity check error */
		#define HWRM_FW_STATE_RESTORE_OUTPUT_RESTORE_STATUS_ERR_CODE_INTEGRITY_CHECK	UINT32_C(0x3)
		#define HWRM_FW_STATE_RESTORE_OUTPUT_RESTORE_STATUS_ERR_CODE_LAST		HWRM_FW_STATE_RESTORE_OUTPUT_RESTORE_STATUS_ERR_CODE_INTEGRITY_CHECK
	/*
	 * If a failure occurs (complete is 0), restore attempts to
	 * completely roll back any state applied so that the failure
	 * results in no state change.  This flag indidicates whether that
	 * rollback completed successfully and thoroughly.
	 */
	#define HWRM_FW_STATE_RESTORE_OUTPUT_RESTORE_STATUS_FAILURE_ROLLBACK_COMPLETED	UINT32_C(0x40000000)
	/* This bit is '1' if the restore request has fully completed. */
	#define HWRM_FW_STATE_RESTORE_OUTPUT_RESTORE_STATUS_COMPLETE			UINT32_C(0x80000000)
	uint8_t	unused_0[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_fw_state_restore_output_t, *phwrm_fw_state_restore_output_t;

/**********************
 * hwrm_exec_fwd_resp *
 **********************/


/* hwrm_exec_fwd_resp_input (size:1024b/128B) */

typedef struct hwrm_exec_fwd_resp_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * This is an encapsulated request. This request should
	 * be executed by the HWRM and the response should be
	 * provided in the response buffer inside the encapsulated
	 * request.
	 */
	uint32_t	encap_request[26];
	/*
	 * This value indicates the target id of the response to
	 * the encapsulated request.
	 * 0x0 - 0xFFF8 - Used for function ids
	 * 0xFFF8 - 0xFFFE - Reserved for internal processors
	 * 0xFFFF - HWRM
	 */
	uint16_t	encap_resp_target_id;
	uint8_t	unused_0[6];
} hwrm_exec_fwd_resp_input_t, *phwrm_exec_fwd_resp_input_t;

/* hwrm_exec_fwd_resp_output (size:128b/16B) */

typedef struct hwrm_exec_fwd_resp_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_exec_fwd_resp_output_t, *phwrm_exec_fwd_resp_output_t;

/************************
 * hwrm_reject_fwd_resp *
 ************************/


/* hwrm_reject_fwd_resp_input (size:1024b/128B) */

typedef struct hwrm_reject_fwd_resp_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * This is an encapsulated request. This request should
	 * be rejected by the HWRM and the error response should be
	 * provided in the response buffer inside the encapsulated
	 * request.
	 */
	uint32_t	encap_request[26];
	/*
	 * This value indicates the target id of the response to
	 * the encapsulated request.
	 * 0x0 - 0xFFF8 - Used for function ids
	 * 0xFFF8 - 0xFFFE - Reserved for internal processors
	 * 0xFFFF - HWRM
	 */
	uint16_t	encap_resp_target_id;
	uint8_t	unused_0[6];
} hwrm_reject_fwd_resp_input_t, *phwrm_reject_fwd_resp_input_t;

/* hwrm_reject_fwd_resp_output (size:128b/16B) */

typedef struct hwrm_reject_fwd_resp_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_reject_fwd_resp_output_t, *phwrm_reject_fwd_resp_output_t;

/*****************
 * hwrm_fwd_resp *
 *****************/


/* hwrm_fwd_resp_input (size:1024b/128B) */

typedef struct hwrm_fwd_resp_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * This value indicates the target id of the encapsulated
	 * response.
	 * 0x0 - 0xFFF8 - Used for function ids
	 * 0xFFF8 - 0xFFFE - Reserved for internal processors
	 * 0xFFFF - HWRM
	 */
	uint16_t	encap_resp_target_id;
	/*
	 * This value indicates the completion ring the encapsulated
	 * response will be optionally completed on.  If the value is
	 * -1, then no CR completion shall be generated for the
	 * encapsulated response. Any other value must be a
	 * valid CR ring_id value. If a valid encap_resp_cmpl_ring
	 * is provided, then a CR completion shall be generated for
	 * the encapsulated response.
	 */
	uint16_t	encap_resp_cmpl_ring;
	/* This field indicates the length of encapsulated response. */
	uint16_t	encap_resp_len;
	uint8_t	unused_0;
	uint8_t	unused_1;
	/*
	 * This is the host address where the encapsulated response
	 * will be written.
	 * This area must be 16B aligned and must be cleared to zero
	 * before the original request is made.
	 */
	uint64_t	encap_resp_addr;
	/* This is an encapsulated response. */
	uint32_t	encap_resp[24];
} hwrm_fwd_resp_input_t, *phwrm_fwd_resp_input_t;

/* hwrm_fwd_resp_output (size:128b/16B) */

typedef struct hwrm_fwd_resp_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_fwd_resp_output_t, *phwrm_fwd_resp_output_t;

/*****************************
 * hwrm_fwd_async_event_cmpl *
 *****************************/


/* hwrm_fwd_async_event_cmpl_input (size:320b/40B) */

typedef struct hwrm_fwd_async_event_cmpl_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * This value indicates the target id of the encapsulated
	 * asynchronous event.
	 * 0x0 - 0xFFF8 - Used for function ids
	 * 0xFFF8 - 0xFFFE - Reserved for internal processors
	 * 0xFFFF - Broadcast to all children VFs (only applicable when
	 * a PF is the requester)
	 */
	uint16_t	encap_async_event_target_id;
	uint8_t	unused_0[6];
	/* This is an encapsulated asynchronous event completion. */
	uint32_t	encap_async_event_cmpl[4];
} hwrm_fwd_async_event_cmpl_input_t, *phwrm_fwd_async_event_cmpl_input_t;

/* hwrm_fwd_async_event_cmpl_output (size:128b/16B) */

typedef struct hwrm_fwd_async_event_cmpl_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_fwd_async_event_cmpl_output_t, *phwrm_fwd_async_event_cmpl_output_t;

/***************************
 * hwrm_temp_monitor_query *
 ***************************/


/* hwrm_temp_monitor_query_input (size:128b/16B) */

typedef struct hwrm_temp_monitor_query_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
} hwrm_temp_monitor_query_input_t, *phwrm_temp_monitor_query_input_t;

/* hwrm_temp_monitor_query_output (size:128b/16B) */

typedef struct hwrm_temp_monitor_query_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * The HWRM shall provide the current temperature of
	 * the device in Celsius. This is the max of PCIe_temp
	 * and PM_temp
	 */
	uint8_t	temp;
	/*
	 * The HWRM shall provide the current temperature of
	 * the phy in Celsius.
	 */
	uint8_t	phy_temp;
	/*
	 * The HWRM shall provide the current temperature of
	 * the module_index in Celsius.
	 */
	uint8_t	om_temp;
	/* Describe individual temperature sensor condition. */
	uint8_t	flags;
	/*
	 * "1" in this bit indicates temperature read not
	 * successful.
	 */
	#define HWRM_TEMP_MONITOR_QUERY_OUTPUT_FLAGS_TEMP_NOT_AVAILABLE		UINT32_C(0x1)
	/*
	 * "1" in this bit indicates phy temperature read not
	 * successful.
	 */
	#define HWRM_TEMP_MONITOR_QUERY_OUTPUT_FLAGS_PHY_TEMP_NOT_AVAILABLE	UINT32_C(0x2)
	/* "1" in this bit indicates optical module(s) not present. */
	#define HWRM_TEMP_MONITOR_QUERY_OUTPUT_FLAGS_OM_NOT_PRESENT		UINT32_C(0x4)
	/*
	 * "1" in this bit indicates om temperature read not
	 * successful.
	 */
	#define HWRM_TEMP_MONITOR_QUERY_OUTPUT_FLAGS_OM_TEMP_NOT_AVAILABLE	UINT32_C(0x8)
	/*
	 * "1" in this bit indicates the extended temperature fields are
	 * available.
	 */
	#define HWRM_TEMP_MONITOR_QUERY_OUTPUT_FLAGS_EXT_TEMP_FIELDS_AVAILABLE	UINT32_C(0x10)
	/*
	 * This field encodes the current device temperature in Celsius.
	 * This field is unsigned and the value range of 0 to 255 is used to
	 * indicate a temperature range from -64 to +191. The actual
	 * temperature is derived by subtracting 64 from this field.
	 * Example: A value of 0 represents a temperature of -64, a value of
	 * 255 represents a temperature of 191.
	 */
	uint8_t	temp2;
	/*
	 * This field encodes the current phy temperature in Celsius. This
	 * field is unsigned and the value range of 0 to 255 is used to
	 * indicate a temperature range from -64 to +191. The actual
	 * temperature is derived by subtracting 64 from this field.
	 * Example: A value of 0 represents a temperature of -64, a value of
	 * 255 represents a temperature of 191.
	 */
	uint8_t	phy_temp2;
	/*
	 * This field encodes the current module index temperature in Celsius.
	 * This field is unsigned and the value range of 0 to 255 is used to
	 * indicate a temperature range from -64 to +191. The actual
	 * temperature is derived by subtracting 64 from this field.
	 * Example: A value of 0 represents a temperature of -64, a value of
	 * 255 represents a temperature of 191.
	 */
	uint8_t	om_temp2;
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_temp_monitor_query_output_t, *phwrm_temp_monitor_query_output_t;

/************************
 * hwrm_reg_power_query *
 ************************/


/* hwrm_reg_power_query_input (size:128b/16B) */

typedef struct hwrm_reg_power_query_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
} hwrm_reg_power_query_input_t, *phwrm_reg_power_query_input_t;

/* hwrm_reg_power_query_output (size:192b/24B) */

typedef struct hwrm_reg_power_query_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Describe availability of switching regulator power values. */
	uint32_t	flags;
	/* When this bit is set to '1', the input power is available. */
	#define HWRM_REG_POWER_QUERY_OUTPUT_FLAGS_IN_POWER_AVAILABLE	UINT32_C(0x1)
	/* When this bit is set to '1', the output power is available. */
	#define HWRM_REG_POWER_QUERY_OUTPUT_FLAGS_OUT_POWER_AVAILABLE	UINT32_C(0x2)
	/*
	 * The HWRM shall provide the current switching regulator
	 * input power in mW, if available.
	 */
	uint32_t	in_power_mw;
	/*
	 * The HWRM shall provide the current switching regulator
	 * output power in mW, if available.
	 */
	uint32_t	out_power_mw;
	uint8_t	unused_0[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_reg_power_query_output_t, *phwrm_reg_power_query_output_t;

/*****************************
 * hwrm_core_frequency_query *
 *****************************/


/* hwrm_core_frequency_query_input (size:128b/16B) */

typedef struct hwrm_core_frequency_query_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
} hwrm_core_frequency_query_input_t, *phwrm_core_frequency_query_input_t;

/* hwrm_core_frequency_query_output (size:128b/16B) */

typedef struct hwrm_core_frequency_query_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* The HWRM shall provide the core frequency in Hz. */
	uint32_t	core_frequency_hz;
	uint8_t	unused_0[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_core_frequency_query_output_t, *phwrm_core_frequency_query_output_t;

/****************************
 * hwrm_reg_power_histogram *
 ****************************/


/* hwrm_reg_power_histogram_input (size:192b/24B) */

typedef struct hwrm_reg_power_histogram_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Describe operational mode of power histogram command. */
	uint32_t	flags;
	/*
	 * When this bit is set to '1', histogram data for the respective
	 * client (HWRM or BMC) is cleared after read.
	 */
	#define HWRM_REG_POWER_HISTOGRAM_INPUT_FLAGS_CLEAR_HISTOGRAM	UINT32_C(0x1)
	uint32_t	unused_0;
} hwrm_reg_power_histogram_input_t, *phwrm_reg_power_histogram_input_t;

/* hwrm_reg_power_histogram_output (size:1088b/136B) */

typedef struct hwrm_reg_power_histogram_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Describe output characteristics of power histogram command. */
	uint16_t	flags;
	/*
	 * Indicates whether input or output power is used. Some switching
	 * regulators provide both input and output voltage and current
	 * measurements, and others provide only output measurements. When
	 * both are available, input is used. This value is constant for a
	 * given board.
	 */
	#define HWRM_REG_POWER_HISTOGRAM_OUTPUT_FLAGS_POWER_IN_OUT	UINT32_C(0x1)
	/*
	 * The switching regulator's input power is used
	 * data.
	 */
		#define HWRM_REG_POWER_HISTOGRAM_OUTPUT_FLAGS_POWER_IN_OUT_INPUT   UINT32_C(0x0)
	/*
	 * The switching regulator's output power is used
	 * data.
	 */
		#define HWRM_REG_POWER_HISTOGRAM_OUTPUT_FLAGS_POWER_IN_OUT_OUTPUT  UINT32_C(0x1)
		#define HWRM_REG_POWER_HISTOGRAM_OUTPUT_FLAGS_POWER_IN_OUT_LAST   HWRM_REG_POWER_HISTOGRAM_OUTPUT_FLAGS_POWER_IN_OUT_OUTPUT
	uint8_t	unused_0[2];
	/*
	 * Time in microseconds between samples. This value is constant in
	 * firmware. The initial design sets this constant at 10000 us (10
	 * ms). Power values for voltage regulators calculate a power value
	 * over a 300 us period, so a 10 ms sampling period covers 3% of
	 * time ranges. Future firmware designs may opt for different
	 * sampling periods, so this value is provided on output.
	 */
	uint32_t	sampling_period;
	/*
	 * Total samples taken since last clear. If no counter has
	 * saturated, the sum of counts in each bucket equates to this
	 * sample_count value. If a single counter has saturated, its value
	 * can be calculated by subtracting the remaining bucket values from
	 * this sample_count value.
	 */
	uint64_t	sample_count;
	/*
	 * The power usage expressed in histogram buckets. Bucket value
	 * ranges and array indices are defined per the enumeration
	 * power_histogram_bucket_enum. Values saturate at the max 32-bit
	 * value, 0xFFFFFFFF, and do not roll over. Clients should use the
	 * clear bit on input to clear the histogram array periodically or
	 * when saturation is observed.
	 */
	uint32_t	power_hist[26];
	uint8_t	unused_1[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_reg_power_histogram_output_t, *phwrm_reg_power_histogram_output_t;

/*
 * Count of timer callback routines run with no data measured. This
 * may occur when data from the switching regulator is not available
 * to the firmware timer callback routine. One possible reason for
 * this is contention with other users of the i2c bus which is used
 * to communicate with the switching regulator, for example when a
 * call to hwrm_reg_power_query occurs while the timer routine is
 * running.
 */
#define BUCKET_NO_DATA_FOR_SAMPLE UINT32_C(0x0)
/* Count of samples measured at less than 8W */
#define BUCKET_RANGE_8W_OR_LESS   UINT32_C(0x1)
/* Count of samples measured >= 8 W and < 9 W */
#define BUCKET_RANGE_8W_TO_9W	UINT32_C(0x2)
/* Count of samples measured >= 9 W and < 10 W */
#define BUCKET_RANGE_9W_TO_10W	UINT32_C(0x3)
/* Count of samples measured >= 10 W and < 11 W */
#define BUCKET_RANGE_10W_TO_11W   UINT32_C(0x4)
/* Count of samples measured >= 11 W and < 12 W */
#define BUCKET_RANGE_11W_TO_12W   UINT32_C(0x5)
/* Count of samples measured >= 12 W and < 13 W */
#define BUCKET_RANGE_12W_TO_13W   UINT32_C(0x6)
/* Count of samples measured >= 13 W and < 14 W */
#define BUCKET_RANGE_13W_TO_14W   UINT32_C(0x7)
/* Count of samples measured >= 14 W and < 15 W */
#define BUCKET_RANGE_14W_TO_15W   UINT32_C(0x8)
/* Count of samples measured >= 15 W and < 16 W */
#define BUCKET_RANGE_15W_TO_16W   UINT32_C(0x9)
/* Count of samples measured >= 16 W and < 18 W */
#define BUCKET_RANGE_16W_TO_18W   UINT32_C(0xa)
/* Count of samples measured >= 18 W and < 20 W */
#define BUCKET_RANGE_18W_TO_20W   UINT32_C(0xb)
/* Count of samples measured >= 20 W and < 22 W */
#define BUCKET_RANGE_20W_TO_22W   UINT32_C(0xc)
/* Count of samples measured >= 22 W and < 24 W */
#define BUCKET_RANGE_22W_TO_24W   UINT32_C(0xd)
/* Count of samples measured >= 24 W and < 26 W */
#define BUCKET_RANGE_24W_TO_26W   UINT32_C(0xe)
/* Count of samples measured >= 26 W and < 28 W */
#define BUCKET_RANGE_26W_TO_28W   UINT32_C(0xf)
/* Count of samples measured >= 28 W and < 30 W */
#define BUCKET_RANGE_28W_TO_30W   UINT32_C(0x10)
/* Count of samples measured >= 30 W and < 32 W */
#define BUCKET_RANGE_30W_TO_32W   UINT32_C(0x11)
/* Count of samples measured >= 32 W and < 34 W */
#define BUCKET_RANGE_32W_TO_34W   UINT32_C(0x12)
/* Count of samples measured >= 34 W and < 36 W */
#define BUCKET_RANGE_34W_TO_36W   UINT32_C(0x13)
/* Count of samples measured >= 36 W and < 38 W */
#define BUCKET_RANGE_36W_TO_38W   UINT32_C(0x14)
/* Count of samples measured >= 38 W and < 40 W */
#define BUCKET_RANGE_38W_TO_40W   UINT32_C(0x15)
/* Count of samples measured >= 40 W and < 42 W */
#define BUCKET_RANGE_40W_TO_42W   UINT32_C(0x16)
/* Count of samples measured >= 42 W and < 44 W */
#define BUCKET_RANGE_42W_TO_44W   UINT32_C(0x17)
/* Count of samples measured >= 44 W and < 50 W */
#define BUCKET_RANGE_44W_TO_50W   UINT32_C(0x18)
/* Count of samples measured at 50 W or greater */
#define BUCKET_RANGE_OVER_50W	UINT32_C(0x19)
#define BUCKET_LAST		BUCKET_RANGE_OVER_50W


/*************************
 * hwrm_wol_filter_alloc *
 *************************/


/* hwrm_wol_filter_alloc_input (size:512b/64B) */

typedef struct hwrm_wol_filter_alloc_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	flags;
	uint32_t	enables;
	/*
	 * This bit must be '1' for the mac_address field to be
	 * configured.
	 */
	#define HWRM_WOL_FILTER_ALLOC_INPUT_ENABLES_MAC_ADDRESS	UINT32_C(0x1)
	/*
	 * This bit must be '1' for the pattern_offset field to be
	 * configured.
	 */
	#define HWRM_WOL_FILTER_ALLOC_INPUT_ENABLES_PATTERN_OFFSET	UINT32_C(0x2)
	/*
	 * This bit must be '1' for the pattern_buf_size field to be
	 * configured.
	 */
	#define HWRM_WOL_FILTER_ALLOC_INPUT_ENABLES_PATTERN_BUF_SIZE	UINT32_C(0x4)
	/*
	 * This bit must be '1' for the pattern_buf_addr field to be
	 * configured.
	 */
	#define HWRM_WOL_FILTER_ALLOC_INPUT_ENABLES_PATTERN_BUF_ADDR	UINT32_C(0x8)
	/*
	 * This bit must be '1' for the pattern_mask_addr field to be
	 * configured.
	 */
	#define HWRM_WOL_FILTER_ALLOC_INPUT_ENABLES_PATTERN_MASK_ADDR	UINT32_C(0x10)
	/*
	 * This bit must be '1' for the pattern_mask_size field to be
	 * configured.
	 */
	#define HWRM_WOL_FILTER_ALLOC_INPUT_ENABLES_PATTERN_MASK_SIZE	UINT32_C(0x20)
	/* Port ID of port on which WoL filter is configured. */
	uint16_t	port_id;
	/* This value represents a Wake-on-LAN type. */
	uint8_t	wol_type;
	/* Magic Packet */
	#define HWRM_WOL_FILTER_ALLOC_INPUT_WOL_TYPE_MAGICPKT UINT32_C(0x0)
	/* Bitmap */
	#define HWRM_WOL_FILTER_ALLOC_INPUT_WOL_TYPE_BMP	UINT32_C(0x1)
	/* Invalid */
	#define HWRM_WOL_FILTER_ALLOC_INPUT_WOL_TYPE_INVALID  UINT32_C(0xff)
	#define HWRM_WOL_FILTER_ALLOC_INPUT_WOL_TYPE_LAST	HWRM_WOL_FILTER_ALLOC_INPUT_WOL_TYPE_INVALID
	uint8_t	unused_0[5];
	/*
	 * # If this field is enabled and magic packet WoL filter
	 * type is specified in this command, the value set in this
	 * field shall be used in setting the magic packet based
	 * WoL filter.
	 * # If this field is not enabled and magic packet WoL
	 * filter type is specified and port id is specified to
	 * 0xFF in this command, then the HWRM
	 * shall use default MAC address configured on the
	 * function associated with the HWRM client.
	 * # If this field is not enabled and magic packet WoL
	 * filter type is specified and port id is not specified to
	 * 0xFF in this command, then the HWRM
	 * shall use default MAC address configured on the port.
	 */
	uint8_t	mac_address[6];
	/*
	 * The offset from the beginning of MAC header where
	 * pattern should be matched.
	 * Applies to bitmap WoL.
	 */
	uint16_t	pattern_offset;
	/*
	 * The size of the pattern that is being matched.
	 * Applies to bitmap WoL.
	 */
	uint16_t	pattern_buf_size;
	/*
	 * The size of the pattern mask.
	 * Applies to bitmap WoL.
	 */
	uint16_t	pattern_mask_size;
	uint8_t	unused_1[4];
	/*
	 * Physical address of the pattern buffer.
	 * Applies to bitmap WoL.
	 */
	uint64_t	pattern_buf_addr;
	/*
	 * Physical address of the pattern mask.
	 * Applies to bitmap WoL.
	 */
	uint64_t	pattern_mask_addr;
} hwrm_wol_filter_alloc_input_t, *phwrm_wol_filter_alloc_input_t;

/* hwrm_wol_filter_alloc_output (size:128b/16B) */

typedef struct hwrm_wol_filter_alloc_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* This value identifies a Wake-on-LAN (WoL) filter. */
	uint8_t	wol_filter_id;
	uint8_t	unused_0[6];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_wol_filter_alloc_output_t, *phwrm_wol_filter_alloc_output_t;

/************************
 * hwrm_wol_filter_free *
 ************************/


/* hwrm_wol_filter_free_input (size:256b/32B) */

typedef struct hwrm_wol_filter_free_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	flags;
	/*
	 * # When this bit is set to '1', then all active WoL
	 * filters on the port are requested to be freed.
	 * # If the a function driver sets this flag to '1', then
	 * the HWRM shall free all active WoL filters that are not
	 * set by other function drivers on that port.
	 */
	#define HWRM_WOL_FILTER_FREE_INPUT_FLAGS_FREE_ALL_WOL_FILTERS	UINT32_C(0x1)
	uint32_t	enables;
	/*
	 * This bit must be '1' for the wol_filter_id field to be
	 * configured.
	 */
	#define HWRM_WOL_FILTER_FREE_INPUT_ENABLES_WOL_FILTER_ID	UINT32_C(0x1)
	/* Port ID of the port on which WoL filter(s) is (are) being freed. */
	uint16_t	port_id;
	/*
	 * The HWRM shall ignore this field if free_all_wol_filters
	 * flag is set.
	 */
	uint8_t	wol_filter_id;
	uint8_t	unused_0[5];
} hwrm_wol_filter_free_input_t, *phwrm_wol_filter_free_input_t;

/* hwrm_wol_filter_free_output (size:128b/16B) */

typedef struct hwrm_wol_filter_free_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_wol_filter_free_output_t, *phwrm_wol_filter_free_output_t;

/************************
 * hwrm_wol_filter_qcfg *
 ************************/


/* hwrm_wol_filter_qcfg_input (size:448b/56B) */

typedef struct hwrm_wol_filter_qcfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Port ID of port on which WoL filter that is being queried. */
	uint16_t	port_id;
	/*
	 * This is an opaque handle used to access filters.
	 * # The HWRM client shall set this field to 0x0000 to begin
	 * the query.
	 * # After the first query, the HWRM client shall retrieve
	 * next filters (if they exist) using the HWRM provided handle
	 * in the response.
	 */
	uint16_t	handle;
	uint8_t	unused_0[4];
	/*
	 * Physical address of the pattern buffer.
	 * Applies to bitmap WoL filter only.
	 * # Value of 0 indicates an invalid buffer address.
	 * If this field is set to 0, then HWRM shall ignore
	 * pattern_buf_size.
	 * # If the HWRM client provides an invalid buffer address
	 * for the pattern, then the HWRM is not required to
	 * provide pattern when the response contains a bitmap WoL
	 * filter.
	 */
	uint64_t	pattern_buf_addr;
	/*
	 * The size of the pattern buffer.
	 * Applies to bitmap WoL filter only.
	 */
	uint16_t	pattern_buf_size;
	uint8_t	unused_1[6];
	/*
	 * Physical address of the pattern mask.
	 * Applies to bitmap WoL filter only.
	 * # Value of 0 indicates an invalid pattern mask address.
	 * If this field is set to 0, then HWRM shall ignore
	 * pattern_mask_size.
	 * # If the HWRM client provides an invalid mask address
	 * for the pattern, then the HWRM is not required to
	 * provide mask when the response contains a bitmap WoL
	 * filter.
	 */
	uint64_t	pattern_mask_addr;
	/*
	 * The size of the buffer for pattern mask.
	 * Applies to bitmap WoL filter only.
	 */
	uint16_t	pattern_mask_size;
	uint8_t	unused_2[6];
} hwrm_wol_filter_qcfg_input_t, *phwrm_wol_filter_qcfg_input_t;

/* hwrm_wol_filter_qcfg_output (size:256b/32B) */

typedef struct hwrm_wol_filter_qcfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * This is the next handle that is used to access filters.
	 * # If this field is set to 0x0000, then no WoL filters are
	 * currently configured on this port and all other fields in
	 * the output shall be ignored by the HWRM client.
	 * # If this field is set to neither 0x0000 nor 0xFFFF, then the
	 * wol_filter_id is valid and the parameters provided in the
	 * response are based on the wol_type.
	 * # If this field is set to 0xFFFF, then there are no remaining
	 * configured WoL filters to be queried for the queried function
	 * after this response, wol_filter_id is valid and the parameters
	 * provided in the response are based on the wol_type.
	 */
	uint16_t	next_handle;
	/*
	 * This value identifies the filter returned in this
	 * response.
	 */
	uint8_t	wol_filter_id;
	/*
	 * This value identifies the type of WoL filter returned
	 * in this response.
	 */
	uint8_t	wol_type;
	/* Magic Packet */
	#define HWRM_WOL_FILTER_QCFG_OUTPUT_WOL_TYPE_MAGICPKT UINT32_C(0x0)
	/* Bitmap */
	#define HWRM_WOL_FILTER_QCFG_OUTPUT_WOL_TYPE_BMP	UINT32_C(0x1)
	/* Invalid */
	#define HWRM_WOL_FILTER_QCFG_OUTPUT_WOL_TYPE_INVALID  UINT32_C(0xff)
	#define HWRM_WOL_FILTER_QCFG_OUTPUT_WOL_TYPE_LAST	HWRM_WOL_FILTER_QCFG_OUTPUT_WOL_TYPE_INVALID
	uint32_t	unused_0;
	/*
	 * The MAC address value used by the WoL filter.
	 * Applies to magic packet based WoL.
	 */
	uint8_t	mac_address[6];
	/*
	 * The offset from the beginning of MAC header where
	 * pattern should be matched.
	 * Applies to bitmap WoL.
	 */
	uint16_t	pattern_offset;
	/*
	 * The actual size of the pattern that is being returned.
	 * Applies to bitmap WoL.
	 */
	uint16_t	pattern_size;
	/*
	 * The actual size of the pattern mask that is being returned.
	 * Applies to bitmap WoL.
	 */
	uint16_t	pattern_mask_size;
	uint8_t	unused_1[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_wol_filter_qcfg_output_t, *phwrm_wol_filter_qcfg_output_t;

/************************
 * hwrm_wol_reason_qcfg *
 ************************/


/* hwrm_wol_reason_qcfg_input (size:320b/40B) */

typedef struct hwrm_wol_reason_qcfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Port ID of port for which this query is for. */
	uint16_t	port_id;
	uint8_t	unused_0[6];
	/*
	 * Physical address of the packet buffer for querying
	 * WoL packet.
	 */
	uint64_t	wol_pkt_buf_addr;
	/* The size of the buffer for the WoL packet. */
	uint16_t	wol_pkt_buf_size;
	uint8_t	unused_1[6];
} hwrm_wol_reason_qcfg_input_t, *phwrm_wol_reason_qcfg_input_t;

/* hwrm_wol_reason_qcfg_output (size:128b/16B) */

typedef struct hwrm_wol_reason_qcfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * This value identifies the filter that matched
	 * the last WoL packet.
	 * This id is only valid with valid WoL reason.
	 */
	uint8_t	wol_filter_id;
	/*
	 * This value identifies the type of WoL reason returned
	 * in this response.
	 * When the wol_type is set to invalid, then there is
	 * no WoL event that happened during last system
	 * wake-up.
	 */
	uint8_t	wol_reason;
	/* Magic Packet */
	#define HWRM_WOL_REASON_QCFG_OUTPUT_WOL_REASON_MAGICPKT UINT32_C(0x0)
	/* Bitmap */
	#define HWRM_WOL_REASON_QCFG_OUTPUT_WOL_REASON_BMP	UINT32_C(0x1)
	/* Invalid */
	#define HWRM_WOL_REASON_QCFG_OUTPUT_WOL_REASON_INVALID  UINT32_C(0xff)
	#define HWRM_WOL_REASON_QCFG_OUTPUT_WOL_REASON_LAST	HWRM_WOL_REASON_QCFG_OUTPUT_WOL_REASON_INVALID
	/* The value identifies the length of the WoL packet in bytes. */
	uint8_t	wol_pkt_len;
	uint8_t	unused_0[4];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_wol_reason_qcfg_output_t, *phwrm_wol_reason_qcfg_output_t;

/*****************************
 * hwrm_dbg_crashdump_header *
 *****************************/


/* hwrm_dbg_crashdump_header_input (size:192b/24B) */

typedef struct hwrm_dbg_crashdump_header_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint64_t	unused_0;
} hwrm_dbg_crashdump_header_input_t, *phwrm_dbg_crashdump_header_input_t;

/* hwrm_dbg_crashdump_header_output (size:512b/64B) */

typedef struct hwrm_dbg_crashdump_header_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Major version. */
	uint8_t	version_hi;
	/* Minor version. */
	uint8_t	version_low;
	/*
	 * Header length in bytes. This includes all fields from version
	 * to dev_uid (whose length is specified in dev_uid_length).
	 */
	uint16_t	header_len;
	/* This is the crash dump size in bytes. */
	uint32_t	dump_size;
	/*
	 * This is a "wall clock" timestamp value of when the crash occurred.
	 * Format is of time_t type.
	 */
	uint32_t	crash_time;
	/* This is the timezone information for the crash_time. */
	int8_t	utc_offset;
	#define HWRM_DBG_CRASHDUMP_HEADER_OUTPUT_UTC_OFFSET_UTC				0
	#define HWRM_DBG_CRASHDUMP_HEADER_OUTPUT_UTC_OFFSET_AMSTERDAM			4
	#define HWRM_DBG_CRASHDUMP_HEADER_OUTPUT_UTC_OFFSET_EGYPT			8
	#define HWRM_DBG_CRASHDUMP_HEADER_OUTPUT_UTC_OFFSET_EUROPE_MOSCOW		12
	#define HWRM_DBG_CRASHDUMP_HEADER_OUTPUT_UTC_OFFSET_IRAN			14
	#define HWRM_DBG_CRASHDUMP_HEADER_OUTPUT_UTC_OFFSET_ASIA_DUBAI			16
	#define HWRM_DBG_CRASHDUMP_HEADER_OUTPUT_UTC_OFFSET_ASIA_KABUL			18
	#define HWRM_DBG_CRASHDUMP_HEADER_OUTPUT_UTC_OFFSET_ANTARCTICA_MAWSON		20
	#define HWRM_DBG_CRASHDUMP_HEADER_OUTPUT_UTC_OFFSET_ASIA_COLOMBO		22
	#define HWRM_DBG_CRASHDUMP_HEADER_OUTPUT_UTC_OFFSET_ASIA_KATHMANDU		23
	#define HWRM_DBG_CRASHDUMP_HEADER_OUTPUT_UTC_OFFSET_INDIAN_CHAGOS		24
	#define HWRM_DBG_CRASHDUMP_HEADER_OUTPUT_UTC_OFFSET_INDIAN_COCOS		26
	#define HWRM_DBG_CRASHDUMP_HEADER_OUTPUT_UTC_OFFSET_ASIA_BANGKOK		28
	#define HWRM_DBG_CRASHDUMP_HEADER_OUTPUT_UTC_OFFSET_ASIA_HONG_KONG		32
	#define HWRM_DBG_CRASHDUMP_HEADER_OUTPUT_UTC_OFFSET_ASIA_PYONGYANG		34
	#define HWRM_DBG_CRASHDUMP_HEADER_OUTPUT_UTC_OFFSET_AUSTRALIA_EUCLA		35
	#define HWRM_DBG_CRASHDUMP_HEADER_OUTPUT_UTC_OFFSET_ASIA_TOKYO			36
	#define HWRM_DBG_CRASHDUMP_HEADER_OUTPUT_UTC_OFFSET_AUSTRALIA_ADELAIDE		38
	#define HWRM_DBG_CRASHDUMP_HEADER_OUTPUT_UTC_OFFSET_AUSTRALIA_BROKEN_HILL	38
	#define HWRM_DBG_CRASHDUMP_HEADER_OUTPUT_UTC_OFFSET_AUSTRALIA_DARWIN		38
	#define HWRM_DBG_CRASHDUMP_HEADER_OUTPUT_UTC_OFFSET_AUSTRALIA_SYDNEY		40
	#define HWRM_DBG_CRASHDUMP_HEADER_OUTPUT_UTC_OFFSET_AUSTRALIA_LORD_HOWE		42
	#define HWRM_DBG_CRASHDUMP_HEADER_OUTPUT_UTC_OFFSET_ANTARCTICA_MACQUARIE	44
	#define HWRM_DBG_CRASHDUMP_HEADER_OUTPUT_UTC_OFFSET_ANTARCTICA_SOUTH_POLE	48
	#define HWRM_DBG_CRASHDUMP_HEADER_OUTPUT_UTC_OFFSET_PACIFIC_CHATHAM		51
	#define HWRM_DBG_CRASHDUMP_HEADER_OUTPUT_UTC_OFFSET_PACIFIC_APIA		52
	#define HWRM_DBG_CRASHDUMP_HEADER_OUTPUT_UTC_OFFSET_PACIFIC_KIRITIMATIS		56
	#define HWRM_DBG_CRASHDUMP_HEADER_OUTPUT_UTC_OFFSET_ATLANTIC_CAPE_VERDE		-4
	#define HWRM_DBG_CRASHDUMP_HEADER_OUTPUT_UTC_OFFSET_ATLANTIC_SOUTH_GEORGIA	-8
	#define HWRM_DBG_CRASHDUMP_HEADER_OUTPUT_UTC_OFFSET_AMERICA_ARGENTINA_BUENOS_AIRES -12
	#define HWRM_DBG_CRASHDUMP_HEADER_OUTPUT_UTC_OFFSET_AMERICA_SAO_PAULO		-12
	#define HWRM_DBG_CRASHDUMP_HEADER_OUTPUT_UTC_OFFSET_AMERICA_NEWFOUNDLAND	-14
	#define HWRM_DBG_CRASHDUMP_HEADER_OUTPUT_UTC_OFFSET_AMERICA_BARBADOS		-16
	#define HWRM_DBG_CRASHDUMP_HEADER_OUTPUT_UTC_OFFSET_AMERICA_CANCUN		-20
	#define HWRM_DBG_CRASHDUMP_HEADER_OUTPUT_UTC_OFFSET_AMERICA_COSTA_RICA		-24
	#define HWRM_DBG_CRASHDUMP_HEADER_OUTPUT_UTC_OFFSET_AMERICA_PHOENIX		-28
	#define HWRM_DBG_CRASHDUMP_HEADER_OUTPUT_UTC_OFFSET_US_ARIZONA			-28
	#define HWRM_DBG_CRASHDUMP_HEADER_OUTPUT_UTC_OFFSET_US_PACIFIC			-32
	#define HWRM_DBG_CRASHDUMP_HEADER_OUTPUT_UTC_OFFSET_US_ALASKA			-36
	#define HWRM_DBG_CRASHDUMP_HEADER_OUTPUT_UTC_OFFSET_PACIFIC_MARQUESAS		-38
	#define HWRM_DBG_CRASHDUMP_HEADER_OUTPUT_UTC_OFFSET_PACIFIC_HAWAII		-40
	#define HWRM_DBG_CRASHDUMP_HEADER_OUTPUT_UTC_OFFSET_PACIFIC_MIDWAY		-44
	#define HWRM_DBG_CRASHDUMP_HEADER_OUTPUT_UTC_OFFSET_LAST			HWRM_DBG_CRASHDUMP_HEADER_OUTPUT_UTC_OFFSET_PACIFIC_MIDWAY
	/*
	 * This field is a counter value of the crash dump available. This
	 * value is incremented monotonically at each crash.
	 */
	uint8_t	crash_cntr;
	/*
	 * This specifies the length of the dev_uid in bytes. The maximum
	 * value is 31.
	 */
	uint16_t	dev_uid_length;
	/*
	 * This is a unique device identifier (e.g. the first port MAC
	 * address for a network controller or a serial number for an
	 * en/decryption device) in ASCII format. It is used to identify
	 * where the crash dump content is coming from. Unused bytes must
	 * have '\0' character.
	 */
	uint8_t	dev_uid[32];
	/*
	 * This is a count value tracking the number of successful boots
	 * before the crash occurred.
	 */
	uint32_t	power_on_count;
	uint8_t	unused_2[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_dbg_crashdump_header_output_t, *phwrm_dbg_crashdump_header_output_t;

/****************************
 * hwrm_dbg_crashdump_erase *
 ****************************/


/* hwrm_dbg_crashdump_erase_input (size:192b/24B) */

typedef struct hwrm_dbg_crashdump_erase_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* The scope of the erase */
	uint8_t	scope;
	/*
	 * Wipe all crashdump data blocks, making them available for
	 * the next crash(es). This is the typical value to be used.
	 */
	#define HWRM_DBG_CRASHDUMP_ERASE_INPUT_SCOPE_INVALIDATE UINT32_C(0x0)
	/*
	 * Experimental: Remove all data blocks from the directory
	 * (without erasing any existing contents), re-allocate and
	 * re-initialize new ones. In case where the crash dump feature
	 * stops functioning, this can be used to restore it back to the
	 * clean slate.
	 */
	#define HWRM_DBG_CRASHDUMP_ERASE_INPUT_SCOPE_REINIT	UINT32_C(0x1)
	#define HWRM_DBG_CRASHDUMP_ERASE_INPUT_SCOPE_LAST	HWRM_DBG_CRASHDUMP_ERASE_INPUT_SCOPE_REINIT
	uint8_t	unused_0[3];
	uint32_t	unused_1;
} hwrm_dbg_crashdump_erase_input_t, *phwrm_dbg_crashdump_erase_input_t;

/* hwrm_dbg_crashdump_erase_output (size:128b/16B) */

typedef struct hwrm_dbg_crashdump_erase_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_1[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_dbg_crashdump_erase_output_t, *phwrm_dbg_crashdump_erase_output_t;

/******************
 * hwrm_dbg_qcaps *
 ******************/


/* hwrm_dbg_qcaps_input (size:192b/24B) */

typedef struct hwrm_dbg_qcaps_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * Function ID of the function that is being queried.
	 * 0xFF... (All Fs) if the query is for the requesting
	 * function.
	 */
	uint16_t	fid;
	uint8_t	unused_0[6];
} hwrm_dbg_qcaps_input_t, *phwrm_dbg_qcaps_input_t;

/* hwrm_dbg_qcaps_output (size:192b/24B) */

typedef struct hwrm_dbg_qcaps_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * FID value.  This value is used to identify operations on the PCI
	 * bus as belonging to a particular PCI function.
	 */
	uint16_t	fid;
	uint8_t	unused_0[2];
	/*
	 * Bitwise field of components FW supports skipping during collection
	 * of coredump as part of a crash collection.
	 */
	uint32_t	coredump_component_disable_caps;
	/*
	 * If 1, FW supports disabling the collection of NVM during a
	 * coredump taken as part of crash collection.
	 */
	#define HWRM_DBG_QCAPS_OUTPUT_COREDUMP_COMPONENT_DISABLE_CAPS_NVRAM	UINT32_C(0x1)
	uint32_t	flags;
	/* If 1, FW supports writing a crashdump to NVM. */
	#define HWRM_DBG_QCAPS_OUTPUT_FLAGS_CRASHDUMP_NVM	UINT32_C(0x1)
	/* If 1, FW supports writing a crashdump to host ddr. */
	#define HWRM_DBG_QCAPS_OUTPUT_FLAGS_CRASHDUMP_HOST_DDR	UINT32_C(0x2)
	/* If 1, FW supports writing a crashdump to soc ddr. */
	#define HWRM_DBG_QCAPS_OUTPUT_FLAGS_CRASHDUMP_SOC_DDR	UINT32_C(0x4)
	/* If 1, FW supports USEQ operations */
	#define HWRM_DBG_QCAPS_OUTPUT_FLAGS_USEQ		UINT32_C(0x8)
	uint8_t	unused_1[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_dbg_qcaps_output_t, *phwrm_dbg_qcaps_output_t;

/*****************
 * hwrm_dbg_qcfg *
 *****************/


/* hwrm_dbg_qcfg_input (size:192b/24B) */

typedef struct hwrm_dbg_qcfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * Function ID of the function that is being queried.
	 * 0xFF... (All Fs) if the query is for the requesting
	 * function.
	 */
	uint16_t	fid;
	uint16_t	flags;
	/*
	 * The crashdump size represents size of crashdump
	 * written to the specified destination.
	 */
	#define HWRM_DBG_QCFG_INPUT_FLAGS_CRASHDUMP_SIZE_FOR_DEST_MASK	UINT32_C(0x3)
	#define HWRM_DBG_QCFG_INPUT_FLAGS_CRASHDUMP_SIZE_FOR_DEST_SFT	0
	/* crashdump size written to nvm */
		#define HWRM_DBG_QCFG_INPUT_FLAGS_CRASHDUMP_SIZE_FOR_DEST_DEST_NVM	UINT32_C(0x0)
	/* crashdump size written to host_ddr */
		#define HWRM_DBG_QCFG_INPUT_FLAGS_CRASHDUMP_SIZE_FOR_DEST_DEST_HOST_DDR  UINT32_C(0x1)
	/* crashdump size written to soc_ddr */
		#define HWRM_DBG_QCFG_INPUT_FLAGS_CRASHDUMP_SIZE_FOR_DEST_DEST_SOC_DDR   UINT32_C(0x2)
		#define HWRM_DBG_QCFG_INPUT_FLAGS_CRASHDUMP_SIZE_FOR_DEST_LAST	HWRM_DBG_QCFG_INPUT_FLAGS_CRASHDUMP_SIZE_FOR_DEST_DEST_SOC_DDR
	/*
	 * Bitwise field of components requested for FW to skip when
	 * calculating the size of a coredump collection.
	 */
	uint32_t	coredump_component_disable_flags;
	/*
	 * If 1, NVM will not be collected during a coredump taken as part
	 * of crash collection.
	 */
	#define HWRM_DBG_QCFG_INPUT_COREDUMP_COMPONENT_DISABLE_FLAGS_NVRAM	UINT32_C(0x1)
} hwrm_dbg_qcfg_input_t, *phwrm_dbg_qcfg_input_t;

/* hwrm_dbg_qcfg_output (size:256b/32B) */

typedef struct hwrm_dbg_qcfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * FID value.  This value is used to identify operations on the PCI
	 * bus as belonging to a particular PCI function.
	 */
	uint16_t	fid;
	uint8_t	unused_0[2];
	/*
	 * Size in bytes of a coredump file created by the FW.  This takes into
	 * consideration any components selected in the
	 * coredump_component_disable_flags field from hwrm_dbg_qcfg_input.
	 */
	uint32_t	coredump_size;
	uint32_t	flags;
	/*
	 * If set to 1, then UART logging is enabled for the primary
	 * firmware. Disabled otherwise.
	 */
	#define HWRM_DBG_QCFG_OUTPUT_FLAGS_UART_LOG		UINT32_C(0x1)
	/*
	 * If set to 1, then UART logging is enabled for the secondary
	 * firmware. Disabled otherwise.
	 */
	#define HWRM_DBG_QCFG_OUTPUT_FLAGS_UART_LOG_SECONDARY	UINT32_C(0x2)
	/*
	 * If set to 1, then completion ring logging is enabled for the
	 * primary firmware. Disabled otherwise.
	 */
	#define HWRM_DBG_QCFG_OUTPUT_FLAGS_FW_TRACE		UINT32_C(0x4)
	/*
	 * If set to 1, then completion ring logging  is enabled for the
	 * secondary firmware. Disabled otherwise.
	 */
	#define HWRM_DBG_QCFG_OUTPUT_FLAGS_FW_TRACE_SECONDARY	UINT32_C(0x8)
	/*
	 * If set to 1, firmware will generate debug_notification async
	 * events to the driver as applicable.
	 */
	#define HWRM_DBG_QCFG_OUTPUT_FLAGS_DEBUG_NOTIFY	UINT32_C(0x10)
	/*
	 * If set to 1, firmware is allowed to be unresponsive to heartbeat
	 * health checks, allowing for JTAG debugging scenarios where the
	 * debugger has the firmware processes stopped indefinitely.  This
	 * flag has effect only on debug builds of firmware.
	 */
	#define HWRM_DBG_QCFG_OUTPUT_FLAGS_JTAG_DEBUG		UINT32_C(0x20)
	/*
	 * Notification queue (completion ring) used by the firmware to post
	 * async debug notifications and fw trace logs. This field is valid
	 * when fw_trace, fw_trace_secondary or debug_notify flags are set.
	 */
	uint16_t	async_cmpl_ring;
	uint8_t	unused_2[2];
	/*
	 * Size in bytes of a crashdump file created by the FW.  Uses input
	 * flags to determine medium destination and corresponding size.
	 */
	uint32_t	crashdump_size;
	uint8_t	unused_3[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_dbg_qcfg_output_t, *phwrm_dbg_qcfg_output_t;

/*********************************
 * hwrm_dbg_crashdump_medium_cfg *
 *********************************/


/* hwrm_dbg_crashdump_medium_cfg_input (size:320b/40B) */

typedef struct hwrm_dbg_crashdump_medium_cfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint16_t	output_dest_flags;
	/* Destination is DDR ram. */
	#define HWRM_DBG_CRASHDUMP_MEDIUM_CFG_INPUT_TYPE_DDR	UINT32_C(0x1)
	uint16_t	pg_size_lvl;
	/* PBL indirect levels. */
	#define HWRM_DBG_CRASHDUMP_MEDIUM_CFG_INPUT_LVL_MASK	UINT32_C(0x3)
	#define HWRM_DBG_CRASHDUMP_MEDIUM_CFG_INPUT_LVL_SFT	0
	/* PBL pointer is physical start address. */
		#define HWRM_DBG_CRASHDUMP_MEDIUM_CFG_INPUT_LVL_LVL_0	UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
		#define HWRM_DBG_CRASHDUMP_MEDIUM_CFG_INPUT_LVL_LVL_1	UINT32_C(0x1)
	/*
	 * PBL pointer points to PDE table with each entry pointing to
	 * PTE tables.
	 */
		#define HWRM_DBG_CRASHDUMP_MEDIUM_CFG_INPUT_LVL_LVL_2	UINT32_C(0x2)
		#define HWRM_DBG_CRASHDUMP_MEDIUM_CFG_INPUT_LVL_LAST	HWRM_DBG_CRASHDUMP_MEDIUM_CFG_INPUT_LVL_LVL_2
	/* page size. */
	#define HWRM_DBG_CRASHDUMP_MEDIUM_CFG_INPUT_PG_SIZE_MASK  UINT32_C(0x1c)
	#define HWRM_DBG_CRASHDUMP_MEDIUM_CFG_INPUT_PG_SIZE_SFT   2
	/* 4KB. */
		#define HWRM_DBG_CRASHDUMP_MEDIUM_CFG_INPUT_PG_SIZE_PG_4K   (UINT32_C(0x0) << 2)
	/* 8KB. */
		#define HWRM_DBG_CRASHDUMP_MEDIUM_CFG_INPUT_PG_SIZE_PG_8K   (UINT32_C(0x1) << 2)
	/* 64KB. */
		#define HWRM_DBG_CRASHDUMP_MEDIUM_CFG_INPUT_PG_SIZE_PG_64K  (UINT32_C(0x2) << 2)
	/* 2MB. */
		#define HWRM_DBG_CRASHDUMP_MEDIUM_CFG_INPUT_PG_SIZE_PG_2M   (UINT32_C(0x3) << 2)
	/* 8MB. */
		#define HWRM_DBG_CRASHDUMP_MEDIUM_CFG_INPUT_PG_SIZE_PG_8M   (UINT32_C(0x4) << 2)
	/* 1GB. */
		#define HWRM_DBG_CRASHDUMP_MEDIUM_CFG_INPUT_PG_SIZE_PG_1G   (UINT32_C(0x5) << 2)
		#define HWRM_DBG_CRASHDUMP_MEDIUM_CFG_INPUT_PG_SIZE_LAST   HWRM_DBG_CRASHDUMP_MEDIUM_CFG_INPUT_PG_SIZE_PG_1G
	/* unused11 is 11 b */
	#define HWRM_DBG_CRASHDUMP_MEDIUM_CFG_INPUT_UNUSED11_MASK UINT32_C(0xffe0)
	#define HWRM_DBG_CRASHDUMP_MEDIUM_CFG_INPUT_UNUSED11_SFT  5
	/* Crashdump buffer size. */
	uint32_t	size;
	/*
	 * Bitwise field of components that FW is requested to skip during
	 * coredump as part of a crash collection.
	 */
	uint32_t	coredump_component_disable_flags;
	/*
	 * If 1, then NVM will not be collected during a coredump taken as
	 * part of crash collection.
	 */
	#define HWRM_DBG_CRASHDUMP_MEDIUM_CFG_INPUT_NVRAM	UINT32_C(0x1)
	uint32_t	unused_0;
	/* Crashdump buffer PBL physical address. */
	uint64_t	pbl;
} hwrm_dbg_crashdump_medium_cfg_input_t, *phwrm_dbg_crashdump_medium_cfg_input_t;

/* hwrm_dbg_crashdump_medium_cfg_output (size:128b/16B) */

typedef struct hwrm_dbg_crashdump_medium_cfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_1[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_dbg_crashdump_medium_cfg_output_t, *phwrm_dbg_crashdump_medium_cfg_output_t;

/* coredump_segment_record (size:128b/16B) */

typedef struct coredump_segment_record {
	/* Component id of the returned component. */
	uint16_t	component_id;
	/* Segment id of the returned component. */
	uint16_t	segment_id;
	/* Not used. */
	uint16_t	max_instances;
	/* Major version. */
	uint8_t	version_hi;
	/* Minor version. */
	uint8_t	version_low;
	/*
	 * bit 0: live data
	 * bit 1: crashed data
	 */
	uint8_t	seg_flags;
	/* This field is used to indicate the segment is compressed. */
	uint8_t	compress_flags;
	/*
	 * SFLAG_COMPRESSED_ZLIB indicates that the segment data is
	 * compressed.
	 */
	#define SFLAG_COMPRESSED_ZLIB	UINT32_C(0x1)
	uint8_t	unused_0[2];
	/*
	 * This field is the length of the segment data. It will be zero if
	 * the firmware does not support returning the segment data length.
	 */
	uint32_t	segment_len;
} coredump_segment_record_t, *pcoredump_segment_record_t;

/**************************
 * hwrm_dbg_coredump_list *
 **************************/


/* hwrm_dbg_coredump_list_input (size:256b/32B) */

typedef struct hwrm_dbg_coredump_list_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * host address where the data content will be written
	 * when the request is complete.  This area must be 16B aligned.
	 */
	uint64_t	host_dest_addr;
	/* Length of host buffer used for transferring debug data. */
	uint32_t	host_buf_len;
	/* Sequence number of the request. Starts at 0. */
	uint16_t	seq_no;
	/*  */
	uint8_t	flags;
	/*
	 * If set to 1, crash dump is requested.
	 * If set to 0, both live core and crash dump are requested.
	 */
	#define HWRM_DBG_COREDUMP_LIST_INPUT_FLAGS_CRASHDUMP	UINT32_C(0x1)
	uint8_t	unused_0[1];
} hwrm_dbg_coredump_list_input_t, *phwrm_dbg_coredump_list_input_t;

/* hwrm_dbg_coredump_list_output (size:128b/16B) */

typedef struct hwrm_dbg_coredump_list_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	flags;
	/*
	 * Value of 1 means that there is more data available.
	 * Issue the request again with the next sequence number.
	 */
	#define HWRM_DBG_COREDUMP_LIST_OUTPUT_FLAGS_MORE	UINT32_C(0x1)
	uint8_t	unused_0;
	/* Total number of segments to be returned. */
	uint16_t	total_segments;
	/* Actual length of data returned in bytes. */
	uint16_t	data_len;
	uint8_t	unused_1;
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_dbg_coredump_list_output_t, *phwrm_dbg_coredump_list_output_t;

/******************************
 * hwrm_dbg_coredump_initiate *
 ******************************/


/* hwrm_dbg_coredump_initiate_input (size:256b/32B) */

typedef struct hwrm_dbg_coredump_initiate_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Component id of the returned component. */
	uint16_t	component_id;
	/* Segment id of the returned component. */
	uint16_t	segment_id;
	/* Not used. */
	uint16_t	instance;
	/* Not used. */
	uint16_t	unused_0;
	/*
	 * bit 0: live data
	 * bit 1: crashed data
	 */
	uint8_t	seg_flags;
	/* Not used. */
	uint8_t	unused_1[7];
} hwrm_dbg_coredump_initiate_input_t, *phwrm_dbg_coredump_initiate_input_t;

/* hwrm_dbg_coredump_initiate_output (size:128b/16B) */

typedef struct hwrm_dbg_coredump_initiate_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_dbg_coredump_initiate_output_t, *phwrm_dbg_coredump_initiate_output_t;

/* coredump_data_hdr (size:128b/16B) */

typedef struct coredump_data_hdr {
	/* Starting address of the register range. */
	uint32_t	address;
	/*
	 * length: 0 - 23 bits represents the actual data without the pad.
	 * flags: 24 - 31 bits represents indirect register ranges.
	 *   - bit 24: Set if registers in this segment are indirect accessed.
	 */
	uint32_t	flags_length;
	/* These bits represents the actual length of the data segment */
	#define COREDUMP_DATA_HDR_FLAGS_LENGTH_ACTUAL_LEN_MASK	UINT32_C(0xffffff)
	#define COREDUMP_DATA_HDR_FLAGS_LENGTH_ACTUAL_LEN_SFT	0
	/* Set if registers in this segment are indirect accessed. */
	#define COREDUMP_DATA_HDR_FLAGS_LENGTH_INDIRECT_ACCESS	UINT32_C(0x1000000)
	/* Value in the partner register for indirect or multi-field registers. */
	uint32_t	instance;
	/* Starting address of the next register after the current data range */
	uint32_t	next_offset;
} coredump_data_hdr_t, *pcoredump_data_hdr_t;

/******************************
 * hwrm_dbg_coredump_retrieve *
 ******************************/


/* hwrm_dbg_coredump_retrieve_input (size:448b/56B) */

typedef struct hwrm_dbg_coredump_retrieve_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * host address where the data content will be written
	 * when the request is complete.  This area must be 16B aligned.
	 */
	uint64_t	host_dest_addr;
	/* Length of host buffer used for transferring debug data. */
	uint32_t	host_buf_len;
	/* Not used. */
	uint32_t	unused_0;
	/* Component id of the returned component. */
	uint16_t	component_id;
	/* Segment id of the returned component. */
	uint16_t	segment_id;
	/* Not used. */
	uint16_t	instance;
	/* Not used. */
	uint16_t	unused_1;
	/*
	 * bit 0: live data
	 * bit 1: crashed data
	 */
	uint8_t	seg_flags;
	uint8_t	unused_2;
	uint16_t	unused_3;
	/* Not used. */
	uint32_t	unused_4;
	/* Sequence number is used per segment request. Starts at 0. */
	uint32_t	seq_no;
	uint32_t	unused_5;
} hwrm_dbg_coredump_retrieve_input_t, *phwrm_dbg_coredump_retrieve_input_t;

/* hwrm_dbg_coredump_retrieve_output (size:128b/16B) */

typedef struct hwrm_dbg_coredump_retrieve_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	flags;
	/*
	 * Value of 1 means that there is more data available.
	 * Issue the request again with the next sequence number.
	 */
	#define HWRM_DBG_COREDUMP_RETRIEVE_OUTPUT_FLAGS_MORE	UINT32_C(0x1)
	uint8_t	unused_0;
	/* Actual length of data returned in bytes. */
	uint16_t	data_len;
	uint8_t	unused_1[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_dbg_coredump_retrieve_output_t, *phwrm_dbg_coredump_retrieve_output_t;

/*******************
 * hwrm_dbg_fw_cli *
 *******************/


/* hwrm_dbg_fw_cli_input (size:1024b/128B) */

typedef struct hwrm_dbg_fw_cli_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * Address of the host buffer where debug CLI data
	 * is requested to be dumped.
	 */
	uint64_t	host_dest_addr;
	/* Length of host buffer used for transferring debug data. */
	uint32_t	host_buf_len;
	/* Length of CLI command. */
	uint16_t	cli_cmd_len;
	uint8_t	unused_0[2];
	/* CLI command string, a single ASCII encoded null terminated string. */
	uint8_t	cli_cmd[96];
} hwrm_dbg_fw_cli_input_t, *phwrm_dbg_fw_cli_input_t;

/* hwrm_dbg_fw_cli_output (size:128b/16B) */

typedef struct hwrm_dbg_fw_cli_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Size of debug CLI data returned in bytes. */
	uint32_t	cli_data_len;
	uint8_t	unused_0[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_dbg_fw_cli_output_t, *phwrm_dbg_fw_cli_output_t;

/**************************
 * hwrm_dbg_ring_info_get *
 **************************/


/* hwrm_dbg_ring_info_get_input (size:192b/24B) */

typedef struct hwrm_dbg_ring_info_get_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Ring Type. */
	uint8_t	ring_type;
	/* L2 Completion Ring (CR) */
	#define HWRM_DBG_RING_INFO_GET_INPUT_RING_TYPE_L2_CMPL UINT32_C(0x0)
	/* TX Ring (TR) */
	#define HWRM_DBG_RING_INFO_GET_INPUT_RING_TYPE_TX	UINT32_C(0x1)
	/* RX Ring (RR) */
	#define HWRM_DBG_RING_INFO_GET_INPUT_RING_TYPE_RX	UINT32_C(0x2)
	/* Notification Queue (NQ) */
	#define HWRM_DBG_RING_INFO_GET_INPUT_RING_TYPE_NQ	UINT32_C(0x3)
	#define HWRM_DBG_RING_INFO_GET_INPUT_RING_TYPE_LAST   HWRM_DBG_RING_INFO_GET_INPUT_RING_TYPE_NQ
	uint8_t	unused_0[3];
	/* Firmware ring ID associated with ring being queried. */
	uint32_t	fw_ring_id;
} hwrm_dbg_ring_info_get_input_t, *phwrm_dbg_ring_info_get_input_t;

/* hwrm_dbg_ring_info_get_output (size:192b/24B) */

typedef struct hwrm_dbg_ring_info_get_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Producer index for the queried ring. */
	uint32_t	producer_index;
	/* Consumer index for the queried ring. */
	uint32_t	consumer_index;
	/*
	 * CAG Vector Control for the queried NQ ring.
	 * Not valid for other ring types.
	 */
	uint32_t	cag_vector_ctrl;
	uint8_t	unused_0[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_dbg_ring_info_get_output_t, *phwrm_dbg_ring_info_get_output_t;

/**********************
 * hwrm_dbg_drv_trace *
 **********************/


/* hwrm_dbg_drv_trace_input (size:1024b/128B) */

typedef struct hwrm_dbg_drv_trace_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Severity of the messege. */
	uint8_t	severity;
	/* Fatal */
	#define HWRM_DBG_DRV_TRACE_INPUT_SEVERITY_TRACE_LEVEL_FATAL   UINT32_C(0x0)
	/* Error */
	#define HWRM_DBG_DRV_TRACE_INPUT_SEVERITY_TRACE_LEVEL_ERROR   UINT32_C(0x1)
	/* Warning */
	#define HWRM_DBG_DRV_TRACE_INPUT_SEVERITY_TRACE_LEVEL_WARNING UINT32_C(0x2)
	/* Info */
	#define HWRM_DBG_DRV_TRACE_INPUT_SEVERITY_TRACE_LEVEL_INFO	UINT32_C(0x3)
	/* Debug */
	#define HWRM_DBG_DRV_TRACE_INPUT_SEVERITY_TRACE_LEVEL_DEBUG   UINT32_C(0x4)
	#define HWRM_DBG_DRV_TRACE_INPUT_SEVERITY_LAST		HWRM_DBG_DRV_TRACE_INPUT_SEVERITY_TRACE_LEVEL_DEBUG
	/* Number of bytes to write including terminating 'NULL' if any. */
	uint8_t	write_len;
	uint8_t	unused_0[6];
	/*
	 * This field reprsents the debug data sent by driver
	 * ASCII chars, 'NULL' termination not required.
	 */
	char	trace_data[104];
} hwrm_dbg_drv_trace_input_t, *phwrm_dbg_drv_trace_input_t;

/* hwrm_dbg_drv_trace_output (size:128b/16B) */

typedef struct hwrm_dbg_drv_trace_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_dbg_drv_trace_output_t, *phwrm_dbg_drv_trace_output_t;

/***********************
 * hwrm_dbg_useq_alloc *
 ***********************/


/* hwrm_dbg_useq_alloc_input (size:192b/24B) */

typedef struct hwrm_dbg_useq_alloc_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Number size of the allocation, in bytes, for the USEQ in the code words array */
	uint32_t	size;
	/* Number of bytes executing the USEQ will produce.  Must be a multiple of 4 */
	uint16_t	output_bytes;
	/* This field is reserved */
	uint16_t	unused_0;
} hwrm_dbg_useq_alloc_input_t, *phwrm_dbg_useq_alloc_input_t;

/* hwrm_dbg_useq_alloc_output (size:256b/32B) */

typedef struct hwrm_dbg_useq_alloc_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Non-zero firmware timestamp */
	uint32_t	nz_fw_timestamp;
	/* The last selected USID */
	uint16_t	last_usid;
	/* The number of USEQs currently allocated */
	uint16_t	num_useq_allocd;
	/* A non-zero value indicates data is available for delivery */
	uint8_t	avail;
	/* Current count of the number of full buffers available for delivery */
	uint8_t	full_cnt;
	/* Reserved */
	uint16_t	durh_unused_0;
	/* A non-zero value indicates that all internal buffers are full */
	uint8_t	overflow;
	/* Reserved */
	uint8_t	durh_unused_1[3];
	/* This field is reserved */
	uint32_t	unused_0;
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint32_t	valid;
} hwrm_dbg_useq_alloc_output_t, *phwrm_dbg_useq_alloc_output_t;

/**********************
 * hwrm_dbg_useq_free *
 **********************/


/* hwrm_dbg_useq_free_input (size:192b/24B) */

typedef struct hwrm_dbg_useq_free_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* The USID of the sequence to free */
	uint16_t	usid;
	/* This field is reserved */
	uint8_t	unused_0[6];
} hwrm_dbg_useq_free_input_t, *phwrm_dbg_useq_free_input_t;

/* hwrm_dbg_useq_free_output (size:256b/32B) */

typedef struct hwrm_dbg_useq_free_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Non-zero firmware timestamp */
	uint32_t	nz_fw_timestamp;
	/* The last selected USID */
	uint16_t	last_usid;
	/* The number of USEQs currently allocated */
	uint16_t	num_useq_allocd;
	/* A non-zero value indicates data is available for delivery */
	uint8_t	avail;
	/* Current count of the number of full buffers available for delivery */
	uint8_t	full_cnt;
	/* Reserved */
	uint16_t	durh_unused_0;
	/* A non-zero value indicates that all internal buffers are full */
	uint8_t	overflow;
	/* Reserved */
	uint8_t	durh_unused_1[3];
	/* This field is reserved */
	uint32_t	unused_0;
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint32_t	valid;
} hwrm_dbg_useq_free_output_t, *phwrm_dbg_useq_free_output_t;

/***********************
 * hwrm_dbg_useq_flush *
 ***********************/


/* hwrm_dbg_useq_flush_input (size:192b/24B) */

typedef struct hwrm_dbg_useq_flush_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Bitwise flags described below */
	uint16_t	flags;
	/* Flush all USEQ code words, resetting all USIDs to invalid */
	#define HWRM_DBG_USEQ_FLUSH_INPUT_USEQ_CODE_WORDS UINT32_C(0x1)
	/* Initialize all buffers, clearing out any collected data */
	#define HWRM_DBG_USEQ_FLUSH_INPUT_BUFFERS	UINT32_C(0x2)
	#define HWRM_DBG_USEQ_FLUSH_INPUT_LAST	HWRM_DBG_USEQ_FLUSH_INPUT_BUFFERS
	/* This field is reserved */
	uint8_t	unused_0[6];
} hwrm_dbg_useq_flush_input_t, *phwrm_dbg_useq_flush_input_t;

/* hwrm_dbg_useq_flush_output (size:256b/32B) */

typedef struct hwrm_dbg_useq_flush_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Non-zero firmware timestamp */
	uint32_t	nz_fw_timestamp;
	/* The last selected USID */
	uint16_t	last_usid;
	/* The number of USEQs currently allocated */
	uint16_t	num_useq_allocd;
	/* A non-zero value indicates data is available for delivery */
	uint8_t	avail;
	/* Current count of the number of full buffers available for delivery */
	uint8_t	full_cnt;
	/* Reserved */
	uint16_t	durh_unused_0;
	/* A non-zero value indicates that all internal buffers are full */
	uint8_t	overflow;
	/* Reserved */
	uint8_t	durh_unused_1[3];
	/* This field is reserved */
	uint32_t	unused_0;
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint32_t	valid;
} hwrm_dbg_useq_flush_output_t, *phwrm_dbg_useq_flush_output_t;

/***********************
 * hwrm_dbg_useq_qcaps *
 ***********************/


/* hwrm_dbg_useq_qcaps_input (size:128b/16B) */

typedef struct hwrm_dbg_useq_qcaps_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
} hwrm_dbg_useq_qcaps_input_t, *phwrm_dbg_useq_qcaps_input_t;

/* hwrm_dbg_useq_qcaps_output (size:384b/48B) */

typedef struct hwrm_dbg_useq_qcaps_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Non-zero firmware timestamp */
	uint32_t	nz_fw_timestamp;
	/* The last selected USID */
	uint16_t	last_usid;
	/* The number of USEQs currently allocated */
	uint16_t	num_useq_allocd;
	/* A non-zero value indicates data is available for delivery */
	uint8_t	avail;
	/* Current count of the number of full buffers available for delivery */
	uint8_t	full_cnt;
	/* Reserved */
	uint16_t	durh_unused_0;
	/* A non-zero value indicates that all internal buffers are full */
	uint8_t	overflow;
	/* Reserved */
	uint8_t	durh_unused_1[3];
	/* Maximum number of USEQ that can be tracked by firmware */
	uint32_t	max_num_useq;
	/* Maximum number of code words for a single USEQ */
	uint32_t	max_useq_len;
	/* The maximum number of 32-bit words a single USEQ may generate */
	uint32_t	max_useq_32b_output_words;
	/* The number of internal USEQ output buffers, each of 4096 bytes */
	uint32_t	num_buf;
	/* This field is reserved */
	uint32_t	unused_0;
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint32_t	valid;
} hwrm_dbg_useq_qcaps_output_t, *phwrm_dbg_useq_qcaps_output_t;

/***************************
 * hwrm_dbg_useq_sched_cfg *
 ***************************/


/* hwrm_dbg_useq_sched_cfg_input (size:192b/24B) */

typedef struct hwrm_dbg_useq_sched_cfg_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Enumeration values for enabling, disabling scheduler */
	uint16_t	global_cfg;
	/* This value will leave the global scheduler in its current state */
	#define HWRM_DBG_USEQ_SCHED_CFG_INPUT_NO_CHANGE UINT32_C(0x0)
	/*
	 * This value disables the global scheduler.  This mode must be used
	 * when the RUN command is being used to run individual sequences.
	 */
	#define HWRM_DBG_USEQ_SCHED_CFG_INPUT_DISABLE   UINT32_C(0x1)
	/*
	 * This value enables the global scheduler.  When enabled, USEQs will
	 * be scheduled based on their polling intervals
	 */
	#define HWRM_DBG_USEQ_SCHED_CFG_INPUT_ENABLE	UINT32_C(0x2)
	#define HWRM_DBG_USEQ_SCHED_CFG_INPUT_LAST	HWRM_DBG_USEQ_SCHED_CFG_INPUT_ENABLE
	/*
	 * The given polling interval will be associated with this USID.  A value
	 * of -1 indicates that the USID is invalid.  The invalid USID is used when
	 * using this message only for global scheduler configuration.
	 */
	uint16_t	usid;
	/* This value represents microseconds between runs of the USEQ */
	uint32_t	polling_interval;
} hwrm_dbg_useq_sched_cfg_input_t, *phwrm_dbg_useq_sched_cfg_input_t;

/* hwrm_dbg_useq_sched_cfg_output (size:256b/32B) */

typedef struct hwrm_dbg_useq_sched_cfg_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Non-zero firmware timestamp */
	uint32_t	nz_fw_timestamp;
	/* The last selected USID */
	uint16_t	last_usid;
	/* The number of USEQs currently allocated */
	uint16_t	num_useq_allocd;
	/* A non-zero value indicates data is available for delivery */
	uint8_t	avail;
	/* Current count of the number of full buffers available for delivery */
	uint8_t	full_cnt;
	/* Reserved */
	uint16_t	durh_unused_0;
	/* A non-zero value indicates that all internal buffers are full */
	uint8_t	overflow;
	/* Reserved */
	uint8_t	durh_unused_1[3];
	/* This field is reserved */
	uint32_t	unused_0;
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint32_t	valid;
} hwrm_dbg_useq_sched_cfg_output_t, *phwrm_dbg_useq_sched_cfg_output_t;

/*********************
 * hwrm_dbg_useq_run *
 *********************/


/* hwrm_dbg_useq_run_input (size:320b/40B) */

typedef struct hwrm_dbg_useq_run_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* The USID to be run */
	uint16_t	usid;
	/* Type of run to execute for the given USID */
	uint8_t	run_type;
	/* This run type will execute the requested USEQ only a single time */
	#define HWRM_DBG_USEQ_RUN_INPUT_RUN_TYPE_SINGLE   UINT32_C(0x0)
	/*
	 * This run type will execute the requested USEQ a number of times given
	 * by run_cnt with a run interval given by the run_interval parameter.
	 */
	#define HWRM_DBG_USEQ_RUN_INPUT_RUN_TYPE_CNT	UINT32_C(0x1)
	/*
	 * This run type will execute the requested USEQ as many times as it needs
	 * to fill an entire buffer to return to the host.  The runs will occur
	 * with a run interval given by the run_interval parameter.
	 */
	#define HWRM_DBG_USEQ_RUN_INPUT_RUN_TYPE_FILL_BUF UINT32_C(0x2)
	#define HWRM_DBG_USEQ_RUN_INPUT_RUN_TYPE_LAST	HWRM_DBG_USEQ_RUN_INPUT_RUN_TYPE_FILL_BUF
	/*
	 * If indicated by flags, this represents the number of times to run the USEQ.
	 * Note that runs are stopped if the buffer fills prior regardless of the
	 * number of runs.  For example, if a run_cnt of 10 is specified and 3 runs
	 * results in the buffer being full then only 3 runs are executed.
	 */
	uint8_t	run_cnt;
	/*
	 * This value represents microseconds between runs of the USEQ when running
	 * multiple times as indicated by flags.
	 */
	uint32_t	run_interval;
	/* Address of the host buffer where collected USEQ output data will be placed */
	uint64_t	host_dest_addr;
	/*
	 * Size, in bytes, of the memory associated with host_dest_addr.  It is expected
	 * that this is >= 4096
	 */
	uint32_t	host_dest_len;
	/* This field is reserved */
	uint32_t	unused_0;
} hwrm_dbg_useq_run_input_t, *phwrm_dbg_useq_run_input_t;

/* hwrm_dbg_useq_run_output (size:256b/32B) */

typedef struct hwrm_dbg_useq_run_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Non-zero firmware timestamp */
	uint32_t	nz_fw_timestamp;
	/* The last selected USID */
	uint16_t	last_usid;
	/* The number of USEQs currently allocated */
	uint16_t	num_useq_allocd;
	/* A non-zero value indicates data is available for delivery */
	uint8_t	avail;
	/* Current count of the number of full buffers available for delivery */
	uint8_t	full_cnt;
	/* Reserved */
	uint16_t	durh_unused_0;
	/* A non-zero value indicates that all internal buffers are full */
	uint8_t	overflow;
	/* Reserved */
	uint8_t	durh_unused_1[3];
	/*
	 * The length, in bytes, of the amount of data placed in the corresponding
	 * host_dest_addr given in the input message.  This will always be a multiple
	 * of 4096
	 */
	uint32_t	host_dest_filled_len;
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint32_t	valid;
} hwrm_dbg_useq_run_output_t, *phwrm_dbg_useq_run_output_t;

/******************************
 * hwrm_dbg_useq_delivery_req *
 ******************************/


/* hwrm_dbg_useq_delivery_req_input (size:896b/112B) */

typedef struct hwrm_dbg_useq_delivery_req_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * Eight destination addresses provide host memory space for FW to deliver
	 * USEQ output details.  A value of 0x0 for the address can be used to
	 * inform FW that the buffer is not available.
	 */
	uint64_t	host_dest_addrs[8];
	/*
	 * The length, in bytes, of the corresponding host_dest_addrs array entry.  Each
	 * valid hist_dest_addrs entry must have a len of at least 4096 bytes
	 */
	uint32_t	host_dest_len[8];
} hwrm_dbg_useq_delivery_req_input_t, *phwrm_dbg_useq_delivery_req_input_t;

/* hwrm_dbg_useq_delivery_req_output (size:512b/64B) */

typedef struct hwrm_dbg_useq_delivery_req_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Non-zero firmware timestamp */
	uint32_t	nz_fw_timestamp;
	/* The last selected USID */
	uint16_t	last_usid;
	/* The number of USEQs currently allocated */
	uint16_t	num_useq_allocd;
	/* A non-zero value indicates data is available for delivery */
	uint8_t	avail;
	/* Current count of the number of full buffers available for delivery */
	uint8_t	full_cnt;
	/* Reserved */
	uint16_t	durh_unused_0;
	/* A non-zero value indicates that all internal buffers are full */
	uint8_t	overflow;
	/* Reserved */
	uint8_t	durh_unused_1[3];
	/*
	 * The length, in bytes, of the amount of data placed in the corresponding
	 * host_dest_addrs entry given in the input message.  This will always be a
	 * multiple of 4096
	 */
	uint32_t	host_dest_filled_len[8];
	/* This field is reserved */
	uint32_t	unused_0;
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint32_t	valid;
} hwrm_dbg_useq_delivery_req_output_t, *phwrm_dbg_useq_delivery_req_output_t;

/**************************
 * hwrm_nvm_raw_write_blk *
 **************************/


/* hwrm_nvm_raw_write_blk_input (size:256b/32B) */

typedef struct hwrm_nvm_raw_write_blk_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * 64-bit Host Source Address.
	 * This is the location of the source data to be written.
	 */
	uint64_t	host_src_addr;
	/*
	 * 32-bit Destination Address.
	 * This is the NVRAM byte-offset where the source data will be written to.
	 */
	uint32_t	dest_addr;
	/* Length of data to be written, in bytes. */
	uint32_t	len;
} hwrm_nvm_raw_write_blk_input_t, *phwrm_nvm_raw_write_blk_input_t;

/* hwrm_nvm_raw_write_blk_output (size:128b/16B) */

typedef struct hwrm_nvm_raw_write_blk_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_nvm_raw_write_blk_output_t, *phwrm_nvm_raw_write_blk_output_t;

/*****************
 * hwrm_nvm_read *
 *****************/


/* hwrm_nvm_read_input (size:320b/40B) */

typedef struct hwrm_nvm_read_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * 64-bit Host Destination Address.
	 * This is the host address where the data will be written to.
	 */
	uint64_t	host_dest_addr;
	/* The 0-based index of the directory entry. */
	uint16_t	dir_idx;
	uint8_t	unused_0[2];
	/* The NVRAM byte-offset to read from. */
	uint32_t	offset;
	/* The length of the data to be read, in bytes. */
	uint32_t	len;
	uint8_t	unused_1[4];
} hwrm_nvm_read_input_t, *phwrm_nvm_read_input_t;

/* hwrm_nvm_read_output (size:128b/16B) */

typedef struct hwrm_nvm_read_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_nvm_read_output_t, *phwrm_nvm_read_output_t;

/*********************
 * hwrm_nvm_raw_dump *
 *********************/


/* hwrm_nvm_raw_dump_input (size:256b/32B) */

typedef struct hwrm_nvm_raw_dump_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * 64-bit Host Destination Address.
	 * This is the host address where the data will be written to.
	 */
	uint64_t	host_dest_addr;
	/* 32-bit NVRAM byte-offset to read from. */
	uint32_t	offset;
	/* Total length of NVRAM contents to be read, in bytes. */
	uint32_t	len;
} hwrm_nvm_raw_dump_input_t, *phwrm_nvm_raw_dump_input_t;

/* hwrm_nvm_raw_dump_output (size:128b/16B) */

typedef struct hwrm_nvm_raw_dump_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_nvm_raw_dump_output_t, *phwrm_nvm_raw_dump_output_t;

/****************************
 * hwrm_nvm_get_dir_entries *
 ****************************/


/* hwrm_nvm_get_dir_entries_input (size:192b/24B) */

typedef struct hwrm_nvm_get_dir_entries_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * 64-bit Host Destination Address.
	 * This is the host address where the directory will be written.
	 */
	uint64_t	host_dest_addr;
} hwrm_nvm_get_dir_entries_input_t, *phwrm_nvm_get_dir_entries_input_t;

/* hwrm_nvm_get_dir_entries_output (size:128b/16B) */

typedef struct hwrm_nvm_get_dir_entries_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_nvm_get_dir_entries_output_t, *phwrm_nvm_get_dir_entries_output_t;

/*************************
 * hwrm_nvm_get_dir_info *
 *************************/


/* hwrm_nvm_get_dir_info_input (size:128b/16B) */

typedef struct hwrm_nvm_get_dir_info_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
} hwrm_nvm_get_dir_info_input_t, *phwrm_nvm_get_dir_info_input_t;

/* hwrm_nvm_get_dir_info_output (size:192b/24B) */

typedef struct hwrm_nvm_get_dir_info_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Number of directory entries in the directory. */
	uint32_t	entries;
	/* Size of each directory entry, in bytes. */
	uint32_t	entry_length;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_nvm_get_dir_info_output_t, *phwrm_nvm_get_dir_info_output_t;

/******************
 * hwrm_nvm_write *
 ******************/


/* hwrm_nvm_write_input (size:384b/48B) */

typedef struct hwrm_nvm_write_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * 64-bit Host Source Address.
	 * This is where the source data is.
	 */
	uint64_t	host_src_addr;
	/* The Directory Entry Type (valid values are defined in the bnxnvm_directory_type enum defined in the file bnxnvm_defs.h). */
	uint16_t	dir_type;
	/*
	 * Directory ordinal.
	 * The 0-based instance of the combined Directory Entry Type and Extension.
	 */
	uint16_t	dir_ordinal;
	/* The Directory Entry Extension flags (see BNX_DIR_EXT_* in the file bnxnvm_defs.h). */
	uint16_t	dir_ext;
	/* Directory Entry Attribute flags (see BNX_DIR_ATTR_* in the file bnxnvm_defs.h). */
	uint16_t	dir_attr;
	/*
	 * Length of data to write, in bytes. May be less than or equal to the allocated size for the directory entry.
	 * The data length stored in the directory entry will be updated to reflect this value once the write is complete.
	 */
	uint32_t	dir_data_length;
	/* Option. */
	uint16_t	option;
	uint16_t	flags;
	/*
	 * When this bit is '1', the original active image
	 * will not be removed. TBD: what purpose is this?
	 */
	#define HWRM_NVM_WRITE_INPUT_FLAGS_KEEP_ORIG_ACTIVE_IMG	UINT32_C(0x1)
	/*
	 * The requested length of the allocated NVM for the item, in bytes. This value may be greater than or equal to the specified data length (dir_data_length).
	 * If this value is less than the specified data length, it will be ignored.
	 * The response will contain the actual allocated item length, which may be greater than the requested item length.
	 * The purpose for allocating more than the required number of bytes for an item's data is to pre-allocate extra storage (padding) to accommodate
	 * the potential future growth of an item (e.g. upgraded firmware with a size increase, log growth, expanded configuration data).
	 */
	uint32_t	dir_item_length;
	uint32_t	unused_0;
} hwrm_nvm_write_input_t, *phwrm_nvm_write_input_t;

/* hwrm_nvm_write_output (size:128b/16B) */

typedef struct hwrm_nvm_write_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * Length of the allocated NVM for the item, in bytes. The value may be greater than or equal to the specified data length or the requested item length.
	 * The actual item length used when creating a new directory entry will be a multiple of an NVM block size.
	 */
	uint32_t	dir_item_length;
	/* The directory index of the created or modified item. */
	uint16_t	dir_idx;
	uint8_t	unused_0;
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_nvm_write_output_t, *phwrm_nvm_write_output_t;

/* hwrm_nvm_write_cmd_err (size:64b/8B) */

typedef struct hwrm_nvm_write_cmd_err {
	/*
	 * command specific error codes that goes to
	 * the cmd_err field in Common HWRM Error Response.
	 */
	uint8_t	code;
	/* Unknown error */
	#define HWRM_NVM_WRITE_CMD_ERR_CODE_UNKNOWN  UINT32_C(0x0)
	/* Unable to complete operation due to fragmentation */
	#define HWRM_NVM_WRITE_CMD_ERR_CODE_FRAG_ERR UINT32_C(0x1)
	/* nvm is completely full. */
	#define HWRM_NVM_WRITE_CMD_ERR_CODE_NO_SPACE UINT32_C(0x2)
	#define HWRM_NVM_WRITE_CMD_ERR_CODE_LAST	HWRM_NVM_WRITE_CMD_ERR_CODE_NO_SPACE
	uint8_t	unused_0[7];
} hwrm_nvm_write_cmd_err_t, *phwrm_nvm_write_cmd_err_t;

/*******************
 * hwrm_nvm_modify *
 *******************/


/* hwrm_nvm_modify_input (size:320b/40B) */

typedef struct hwrm_nvm_modify_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * 64-bit Host Source Address.
	 * This is where the modified data is.
	 */
	uint64_t	host_src_addr;
	/* 16-bit directory entry index. */
	uint16_t	dir_idx;
	uint16_t	flags;
	/*
	 * This flag indicates the sender wants to modify a continuous NVRAM
	 * area using a batch of this HWRM requests. The offset of a request
	 * must be continuous to the end of previous request's. Firmware does
	 * not update the directory entry until receiving the last request,
	 * which is indicated by the batch_last flag.
	 * This flag is set usually when a sender does not have a block of
	 * memory that is big enough to hold the entire NVRAM data for send
	 * at one time.
	 */
	#define HWRM_NVM_MODIFY_INPUT_FLAGS_BATCH_MODE	UINT32_C(0x1)
	/*
	 * This flag can be used only when the batch_mode flag is set.
	 * It indicates this request is the last of batch requests.
	 */
	#define HWRM_NVM_MODIFY_INPUT_FLAGS_BATCH_LAST	UINT32_C(0x2)
	/* 32-bit NVRAM byte-offset to modify content from. */
	uint32_t	offset;
	/*
	 * Length of data to be modified, in bytes. The length shall
	 * be non-zero.
	 */
	uint32_t	len;
	uint8_t	unused_1[4];
} hwrm_nvm_modify_input_t, *phwrm_nvm_modify_input_t;

/* hwrm_nvm_modify_output (size:128b/16B) */

typedef struct hwrm_nvm_modify_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_nvm_modify_output_t, *phwrm_nvm_modify_output_t;

/***************************
 * hwrm_nvm_find_dir_entry *
 ***************************/


/* hwrm_nvm_find_dir_entry_input (size:256b/32B) */

typedef struct hwrm_nvm_find_dir_entry_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	enables;
	/*
	 * This bit must be '1' for the dir_idx_valid field to be
	 * configured.
	 */
	#define HWRM_NVM_FIND_DIR_ENTRY_INPUT_ENABLES_DIR_IDX_VALID	UINT32_C(0x1)
	/* Directory Entry Index */
	uint16_t	dir_idx;
	/* Directory Entry (Image) Type */
	uint16_t	dir_type;
	/*
	 * Directory ordinal.
	 * The instance of this Directory Type
	 */
	uint16_t	dir_ordinal;
	/* The Directory Entry Extension flags. */
	uint16_t	dir_ext;
	/* This value indicates the search option using dir_ordinal. */
	uint8_t	opt_ordinal;
	/* This value indicates the search option using dir_ordinal. */
	#define HWRM_NVM_FIND_DIR_ENTRY_INPUT_OPT_ORDINAL_MASK UINT32_C(0x3)
	#define HWRM_NVM_FIND_DIR_ENTRY_INPUT_OPT_ORDINAL_SFT 0
	/* Equal to specified ordinal value. */
		#define HWRM_NVM_FIND_DIR_ENTRY_INPUT_OPT_ORDINAL_EQ	UINT32_C(0x0)
	/* Greater than or equal to specified ordinal value */
		#define HWRM_NVM_FIND_DIR_ENTRY_INPUT_OPT_ORDINAL_GE	UINT32_C(0x1)
	/* Greater than specified ordinal value */
		#define HWRM_NVM_FIND_DIR_ENTRY_INPUT_OPT_ORDINAL_GT	UINT32_C(0x2)
		#define HWRM_NVM_FIND_DIR_ENTRY_INPUT_OPT_ORDINAL_LAST HWRM_NVM_FIND_DIR_ENTRY_INPUT_OPT_ORDINAL_GT
	uint8_t	unused_0[3];
} hwrm_nvm_find_dir_entry_input_t, *phwrm_nvm_find_dir_entry_input_t;

/* hwrm_nvm_find_dir_entry_output (size:256b/32B) */

typedef struct hwrm_nvm_find_dir_entry_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Allocated NVRAM for this directory entry, in bytes. */
	uint32_t	dir_item_length;
	/* Size of the stored data for this directory entry, in bytes. */
	uint32_t	dir_data_length;
	/*
	 * Firmware version.
	 * Only valid if the directory entry is for embedded firmware stored in APE_BIN Format.
	 */
	uint32_t	fw_ver;
	/* Directory ordinal. */
	uint16_t	dir_ordinal;
	/* Directory Entry Index */
	uint16_t	dir_idx;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_nvm_find_dir_entry_output_t, *phwrm_nvm_find_dir_entry_output_t;

/****************************
 * hwrm_nvm_erase_dir_entry *
 ****************************/


/* hwrm_nvm_erase_dir_entry_input (size:192b/24B) */

typedef struct hwrm_nvm_erase_dir_entry_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Directory Entry Index */
	uint16_t	dir_idx;
	uint8_t	unused_0[6];
} hwrm_nvm_erase_dir_entry_input_t, *phwrm_nvm_erase_dir_entry_input_t;

/* hwrm_nvm_erase_dir_entry_output (size:128b/16B) */

typedef struct hwrm_nvm_erase_dir_entry_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_nvm_erase_dir_entry_output_t, *phwrm_nvm_erase_dir_entry_output_t;

/*************************
 * hwrm_nvm_get_dev_info *
 *************************/


/* hwrm_nvm_get_dev_info_input (size:128b/16B) */

typedef struct hwrm_nvm_get_dev_info_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
} hwrm_nvm_get_dev_info_input_t, *phwrm_nvm_get_dev_info_input_t;

/* hwrm_nvm_get_dev_info_output (size:640b/80B) */

typedef struct hwrm_nvm_get_dev_info_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* Manufacturer ID. */
	uint16_t	manufacturer_id;
	/* Device ID. */
	uint16_t	device_id;
	/* Sector size of the NVRAM device. */
	uint32_t	sector_size;
	/* Total size, in bytes of the NVRAM device. */
	uint32_t	nvram_size;
	uint32_t	reserved_size;
	/* Available size that can be used, in bytes.  Available size is the NVRAM size take away the used size and reserved size. */
	uint32_t	available_size;
	/* This field represents the major version of NVM cfg */
	uint8_t	nvm_cfg_ver_maj;
	/* This field represents the minor version of NVM cfg */
	uint8_t	nvm_cfg_ver_min;
	/* This field represents the update version of NVM cfg */
	uint8_t	nvm_cfg_ver_upd;
	uint8_t	flags;
	/*
	 * If set to 1, firmware will provide various firmware version
	 * information stored in the flash.
	 */
	#define HWRM_NVM_GET_DEV_INFO_OUTPUT_FLAGS_FW_VER_VALID	UINT32_C(0x1)
	/*
	 * This field represents the board package name stored in the flash.
	 * (ASCII chars with NULL at the end).
	 */
	char	pkg_name[16];
	/*
	 * This field represents the major version of HWRM firmware, stored in
	 * the flash.
	 */
	uint16_t	hwrm_fw_major;
	/*
	 * This field represents the minor version of HWRM firmware, stored in
	 * the flash.
	 */
	uint16_t	hwrm_fw_minor;
	/*
	 * This field represents the build version of HWRM firmware, stored in
	 * the flash.
	 */
	uint16_t	hwrm_fw_build;
	/*
	 * This field can be used to represent firmware branches or customer
	 * specific releases tied to a specific (major, minor, build) version
	 * of the HWRM firmware.
	 */
	uint16_t	hwrm_fw_patch;
	/*
	 * This field represents the major version of mgmt firmware, stored in
	 * the flash.
	 */
	uint16_t	mgmt_fw_major;
	/*
	 * This field represents the minor version of mgmt firmware, stored in
	 * the flash.
	 */
	uint16_t	mgmt_fw_minor;
	/*
	 * This field represents the build version of mgmt firmware, stored in
	 * the flash.
	 */
	uint16_t	mgmt_fw_build;
	/*
	 * This field can be used to represent firmware branches or customer
	 * specific releases tied to a specific (major, minor, build) version
	 * of the mgmt firmware.
	 */
	uint16_t	mgmt_fw_patch;
	/*
	 * This field represents the major version of roce firmware, stored in
	 * the flash.
	 */
	uint16_t	roce_fw_major;
	/*
	 * This field represents the minor version of roce firmware, stored in
	 * the flash.
	 */
	uint16_t	roce_fw_minor;
	/*
	 * This field represents the build version of roce firmware, stored in
	 * the flash.
	 */
	uint16_t	roce_fw_build;
	/*
	 * This field can be used to represent firmware branches or customer
	 * specific releases tied to a specific (major, minor, build) version
	 * of the roce firmware.
	 */
	uint16_t	roce_fw_patch;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_nvm_get_dev_info_output_t, *phwrm_nvm_get_dev_info_output_t;

/**************************
 * hwrm_nvm_mod_dir_entry *
 **************************/


/* hwrm_nvm_mod_dir_entry_input (size:256b/32B) */

typedef struct hwrm_nvm_mod_dir_entry_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	enables;
	/*
	 * This bit must be '1' for the checksum field to be
	 * configured.
	 */
	#define HWRM_NVM_MOD_DIR_ENTRY_INPUT_ENABLES_CHECKSUM	UINT32_C(0x1)
	/* Directory Entry Index */
	uint16_t	dir_idx;
	/*
	 * Directory ordinal.
	 * The (0-based) instance of this Directory Type.
	 */
	uint16_t	dir_ordinal;
	/* The Directory Entry Extension flags (see BNX_DIR_EXT_* for extension flag definitions). */
	uint16_t	dir_ext;
	/* Directory Entry Attribute flags (see BNX_DIR_ATTR_* for attribute flag definitions). */
	uint16_t	dir_attr;
	/*
	 * If valid, then this field updates the checksum
	 * value of the content in the directory entry.
	 */
	uint32_t	checksum;
} hwrm_nvm_mod_dir_entry_input_t, *phwrm_nvm_mod_dir_entry_input_t;

/* hwrm_nvm_mod_dir_entry_output (size:128b/16B) */

typedef struct hwrm_nvm_mod_dir_entry_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_nvm_mod_dir_entry_output_t, *phwrm_nvm_mod_dir_entry_output_t;

/**************************
 * hwrm_nvm_verify_update *
 **************************/


/* hwrm_nvm_verify_update_input (size:192b/24B) */

typedef struct hwrm_nvm_verify_update_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/* Directory Entry Type, to be verified. */
	uint16_t	dir_type;
	/*
	 * Directory ordinal.
	 * The instance of the Directory Type to be verified.
	 */
	uint16_t	dir_ordinal;
	/*
	 * The Directory Entry Extension flags.
	 * The "UPDATE" extension flag must be set in this value.
	 * A corresponding directory entry with the same type and ordinal values but *without*
	 * the "UPDATE" extension flag must also exist. The other flags of the extension must
	 * be identical between the active and update entries.
	 */
	uint16_t	dir_ext;
	uint8_t	unused_0[2];
} hwrm_nvm_verify_update_input_t, *phwrm_nvm_verify_update_input_t;

/* hwrm_nvm_verify_update_output (size:128b/16B) */

typedef struct hwrm_nvm_verify_update_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_nvm_verify_update_output_t, *phwrm_nvm_verify_update_output_t;

/***************************
 * hwrm_nvm_install_update *
 ***************************/


/* hwrm_nvm_install_update_input (size:192b/24B) */

typedef struct hwrm_nvm_install_update_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * Installation type. If the value 3 through 0xffff is used,
	 * only packaged items with that type value will be installed and
	 * conditional installation directives for those packaged items
	 * will be over-ridden (i.e. 'create' or 'replace' will be treated
	 * as 'install').
	 */
	uint32_t	install_type;
	/*
	 * Perform a normal package installation. Conditional installation
	 * directives (e.g. 'create' and 'replace') of packaged items
	 * will be followed.
	 */
	#define HWRM_NVM_INSTALL_UPDATE_INPUT_INSTALL_TYPE_NORMAL UINT32_C(0x0)
	/*
	 * Install all packaged items regardless of installation directive
	 * (i.e. treat all packaged items as though they have an installation
	 * directive of 'install').
	 */
	#define HWRM_NVM_INSTALL_UPDATE_INPUT_INSTALL_TYPE_ALL	UINT32_C(0xffffffff)
	#define HWRM_NVM_INSTALL_UPDATE_INPUT_INSTALL_TYPE_LAST  HWRM_NVM_INSTALL_UPDATE_INPUT_INSTALL_TYPE_ALL
	uint16_t	flags;
	/* If set to 1, then securely erase all unused locations in persistent storage. */
	#define HWRM_NVM_INSTALL_UPDATE_INPUT_FLAGS_ERASE_UNUSED_SPACE	UINT32_C(0x1)
	/*
	 * If set to 1, then unspecified images, images not in the package file, will be safely deleted.
	 * When combined with erase_unused_space then unspecified images will be securely erased.
	 */
	#define HWRM_NVM_INSTALL_UPDATE_INPUT_FLAGS_REMOVE_UNUSED_PKG	UINT32_C(0x2)
	/*
	 * If set to 1, FW will defragment the NVM if defragmentation is required for the update.
	 * Allow additional time for this command to complete if this bit is set to 1.
	 */
	#define HWRM_NVM_INSTALL_UPDATE_INPUT_FLAGS_ALLOWED_TO_DEFRAG	UINT32_C(0x4)
	/*
	 * If set to 1, FW will verify the package in the "UPDATE" NVM item
	 * without installing it. This flag is for FW internal use only.
	 * Users should not set this flag. The request will otherwise fail.
	 */
	#define HWRM_NVM_INSTALL_UPDATE_INPUT_FLAGS_VERIFY_ONLY		UINT32_C(0x8)
	uint8_t	unused_0[2];
} hwrm_nvm_install_update_input_t, *phwrm_nvm_install_update_input_t;

/* hwrm_nvm_install_update_output (size:192b/24B) */

typedef struct hwrm_nvm_install_update_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/*
	 * Bit-mask of successfully installed items.
	 * Bit-0 corresponding to the first packaged item, Bit-1 for the second item, etc.
	 * A value of 0 indicates that no items were successfully installed.
	 */
	uint64_t	installed_items;
	/* result is 8 b */
	uint8_t	result;
	/* There was no problem with the package installation. */
	#define HWRM_NVM_INSTALL_UPDATE_OUTPUT_RESULT_SUCCESS UINT32_C(0x0)
	#define HWRM_NVM_INSTALL_UPDATE_OUTPUT_RESULT_LAST   HWRM_NVM_INSTALL_UPDATE_OUTPUT_RESULT_SUCCESS
	/* problem_item is 8 b */
	uint8_t	problem_item;
	/* There was no problem with any packaged items. */
	#define HWRM_NVM_INSTALL_UPDATE_OUTPUT_PROBLEM_ITEM_NONE	UINT32_C(0x0)
	/* There was a problem with the NVM package itself. */
	#define HWRM_NVM_INSTALL_UPDATE_OUTPUT_PROBLEM_ITEM_PACKAGE UINT32_C(0xff)
	#define HWRM_NVM_INSTALL_UPDATE_OUTPUT_PROBLEM_ITEM_LAST   HWRM_NVM_INSTALL_UPDATE_OUTPUT_PROBLEM_ITEM_PACKAGE
	/* reset_required is 8 b */
	uint8_t	reset_required;
	/*
	 * No reset is required for installed/updated firmware or
	 * microcode to take effect.
	 */
	#define HWRM_NVM_INSTALL_UPDATE_OUTPUT_RESET_REQUIRED_NONE  UINT32_C(0x0)
	/*
	 * A PCIe reset (e.g. system reboot) is
	 * required for newly installed/updated firmware or
	 * microcode to take effect.
	 */
	#define HWRM_NVM_INSTALL_UPDATE_OUTPUT_RESET_REQUIRED_PCI   UINT32_C(0x1)
	/*
	 * A controller power reset (e.g. system power-cycle) is
	 * required for newly installed/updated firmware or
	 * microcode to take effect. Some newly installed/updated
	 * firmware or microcode may still take effect upon the
	 * next PCIe reset.
	 */
	#define HWRM_NVM_INSTALL_UPDATE_OUTPUT_RESET_REQUIRED_POWER UINT32_C(0x2)
	#define HWRM_NVM_INSTALL_UPDATE_OUTPUT_RESET_REQUIRED_LAST HWRM_NVM_INSTALL_UPDATE_OUTPUT_RESET_REQUIRED_POWER
	uint8_t	unused_0[4];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_nvm_install_update_output_t, *phwrm_nvm_install_update_output_t;

/* hwrm_nvm_install_update_cmd_err (size:64b/8B) */

typedef struct hwrm_nvm_install_update_cmd_err {
	/*
	 * command specific error codes that goes to
	 * the cmd_err field in Common HWRM Error Response.
	 */
	uint8_t	code;
	/* Unknown error */
	#define HWRM_NVM_INSTALL_UPDATE_CMD_ERR_CODE_UNKNOWN  UINT32_C(0x0)
	/* Unable to complete operation due to fragmentation */
	#define HWRM_NVM_INSTALL_UPDATE_CMD_ERR_CODE_FRAG_ERR UINT32_C(0x1)
	/* nvm is completely full. */
	#define HWRM_NVM_INSTALL_UPDATE_CMD_ERR_CODE_NO_SPACE UINT32_C(0x2)
	#define HWRM_NVM_INSTALL_UPDATE_CMD_ERR_CODE_LAST	HWRM_NVM_INSTALL_UPDATE_CMD_ERR_CODE_NO_SPACE
	uint8_t	unused_0[7];
} hwrm_nvm_install_update_cmd_err_t, *phwrm_nvm_install_update_cmd_err_t;

/******************
 * hwrm_nvm_flush *
 ******************/


/* hwrm_nvm_flush_input (size:128b/16B) */

typedef struct hwrm_nvm_flush_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
} hwrm_nvm_flush_input_t, *phwrm_nvm_flush_input_t;

/* hwrm_nvm_flush_output (size:128b/16B) */

typedef struct hwrm_nvm_flush_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_nvm_flush_output_t, *phwrm_nvm_flush_output_t;

/* hwrm_nvm_flush_cmd_err (size:64b/8B) */

typedef struct hwrm_nvm_flush_cmd_err {
	/*
	 * command specific error codes that goes to
	 * the cmd_err field in Common HWRM Error Response.
	 */
	uint8_t	code;
	/* Unknown error */
	#define HWRM_NVM_FLUSH_CMD_ERR_CODE_UNKNOWN UINT32_C(0x0)
	/* flush could not be performed */
	#define HWRM_NVM_FLUSH_CMD_ERR_CODE_FAIL	UINT32_C(0x1)
	#define HWRM_NVM_FLUSH_CMD_ERR_CODE_LAST   HWRM_NVM_FLUSH_CMD_ERR_CODE_FAIL
	uint8_t	unused_0[7];
} hwrm_nvm_flush_cmd_err_t, *phwrm_nvm_flush_cmd_err_t;

/*************************
 * hwrm_nvm_get_variable *
 *************************/


/* hwrm_nvm_get_variable_input (size:320b/40B) */

typedef struct hwrm_nvm_get_variable_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * This is the host address where
	 * nvm variable will be stored
	 */
	uint64_t	dest_data_addr;
	/* size of data in bits */
	uint16_t	data_len;
	/* nvm cfg option number */
	uint16_t	option_num;
	/* reserved. */
	#define HWRM_NVM_GET_VARIABLE_INPUT_OPTION_NUM_RSVD_0	UINT32_C(0x0)
	/* reserved. */
	#define HWRM_NVM_GET_VARIABLE_INPUT_OPTION_NUM_RSVD_FFFF UINT32_C(0xffff)
	#define HWRM_NVM_GET_VARIABLE_INPUT_OPTION_NUM_LAST	HWRM_NVM_GET_VARIABLE_INPUT_OPTION_NUM_RSVD_FFFF
	/*
	 * Number of dimensions for this nvm configuration variable.
	 * This value indicates how many of the indexN values to use.
	 * A value of 0 means that none of the indexN values are valid.
	 * A value of 1 requires at index0 is valued, a value of 2
	 * requires that index0 and index1 are valid, and so forth
	 */
	uint16_t	dimensions;
	/* index for the 1st dimensions */
	uint16_t	index_0;
	/* index for the 2nd dimensions */
	uint16_t	index_1;
	/* index for the 3rd dimensions */
	uint16_t	index_2;
	/* index for the 4th dimensions */
	uint16_t	index_3;
	uint8_t	flags;
	/*
	 * When this bit is set to 1, the factory default value will be returned,
	 * 0 returns the operational value.
	 */
	#define HWRM_NVM_GET_VARIABLE_INPUT_FLAGS_FACTORY_DFLT	UINT32_C(0x1)
	uint8_t	unused_0;
} hwrm_nvm_get_variable_input_t, *phwrm_nvm_get_variable_input_t;

/* hwrm_nvm_get_variable_output (size:128b/16B) */

typedef struct hwrm_nvm_get_variable_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	/* size of data of the actual variable retrieved in bits */
	uint16_t	data_len;
	/*
	 * option_num is the option number for the data retrieved.  It is possible in the
	 * future that the option number returned would be different than requested.  This
	 * condition could occur if an option is deprecated and a new option id is defined
	 * with similar characteristics, but has a slightly different definition.  This
	 * also makes it convenient for the caller to identify the variable result with
	 * the option id from the response.
	 */
	uint16_t	option_num;
	/* reserved. */
	#define HWRM_NVM_GET_VARIABLE_OUTPUT_OPTION_NUM_RSVD_0	UINT32_C(0x0)
	/* reserved. */
	#define HWRM_NVM_GET_VARIABLE_OUTPUT_OPTION_NUM_RSVD_FFFF UINT32_C(0xffff)
	#define HWRM_NVM_GET_VARIABLE_OUTPUT_OPTION_NUM_LAST	HWRM_NVM_GET_VARIABLE_OUTPUT_OPTION_NUM_RSVD_FFFF
	uint8_t	unused_0[3];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_nvm_get_variable_output_t, *phwrm_nvm_get_variable_output_t;

/* hwrm_nvm_get_variable_cmd_err (size:64b/8B) */

typedef struct hwrm_nvm_get_variable_cmd_err {
	/*
	 * command specific error codes that goes to
	 * the cmd_err field in Common HWRM Error Response.
	 */
	uint8_t	code;
	/* Unknown error */
	#define HWRM_NVM_GET_VARIABLE_CMD_ERR_CODE_UNKNOWN	UINT32_C(0x0)
	/* variable does not exist */
	#define HWRM_NVM_GET_VARIABLE_CMD_ERR_CODE_VAR_NOT_EXIST UINT32_C(0x1)
	/* configuration is corrupted and the variable cannot be saved */
	#define HWRM_NVM_GET_VARIABLE_CMD_ERR_CODE_CORRUPT_VAR   UINT32_C(0x2)
	/* length specified is too small */
	#define HWRM_NVM_GET_VARIABLE_CMD_ERR_CODE_LEN_TOO_SHORT UINT32_C(0x3)
	#define HWRM_NVM_GET_VARIABLE_CMD_ERR_CODE_LAST	HWRM_NVM_GET_VARIABLE_CMD_ERR_CODE_LEN_TOO_SHORT
	uint8_t	unused_0[7];
} hwrm_nvm_get_variable_cmd_err_t, *phwrm_nvm_get_variable_cmd_err_t;

/*************************
 * hwrm_nvm_set_variable *
 *************************/


/* hwrm_nvm_set_variable_input (size:320b/40B) */

typedef struct hwrm_nvm_set_variable_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * This is the host address where
	 * nvm variable will be copied from
	 */
	uint64_t	src_data_addr;
	/* size of data in bits */
	uint16_t	data_len;
	/* nvm cfg option number */
	uint16_t	option_num;
	/* reserved. */
	#define HWRM_NVM_SET_VARIABLE_INPUT_OPTION_NUM_RSVD_0	UINT32_C(0x0)
	/* reserved. */
	#define HWRM_NVM_SET_VARIABLE_INPUT_OPTION_NUM_RSVD_FFFF UINT32_C(0xffff)
	#define HWRM_NVM_SET_VARIABLE_INPUT_OPTION_NUM_LAST	HWRM_NVM_SET_VARIABLE_INPUT_OPTION_NUM_RSVD_FFFF
	/*
	 * Number of dimensions for this nvm configuration variable.
	 * This value indicates how many of the indexN values to use.
	 * A value of 0 means that none of the indexN values are valid.
	 * A value of 1 requires at index0 is valued, a value of 2
	 * requires that index0 and index1 are valid, and so forth
	 */
	uint16_t	dimensions;
	/* index for the 1st dimensions */
	uint16_t	index_0;
	/* index for the 2nd dimensions */
	uint16_t	index_1;
	/* index for the 3rd dimensions */
	uint16_t	index_2;
	/* index for the 4th dimensions */
	uint16_t	index_3;
	uint8_t	flags;
	/* When this bit is 1, flush internal cache after this write operation (see hwrm_nvm_flush command.) */
	#define HWRM_NVM_SET_VARIABLE_INPUT_FLAGS_FORCE_FLUSH		UINT32_C(0x1)
	/* encryption method */
	#define HWRM_NVM_SET_VARIABLE_INPUT_FLAGS_ENCRYPT_MODE_MASK	UINT32_C(0xe)
	#define HWRM_NVM_SET_VARIABLE_INPUT_FLAGS_ENCRYPT_MODE_SFT	1
	/* No encryption. */
		#define HWRM_NVM_SET_VARIABLE_INPUT_FLAGS_ENCRYPT_MODE_NONE		(UINT32_C(0x0) << 1)
	/* one-way encryption. */
		#define HWRM_NVM_SET_VARIABLE_INPUT_FLAGS_ENCRYPT_MODE_HMAC_SHA1	(UINT32_C(0x1) << 1)
	/* symmetric AES256 encryption. */
		#define HWRM_NVM_SET_VARIABLE_INPUT_FLAGS_ENCRYPT_MODE_AES256	(UINT32_C(0x2) << 1)
	/* SHA1 digest appended to plaintext contents, for authentication */
		#define HWRM_NVM_SET_VARIABLE_INPUT_FLAGS_ENCRYPT_MODE_HMAC_SHA1_AUTH  (UINT32_C(0x3) << 1)
		#define HWRM_NVM_SET_VARIABLE_INPUT_FLAGS_ENCRYPT_MODE_LAST	HWRM_NVM_SET_VARIABLE_INPUT_FLAGS_ENCRYPT_MODE_HMAC_SHA1_AUTH
	#define HWRM_NVM_SET_VARIABLE_INPUT_FLAGS_FLAGS_UNUSED_0_MASK	UINT32_C(0x70)
	#define HWRM_NVM_SET_VARIABLE_INPUT_FLAGS_FLAGS_UNUSED_0_SFT	4
	/* When this bit is 1, update the factory default region */
	#define HWRM_NVM_SET_VARIABLE_INPUT_FLAGS_FACTORY_DEFAULT		UINT32_C(0x80)
	uint8_t	unused_0;
} hwrm_nvm_set_variable_input_t, *phwrm_nvm_set_variable_input_t;

/* hwrm_nvm_set_variable_output (size:128b/16B) */

typedef struct hwrm_nvm_set_variable_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	unused_0[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_nvm_set_variable_output_t, *phwrm_nvm_set_variable_output_t;

/* hwrm_nvm_set_variable_cmd_err (size:64b/8B) */

typedef struct hwrm_nvm_set_variable_cmd_err {
	/*
	 * command specific error codes that goes to
	 * the cmd_err field in Common HWRM Error Response.
	 */
	uint8_t	code;
	/* Unknown error */
	#define HWRM_NVM_SET_VARIABLE_CMD_ERR_CODE_UNKNOWN	UINT32_C(0x0)
	/* variable does not exist */
	#define HWRM_NVM_SET_VARIABLE_CMD_ERR_CODE_VAR_NOT_EXIST UINT32_C(0x1)
	/* configuration is corrupted and the variable cannot be saved */
	#define HWRM_NVM_SET_VARIABLE_CMD_ERR_CODE_CORRUPT_VAR   UINT32_C(0x2)
	#define HWRM_NVM_SET_VARIABLE_CMD_ERR_CODE_LAST	HWRM_NVM_SET_VARIABLE_CMD_ERR_CODE_CORRUPT_VAR
	uint8_t	unused_0[7];
} hwrm_nvm_set_variable_cmd_err_t, *phwrm_nvm_set_variable_cmd_err_t;

/****************************
 * hwrm_nvm_validate_option *
 ****************************/


/* hwrm_nvm_validate_option_input (size:320b/40B) */

typedef struct hwrm_nvm_validate_option_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	/*
	 * This is the host address where
	 * nvm variable will be copied from
	 */
	uint64_t	src_data_addr;
	/* size of data in bits */
	uint16_t	data_len;
	/* nvm cfg option number */
	uint16_t	option_num;
	/* reserved. */
	#define HWRM_NVM_VALIDATE_OPTION_INPUT_OPTION_NUM_RSVD_0	UINT32_C(0x0)
	/* reserved. */
	#define HWRM_NVM_VALIDATE_OPTION_INPUT_OPTION_NUM_RSVD_FFFF UINT32_C(0xffff)
	#define HWRM_NVM_VALIDATE_OPTION_INPUT_OPTION_NUM_LAST	HWRM_NVM_VALIDATE_OPTION_INPUT_OPTION_NUM_RSVD_FFFF
	/*
	 * Number of dimensions for this nvm configuration variable.
	 * This value indicates how many of the indexN values to use.
	 * A value of 0 means that none of the indexN values are valid.
	 * A value of 1 requires at index0 is valued, a value of 2
	 * requires that index0 and index1 are valid, and so forth
	 */
	uint16_t	dimensions;
	/* index for the 1st dimensions */
	uint16_t	index_0;
	/* index for the 2nd dimensions */
	uint16_t	index_1;
	/* index for the 3rd dimensions */
	uint16_t	index_2;
	/* index for the 4th dimensions */
	uint16_t	index_3;
	uint8_t	unused_0[2];
} hwrm_nvm_validate_option_input_t, *phwrm_nvm_validate_option_input_t;

/* hwrm_nvm_validate_option_output (size:128b/16B) */

typedef struct hwrm_nvm_validate_option_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint8_t	result;
	/* indicates that the value provided for the option is not matching with the saved data. */
	#define HWRM_NVM_VALIDATE_OPTION_OUTPUT_RESULT_NOT_MATCH UINT32_C(0x0)
	/* indicates that the value provided for the option is matching the saved data. */
	#define HWRM_NVM_VALIDATE_OPTION_OUTPUT_RESULT_MATCH	UINT32_C(0x1)
	#define HWRM_NVM_VALIDATE_OPTION_OUTPUT_RESULT_LAST	HWRM_NVM_VALIDATE_OPTION_OUTPUT_RESULT_MATCH
	uint8_t	unused_0[6];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_nvm_validate_option_output_t, *phwrm_nvm_validate_option_output_t;

/* hwrm_nvm_validate_option_cmd_err (size:64b/8B) */

typedef struct hwrm_nvm_validate_option_cmd_err {
	/*
	 * command specific error codes that goes to
	 * the cmd_err field in Common HWRM Error Response.
	 */
	uint8_t	code;
	/* Unknown error */
	#define HWRM_NVM_VALIDATE_OPTION_CMD_ERR_CODE_UNKNOWN UINT32_C(0x0)
	#define HWRM_NVM_VALIDATE_OPTION_CMD_ERR_CODE_LAST   HWRM_NVM_VALIDATE_OPTION_CMD_ERR_CODE_UNKNOWN
	uint8_t	unused_0[7];
} hwrm_nvm_validate_option_cmd_err_t, *phwrm_nvm_validate_option_cmd_err_t;

#define ROCE_SP_HSI_VERSION_MAJOR 1
#define ROCE_SP_HSI_VERSION_MINOR 8
#define ROCE_SP_HSI_VERSION_UPDATE 4
#define ROCE_SP_HSI_VERSION_STR "1.8.4"
/*
 * Following is the signature for ROCE_SP_HSI message field that indicates not
 * applicable (All F's). Need to cast it the size of the field if needed.
 */
#define ROCE_SP_HSI_NA_SIGNATURE ((uint32_t)(-1))

/* cmdq_init (size:128b/16B) */

typedef struct cmdq_init {
	/* CMDQ PBL physical address. */
	uint64_t	cmdq_pbl;
	uint16_t	cmdq_size_cmdq_lvl;
	/* CMDQ PBL indirection levels. */
	#define CMDQ_INIT_CMDQ_LVL_MASK UINT32_C(0x3)
	#define CMDQ_INIT_CMDQ_LVL_SFT  0
	/* CMDQ size. */
	#define CMDQ_INIT_CMDQ_SIZE_MASK UINT32_C(0xfffc)
	#define CMDQ_INIT_CMDQ_SIZE_SFT 2
	/* CREQ completion ring id. */
	uint16_t	creq_ring_id;
	/* Mailbox producer index. MSB must also be set. */
	uint32_t	prod_idx;
} cmdq_init_t, *pcmdq_init_t;

/* cmdq_update (size:128b/16B) */

typedef struct cmdq_update {
	/* reserved64 is 64 b */
	uint64_t	reserved64;
	/* reserved32 is 32 b */
	uint32_t	reserved32;
	/* Mailbox producer index. */
	uint32_t	prod_idx;
} cmdq_update_t, *pcmdq_update_t;

/* cmdq_base (size:128b/16B) */

typedef struct cmdq_base {
	/* Command opcode. */
	uint8_t	opcode;
	/*
	 * Create QP command allocates QP context with the specified
	 * SQ, RQ/SRQ, CQ and other parameters.
	 */
	#define CMDQ_BASE_OPCODE_CREATE_QP		UINT32_C(0x1)
	/*
	 * Destroy QP command deletes the QP context and ceases
	 * any further reference.
	 */
	#define CMDQ_BASE_OPCODE_DESTROY_QP		UINT32_C(0x2)
	/*
	 * Modify QP command changes QP states and other QP specific
	 * parameters.
	 */
	#define CMDQ_BASE_OPCODE_MODIFY_QP		UINT32_C(0x3)
	/* Query QP command retrieves info about the specified QP. */
	#define CMDQ_BASE_OPCODE_QUERY_QP		UINT32_C(0x4)
	/* Create SRQ command allocates a SRQ with the specified parameters. */
	#define CMDQ_BASE_OPCODE_CREATE_SRQ		UINT32_C(0x5)
	/* Destroy SRQ command deletes and flushes the specified SRQ. */
	#define CMDQ_BASE_OPCODE_DESTROY_SRQ		UINT32_C(0x6)
	/* Query SRP command retrieves info about the specified SRQ. */
	#define CMDQ_BASE_OPCODE_QUERY_SRQ		UINT32_C(0x8)
	/* Create CQ command allocates a CQ with the specified parameters. */
	#define CMDQ_BASE_OPCODE_CREATE_CQ		UINT32_C(0x9)
	/* Destroy CQ command deletes and flushes the specified CQ. */
	#define CMDQ_BASE_OPCODE_DESTROY_CQ		UINT32_C(0xa)
	/* Resize CQ command resizes the specified CQ. */
	#define CMDQ_BASE_OPCODE_RESIZE_CQ		UINT32_C(0xc)
	/*
	 * Allocate MRW command allocates a MR/MW with the specified parameters
	 * and returns the region's L_KEY/R_KEY
	 */
	#define CMDQ_BASE_OPCODE_ALLOCATE_MRW	UINT32_C(0xd)
	/* De-allocate key command frees a MR/MW entry associated with the specified key. */
	#define CMDQ_BASE_OPCODE_DEALLOCATE_KEY	UINT32_C(0xe)
	/* Register MR command registers memory to the specified MR. */
	#define CMDQ_BASE_OPCODE_REGISTER_MR		UINT32_C(0xf)
	/* Deregister MR command de-registers memory from the specified MR. */
	#define CMDQ_BASE_OPCODE_DEREGISTER_MR	UINT32_C(0x10)
	/* Add GID command adds a GID to the local address table. */
	#define CMDQ_BASE_OPCODE_ADD_GID		UINT32_C(0x11)
	/* Delete GID command deletes a GID from the local address table. */
	#define CMDQ_BASE_OPCODE_DELETE_GID		UINT32_C(0x12)
	/* Modify GID command modifies a GID in the local address table. */
	#define CMDQ_BASE_OPCODE_MODIFY_GID		UINT32_C(0x17)
	/* Query GID command queries a GID in the local address table. */
	#define CMDQ_BASE_OPCODE_QUERY_GID		UINT32_C(0x18)
	/* Create QP1 command allocates a QP1 only. */
	#define CMDQ_BASE_OPCODE_CREATE_QP1		UINT32_C(0x13)
	/* Destroy QP1 command deletes and flushes the specified QP1. */
	#define CMDQ_BASE_OPCODE_DESTROY_QP1		UINT32_C(0x14)
	/* Create AH command allocates an AH with the specified parameters. */
	#define CMDQ_BASE_OPCODE_CREATE_AH		UINT32_C(0x15)
	/* Destroy AH command deletes the specified AH. */
	#define CMDQ_BASE_OPCODE_DESTROY_AH		UINT32_C(0x16)
	/*
	 * Initialize firmware command initializes the firmware with
	 * the specified parameters.
	 */
	#define CMDQ_BASE_OPCODE_INITIALIZE_FW	UINT32_C(0x80)
	/* De-initialize firmware command deinitializes the firmware. */
	#define CMDQ_BASE_OPCODE_DEINITIALIZE_FW	UINT32_C(0x81)
	/* Stop the function */
	#define CMDQ_BASE_OPCODE_STOP_FUNC		UINT32_C(0x82)
	/* Query the HW capabilities for the function. */
	#define CMDQ_BASE_OPCODE_QUERY_FUNC		UINT32_C(0x83)
	/*
	 * Set the following resources for the function:
	 * - Max QP, CQ, MR+MW, SRQ per PF
	 * - Max QP, CQ, MR+MW, SRQ per VF
	 */
	#define CMDQ_BASE_OPCODE_SET_FUNC_RESOURCES	UINT32_C(0x84)
	/* Read the current state of any internal resource context. Can only be issued from a PF. */
	#define CMDQ_BASE_OPCODE_READ_CONTEXT	UINT32_C(0x85)
	/* Send a request from VF to pass a command to the PF. VF HSI is suspended until the PF returns the response */
	#define CMDQ_BASE_OPCODE_VF_BACKCHANNEL_REQUEST UINT32_C(0x86)
	/* Read VF memory (primarily to get the backchannel request blob). Can only be issued from a PF. */
	#define CMDQ_BASE_OPCODE_READ_VF_MEMORY	UINT32_C(0x87)
	/* Write VF memory (primarily to put the backchannel response blob), and reenable VF HSI (post a CAG completion to it). Can only be issued from a PF. */
	#define CMDQ_BASE_OPCODE_COMPLETE_VF_REQUEST	UINT32_C(0x88)
	/* Extend resource (QPC, MRW, CQ, SRQ) array, after the host allocates more. Can only be issued from a PF. */
	#define CMDQ_BASE_OPCODE_EXTEND_CONTEXT_ARRRAY  UINT32_C(0x89)
	/* Map TC to COS. Can only be issued from a PF. */
	#define CMDQ_BASE_OPCODE_MAP_TC_TO_COS	UINT32_C(0x8a)
	/* Query version. */
	#define CMDQ_BASE_OPCODE_QUERY_VERSION	UINT32_C(0x8b)
	/* Modify congestion control. Can only be issued from a PF. */
	#define CMDQ_BASE_OPCODE_MODIFY_ROCE_CC	UINT32_C(0x8c)
	/* Query congestion control. */
	#define CMDQ_BASE_OPCODE_QUERY_ROCE_CC	UINT32_C(0x8d)
	/* Query RoCE statistics. */
	#define CMDQ_BASE_OPCODE_QUERY_ROCE_STATS	UINT32_C(0x8e)
	/* Set LAG mode. */
	#define CMDQ_BASE_OPCODE_SET_LINK_AGGR_MODE	UINT32_C(0x8f)
	/* Modify CQ */
	#define CMDQ_BASE_OPCODE_MODIFY_CQ		UINT32_C(0x90)
	/*
	 * Query QP for a PF other than the requesting PF. Also can query for more
	 * than one QP.
	 */
	#define CMDQ_BASE_OPCODE_QUERY_QP_EXTEND	UINT32_C(0x91)
	/* Query extended RoCE statistics. */
	#define CMDQ_BASE_OPCODE_QUERY_ROCE_STATS_EXT   UINT32_C(0x92)
	#define CMDQ_BASE_OPCODE_LAST		CMDQ_BASE_OPCODE_QUERY_ROCE_STATS_EXT
	/* Size of the command in 16-byte units. */
	uint8_t	cmd_size;
	/* Flags and attribs of the command. */
	uint16_t	flags;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* Size of the response buffer in 16-byte units. */
	uint8_t	resp_size;
	uint8_t	reserved8;
	/* Host address of the response. */
	uint64_t	resp_addr;
} cmdq_base_t, *pcmdq_base_t;

/* creq_base (size:128b/16B) */

typedef struct creq_base {
	uint8_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define CREQ_BASE_TYPE_MASK	UINT32_C(0x3f)
	#define CREQ_BASE_TYPE_SFT	0
	/* QP Async Notification */
		#define CREQ_BASE_TYPE_QP_EVENT	UINT32_C(0x38)
	/* Function Async Notification */
		#define CREQ_BASE_TYPE_FUNC_EVENT  UINT32_C(0x3a)
		#define CREQ_BASE_TYPE_LAST	CREQ_BASE_TYPE_FUNC_EVENT
	uint8_t	reserved56[7];
	uint8_t	v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define CREQ_BASE_V	UINT32_C(0x1)
	/* This is the modifier on to the type field. */
	uint8_t	event;
	uint8_t	reserved48[6];
} creq_base_t, *pcreq_base_t;

/*****************
 * query_version *
 *****************/


/* cmdq_query_version (size:128b/16B) */

typedef struct cmdq_query_version {
	/* Command opcode. */
	uint8_t	opcode;
	/* Query version. */
	#define CMDQ_QUERY_VERSION_OPCODE_QUERY_VERSION UINT32_C(0x8b)
	#define CMDQ_QUERY_VERSION_OPCODE_LAST	CMDQ_QUERY_VERSION_OPCODE_QUERY_VERSION
	/* Size of the command in 16-byte units. */
	uint8_t	cmd_size;
	/* Flags and attribs of the command. */
	uint16_t	flags;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* Size of the response buffer in 16-byte units. */
	uint8_t	resp_size;
	uint8_t	reserved8;
	/* Host address of the response. */
	uint64_t	resp_addr;
} cmdq_query_version_t, *pcmdq_query_version_t;

/* creq_query_version_resp (size:128b/16B) */

typedef struct creq_query_version_resp {
	uint8_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define CREQ_QUERY_VERSION_RESP_TYPE_MASK	UINT32_C(0x3f)
	#define CREQ_QUERY_VERSION_RESP_TYPE_SFT	0
	/* QP Async Notification */
		#define CREQ_QUERY_VERSION_RESP_TYPE_QP_EVENT  UINT32_C(0x38)
		#define CREQ_QUERY_VERSION_RESP_TYPE_LAST	CREQ_QUERY_VERSION_RESP_TYPE_QP_EVENT
	/* Status of the response. */
	uint8_t	status;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* firmware major version */
	uint8_t	fw_maj;
	/* firmware minor version */
	uint8_t	fw_minor;
	/* firmware build version */
	uint8_t	fw_bld;
	/* firmware reserved version */
	uint8_t	fw_rsvd;
	uint8_t	v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define CREQ_QUERY_VERSION_RESP_V	UINT32_C(0x1)
	/* Event or command opcode. */
	uint8_t	event;
	/* Query firmware and interface version response. */
	#define CREQ_QUERY_VERSION_RESP_EVENT_QUERY_VERSION UINT32_C(0x8b)
	#define CREQ_QUERY_VERSION_RESP_EVENT_LAST	CREQ_QUERY_VERSION_RESP_EVENT_QUERY_VERSION
	uint16_t	reserved16;
	/* interface major version */
	uint8_t	intf_maj;
	/* interface minor version */
	uint8_t	intf_minor;
	/* interface build version */
	uint8_t	intf_bld;
	/* interface reserved version */
	uint8_t	intf_rsvd;
} creq_query_version_resp_t, *pcreq_query_version_resp_t;

/*****************
 * initialize_fw *
 *****************/


/* cmdq_initialize_fw (size:896b/112B) */

typedef struct cmdq_initialize_fw {
	/* Command opcode. */
	uint8_t	opcode;
	/*
	 * Initialize firmware command initializes the firmware with
	 * the specified parameters.
	 */
	#define CMDQ_INITIALIZE_FW_OPCODE_INITIALIZE_FW UINT32_C(0x80)
	#define CMDQ_INITIALIZE_FW_OPCODE_LAST	CMDQ_INITIALIZE_FW_OPCODE_INITIALIZE_FW
	/* Size of the command in 16-byte units. */
	uint8_t	cmd_size;
	/* Flags and attribs of the command. */
	uint16_t	flags;
	/*
	 * When set, the 32b `max_mrw_per_vf` field is logically divided
	 * into two 16b fields, `max_mr_per_vf` and `max_av_per_vf`.
	 */
	#define CMDQ_INITIALIZE_FW_FLAGS_MRAV_RESERVATION_SPLIT	UINT32_C(0x1)
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* Size of the response buffer in 16-byte units. */
	uint8_t	resp_size;
	uint8_t	reserved8;
	/* Host address of the response. */
	uint64_t	resp_addr;
	uint8_t	qpc_pg_size_qpc_lvl;
	/* QPC PBL indirect levels. */
	#define CMDQ_INITIALIZE_FW_QPC_LVL_MASK	UINT32_C(0xf)
	#define CMDQ_INITIALIZE_FW_QPC_LVL_SFT	0
	/* PBL pointer is physical start address. */
		#define CMDQ_INITIALIZE_FW_QPC_LVL_LVL_0	UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
		#define CMDQ_INITIALIZE_FW_QPC_LVL_LVL_1	UINT32_C(0x1)
	/* PBL pointer points to PDE table with each entry pointing to PTE tables. */
		#define CMDQ_INITIALIZE_FW_QPC_LVL_LVL_2	UINT32_C(0x2)
		#define CMDQ_INITIALIZE_FW_QPC_LVL_LAST	CMDQ_INITIALIZE_FW_QPC_LVL_LVL_2
	/* QPC page size. */
	#define CMDQ_INITIALIZE_FW_QPC_PG_SIZE_MASK  UINT32_C(0xf0)
	#define CMDQ_INITIALIZE_FW_QPC_PG_SIZE_SFT   4
	/* 4KB. */
		#define CMDQ_INITIALIZE_FW_QPC_PG_SIZE_PG_4K   (UINT32_C(0x0) << 4)
	/* 8KB. */
		#define CMDQ_INITIALIZE_FW_QPC_PG_SIZE_PG_8K   (UINT32_C(0x1) << 4)
	/* 64KB. */
		#define CMDQ_INITIALIZE_FW_QPC_PG_SIZE_PG_64K  (UINT32_C(0x2) << 4)
	/* 2MB. */
		#define CMDQ_INITIALIZE_FW_QPC_PG_SIZE_PG_2M   (UINT32_C(0x3) << 4)
	/* 8MB. */
		#define CMDQ_INITIALIZE_FW_QPC_PG_SIZE_PG_8M   (UINT32_C(0x4) << 4)
	/* 1GB. */
		#define CMDQ_INITIALIZE_FW_QPC_PG_SIZE_PG_1G   (UINT32_C(0x5) << 4)
		#define CMDQ_INITIALIZE_FW_QPC_PG_SIZE_LAST   CMDQ_INITIALIZE_FW_QPC_PG_SIZE_PG_1G
	uint8_t	mrw_pg_size_mrw_lvl;
	/* MRW PBL indirect levels. */
	#define CMDQ_INITIALIZE_FW_MRW_LVL_MASK	UINT32_C(0xf)
	#define CMDQ_INITIALIZE_FW_MRW_LVL_SFT	0
	/* PBL pointer is physical start address. */
		#define CMDQ_INITIALIZE_FW_MRW_LVL_LVL_0	UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
		#define CMDQ_INITIALIZE_FW_MRW_LVL_LVL_1	UINT32_C(0x1)
	/* PBL pointer points to PDE table with each entry pointing to PTE tables. */
		#define CMDQ_INITIALIZE_FW_MRW_LVL_LVL_2	UINT32_C(0x2)
		#define CMDQ_INITIALIZE_FW_MRW_LVL_LAST	CMDQ_INITIALIZE_FW_MRW_LVL_LVL_2
	/* MRW page size. */
	#define CMDQ_INITIALIZE_FW_MRW_PG_SIZE_MASK  UINT32_C(0xf0)
	#define CMDQ_INITIALIZE_FW_MRW_PG_SIZE_SFT   4
	/* 4KB. */
		#define CMDQ_INITIALIZE_FW_MRW_PG_SIZE_PG_4K   (UINT32_C(0x0) << 4)
	/* 8KB. */
		#define CMDQ_INITIALIZE_FW_MRW_PG_SIZE_PG_8K   (UINT32_C(0x1) << 4)
	/* 64KB. */
		#define CMDQ_INITIALIZE_FW_MRW_PG_SIZE_PG_64K  (UINT32_C(0x2) << 4)
	/* 2MB. */
		#define CMDQ_INITIALIZE_FW_MRW_PG_SIZE_PG_2M   (UINT32_C(0x3) << 4)
	/* 8MB. */
		#define CMDQ_INITIALIZE_FW_MRW_PG_SIZE_PG_8M   (UINT32_C(0x4) << 4)
	/* 1GB. */
		#define CMDQ_INITIALIZE_FW_MRW_PG_SIZE_PG_1G   (UINT32_C(0x5) << 4)
		#define CMDQ_INITIALIZE_FW_MRW_PG_SIZE_LAST   CMDQ_INITIALIZE_FW_MRW_PG_SIZE_PG_1G
	uint8_t	srq_pg_size_srq_lvl;
	/* SRQ PBL indirect levels. */
	#define CMDQ_INITIALIZE_FW_SRQ_LVL_MASK	UINT32_C(0xf)
	#define CMDQ_INITIALIZE_FW_SRQ_LVL_SFT	0
	/* PBL pointer is physical start address. */
		#define CMDQ_INITIALIZE_FW_SRQ_LVL_LVL_0	UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
		#define CMDQ_INITIALIZE_FW_SRQ_LVL_LVL_1	UINT32_C(0x1)
	/* PBL pointer points to PDE table with each entry pointing to PTE tables. */
		#define CMDQ_INITIALIZE_FW_SRQ_LVL_LVL_2	UINT32_C(0x2)
		#define CMDQ_INITIALIZE_FW_SRQ_LVL_LAST	CMDQ_INITIALIZE_FW_SRQ_LVL_LVL_2
	/* SRQ page size. */
	#define CMDQ_INITIALIZE_FW_SRQ_PG_SIZE_MASK  UINT32_C(0xf0)
	#define CMDQ_INITIALIZE_FW_SRQ_PG_SIZE_SFT   4
	/* 4KB. */
		#define CMDQ_INITIALIZE_FW_SRQ_PG_SIZE_PG_4K   (UINT32_C(0x0) << 4)
	/* 8KB. */
		#define CMDQ_INITIALIZE_FW_SRQ_PG_SIZE_PG_8K   (UINT32_C(0x1) << 4)
	/* 64KB. */
		#define CMDQ_INITIALIZE_FW_SRQ_PG_SIZE_PG_64K  (UINT32_C(0x2) << 4)
	/* 2MB. */
		#define CMDQ_INITIALIZE_FW_SRQ_PG_SIZE_PG_2M   (UINT32_C(0x3) << 4)
	/* 8MB. */
		#define CMDQ_INITIALIZE_FW_SRQ_PG_SIZE_PG_8M   (UINT32_C(0x4) << 4)
	/* 1GB. */
		#define CMDQ_INITIALIZE_FW_SRQ_PG_SIZE_PG_1G   (UINT32_C(0x5) << 4)
		#define CMDQ_INITIALIZE_FW_SRQ_PG_SIZE_LAST   CMDQ_INITIALIZE_FW_SRQ_PG_SIZE_PG_1G
	uint8_t	cq_pg_size_cq_lvl;
	/* CQ PBL indirect levels. */
	#define CMDQ_INITIALIZE_FW_CQ_LVL_MASK	UINT32_C(0xf)
	#define CMDQ_INITIALIZE_FW_CQ_LVL_SFT	0
	/* PBL pointer is physical start address. */
		#define CMDQ_INITIALIZE_FW_CQ_LVL_LVL_0	UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
		#define CMDQ_INITIALIZE_FW_CQ_LVL_LVL_1	UINT32_C(0x1)
	/* PBL pointer points to PDE table with each entry pointing to PTE tables. */
		#define CMDQ_INITIALIZE_FW_CQ_LVL_LVL_2	UINT32_C(0x2)
		#define CMDQ_INITIALIZE_FW_CQ_LVL_LAST	CMDQ_INITIALIZE_FW_CQ_LVL_LVL_2
	/* CQ page size. */
	#define CMDQ_INITIALIZE_FW_CQ_PG_SIZE_MASK  UINT32_C(0xf0)
	#define CMDQ_INITIALIZE_FW_CQ_PG_SIZE_SFT   4
	/* 4KB. */
		#define CMDQ_INITIALIZE_FW_CQ_PG_SIZE_PG_4K   (UINT32_C(0x0) << 4)
	/* 8KB. */
		#define CMDQ_INITIALIZE_FW_CQ_PG_SIZE_PG_8K   (UINT32_C(0x1) << 4)
	/* 64KB. */
		#define CMDQ_INITIALIZE_FW_CQ_PG_SIZE_PG_64K  (UINT32_C(0x2) << 4)
	/* 2MB. */
		#define CMDQ_INITIALIZE_FW_CQ_PG_SIZE_PG_2M   (UINT32_C(0x3) << 4)
	/* 8MB. */
		#define CMDQ_INITIALIZE_FW_CQ_PG_SIZE_PG_8M   (UINT32_C(0x4) << 4)
	/* 1GB. */
		#define CMDQ_INITIALIZE_FW_CQ_PG_SIZE_PG_1G   (UINT32_C(0x5) << 4)
		#define CMDQ_INITIALIZE_FW_CQ_PG_SIZE_LAST   CMDQ_INITIALIZE_FW_CQ_PG_SIZE_PG_1G
	uint8_t	tqm_pg_size_tqm_lvl;
	/* TQM PBL indirect levels. */
	#define CMDQ_INITIALIZE_FW_TQM_LVL_MASK	UINT32_C(0xf)
	#define CMDQ_INITIALIZE_FW_TQM_LVL_SFT	0
	/* PBL pointer is physical start address. */
		#define CMDQ_INITIALIZE_FW_TQM_LVL_LVL_0	UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
		#define CMDQ_INITIALIZE_FW_TQM_LVL_LVL_1	UINT32_C(0x1)
	/* PBL pointer points to PDE table with each entry pointing to PTE tables. */
		#define CMDQ_INITIALIZE_FW_TQM_LVL_LVL_2	UINT32_C(0x2)
		#define CMDQ_INITIALIZE_FW_TQM_LVL_LAST	CMDQ_INITIALIZE_FW_TQM_LVL_LVL_2
	/* TQM page size. */
	#define CMDQ_INITIALIZE_FW_TQM_PG_SIZE_MASK  UINT32_C(0xf0)
	#define CMDQ_INITIALIZE_FW_TQM_PG_SIZE_SFT   4
	/* 4KB. */
		#define CMDQ_INITIALIZE_FW_TQM_PG_SIZE_PG_4K   (UINT32_C(0x0) << 4)
	/* 8KB. */
		#define CMDQ_INITIALIZE_FW_TQM_PG_SIZE_PG_8K   (UINT32_C(0x1) << 4)
	/* 64KB. */
		#define CMDQ_INITIALIZE_FW_TQM_PG_SIZE_PG_64K  (UINT32_C(0x2) << 4)
	/* 2MB. */
		#define CMDQ_INITIALIZE_FW_TQM_PG_SIZE_PG_2M   (UINT32_C(0x3) << 4)
	/* 8MB. */
		#define CMDQ_INITIALIZE_FW_TQM_PG_SIZE_PG_8M   (UINT32_C(0x4) << 4)
	/* 1GB. */
		#define CMDQ_INITIALIZE_FW_TQM_PG_SIZE_PG_1G   (UINT32_C(0x5) << 4)
		#define CMDQ_INITIALIZE_FW_TQM_PG_SIZE_LAST   CMDQ_INITIALIZE_FW_TQM_PG_SIZE_PG_1G
	uint8_t	tim_pg_size_tim_lvl;
	/* TIM PBL indirect levels. */
	#define CMDQ_INITIALIZE_FW_TIM_LVL_MASK	UINT32_C(0xf)
	#define CMDQ_INITIALIZE_FW_TIM_LVL_SFT	0
	/* PBL pointer is physical start address. */
		#define CMDQ_INITIALIZE_FW_TIM_LVL_LVL_0	UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
		#define CMDQ_INITIALIZE_FW_TIM_LVL_LVL_1	UINT32_C(0x1)
	/* PBL pointer points to PDE table with each entry pointing to PTE tables. */
		#define CMDQ_INITIALIZE_FW_TIM_LVL_LVL_2	UINT32_C(0x2)
		#define CMDQ_INITIALIZE_FW_TIM_LVL_LAST	CMDQ_INITIALIZE_FW_TIM_LVL_LVL_2
	/* TIM page size. */
	#define CMDQ_INITIALIZE_FW_TIM_PG_SIZE_MASK  UINT32_C(0xf0)
	#define CMDQ_INITIALIZE_FW_TIM_PG_SIZE_SFT   4
	/* 4KB. */
		#define CMDQ_INITIALIZE_FW_TIM_PG_SIZE_PG_4K   (UINT32_C(0x0) << 4)
	/* 8KB. */
		#define CMDQ_INITIALIZE_FW_TIM_PG_SIZE_PG_8K   (UINT32_C(0x1) << 4)
	/* 64KB. */
		#define CMDQ_INITIALIZE_FW_TIM_PG_SIZE_PG_64K  (UINT32_C(0x2) << 4)
	/* 2MB. */
		#define CMDQ_INITIALIZE_FW_TIM_PG_SIZE_PG_2M   (UINT32_C(0x3) << 4)
	/* 8MB. */
		#define CMDQ_INITIALIZE_FW_TIM_PG_SIZE_PG_8M   (UINT32_C(0x4) << 4)
	/* 1GB. */
		#define CMDQ_INITIALIZE_FW_TIM_PG_SIZE_PG_1G   (UINT32_C(0x5) << 4)
		#define CMDQ_INITIALIZE_FW_TIM_PG_SIZE_LAST   CMDQ_INITIALIZE_FW_TIM_PG_SIZE_PG_1G
	uint16_t	log2_dbr_pg_size;
	/* Log base 2 of DBR page size - 12. 0 for 4KB. HW supported values are enumerated below. */
	#define CMDQ_INITIALIZE_FW_LOG2_DBR_PG_SIZE_MASK   UINT32_C(0xf)
	#define CMDQ_INITIALIZE_FW_LOG2_DBR_PG_SIZE_SFT	0
	/* 4KB. */
		#define CMDQ_INITIALIZE_FW_LOG2_DBR_PG_SIZE_PG_4K	UINT32_C(0x0)
	/* 8KB. */
		#define CMDQ_INITIALIZE_FW_LOG2_DBR_PG_SIZE_PG_8K	UINT32_C(0x1)
	/* 16KB. */
		#define CMDQ_INITIALIZE_FW_LOG2_DBR_PG_SIZE_PG_16K   UINT32_C(0x2)
	/* 32KB. */
		#define CMDQ_INITIALIZE_FW_LOG2_DBR_PG_SIZE_PG_32K   UINT32_C(0x3)
	/* 64KB. */
		#define CMDQ_INITIALIZE_FW_LOG2_DBR_PG_SIZE_PG_64K   UINT32_C(0x4)
	/* 128KB. */
		#define CMDQ_INITIALIZE_FW_LOG2_DBR_PG_SIZE_PG_128K  UINT32_C(0x5)
	/* 256KB. */
		#define CMDQ_INITIALIZE_FW_LOG2_DBR_PG_SIZE_PG_256K  UINT32_C(0x6)
	/* 512KB. */
		#define CMDQ_INITIALIZE_FW_LOG2_DBR_PG_SIZE_PG_512K  UINT32_C(0x7)
	/* 1MB. */
		#define CMDQ_INITIALIZE_FW_LOG2_DBR_PG_SIZE_PG_1M	UINT32_C(0x8)
	/* 2MB. */
		#define CMDQ_INITIALIZE_FW_LOG2_DBR_PG_SIZE_PG_2M	UINT32_C(0x9)
	/* 4MB. */
		#define CMDQ_INITIALIZE_FW_LOG2_DBR_PG_SIZE_PG_4M	UINT32_C(0xa)
	/* 8MB. */
		#define CMDQ_INITIALIZE_FW_LOG2_DBR_PG_SIZE_PG_8M	UINT32_C(0xb)
	/* 16MB. */
		#define CMDQ_INITIALIZE_FW_LOG2_DBR_PG_SIZE_PG_16M   UINT32_C(0xc)
	/* 32MB. */
		#define CMDQ_INITIALIZE_FW_LOG2_DBR_PG_SIZE_PG_32M   UINT32_C(0xd)
	/* 64MB. */
		#define CMDQ_INITIALIZE_FW_LOG2_DBR_PG_SIZE_PG_64M   UINT32_C(0xe)
	/* 128MB. */
		#define CMDQ_INITIALIZE_FW_LOG2_DBR_PG_SIZE_PG_128M  UINT32_C(0xf)
		#define CMDQ_INITIALIZE_FW_LOG2_DBR_PG_SIZE_LAST	CMDQ_INITIALIZE_FW_LOG2_DBR_PG_SIZE_PG_128M
	/* rsvd is 12 b */
	#define CMDQ_INITIALIZE_FW_RSVD_MASK		UINT32_C(0xfff0)
	#define CMDQ_INITIALIZE_FW_RSVD_SFT		4
	/* Kernel notification queue page directory. */
	uint64_t	qpc_page_dir;
	/* MRW page directory. */
	uint64_t	mrw_page_dir;
	/* SRQ page directory. */
	uint64_t	srq_page_dir;
	/* CQ page directory. */
	uint64_t	cq_page_dir;
	/* TQM page directory. */
	uint64_t	tqm_page_dir;
	/* TIM page directory. */
	uint64_t	tim_page_dir;
	/* Number of QPs. */
	uint32_t	number_of_qp;
	/* Number of MRWs. */
	uint32_t	number_of_mrw;
	/* Number of SRQs. */
	uint32_t	number_of_srq;
	/* Number of CQs. */
	uint32_t	number_of_cq;
	/* Number of QPs per VF. */
	uint32_t	max_qp_per_vf;
	/*
	 * If the MR/AV split reservation flag is not set, then this field
	 * represents the total number of MR plus AV entries allowed per
	 * VF. For versions of firmware that support the split reservation,
	 * when it is not specified half of the entries will be reserved
	 * for MRs and the other half for AVs.
	 *
	 * If the MR/AV split reservation flag is set, then this
	 * field is logically divided into two 16b fields. Bits `[31:16]`
	 * represents the `max_mr_per_vf` and bits `[15:0]` represents
	 * `max_av_per_vf`. The granularity of these values is defined by
	 * the `mrav_num_entries_unit` field returned by the
	 * `backing_store_qcaps` command.
	 */
	uint32_t	max_mrw_per_vf;
	/* Number of SRQs per VF. */
	uint32_t	max_srq_per_vf;
	/* Number of CQs per VF. */
	uint32_t	max_cq_per_vf;
	/* Number of GIDs per VF. */
	uint32_t	max_gid_per_vf;
	/* Statistics context index for this function. */
	uint32_t	stat_ctx_id;
} cmdq_initialize_fw_t, *pcmdq_initialize_fw_t;

/* creq_initialize_fw_resp (size:128b/16B) */

typedef struct creq_initialize_fw_resp {
	uint8_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define CREQ_INITIALIZE_FW_RESP_TYPE_MASK	UINT32_C(0x3f)
	#define CREQ_INITIALIZE_FW_RESP_TYPE_SFT	0
	/* QP Async Notification */
		#define CREQ_INITIALIZE_FW_RESP_TYPE_QP_EVENT  UINT32_C(0x38)
		#define CREQ_INITIALIZE_FW_RESP_TYPE_LAST	CREQ_INITIALIZE_FW_RESP_TYPE_QP_EVENT
	/* Status of the response. */
	uint8_t	status;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	uint32_t	reserved32;
	uint8_t	v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define CREQ_INITIALIZE_FW_RESP_V	UINT32_C(0x1)
	/* Event or command opcode. */
	uint8_t	event;
	/* Initialize firmware command response. */
	#define CREQ_INITIALIZE_FW_RESP_EVENT_INITIALIZE_FW UINT32_C(0x80)
	#define CREQ_INITIALIZE_FW_RESP_EVENT_LAST	CREQ_INITIALIZE_FW_RESP_EVENT_INITIALIZE_FW
	uint8_t	reserved48[6];
} creq_initialize_fw_resp_t, *pcreq_initialize_fw_resp_t;

/*******************
 * deinitialize_fw *
 *******************/


/* cmdq_deinitialize_fw (size:128b/16B) */

typedef struct cmdq_deinitialize_fw {
	/* Command opcode. */
	uint8_t	opcode;
	/* De-initialize firmware command deinitializes the firmware. */
	#define CMDQ_DEINITIALIZE_FW_OPCODE_DEINITIALIZE_FW UINT32_C(0x81)
	#define CMDQ_DEINITIALIZE_FW_OPCODE_LAST	CMDQ_DEINITIALIZE_FW_OPCODE_DEINITIALIZE_FW
	/* Size of the command in 16-byte units. */
	uint8_t	cmd_size;
	/* Flags and attribs of the command. */
	uint16_t	flags;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* Size of the response buffer in 16-byte units. */
	uint8_t	resp_size;
	uint8_t	reserved8;
	/* Host address of the response. */
	uint64_t	resp_addr;
} cmdq_deinitialize_fw_t, *pcmdq_deinitialize_fw_t;

/* creq_deinitialize_fw_resp (size:128b/16B) */

typedef struct creq_deinitialize_fw_resp {
	uint8_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define CREQ_DEINITIALIZE_FW_RESP_TYPE_MASK	UINT32_C(0x3f)
	#define CREQ_DEINITIALIZE_FW_RESP_TYPE_SFT	0
	/* QP Async Notification */
		#define CREQ_DEINITIALIZE_FW_RESP_TYPE_QP_EVENT  UINT32_C(0x38)
		#define CREQ_DEINITIALIZE_FW_RESP_TYPE_LAST	CREQ_DEINITIALIZE_FW_RESP_TYPE_QP_EVENT
	/* Status of the response. */
	uint8_t	status;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	uint32_t	reserved32;
	uint8_t	v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define CREQ_DEINITIALIZE_FW_RESP_V	UINT32_C(0x1)
	/* Event or command opcode. */
	uint8_t	event;
	/* De-initialize firmware command response. */
	#define CREQ_DEINITIALIZE_FW_RESP_EVENT_DEINITIALIZE_FW UINT32_C(0x81)
	#define CREQ_DEINITIALIZE_FW_RESP_EVENT_LAST	CREQ_DEINITIALIZE_FW_RESP_EVENT_DEINITIALIZE_FW
	uint8_t	reserved48[6];
} creq_deinitialize_fw_resp_t, *pcreq_deinitialize_fw_resp_t;

/*************
 * create_qp *
 *************/


/* cmdq_create_qp (size:768b/96B) */

typedef struct cmdq_create_qp {
	/* Command opcode. */
	uint8_t	opcode;
	/*
	 * Create QP command allocates QP context with the specified
	 * SQ, RQ/SRQ, CQ and other parameters.
	 */
	#define CMDQ_CREATE_QP_OPCODE_CREATE_QP UINT32_C(0x1)
	#define CMDQ_CREATE_QP_OPCODE_LAST	CMDQ_CREATE_QP_OPCODE_CREATE_QP
	/* Size of the command in 16-byte units. */
	uint8_t	cmd_size;
	/* Flags and attribs of the command. */
	uint16_t	flags;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* Size of the response buffer in 16-byte units. */
	uint8_t	resp_size;
	uint8_t	reserved8;
	/* Host address of the response. */
	uint64_t	resp_addr;
	/* QP handle. */
	uint64_t	qp_handle;
	/* Create QP flags. */
	uint32_t	qp_flags;
	/* SRQ is used. */
	#define CMDQ_CREATE_QP_QP_FLAGS_SRQ_USED		UINT32_C(0x1)
	/* post CQE for all SQ WQEs. */
	#define CMDQ_CREATE_QP_QP_FLAGS_FORCE_COMPLETION	UINT32_C(0x2)
	/* This QP can use reserved L_Key */
	#define CMDQ_CREATE_QP_QP_FLAGS_RESERVED_LKEY_ENABLE	UINT32_C(0x4)
	/* This QP can fast register physical memory */
	#define CMDQ_CREATE_QP_QP_FLAGS_FR_PMR_ENABLED		UINT32_C(0x8)
	/* This QP can send variable sized WQEs. */
	#define CMDQ_CREATE_QP_QP_FLAGS_VARIABLE_SIZED_WQE_ENABLED UINT32_C(0x10)
	/*
	 * WQEs with inline data sent on this QP are able to flow
	 * through an optimized transmit path to lower latency. This
	 * transmit path is opportunistic and not guaranteed to always
	 * occur.
	 */
	#define CMDQ_CREATE_QP_QP_FLAGS_OPTIMIZED_TRANSMIT_ENABLED UINT32_C(0x20)
	/*
	 * For UD QPs the default responder CQE format is `cq_res_ud`.
	 * This flag specifies the `cq_res_ud_cfa` format to be used
	 * instead.
	 */
	#define CMDQ_CREATE_QP_QP_FLAGS_RESPONDER_UD_CQE_WITH_CFA  UINT32_C(0x40)
	/*
	 * This QP must be included in the extended RoCE statistics
	 * that can be queried via `query_roce_stats_ext`.
	 */
	#define CMDQ_CREATE_QP_QP_FLAGS_EXT_STATS_ENABLED	UINT32_C(0x80)
	#define CMDQ_CREATE_QP_QP_FLAGS_LAST			CMDQ_CREATE_QP_QP_FLAGS_EXT_STATS_ENABLED
	/* Supported QP types. */
	uint8_t	type;
	/* Reliable Connection. */
	#define CMDQ_CREATE_QP_TYPE_RC		UINT32_C(0x2)
	/* Unreliable Datagram. */
	#define CMDQ_CREATE_QP_TYPE_UD		UINT32_C(0x4)
	/* Raw Ethertype. */
	#define CMDQ_CREATE_QP_TYPE_RAW_ETHERTYPE UINT32_C(0x6)
	/* General Services Interface on QP1 over UD. */
	#define CMDQ_CREATE_QP_TYPE_GSI	UINT32_C(0x7)
	#define CMDQ_CREATE_QP_TYPE_LAST	CMDQ_CREATE_QP_TYPE_GSI
	uint8_t	sq_pg_size_sq_lvl;
	/* SQ PBL indirect levels. */
	#define CMDQ_CREATE_QP_SQ_LVL_MASK	UINT32_C(0xf)
	#define CMDQ_CREATE_QP_SQ_LVL_SFT	0
	/* PBL pointer is physical start address. */
		#define CMDQ_CREATE_QP_SQ_LVL_LVL_0	UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
		#define CMDQ_CREATE_QP_SQ_LVL_LVL_1	UINT32_C(0x1)
	/* PBL pointer points to PDE table with each entry pointing to PTE tables. */
		#define CMDQ_CREATE_QP_SQ_LVL_LVL_2	UINT32_C(0x2)
		#define CMDQ_CREATE_QP_SQ_LVL_LAST	CMDQ_CREATE_QP_SQ_LVL_LVL_2
	/* SQ page size. */
	#define CMDQ_CREATE_QP_SQ_PG_SIZE_MASK  UINT32_C(0xf0)
	#define CMDQ_CREATE_QP_SQ_PG_SIZE_SFT   4
	/* 4KB. */
		#define CMDQ_CREATE_QP_SQ_PG_SIZE_PG_4K   (UINT32_C(0x0) << 4)
	/* 8KB. */
		#define CMDQ_CREATE_QP_SQ_PG_SIZE_PG_8K   (UINT32_C(0x1) << 4)
	/* 64KB. */
		#define CMDQ_CREATE_QP_SQ_PG_SIZE_PG_64K  (UINT32_C(0x2) << 4)
	/* 2MB. */
		#define CMDQ_CREATE_QP_SQ_PG_SIZE_PG_2M   (UINT32_C(0x3) << 4)
	/* 8MB. */
		#define CMDQ_CREATE_QP_SQ_PG_SIZE_PG_8M   (UINT32_C(0x4) << 4)
	/* 1GB. */
		#define CMDQ_CREATE_QP_SQ_PG_SIZE_PG_1G   (UINT32_C(0x5) << 4)
		#define CMDQ_CREATE_QP_SQ_PG_SIZE_LAST   CMDQ_CREATE_QP_SQ_PG_SIZE_PG_1G
	uint8_t	rq_pg_size_rq_lvl;
	/* RQ PBL indirect levels. */
	#define CMDQ_CREATE_QP_RQ_LVL_MASK	UINT32_C(0xf)
	#define CMDQ_CREATE_QP_RQ_LVL_SFT	0
	/* PBL pointer is physical start address. */
		#define CMDQ_CREATE_QP_RQ_LVL_LVL_0	UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
		#define CMDQ_CREATE_QP_RQ_LVL_LVL_1	UINT32_C(0x1)
	/* PBL pointer points to PDE table with each entry pointing to PTE tables. */
		#define CMDQ_CREATE_QP_RQ_LVL_LVL_2	UINT32_C(0x2)
		#define CMDQ_CREATE_QP_RQ_LVL_LAST	CMDQ_CREATE_QP_RQ_LVL_LVL_2
	/* RQ page size. */
	#define CMDQ_CREATE_QP_RQ_PG_SIZE_MASK  UINT32_C(0xf0)
	#define CMDQ_CREATE_QP_RQ_PG_SIZE_SFT   4
	/* 4KB. */
		#define CMDQ_CREATE_QP_RQ_PG_SIZE_PG_4K   (UINT32_C(0x0) << 4)
	/* 8KB. */
		#define CMDQ_CREATE_QP_RQ_PG_SIZE_PG_8K   (UINT32_C(0x1) << 4)
	/* 64KB. */
		#define CMDQ_CREATE_QP_RQ_PG_SIZE_PG_64K  (UINT32_C(0x2) << 4)
	/* 2MB. */
		#define CMDQ_CREATE_QP_RQ_PG_SIZE_PG_2M   (UINT32_C(0x3) << 4)
	/* 8MB. */
		#define CMDQ_CREATE_QP_RQ_PG_SIZE_PG_8M   (UINT32_C(0x4) << 4)
	/* 1GB. */
		#define CMDQ_CREATE_QP_RQ_PG_SIZE_PG_1G   (UINT32_C(0x5) << 4)
		#define CMDQ_CREATE_QP_RQ_PG_SIZE_LAST   CMDQ_CREATE_QP_RQ_PG_SIZE_PG_1G
	uint8_t	unused_0;
	/* Doorbell page index. */
	uint32_t	dpi;
	/* Max number of SQ wqes. */
	uint32_t	sq_size;
	/* Max number of RQ wqes. */
	uint32_t	rq_size;
	uint16_t	sq_fwo_sq_sge;
	/* Max send SGEs per SWQE. */
	#define CMDQ_CREATE_QP_SQ_SGE_MASK UINT32_C(0xf)
	#define CMDQ_CREATE_QP_SQ_SGE_SFT 0
	/* Offset of First WQE in the first SQ page, in 128 byte units */
	#define CMDQ_CREATE_QP_SQ_FWO_MASK UINT32_C(0xfff0)
	#define CMDQ_CREATE_QP_SQ_FWO_SFT 4
	uint16_t	rq_fwo_rq_sge;
	/*
	 * Max recv SGEs per RWQE.
	 * On chips with variable-size WQE support, a value of zero implies 30 SGEs.
	 */
	#define CMDQ_CREATE_QP_RQ_SGE_MASK UINT32_C(0xf)
	#define CMDQ_CREATE_QP_RQ_SGE_SFT 0
	/* Offset of First WQE in the first RQ page, in 128 byte units */
	#define CMDQ_CREATE_QP_RQ_FWO_MASK UINT32_C(0xfff0)
	#define CMDQ_CREATE_QP_RQ_FWO_SFT 4
	/* Send CQ context id. */
	uint32_t	scq_cid;
	/* Receive CQ context id. */
	uint32_t	rcq_cid;
	/* SRQ context id. */
	uint32_t	srq_cid;
	/* Protection domain id. */
	uint32_t	pd_id;
	/* SQ PBL physical address. */
	uint64_t	sq_pbl;
	/* RQ PBL physical address. */
	uint64_t	rq_pbl;
	/* IRRQ address. */
	uint64_t	irrq_addr;
	/* ORRQ address. */
	uint64_t	orrq_addr;
} cmdq_create_qp_t, *pcmdq_create_qp_t;

/* creq_create_qp_resp (size:128b/16B) */

typedef struct creq_create_qp_resp {
	uint8_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define CREQ_CREATE_QP_RESP_TYPE_MASK	UINT32_C(0x3f)
	#define CREQ_CREATE_QP_RESP_TYPE_SFT	0
	/* QP Async Notification */
		#define CREQ_CREATE_QP_RESP_TYPE_QP_EVENT  UINT32_C(0x38)
		#define CREQ_CREATE_QP_RESP_TYPE_LAST	CREQ_CREATE_QP_RESP_TYPE_QP_EVENT
	/* Status of the response. */
	uint8_t	status;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* QP context id */
	uint32_t	xid;
	uint8_t	v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define CREQ_CREATE_QP_RESP_V	UINT32_C(0x1)
	/* Event or command opcode. */
	uint8_t	event;
	/* Create QP command response. */
	#define CREQ_CREATE_QP_RESP_EVENT_CREATE_QP UINT32_C(0x1)
	#define CREQ_CREATE_QP_RESP_EVENT_LAST	CREQ_CREATE_QP_RESP_EVENT_CREATE_QP
	/*
	 * Support for optimized transmit path to lower latency
	 * for WQEs with inline data has been enabled for this QP.
	 */
	uint8_t	optimized_transmit_enabled;
	uint8_t	reserved48[5];
} creq_create_qp_resp_t, *pcreq_create_qp_resp_t;

/**************
 * destroy_qp *
 **************/


/* cmdq_destroy_qp (size:192b/24B) */

typedef struct cmdq_destroy_qp {
	/* Command opcode. */
	uint8_t	opcode;
	/*
	 * Destroy QP command deletes the QP context and ceases
	 * any further reference.
	 */
	#define CMDQ_DESTROY_QP_OPCODE_DESTROY_QP UINT32_C(0x2)
	#define CMDQ_DESTROY_QP_OPCODE_LAST	CMDQ_DESTROY_QP_OPCODE_DESTROY_QP
	/* Size of the command in 16-byte units. */
	uint8_t	cmd_size;
	/* Flags and attribs of the command. */
	uint16_t	flags;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* Size of the response buffer in 16-byte units. */
	uint8_t	resp_size;
	uint8_t	reserved8;
	/* Host address of the response. */
	uint64_t	resp_addr;
	/* QP context id */
	uint32_t	qp_cid;
	uint32_t	unused_0;
} cmdq_destroy_qp_t, *pcmdq_destroy_qp_t;

/* creq_destroy_qp_resp (size:128b/16B) */

typedef struct creq_destroy_qp_resp {
	uint8_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define CREQ_DESTROY_QP_RESP_TYPE_MASK	UINT32_C(0x3f)
	#define CREQ_DESTROY_QP_RESP_TYPE_SFT	0
	/* QP Async Notification */
		#define CREQ_DESTROY_QP_RESP_TYPE_QP_EVENT  UINT32_C(0x38)
		#define CREQ_DESTROY_QP_RESP_TYPE_LAST	CREQ_DESTROY_QP_RESP_TYPE_QP_EVENT
	/* Status of the response. */
	uint8_t	status;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* QP context id */
	uint32_t	xid;
	uint8_t	v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define CREQ_DESTROY_QP_RESP_V	UINT32_C(0x1)
	/* Event or command opcode. */
	uint8_t	event;
	/* Destroy QP command response. */
	#define CREQ_DESTROY_QP_RESP_EVENT_DESTROY_QP UINT32_C(0x2)
	#define CREQ_DESTROY_QP_RESP_EVENT_LAST	CREQ_DESTROY_QP_RESP_EVENT_DESTROY_QP
	uint8_t	reserved48[6];
} creq_destroy_qp_resp_t, *pcreq_destroy_qp_resp_t;

/*************
 * modify_qp *
 *************/


/* cmdq_modify_qp (size:1024b/128B) */

typedef struct cmdq_modify_qp {
	/* Command opcode. */
	uint8_t	opcode;
	/*
	 * Modify QP command changes QP states and other QP specific
	 * parameters.
	 */
	#define CMDQ_MODIFY_QP_OPCODE_MODIFY_QP UINT32_C(0x3)
	#define CMDQ_MODIFY_QP_OPCODE_LAST	CMDQ_MODIFY_QP_OPCODE_MODIFY_QP
	/* Size of the command in 16-byte units. */
	uint8_t	cmd_size;
	/* Flags and attribs of the command. */
	uint16_t	flags;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* Size of the response buffer in 16-byte units. */
	uint8_t	resp_size;
	uint8_t	reserved8;
	/* Host address of the response. */
	uint64_t	resp_addr;
	/* Modify mask signifies the field that is requesting the change. */
	uint32_t	modify_mask;
	/* QP state change. */
	#define CMDQ_MODIFY_QP_MODIFY_MASK_STATE		UINT32_C(0x1)
	/* Enable SQ drain asynchronous notification change. */
	#define CMDQ_MODIFY_QP_MODIFY_MASK_EN_SQD_ASYNC_NOTIFY	UINT32_C(0x2)
	/* Access change. */
	#define CMDQ_MODIFY_QP_MODIFY_MASK_ACCESS		UINT32_C(0x4)
	/* P_KEY change. */
	#define CMDQ_MODIFY_QP_MODIFY_MASK_PKEY			UINT32_C(0x8)
	/* Q_KEY index change. */
	#define CMDQ_MODIFY_QP_MODIFY_MASK_QKEY			UINT32_C(0x10)
	/* Destination GID change. */
	#define CMDQ_MODIFY_QP_MODIFY_MASK_DGID			UINT32_C(0x20)
	/* Flow label change. */
	#define CMDQ_MODIFY_QP_MODIFY_MASK_FLOW_LABEL		UINT32_C(0x40)
	/* SGID change. */
	#define CMDQ_MODIFY_QP_MODIFY_MASK_SGID_INDEX		UINT32_C(0x80)
	/* Hop limit change. */
	#define CMDQ_MODIFY_QP_MODIFY_MASK_HOP_LIMIT		UINT32_C(0x100)
	/* Traffic class change. */
	#define CMDQ_MODIFY_QP_MODIFY_MASK_TRAFFIC_CLASS	UINT32_C(0x200)
	/* destination MAC change. */
	#define CMDQ_MODIFY_QP_MODIFY_MASK_DEST_MAC		UINT32_C(0x400)
	/* Ping pong push mode change. */
	#define CMDQ_MODIFY_QP_MODIFY_MASK_PINGPONG_PUSH_MODE	UINT32_C(0x800)
	/* Path MTU change. */
	#define CMDQ_MODIFY_QP_MODIFY_MASK_PATH_MTU		UINT32_C(0x1000)
	/* Timeout change. */
	#define CMDQ_MODIFY_QP_MODIFY_MASK_TIMEOUT		UINT32_C(0x2000)
	/* Retry count change. */
	#define CMDQ_MODIFY_QP_MODIFY_MASK_RETRY_CNT		UINT32_C(0x4000)
	/* RNR Retry change. */
	#define CMDQ_MODIFY_QP_MODIFY_MASK_RNR_RETRY		UINT32_C(0x8000)
	/* RQ start packet sequence number change. */
	#define CMDQ_MODIFY_QP_MODIFY_MASK_RQ_PSN		UINT32_C(0x10000)
	/* Max outstanding RDMA read atomic change. */
	#define CMDQ_MODIFY_QP_MODIFY_MASK_MAX_RD_ATOMIC	UINT32_C(0x20000)
	/* RNR minimum timer change. */
	#define CMDQ_MODIFY_QP_MODIFY_MASK_MIN_RNR_TIMER	UINT32_C(0x40000)
	/* SQ start packet sequence number change. */
	#define CMDQ_MODIFY_QP_MODIFY_MASK_SQ_PSN		UINT32_C(0x80000)
	/* Max destination outstanding RDMA read atomic change. */
	#define CMDQ_MODIFY_QP_MODIFY_MASK_MAX_DEST_RD_ATOMIC	UINT32_C(0x100000)
	/* Max send WQE change. */
	#define CMDQ_MODIFY_QP_MODIFY_MASK_SQ_SIZE		UINT32_C(0x200000)
	/* Max recv WQE change. */
	#define CMDQ_MODIFY_QP_MODIFY_MASK_RQ_SIZE		UINT32_C(0x400000)
	/* Max recv SGEs per SWQE change. */
	#define CMDQ_MODIFY_QP_MODIFY_MASK_SQ_SGE		UINT32_C(0x800000)
	/* Max send SGEs per RWQE change. */
	#define CMDQ_MODIFY_QP_MODIFY_MASK_RQ_SGE		UINT32_C(0x1000000)
	/* Max inline data length change. */
	#define CMDQ_MODIFY_QP_MODIFY_MASK_MAX_INLINE_DATA	UINT32_C(0x2000000)
	/* Destination QP id change. */
	#define CMDQ_MODIFY_QP_MODIFY_MASK_DEST_QP_ID		UINT32_C(0x4000000)
	/* Source MAC change. */
	#define CMDQ_MODIFY_QP_MODIFY_MASK_SRC_MAC		UINT32_C(0x8000000)
	/* Source VLAN id change. */
	#define CMDQ_MODIFY_QP_MODIFY_MASK_VLAN_ID		UINT32_C(0x10000000)
	/* Congestion control RoCE v2 change. */
	#define CMDQ_MODIFY_QP_MODIFY_MASK_ENABLE_CC		UINT32_C(0x20000000)
	/* IP TOS ECN change */
	#define CMDQ_MODIFY_QP_MODIFY_MASK_TOS_ECN		UINT32_C(0x40000000)
	/* IP TOS DSCP change */
	#define CMDQ_MODIFY_QP_MODIFY_MASK_TOS_DSCP		UINT32_C(0x80000000)
	/* QP context id */
	uint32_t	qp_cid;
	uint8_t	network_type_en_sqd_async_notify_new_state;
	/* New QP state. */
	#define CMDQ_MODIFY_QP_NEW_STATE_MASK	UINT32_C(0xf)
	#define CMDQ_MODIFY_QP_NEW_STATE_SFT	0
	/* Reset. */
		#define CMDQ_MODIFY_QP_NEW_STATE_RESET	UINT32_C(0x0)
	/* Init. */
		#define CMDQ_MODIFY_QP_NEW_STATE_INIT		UINT32_C(0x1)
	/* Ready To Receive. */
		#define CMDQ_MODIFY_QP_NEW_STATE_RTR		UINT32_C(0x2)
	/* Ready To Send. */
		#define CMDQ_MODIFY_QP_NEW_STATE_RTS		UINT32_C(0x3)
	/* SQ Drain. */
		#define CMDQ_MODIFY_QP_NEW_STATE_SQD		UINT32_C(0x4)
	/* SQ Error. */
		#define CMDQ_MODIFY_QP_NEW_STATE_SQE		UINT32_C(0x5)
	/* Error. */
		#define CMDQ_MODIFY_QP_NEW_STATE_ERR		UINT32_C(0x6)
		#define CMDQ_MODIFY_QP_NEW_STATE_LAST	CMDQ_MODIFY_QP_NEW_STATE_ERR
	/* Enable SQ drain asynchronous notification. */
	#define CMDQ_MODIFY_QP_EN_SQD_ASYNC_NOTIFY	UINT32_C(0x10)
	/* unused1 is 1 b */
	#define CMDQ_MODIFY_QP_UNUSED1		UINT32_C(0x20)
	/* network type. */
	#define CMDQ_MODIFY_QP_NETWORK_TYPE_MASK	UINT32_C(0xc0)
	#define CMDQ_MODIFY_QP_NETWORK_TYPE_SFT	6
	/* RoCEv1. */
		#define CMDQ_MODIFY_QP_NETWORK_TYPE_ROCEV1	(UINT32_C(0x0) << 6)
	/* RoCEv2 IPv4. */
		#define CMDQ_MODIFY_QP_NETWORK_TYPE_ROCEV2_IPV4  (UINT32_C(0x2) << 6)
	/* RoCEv2 IPv6. */
		#define CMDQ_MODIFY_QP_NETWORK_TYPE_ROCEV2_IPV6  (UINT32_C(0x3) << 6)
		#define CMDQ_MODIFY_QP_NETWORK_TYPE_LAST	CMDQ_MODIFY_QP_NETWORK_TYPE_ROCEV2_IPV6
	/* Access flags. */
	uint8_t	access;
	#define CMDQ_MODIFY_QP_ACCESS_REMOTE_ATOMIC_REMOTE_READ_REMOTE_WRITE_LOCAL_WRITE_MASK		UINT32_C(0xff)
	#define CMDQ_MODIFY_QP_ACCESS_REMOTE_ATOMIC_REMOTE_READ_REMOTE_WRITE_LOCAL_WRITE_SFT		0
	/* Local write access. */
	#define CMDQ_MODIFY_QP_ACCESS_LOCAL_WRITE							UINT32_C(0x1)
	/* Remote write access. */
	#define CMDQ_MODIFY_QP_ACCESS_REMOTE_WRITE							UINT32_C(0x2)
	/* Remote read access. */
	#define CMDQ_MODIFY_QP_ACCESS_REMOTE_READ							UINT32_C(0x4)
	/* Remote atomic access. */
	#define CMDQ_MODIFY_QP_ACCESS_REMOTE_ATOMIC							UINT32_C(0x8)
	/* P_KEY. */
	uint16_t	pkey;
	/* Q_KEY. */
	uint32_t	qkey;
	/* Destination GID. */
	uint32_t	dgid[4];
	/* Flow label. */
	uint32_t	flow_label;
	/* Source GID index. */
	uint16_t	sgid_index;
	/* Hop limit. */
	uint8_t	hop_limit;
	/* Traffic class. */
	uint8_t	traffic_class;
	/* Destination MAC address. */
	uint16_t	dest_mac[3];
	uint8_t	tos_dscp_tos_ecn;
	/* IP TOS ECN. Valid values are 1 or 2 when ECN is enabled. */
	#define CMDQ_MODIFY_QP_TOS_ECN_MASK UINT32_C(0x3)
	#define CMDQ_MODIFY_QP_TOS_ECN_SFT  0
	/* IP TOS DSCP. */
	#define CMDQ_MODIFY_QP_TOS_DSCP_MASK UINT32_C(0xfc)
	#define CMDQ_MODIFY_QP_TOS_DSCP_SFT 2
	uint8_t	path_mtu_pingpong_push_enable;
	/*
	 * Driver requests for ping pong push mode to be enbabled for this
	 * QP. This request can be done only during modify from RST to INIT
	 * state.
	 */
	#define CMDQ_MODIFY_QP_PINGPONG_PUSH_ENABLE	UINT32_C(0x1)
	/* unused3 is 3 b */
	#define CMDQ_MODIFY_QP_UNUSED3_MASK		UINT32_C(0xe)
	#define CMDQ_MODIFY_QP_UNUSED3_SFT		1
	/* Path MTU. */
	#define CMDQ_MODIFY_QP_PATH_MTU_MASK		UINT32_C(0xf0)
	#define CMDQ_MODIFY_QP_PATH_MTU_SFT		4
	/* 256. */
		#define CMDQ_MODIFY_QP_PATH_MTU_MTU_256	(UINT32_C(0x0) << 4)
	/* 512. */
		#define CMDQ_MODIFY_QP_PATH_MTU_MTU_512	(UINT32_C(0x1) << 4)
	/* 1024. */
		#define CMDQ_MODIFY_QP_PATH_MTU_MTU_1024	(UINT32_C(0x2) << 4)
	/* 2048. */
		#define CMDQ_MODIFY_QP_PATH_MTU_MTU_2048	(UINT32_C(0x3) << 4)
	/* 4096. */
		#define CMDQ_MODIFY_QP_PATH_MTU_MTU_4096	(UINT32_C(0x4) << 4)
	/* 8192. */
		#define CMDQ_MODIFY_QP_PATH_MTU_MTU_8192	(UINT32_C(0x5) << 4)
		#define CMDQ_MODIFY_QP_PATH_MTU_LAST		CMDQ_MODIFY_QP_PATH_MTU_MTU_8192
	/* Timeout value for SWQEs. */
	uint8_t	timeout;
	/* Max retry count for WQEs. */
	uint8_t	retry_cnt;
	/* Max RNR retry count for WQEs. */
	uint8_t	rnr_retry;
	/* Min RNR timer that the QP will report to the remote. */
	uint8_t	min_rnr_timer;
	/* RQ start packet sequence number. */
	uint32_t	rq_psn;
	/* SQ start packet sequence number. */
	uint32_t	sq_psn;
	/* Max outstanding RDMA read atomic. */
	uint8_t	max_rd_atomic;
	/* Max destination outstanding RDMA read atomic. */
	uint8_t	max_dest_rd_atomic;
	uint16_t	enable_cc;
	/* Enable congestion control. */
	#define CMDQ_MODIFY_QP_ENABLE_CC	UINT32_C(0x1)
	/* unused15 is 15 b */
	#define CMDQ_MODIFY_QP_UNUSED15_MASK UINT32_C(0xfffe)
	#define CMDQ_MODIFY_QP_UNUSED15_SFT  1
	/* Max send WQE. */
	uint32_t	sq_size;
	/* Max recv WQE. */
	uint32_t	rq_size;
	/* Max send SGEs per SWQE. */
	uint16_t	sq_sge;
	/* Max recv SGEs per RWQE. */
	uint16_t	rq_sge;
	/* Max inline data length (upto 120 bytes). */
	uint32_t	max_inline_data;
	/* Destination QP id. */
	uint32_t	dest_qp_id;
	/* This is the DPI RoCE driver allocated for ping pong push. */
	uint32_t	pingpong_push_dpi;
	/* Source MAC. (Unused. Comes from Source GID index) */
	uint16_t	src_mac[3];
	uint16_t	vlan_pcp_vlan_dei_vlan_id;
	/* VLAN id. (Unused. Comes from Source GID index) */
	#define CMDQ_MODIFY_QP_VLAN_ID_MASK UINT32_C(0xfff)
	#define CMDQ_MODIFY_QP_VLAN_ID_SFT  0
	/* VLAN DEI field - Drop Eligibility Indicator. */
	#define CMDQ_MODIFY_QP_VLAN_DEI	UINT32_C(0x1000)
	/* VLAN PCP field - Priority Code Point. */
	#define CMDQ_MODIFY_QP_VLAN_PCP_MASK UINT32_C(0xe000)
	#define CMDQ_MODIFY_QP_VLAN_PCP_SFT 13
	/* IRRQ address. */
	uint64_t	irrq_addr;
	/* ORRQ address. */
	uint64_t	orrq_addr;
} cmdq_modify_qp_t, *pcmdq_modify_qp_t;

/* creq_modify_qp_resp (size:128b/16B) */

typedef struct creq_modify_qp_resp {
	uint8_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define CREQ_MODIFY_QP_RESP_TYPE_MASK	UINT32_C(0x3f)
	#define CREQ_MODIFY_QP_RESP_TYPE_SFT	0
	/* QP Async Notification */
		#define CREQ_MODIFY_QP_RESP_TYPE_QP_EVENT  UINT32_C(0x38)
		#define CREQ_MODIFY_QP_RESP_TYPE_LAST	CREQ_MODIFY_QP_RESP_TYPE_QP_EVENT
	/* Status of the response. */
	uint8_t	status;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* QP context id */
	uint32_t	xid;
	uint8_t	v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define CREQ_MODIFY_QP_RESP_V	UINT32_C(0x1)
	/* Event or command opcode. */
	uint8_t	event;
	/* Modify QP command response. */
	#define CREQ_MODIFY_QP_RESP_EVENT_MODIFY_QP UINT32_C(0x3)
	#define CREQ_MODIFY_QP_RESP_EVENT_LAST	CREQ_MODIFY_QP_RESP_EVENT_MODIFY_QP
	uint8_t	pingpong_push_state_index_enabled;
	/*
	 * When set it indicates that FW was able to successfully enable
	 * ping pong push mode for this QP.
	 */
	#define CREQ_MODIFY_QP_RESP_PINGPONG_PUSH_ENABLED	UINT32_C(0x1)
	/*
	 * When ping pong push mode is enabled this field will give the
	 * index into the push page where the QP has been mapped.
	 */
	#define CREQ_MODIFY_QP_RESP_PINGPONG_PUSH_INDEX_MASK  UINT32_C(0xe)
	#define CREQ_MODIFY_QP_RESP_PINGPONG_PUSH_INDEX_SFT   1
	/*
	 * This bit will tell whether to use ping or pong buffer
	 * for first push operation. 0 - ping buffer, 1 - pong buffer.
	 */
	#define CREQ_MODIFY_QP_RESP_PINGPONG_PUSH_STATE	UINT32_C(0x10)
	uint8_t	reserved8;
	/* Scrambled src mac needed to calculate UDP source port. */
	uint32_t	lag_src_mac;
} creq_modify_qp_resp_t, *pcreq_modify_qp_resp_t;

/************
 * query_qp *
 ************/


/* cmdq_query_qp (size:192b/24B) */

typedef struct cmdq_query_qp {
	/* Command opcode. */
	uint8_t	opcode;
	/* Query QP command retrieves info about the specified QP. */
	#define CMDQ_QUERY_QP_OPCODE_QUERY_QP UINT32_C(0x4)
	#define CMDQ_QUERY_QP_OPCODE_LAST	CMDQ_QUERY_QP_OPCODE_QUERY_QP
	/* Size of the command in 16-byte units. */
	uint8_t	cmd_size;
	/* Flags and attribs of the command. */
	uint16_t	flags;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* Size of the response buffer in 16-byte units. */
	uint8_t	resp_size;
	uint8_t	reserved8;
	/* Host address of the response. */
	uint64_t	resp_addr;
	/* QP context id */
	uint32_t	qp_cid;
	uint32_t	unused_0;
} cmdq_query_qp_t, *pcmdq_query_qp_t;

/* creq_query_qp_resp (size:128b/16B) */

typedef struct creq_query_qp_resp {
	uint8_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define CREQ_QUERY_QP_RESP_TYPE_MASK	UINT32_C(0x3f)
	#define CREQ_QUERY_QP_RESP_TYPE_SFT	0
	/* QP Async Notification */
		#define CREQ_QUERY_QP_RESP_TYPE_QP_EVENT  UINT32_C(0x38)
		#define CREQ_QUERY_QP_RESP_TYPE_LAST	CREQ_QUERY_QP_RESP_TYPE_QP_EVENT
	/* Status of the response. */
	uint8_t	status;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* Side buffer size in 16-byte units */
	uint32_t	size;
	uint8_t	v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define CREQ_QUERY_QP_RESP_V	UINT32_C(0x1)
	/* Event or command opcode. */
	uint8_t	event;
	/* Query QP command response. */
	#define CREQ_QUERY_QP_RESP_EVENT_QUERY_QP UINT32_C(0x4)
	#define CREQ_QUERY_QP_RESP_EVENT_LAST	CREQ_QUERY_QP_RESP_EVENT_QUERY_QP
	uint8_t	reserved48[6];
} creq_query_qp_resp_t, *pcreq_query_qp_resp_t;

/* Query QP command response side buffer structure. */
/* creq_query_qp_resp_sb (size:832b/104B) */

typedef struct creq_query_qp_resp_sb {
	/* Command opcode. */
	uint8_t	opcode;
	/* Query QP command response. */
	#define CREQ_QUERY_QP_RESP_SB_OPCODE_QUERY_QP UINT32_C(0x4)
	#define CREQ_QUERY_QP_RESP_SB_OPCODE_LAST	CREQ_QUERY_QP_RESP_SB_OPCODE_QUERY_QP
	/* Status of the response. */
	uint8_t	status;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* Flags and attribs of the command. */
	uint16_t	flags;
	/* Size of the response buffer in 16-byte units. */
	uint8_t	resp_size;
	uint8_t	reserved8;
	/* QP context id */
	uint32_t	xid;
	uint8_t	en_sqd_async_notify_state;
	/* QP state */
	#define CREQ_QUERY_QP_RESP_SB_STATE_MASK		UINT32_C(0xf)
	#define CREQ_QUERY_QP_RESP_SB_STATE_SFT		0
	/* Reset. */
		#define CREQ_QUERY_QP_RESP_SB_STATE_RESET		UINT32_C(0x0)
	/* Init. */
		#define CREQ_QUERY_QP_RESP_SB_STATE_INIT		UINT32_C(0x1)
	/* Ready To Receive. */
		#define CREQ_QUERY_QP_RESP_SB_STATE_RTR		UINT32_C(0x2)
	/* Ready To Send. */
		#define CREQ_QUERY_QP_RESP_SB_STATE_RTS		UINT32_C(0x3)
	/* SQ Drain. */
		#define CREQ_QUERY_QP_RESP_SB_STATE_SQD		UINT32_C(0x4)
	/* SQ Error. */
		#define CREQ_QUERY_QP_RESP_SB_STATE_SQE		UINT32_C(0x5)
	/* Error. */
		#define CREQ_QUERY_QP_RESP_SB_STATE_ERR		UINT32_C(0x6)
		#define CREQ_QUERY_QP_RESP_SB_STATE_LAST		CREQ_QUERY_QP_RESP_SB_STATE_ERR
	/* SQ drain asynchronous notification. */
	#define CREQ_QUERY_QP_RESP_SB_EN_SQD_ASYNC_NOTIFY	UINT32_C(0x10)
	/* Enable congestion control. */
	#define CREQ_QUERY_QP_RESP_SB_UNUSED3_MASK		UINT32_C(0xe0)
	#define CREQ_QUERY_QP_RESP_SB_UNUSED3_SFT		5
	/* Access flags. */
	uint8_t	access;
	#define CREQ_QUERY_QP_RESP_SB_ACCESS_REMOTE_ATOMIC_REMOTE_READ_REMOTE_WRITE_LOCAL_WRITE_MASK		UINT32_C(0xff)
	#define CREQ_QUERY_QP_RESP_SB_ACCESS_REMOTE_ATOMIC_REMOTE_READ_REMOTE_WRITE_LOCAL_WRITE_SFT		0
	/* Local write access. */
	#define CREQ_QUERY_QP_RESP_SB_ACCESS_LOCAL_WRITE							UINT32_C(0x1)
	/* Remote write access. */
	#define CREQ_QUERY_QP_RESP_SB_ACCESS_REMOTE_WRITE							UINT32_C(0x2)
	/* Remote read access. */
	#define CREQ_QUERY_QP_RESP_SB_ACCESS_REMOTE_READ							UINT32_C(0x4)
	/* Remote atomic access. */
	#define CREQ_QUERY_QP_RESP_SB_ACCESS_REMOTE_ATOMIC							UINT32_C(0x8)
	/* P_KEY index. */
	uint16_t	pkey;
	/* Q_KEY. */
	uint32_t	qkey;
	uint32_t	reserved32;
	/* Destination GID. */
	uint32_t	dgid[4];
	/* Flow label. */
	uint32_t	flow_label;
	/* Source GID index. */
	uint16_t	sgid_index;
	/* Hop limit. */
	uint8_t	hop_limit;
	/* Traffic class. */
	uint8_t	traffic_class;
	/* Destination MAC address. */
	uint16_t	dest_mac[3];
	uint16_t	path_mtu_dest_vlan_id;
	/* Destination VLAN ID. */
	#define CREQ_QUERY_QP_RESP_SB_DEST_VLAN_ID_MASK UINT32_C(0xfff)
	#define CREQ_QUERY_QP_RESP_SB_DEST_VLAN_ID_SFT 0
	/* Path MTU. */
	#define CREQ_QUERY_QP_RESP_SB_PATH_MTU_MASK	UINT32_C(0xf000)
	#define CREQ_QUERY_QP_RESP_SB_PATH_MTU_SFT	12
	/* 256. */
		#define CREQ_QUERY_QP_RESP_SB_PATH_MTU_MTU_256   (UINT32_C(0x0) << 12)
	/* 512. */
		#define CREQ_QUERY_QP_RESP_SB_PATH_MTU_MTU_512   (UINT32_C(0x1) << 12)
	/* 1024. */
		#define CREQ_QUERY_QP_RESP_SB_PATH_MTU_MTU_1024  (UINT32_C(0x2) << 12)
	/* 2048. */
		#define CREQ_QUERY_QP_RESP_SB_PATH_MTU_MTU_2048  (UINT32_C(0x3) << 12)
	/* 4096. */
		#define CREQ_QUERY_QP_RESP_SB_PATH_MTU_MTU_4096  (UINT32_C(0x4) << 12)
	/* 8192. */
		#define CREQ_QUERY_QP_RESP_SB_PATH_MTU_MTU_8192  (UINT32_C(0x5) << 12)
		#define CREQ_QUERY_QP_RESP_SB_PATH_MTU_LAST	CREQ_QUERY_QP_RESP_SB_PATH_MTU_MTU_8192
	/* Timeout value for SWQEs. */
	uint8_t	timeout;
	/* Max retry count for WQEs. */
	uint8_t	retry_cnt;
	/* Max RNR retry count for WQEs. */
	uint8_t	rnr_retry;
	/* Min RNR timer that the QP will report to the remote. */
	uint8_t	min_rnr_timer;
	/* RQ start packet sequence number. */
	uint32_t	rq_psn;
	/* SQ start packet sequence number. */
	uint32_t	sq_psn;
	/* Max outstanding RDMA read atomic. */
	uint8_t	max_rd_atomic;
	/* Max destination outstanding RDMA read atomic. */
	uint8_t	max_dest_rd_atomic;
	uint8_t	tos_dscp_tos_ecn;
	/* IP TOS ECN. */
	#define CREQ_QUERY_QP_RESP_SB_TOS_ECN_MASK UINT32_C(0x3)
	#define CREQ_QUERY_QP_RESP_SB_TOS_ECN_SFT  0
	/* IP TOS DSCP. */
	#define CREQ_QUERY_QP_RESP_SB_TOS_DSCP_MASK UINT32_C(0xfc)
	#define CREQ_QUERY_QP_RESP_SB_TOS_DSCP_SFT 2
	uint8_t	enable_cc;
	/* enable_cc is 1 b */
	#define CREQ_QUERY_QP_RESP_SB_ENABLE_CC	UINT32_C(0x1)
	/* Max send WQE. */
	uint32_t	sq_size;
	/* Max recv WQE. */
	uint32_t	rq_size;
	/* Max send SGEs per SWQE. */
	uint16_t	sq_sge;
	/* Max recv SGEs per RWQE (NOT SUPPORTED BY HARDWARE). */
	uint16_t	rq_sge;
	/* Max inline data length (upto 120 bytes). */
	uint32_t	max_inline_data;
	/* Destination QP id. */
	uint32_t	dest_qp_id;
	/* Port ID associated with the QP. */
	uint16_t	port_id;
	uint8_t	unused_0;
	/* Statistic collection ID allocated for this QP. */
	uint8_t	stat_collection_id;
	/* Source MAC. */
	uint16_t	src_mac[3];
	uint16_t	vlan_pcp_vlan_dei_vlan_id;
	/* Source VLAN id. */
	#define CREQ_QUERY_QP_RESP_SB_VLAN_ID_MASK UINT32_C(0xfff)
	#define CREQ_QUERY_QP_RESP_SB_VLAN_ID_SFT  0
	/* VLAN DEI field - Drop Eligibility Indicator. */
	#define CREQ_QUERY_QP_RESP_SB_VLAN_DEI	UINT32_C(0x1000)
	/* VLAN PCP field - Priority Code Point. */
	#define CREQ_QUERY_QP_RESP_SB_VLAN_PCP_MASK UINT32_C(0xe000)
	#define CREQ_QUERY_QP_RESP_SB_VLAN_PCP_SFT 13
} creq_query_qp_resp_sb_t, *pcreq_query_qp_resp_sb_t;

/*******************
 * query_qp_extend *
 *******************/


/* cmdq_query_qp_extend (size:192b/24B) */

typedef struct cmdq_query_qp_extend {
	/* Command opcode. */
	uint8_t	opcode;
	/*
	 * Query QP extend command retrieves info about multiple QPs associated
	 * with a specific PF.
	 */
	#define CMDQ_QUERY_QP_EXTEND_OPCODE_QUERY_QP_EXTEND UINT32_C(0x91)
	#define CMDQ_QUERY_QP_EXTEND_OPCODE_LAST	CMDQ_QUERY_QP_EXTEND_OPCODE_QUERY_QP_EXTEND
	/* Size of the command in 16-byte units. */
	uint8_t	cmd_size;
	/* Flags and attribs of the command. */
	uint16_t	flags;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* Size of the response buffer in 16-byte units. */
	uint8_t	resp_size;
	/* Number of QPs for which FW needs to query and provide info back to host. */
	uint8_t	num_qps;
	/* Host address of the response. */
	uint64_t	resp_addr;
	/* Unique identified for a function */
	uint32_t	function_id;
	/* PF number */
	#define CMDQ_QUERY_QP_EXTEND_PF_NUM_MASK  UINT32_C(0xff)
	#define CMDQ_QUERY_QP_EXTEND_PF_NUM_SFT   0
	/* VF number */
	#define CMDQ_QUERY_QP_EXTEND_VF_NUM_MASK  UINT32_C(0xffff00)
	#define CMDQ_QUERY_QP_EXTEND_VF_NUM_SFT   8
	/* When set the vf_num is valid. */
	#define CMDQ_QUERY_QP_EXTEND_VF_VALID	UINT32_C(0x1000000)
	/*
	 * This is the current index where firmware left off for query qp. Driver
	 * will pass this back in the next query_qp_extend command.
	 */
	uint32_t	current_index;
} cmdq_query_qp_extend_t, *pcmdq_query_qp_extend_t;

/* creq_query_qp_extend_resp (size:128b/16B) */

typedef struct creq_query_qp_extend_resp {
	uint8_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define CREQ_QUERY_QP_EXTEND_RESP_TYPE_MASK	UINT32_C(0x3f)
	#define CREQ_QUERY_QP_EXTEND_RESP_TYPE_SFT	0
	/* QP Async Notification */
		#define CREQ_QUERY_QP_EXTEND_RESP_TYPE_QP_EVENT  UINT32_C(0x38)
		#define CREQ_QUERY_QP_EXTEND_RESP_TYPE_LAST	CREQ_QUERY_QP_EXTEND_RESP_TYPE_QP_EVENT
	/* Status of the response. */
	uint8_t	status;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* Side buffer size in 16-byte units */
	uint32_t	size;
	uint8_t	v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define CREQ_QUERY_QP_EXTEND_RESP_V	UINT32_C(0x1)
	/* Event or command opcode. */
	uint8_t	event;
	/* Query QP extend command response. */
	#define CREQ_QUERY_QP_EXTEND_RESP_EVENT_QUERY_QP_EXTEND UINT32_C(0x91)
	#define CREQ_QUERY_QP_EXTEND_RESP_EVENT_LAST	CREQ_QUERY_QP_EXTEND_RESP_EVENT_QUERY_QP_EXTEND
	uint16_t	reserved16;
	/*
	 * This is the current index where firmware left off for query qp. Driver
	 * will pass this back in the next query_qp_extend command.
	 */
	uint32_t	current_index;
} creq_query_qp_extend_resp_t, *pcreq_query_qp_extend_resp_t;

/* Query QP extend command response side buffer structure. */
/* creq_query_qp_extend_resp_sb (size:384b/48B) */

typedef struct creq_query_qp_extend_resp_sb {
	/* Command opcode. */
	uint8_t	opcode;
	/* Query QP command extend response. */
	#define CREQ_QUERY_QP_EXTEND_RESP_SB_OPCODE_QUERY_QP_EXTEND UINT32_C(0x91)
	#define CREQ_QUERY_QP_EXTEND_RESP_SB_OPCODE_LAST	CREQ_QUERY_QP_EXTEND_RESP_SB_OPCODE_QUERY_QP_EXTEND
	/* Status of the response. */
	uint8_t	status;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* Flags and attribs of the command. */
	uint16_t	flags;
	/* Size of the response buffer in 16-byte units. */
	uint8_t	resp_size;
	uint8_t	reserved8;
	/* QP context id */
	uint32_t	xid;
	uint8_t	state;
	/* QP state */
	#define CREQ_QUERY_QP_EXTEND_RESP_SB_STATE_MASK  UINT32_C(0xf)
	#define CREQ_QUERY_QP_EXTEND_RESP_SB_STATE_SFT   0
	/* Reset. */
		#define CREQ_QUERY_QP_EXTEND_RESP_SB_STATE_RESET   UINT32_C(0x0)
	/* Init. */
		#define CREQ_QUERY_QP_EXTEND_RESP_SB_STATE_INIT	UINT32_C(0x1)
	/* Ready To Receive. */
		#define CREQ_QUERY_QP_EXTEND_RESP_SB_STATE_RTR	UINT32_C(0x2)
	/* Ready To Send. */
		#define CREQ_QUERY_QP_EXTEND_RESP_SB_STATE_RTS	UINT32_C(0x3)
	/* SQ Drain. */
		#define CREQ_QUERY_QP_EXTEND_RESP_SB_STATE_SQD	UINT32_C(0x4)
	/* SQ Error. */
		#define CREQ_QUERY_QP_EXTEND_RESP_SB_STATE_SQE	UINT32_C(0x5)
	/* Error. */
		#define CREQ_QUERY_QP_EXTEND_RESP_SB_STATE_ERR	UINT32_C(0x6)
		#define CREQ_QUERY_QP_EXTEND_RESP_SB_STATE_LAST   CREQ_QUERY_QP_EXTEND_RESP_SB_STATE_ERR
	/*  */
	#define CREQ_QUERY_QP_EXTEND_RESP_SB_UNUSED4_MASK UINT32_C(0xf0)
	#define CREQ_QUERY_QP_EXTEND_RESP_SB_UNUSED4_SFT 4
	uint8_t	reserved_8;
	/* Port ID associated with the QP. */
	uint16_t	port_id;
	/* Q_KEY. */
	uint32_t	qkey;
	/* Source GID index. */
	uint16_t	sgid_index;
	/* Network type. */
	uint8_t	network_type;
	/* RoCEv1. */
	#define CREQ_QUERY_QP_EXTEND_RESP_SB_NETWORK_TYPE_ROCEV1	UINT32_C(0x0)
	/* RoCEv2 IPv4. */
	#define CREQ_QUERY_QP_EXTEND_RESP_SB_NETWORK_TYPE_ROCEV2_IPV4 UINT32_C(0x2)
	/* RoCEv2 IPv6. */
	#define CREQ_QUERY_QP_EXTEND_RESP_SB_NETWORK_TYPE_ROCEV2_IPV6 UINT32_C(0x3)
	#define CREQ_QUERY_QP_EXTEND_RESP_SB_NETWORK_TYPE_LAST	CREQ_QUERY_QP_EXTEND_RESP_SB_NETWORK_TYPE_ROCEV2_IPV6
	uint8_t	unused_0;
	/* Destination GID. */
	uint32_t	dgid[4];
	/* Destination QP id. */
	uint32_t	dest_qp_id;
	/* Statistic collection ID allocated for this QP. */
	uint8_t	stat_collection_id;
	uint8_t	reservred_8;
	uint16_t	reserved_16;
} creq_query_qp_extend_resp_sb_t, *pcreq_query_qp_extend_resp_sb_t;

/*
 * TLV encapsulated Query QP extend control command response
 * side buffer.
 */
/* creq_query_qp_extend_resp_sb_tlv (size:512b/64B) */

typedef struct creq_query_qp_extend_resp_sb_tlv {
	/*
	 * The command discriminator is used to differentiate between various
	 * types of HWRM messages. This includes legacy HWRM and RoCE slowpath
	 * command messages as well as newer TLV encapsulated HWRM commands.
	 *
	 * For TLV encapsulated messages this field must be 0x8000.
	 */
	uint16_t	cmd_discr;
	uint8_t	reserved_8b;
	uint8_t	tlv_flags;
	/*
	 * Indicates the presence of additional TLV encapsulated data
	 * follows this TLV.
	 */
	#define CREQ_QUERY_QP_EXTEND_RESP_SB_TLV_TLV_FLAGS_MORE	UINT32_C(0x1)
	/* Last TLV in a sequence of TLVs. */
		#define CREQ_QUERY_QP_EXTEND_RESP_SB_TLV_TLV_FLAGS_MORE_LAST	UINT32_C(0x0)
	/* More TLVs follow this TLV. */
		#define CREQ_QUERY_QP_EXTEND_RESP_SB_TLV_TLV_FLAGS_MORE_NOT_LAST  UINT32_C(0x1)
	/*
	 * When an HWRM receiver detects a TLV type that it does not
	 * support with the TLV required flag set, the receiver must
	 * reject the HWRM message with an error code indicating an
	 * unsupported TLV type.
	 */
	#define CREQ_QUERY_QP_EXTEND_RESP_SB_TLV_TLV_FLAGS_REQUIRED	UINT32_C(0x2)
	/* No */
		#define CREQ_QUERY_QP_EXTEND_RESP_SB_TLV_TLV_FLAGS_REQUIRED_NO	(UINT32_C(0x0) << 1)
	/* Yes */
		#define CREQ_QUERY_QP_EXTEND_RESP_SB_TLV_TLV_FLAGS_REQUIRED_YES   (UINT32_C(0x1) << 1)
		#define CREQ_QUERY_QP_EXTEND_RESP_SB_TLV_TLV_FLAGS_REQUIRED_LAST CREQ_QUERY_QP_EXTEND_RESP_SB_TLV_TLV_FLAGS_REQUIRED_YES
	/*
	 * This field defines the TLV type value which is divided into
	 * two ranges to differentiate between global and local TLV types.
	 * Global TLV types must be unique across all defined TLV types.
	 * Local TLV types are valid only for extensions to a given
	 * HWRM message and may be repeated across different HWRM message
	 * types. There is a direct correlation of each HWRM message type
	 * to a single global TLV type value.
	 *
	 * Global TLV range: `0 - (63k-1)`
	 *
	 * Local TLV range: `63k - (64k-1)`
	 */
	uint16_t	tlv_type;
	/*
	 * Length of the message data encapsulated by this TLV in bytes.
	 * This length does not include the size of the TLV header itself
	 * and it must be an integer multiple of 8B.
	 */
	uint16_t	length;
	/*
	 * Size of the tlv encapsulated response,
	 * including all tlvs and extension data in 16-byte units.
	 */
	uint8_t	total_size;
	uint8_t	reserved56[7];
	/* Command opcode. */
	uint8_t	opcode;
	/* Query QP command extend response. */
	#define CREQ_QUERY_QP_EXTEND_RESP_SB_TLV_OPCODE_QUERY_QP_EXTEND UINT32_C(0x91)
	#define CREQ_QUERY_QP_EXTEND_RESP_SB_TLV_OPCODE_LAST	CREQ_QUERY_QP_EXTEND_RESP_SB_TLV_OPCODE_QUERY_QP_EXTEND
	/* Status of the response. */
	uint8_t	status;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* Flags and attribs of the command. */
	uint16_t	flags;
	/* Size of the response buffer in 16-byte units. */
	uint8_t	resp_size;
	uint8_t	reserved8;
	/* QP context id */
	uint32_t	xid;
	uint8_t	state;
	/* QP state */
	#define CREQ_QUERY_QP_EXTEND_RESP_SB_TLV_STATE_MASK  UINT32_C(0xf)
	#define CREQ_QUERY_QP_EXTEND_RESP_SB_TLV_STATE_SFT   0
	/* Reset. */
		#define CREQ_QUERY_QP_EXTEND_RESP_SB_TLV_STATE_RESET   UINT32_C(0x0)
	/* Init. */
		#define CREQ_QUERY_QP_EXTEND_RESP_SB_TLV_STATE_INIT	UINT32_C(0x1)
	/* Ready To Receive. */
		#define CREQ_QUERY_QP_EXTEND_RESP_SB_TLV_STATE_RTR	UINT32_C(0x2)
	/* Ready To Send. */
		#define CREQ_QUERY_QP_EXTEND_RESP_SB_TLV_STATE_RTS	UINT32_C(0x3)
	/* SQ Drain. */
		#define CREQ_QUERY_QP_EXTEND_RESP_SB_TLV_STATE_SQD	UINT32_C(0x4)
	/* SQ Error. */
		#define CREQ_QUERY_QP_EXTEND_RESP_SB_TLV_STATE_SQE	UINT32_C(0x5)
	/* Error. */
		#define CREQ_QUERY_QP_EXTEND_RESP_SB_TLV_STATE_ERR	UINT32_C(0x6)
		#define CREQ_QUERY_QP_EXTEND_RESP_SB_TLV_STATE_LAST   CREQ_QUERY_QP_EXTEND_RESP_SB_TLV_STATE_ERR
	/*  */
	#define CREQ_QUERY_QP_EXTEND_RESP_SB_TLV_UNUSED4_MASK UINT32_C(0xf0)
	#define CREQ_QUERY_QP_EXTEND_RESP_SB_TLV_UNUSED4_SFT 4
	uint8_t	reserved_8;
	/* Port ID associated with the QP. */
	uint16_t	port_id;
	/* Q_KEY. */
	uint32_t	qkey;
	/* Source GID index. */
	uint16_t	sgid_index;
	/* Network type. */
	uint8_t	network_type;
	/* RoCEv1. */
	#define CREQ_QUERY_QP_EXTEND_RESP_SB_TLV_NETWORK_TYPE_ROCEV1	UINT32_C(0x0)
	/* RoCEv2 IPv4. */
	#define CREQ_QUERY_QP_EXTEND_RESP_SB_TLV_NETWORK_TYPE_ROCEV2_IPV4 UINT32_C(0x2)
	/* RoCEv2 IPv6. */
	#define CREQ_QUERY_QP_EXTEND_RESP_SB_TLV_NETWORK_TYPE_ROCEV2_IPV6 UINT32_C(0x3)
	#define CREQ_QUERY_QP_EXTEND_RESP_SB_TLV_NETWORK_TYPE_LAST	CREQ_QUERY_QP_EXTEND_RESP_SB_TLV_NETWORK_TYPE_ROCEV2_IPV6
	uint8_t	unused_0;
	/* Destination GID. */
	uint32_t	dgid[4];
	/* Destination QP id. */
	uint32_t	dest_qp_id;
	/* Statistic collection ID allocated for this QP. */
	uint8_t	stat_collection_id;
	uint8_t	reservred_8;
	uint16_t	reserved_16;
} creq_query_qp_extend_resp_sb_tlv_t, *pcreq_query_qp_extend_resp_sb_tlv_t;

/**************
 * create_srq *
 **************/


/* cmdq_create_srq (size:384b/48B) */

typedef struct cmdq_create_srq {
	/* Command opcode. */
	uint8_t	opcode;
	/* Create SRQ command allocates a SRQ with the specified parameters. */
	#define CMDQ_CREATE_SRQ_OPCODE_CREATE_SRQ UINT32_C(0x5)
	#define CMDQ_CREATE_SRQ_OPCODE_LAST	CMDQ_CREATE_SRQ_OPCODE_CREATE_SRQ
	/* Size of the command in 16-byte units. */
	uint8_t	cmd_size;
	/* Flags and attribs of the command. */
	uint16_t	flags;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* Size of the response buffer in 16-byte units. */
	uint8_t	resp_size;
	uint8_t	reserved8;
	/* Host address of the response. */
	uint64_t	resp_addr;
	/* SRQ handle. */
	uint64_t	srq_handle;
	uint16_t	pg_size_lvl;
	/* SRQ PBL indirect levels. */
	#define CMDQ_CREATE_SRQ_LVL_MASK	UINT32_C(0x3)
	#define CMDQ_CREATE_SRQ_LVL_SFT	0
	/* PBL pointer is physical start address. */
		#define CMDQ_CREATE_SRQ_LVL_LVL_0	UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
		#define CMDQ_CREATE_SRQ_LVL_LVL_1	UINT32_C(0x1)
	/* PBL pointer points to PDE table with each entry pointing to PTE tables. */
		#define CMDQ_CREATE_SRQ_LVL_LVL_2	UINT32_C(0x2)
		#define CMDQ_CREATE_SRQ_LVL_LAST	CMDQ_CREATE_SRQ_LVL_LVL_2
	/* page size. */
	#define CMDQ_CREATE_SRQ_PG_SIZE_MASK  UINT32_C(0x1c)
	#define CMDQ_CREATE_SRQ_PG_SIZE_SFT   2
	/* 4KB. */
		#define CMDQ_CREATE_SRQ_PG_SIZE_PG_4K   (UINT32_C(0x0) << 2)
	/* 8KB. */
		#define CMDQ_CREATE_SRQ_PG_SIZE_PG_8K   (UINT32_C(0x1) << 2)
	/* 64KB. */
		#define CMDQ_CREATE_SRQ_PG_SIZE_PG_64K  (UINT32_C(0x2) << 2)
	/* 2MB. */
		#define CMDQ_CREATE_SRQ_PG_SIZE_PG_2M   (UINT32_C(0x3) << 2)
	/* 8MB. */
		#define CMDQ_CREATE_SRQ_PG_SIZE_PG_8M   (UINT32_C(0x4) << 2)
	/* 1GB. */
		#define CMDQ_CREATE_SRQ_PG_SIZE_PG_1G   (UINT32_C(0x5) << 2)
		#define CMDQ_CREATE_SRQ_PG_SIZE_LAST   CMDQ_CREATE_SRQ_PG_SIZE_PG_1G
	/* unused11 is 11 b */
	#define CMDQ_CREATE_SRQ_UNUSED11_MASK UINT32_C(0xffe0)
	#define CMDQ_CREATE_SRQ_UNUSED11_SFT  5
	uint16_t	eventq_id;
	/* eventq_id is 12 b */
	#define CMDQ_CREATE_SRQ_EVENTQ_ID_MASK UINT32_C(0xfff)
	#define CMDQ_CREATE_SRQ_EVENTQ_ID_SFT 0
	/* unused4 is 4 b */
	#define CMDQ_CREATE_SRQ_UNUSED4_MASK  UINT32_C(0xf000)
	#define CMDQ_CREATE_SRQ_UNUSED4_SFT   12
	/* Max number of SRQ wqes. */
	uint16_t	srq_size;
	/* Offsetof first WQE in the first page of SRQ, in 128 byte units */
	uint16_t	srq_fwo;
	/* Doorbell page index. */
	uint32_t	dpi;
	/* Protection domain id. */
	uint32_t	pd_id;
	/* RQ PBL physical address. */
	uint64_t	pbl;
} cmdq_create_srq_t, *pcmdq_create_srq_t;

/* creq_create_srq_resp (size:128b/16B) */

typedef struct creq_create_srq_resp {
	uint8_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define CREQ_CREATE_SRQ_RESP_TYPE_MASK	UINT32_C(0x3f)
	#define CREQ_CREATE_SRQ_RESP_TYPE_SFT	0
	/* QP Async Notification */
		#define CREQ_CREATE_SRQ_RESP_TYPE_QP_EVENT  UINT32_C(0x38)
		#define CREQ_CREATE_SRQ_RESP_TYPE_LAST	CREQ_CREATE_SRQ_RESP_TYPE_QP_EVENT
	/* Status of the response. */
	uint8_t	status;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* SRQ context id */
	uint32_t	xid;
	uint8_t	v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define CREQ_CREATE_SRQ_RESP_V	UINT32_C(0x1)
	/* Event or command opcode. */
	uint8_t	event;
	/* Create SRQ command response. */
	#define CREQ_CREATE_SRQ_RESP_EVENT_CREATE_SRQ UINT32_C(0x5)
	#define CREQ_CREATE_SRQ_RESP_EVENT_LAST	CREQ_CREATE_SRQ_RESP_EVENT_CREATE_SRQ
	uint8_t	reserved48[6];
} creq_create_srq_resp_t, *pcreq_create_srq_resp_t;

/***************
 * destroy_srq *
 ***************/


/* cmdq_destroy_srq (size:192b/24B) */

typedef struct cmdq_destroy_srq {
	/* Command opcode. */
	uint8_t	opcode;
	/* Destroy SRQ command deletes and flushes the specified SRQ. */
	#define CMDQ_DESTROY_SRQ_OPCODE_DESTROY_SRQ UINT32_C(0x6)
	#define CMDQ_DESTROY_SRQ_OPCODE_LAST	CMDQ_DESTROY_SRQ_OPCODE_DESTROY_SRQ
	/* Size of the command in 16-byte units. */
	uint8_t	cmd_size;
	/* Flags and attribs of the command. */
	uint16_t	flags;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* Size of the response buffer in 16-byte units. */
	uint8_t	resp_size;
	uint8_t	reserved8;
	/* Host address of the response. */
	uint64_t	resp_addr;
	/* SRQ context id */
	uint32_t	srq_cid;
	uint32_t	unused_0;
} cmdq_destroy_srq_t, *pcmdq_destroy_srq_t;

/* creq_destroy_srq_resp (size:128b/16B) */

typedef struct creq_destroy_srq_resp {
	uint8_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define CREQ_DESTROY_SRQ_RESP_TYPE_MASK	UINT32_C(0x3f)
	#define CREQ_DESTROY_SRQ_RESP_TYPE_SFT	0
	/* QP Async Notification */
		#define CREQ_DESTROY_SRQ_RESP_TYPE_QP_EVENT  UINT32_C(0x38)
		#define CREQ_DESTROY_SRQ_RESP_TYPE_LAST	CREQ_DESTROY_SRQ_RESP_TYPE_QP_EVENT
	/* Status of the response. */
	uint8_t	status;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* SRQ context id */
	uint32_t	xid;
	uint8_t	v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define CREQ_DESTROY_SRQ_RESP_V	UINT32_C(0x1)
	/* Event or command opcode. */
	uint8_t	event;
	/* Destroy SRQ command response. */
	#define CREQ_DESTROY_SRQ_RESP_EVENT_DESTROY_SRQ UINT32_C(0x6)
	#define CREQ_DESTROY_SRQ_RESP_EVENT_LAST	CREQ_DESTROY_SRQ_RESP_EVENT_DESTROY_SRQ
	uint16_t	enable_for_arm[3];
	#define CREQ_DESTROY_SRQ_RESP_UNUSED0_MASK	UINT32_C(0xffff)
	#define CREQ_DESTROY_SRQ_RESP_UNUSED0_SFT	0
	/* Set to 1 if this SRQ is allowed to be armed for threshold async event */
	#define CREQ_DESTROY_SRQ_RESP_ENABLE_FOR_ARM_MASK UINT32_C(0x30000)
	#define CREQ_DESTROY_SRQ_RESP_ENABLE_FOR_ARM_SFT 16
} creq_destroy_srq_resp_t, *pcreq_destroy_srq_resp_t;

/*************
 * query_srq *
 *************/


/* cmdq_query_srq (size:192b/24B) */

typedef struct cmdq_query_srq {
	/* Command opcode. */
	uint8_t	opcode;
	/* Query SRP command retrieves info about the specified SRQ. */
	#define CMDQ_QUERY_SRQ_OPCODE_QUERY_SRQ UINT32_C(0x8)
	#define CMDQ_QUERY_SRQ_OPCODE_LAST	CMDQ_QUERY_SRQ_OPCODE_QUERY_SRQ
	/* Size of the command in 16-byte units. */
	uint8_t	cmd_size;
	/* Flags and attribs of the command. */
	uint16_t	flags;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* Size of the response buffer in 16-byte units. */
	uint8_t	resp_size;
	uint8_t	reserved8;
	/* Host address of the response. */
	uint64_t	resp_addr;
	/* SRQ context id */
	uint32_t	srq_cid;
	uint32_t	unused_0;
} cmdq_query_srq_t, *pcmdq_query_srq_t;

/* creq_query_srq_resp (size:128b/16B) */

typedef struct creq_query_srq_resp {
	uint8_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define CREQ_QUERY_SRQ_RESP_TYPE_MASK	UINT32_C(0x3f)
	#define CREQ_QUERY_SRQ_RESP_TYPE_SFT	0
	/* QP Async Notification */
		#define CREQ_QUERY_SRQ_RESP_TYPE_QP_EVENT  UINT32_C(0x38)
		#define CREQ_QUERY_SRQ_RESP_TYPE_LAST	CREQ_QUERY_SRQ_RESP_TYPE_QP_EVENT
	/* Status of the response. */
	uint8_t	status;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* Side buffer size in 16-byte units */
	uint32_t	size;
	uint8_t	v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define CREQ_QUERY_SRQ_RESP_V	UINT32_C(0x1)
	/* Event or command opcode. */
	uint8_t	event;
	/* Query SRQ command response. */
	#define CREQ_QUERY_SRQ_RESP_EVENT_QUERY_SRQ UINT32_C(0x8)
	#define CREQ_QUERY_SRQ_RESP_EVENT_LAST	CREQ_QUERY_SRQ_RESP_EVENT_QUERY_SRQ
	uint8_t	reserved48[6];
} creq_query_srq_resp_t, *pcreq_query_srq_resp_t;

/* Query SRQ command response side buffer structure. */
/* creq_query_srq_resp_sb (size:256b/32B) */

typedef struct creq_query_srq_resp_sb {
	/* Command opcode. */
	uint8_t	opcode;
	/* Query SRQ command response. */
	#define CREQ_QUERY_SRQ_RESP_SB_OPCODE_QUERY_SRQ UINT32_C(0x8)
	#define CREQ_QUERY_SRQ_RESP_SB_OPCODE_LAST	CREQ_QUERY_SRQ_RESP_SB_OPCODE_QUERY_SRQ
	/* Status of the response. */
	uint8_t	status;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* Flags and attribs of the command. */
	uint16_t	flags;
	/* Size of the response buffer in 16-byte units. */
	uint8_t	resp_size;
	uint8_t	reserved8;
	/* SRQ context id */
	uint32_t	xid;
	/* Watermark value to generate a SRQ limit event. */
	uint16_t	srq_limit;
	uint16_t	reserved16;
	/* data is 128 b */
	uint32_t	data[4];
} creq_query_srq_resp_sb_t, *pcreq_query_srq_resp_sb_t;

/*************
 * create_cq *
 *************/


/* cmdq_create_cq (size:384b/48B) */

typedef struct cmdq_create_cq {
	/* Command opcode. */
	uint8_t	opcode;
	/* Create CQ command allocates a CQ with the specified parameters. */
	#define CMDQ_CREATE_CQ_OPCODE_CREATE_CQ UINT32_C(0x9)
	#define CMDQ_CREATE_CQ_OPCODE_LAST	CMDQ_CREATE_CQ_OPCODE_CREATE_CQ
	/* Size of the command in 16-byte units. */
	uint8_t	cmd_size;
	/* Flags and attribs of the command. */
	uint16_t	flags;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* Size of the response buffer in 16-byte units. */
	uint8_t	resp_size;
	uint8_t	reserved8;
	/* Host address of the response. */
	uint64_t	resp_addr;
	/* CQ handle. */
	uint64_t	cq_handle;
	uint32_t	pg_size_lvl;
	/* PBL indirect levels. */
	#define CMDQ_CREATE_CQ_LVL_MASK	UINT32_C(0x3)
	#define CMDQ_CREATE_CQ_LVL_SFT	0
	/* PBL pointer is physical start address. */
		#define CMDQ_CREATE_CQ_LVL_LVL_0	UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
		#define CMDQ_CREATE_CQ_LVL_LVL_1	UINT32_C(0x1)
	/* PBL pointer points to PDE table with each entry pointing to PTE tables. */
		#define CMDQ_CREATE_CQ_LVL_LVL_2	UINT32_C(0x2)
		#define CMDQ_CREATE_CQ_LVL_LAST	CMDQ_CREATE_CQ_LVL_LVL_2
	/* page size. */
	#define CMDQ_CREATE_CQ_PG_SIZE_MASK  UINT32_C(0x1c)
	#define CMDQ_CREATE_CQ_PG_SIZE_SFT   2
	/* 4KB. */
		#define CMDQ_CREATE_CQ_PG_SIZE_PG_4K   (UINT32_C(0x0) << 2)
	/* 8KB. */
		#define CMDQ_CREATE_CQ_PG_SIZE_PG_8K   (UINT32_C(0x1) << 2)
	/* 64KB. */
		#define CMDQ_CREATE_CQ_PG_SIZE_PG_64K  (UINT32_C(0x2) << 2)
	/* 2MB. */
		#define CMDQ_CREATE_CQ_PG_SIZE_PG_2M   (UINT32_C(0x3) << 2)
	/* 8MB. */
		#define CMDQ_CREATE_CQ_PG_SIZE_PG_8M   (UINT32_C(0x4) << 2)
	/* 1GB. */
		#define CMDQ_CREATE_CQ_PG_SIZE_PG_1G   (UINT32_C(0x5) << 2)
		#define CMDQ_CREATE_CQ_PG_SIZE_LAST   CMDQ_CREATE_CQ_PG_SIZE_PG_1G
	/* unused27 is 27 b */
	#define CMDQ_CREATE_CQ_UNUSED27_MASK UINT32_C(0xffffffe0)
	#define CMDQ_CREATE_CQ_UNUSED27_SFT  5
	uint32_t	cq_fco_cnq_id;
	/* cnq_id is 12 b */
	#define CMDQ_CREATE_CQ_CNQ_ID_MASK UINT32_C(0xfff)
	#define CMDQ_CREATE_CQ_CNQ_ID_SFT 0
	/* Offset of first CQE in the first Page, in 32 byte units */
	#define CMDQ_CREATE_CQ_CQ_FCO_MASK UINT32_C(0xfffff000)
	#define CMDQ_CREATE_CQ_CQ_FCO_SFT 12
	/* Doorbell page index. */
	uint32_t	dpi;
	/* Max number of CQ wqes. */
	uint32_t	cq_size;
	/* CQ PBL physical address. */
	uint64_t	pbl;
} cmdq_create_cq_t, *pcmdq_create_cq_t;

/* creq_create_cq_resp (size:128b/16B) */

typedef struct creq_create_cq_resp {
	uint8_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define CREQ_CREATE_CQ_RESP_TYPE_MASK	UINT32_C(0x3f)
	#define CREQ_CREATE_CQ_RESP_TYPE_SFT	0
	/* QP Async Notification */
		#define CREQ_CREATE_CQ_RESP_TYPE_QP_EVENT  UINT32_C(0x38)
		#define CREQ_CREATE_CQ_RESP_TYPE_LAST	CREQ_CREATE_CQ_RESP_TYPE_QP_EVENT
	/* Status of the response. */
	uint8_t	status;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* CQ context id */
	uint32_t	xid;
	uint8_t	v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define CREQ_CREATE_CQ_RESP_V	UINT32_C(0x1)
	/* Event or command opcode. */
	uint8_t	event;
	/* Create CQ command response. */
	#define CREQ_CREATE_CQ_RESP_EVENT_CREATE_CQ UINT32_C(0x9)
	#define CREQ_CREATE_CQ_RESP_EVENT_LAST	CREQ_CREATE_CQ_RESP_EVENT_CREATE_CQ
	uint8_t	reserved48[6];
} creq_create_cq_resp_t, *pcreq_create_cq_resp_t;

/**************
 * destroy_cq *
 **************/


/* cmdq_destroy_cq (size:192b/24B) */

typedef struct cmdq_destroy_cq {
	/* Command opcode. */
	uint8_t	opcode;
	/* Destroy CQ command deletes and flushes the specified CQ. */
	#define CMDQ_DESTROY_CQ_OPCODE_DESTROY_CQ UINT32_C(0xa)
	#define CMDQ_DESTROY_CQ_OPCODE_LAST	CMDQ_DESTROY_CQ_OPCODE_DESTROY_CQ
	/* Size of the command in 16-byte units. */
	uint8_t	cmd_size;
	/* Flags and attribs of the command. */
	uint16_t	flags;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* Size of the response buffer in 16-byte units. */
	uint8_t	resp_size;
	uint8_t	reserved8;
	/* Host address of the response. */
	uint64_t	resp_addr;
	/* CQ context id */
	uint32_t	cq_cid;
	uint32_t	unused_0;
} cmdq_destroy_cq_t, *pcmdq_destroy_cq_t;

/* creq_destroy_cq_resp (size:128b/16B) */

typedef struct creq_destroy_cq_resp {
	uint8_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define CREQ_DESTROY_CQ_RESP_TYPE_MASK	UINT32_C(0x3f)
	#define CREQ_DESTROY_CQ_RESP_TYPE_SFT	0
	/* QP Async Notification */
		#define CREQ_DESTROY_CQ_RESP_TYPE_QP_EVENT  UINT32_C(0x38)
		#define CREQ_DESTROY_CQ_RESP_TYPE_LAST	CREQ_DESTROY_CQ_RESP_TYPE_QP_EVENT
	/* Status of the response. */
	uint8_t	status;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* CQ context id */
	uint32_t	xid;
	uint8_t	v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define CREQ_DESTROY_CQ_RESP_V	UINT32_C(0x1)
	/* Event or command opcode. */
	uint8_t	event;
	/* Destroy CQ command response. */
	#define CREQ_DESTROY_CQ_RESP_EVENT_DESTROY_CQ UINT32_C(0xa)
	#define CREQ_DESTROY_CQ_RESP_EVENT_LAST	CREQ_DESTROY_CQ_RESP_EVENT_DESTROY_CQ
	uint16_t	cq_arm_lvl;
	/*
	 * CQ ARM Level:
	 * 0 ? Not Armed
	 * 1 ? Arm SE Only, Generate CNQE only for incoming Solicted Events
	 * 2 ? Arm all, Generate CNQE for Rx and Tx
	 */
	#define CREQ_DESTROY_CQ_RESP_CQ_ARM_LVL_MASK UINT32_C(0x3)
	#define CREQ_DESTROY_CQ_RESP_CQ_ARM_LVL_SFT 0
	/*
	 * The total number of CNQ events for the CQ, incremented on each CNQ event for the CQ
	 *	(including firmware-generated CQ error notification).
	 */
	uint16_t	total_cnq_events;
	uint16_t	reserved16;
} creq_destroy_cq_resp_t, *pcreq_destroy_cq_resp_t;

/*************
 * resize_cq *
 *************/


/* cmdq_resize_cq (size:320b/40B) */

typedef struct cmdq_resize_cq {
	/* Command opcode. */
	uint8_t	opcode;
	/* Resize CQ command resizes the specified CQ. */
	#define CMDQ_RESIZE_CQ_OPCODE_RESIZE_CQ UINT32_C(0xc)
	#define CMDQ_RESIZE_CQ_OPCODE_LAST	CMDQ_RESIZE_CQ_OPCODE_RESIZE_CQ
	/* Size of the command in 16-byte units. */
	uint8_t	cmd_size;
	/* Flags and attribs of the command. */
	uint16_t	flags;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* Size of the response buffer in 16-byte units. */
	uint8_t	resp_size;
	uint8_t	reserved8;
	/* Host address of the response. */
	uint64_t	resp_addr;
	/* CQ context id */
	uint32_t	cq_cid;
	uint32_t	new_cq_size_pg_size_lvl;
	/* PBL indirect levels. */
	#define CMDQ_RESIZE_CQ_LVL_MASK	UINT32_C(0x3)
	#define CMDQ_RESIZE_CQ_LVL_SFT	0
	/* PBL pointer is physical start address. */
		#define CMDQ_RESIZE_CQ_LVL_LVL_0	UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
		#define CMDQ_RESIZE_CQ_LVL_LVL_1	UINT32_C(0x1)
	/* PBL pointer points to PDE table with each entry pointing to PTE tables. */
		#define CMDQ_RESIZE_CQ_LVL_LVL_2	UINT32_C(0x2)
		#define CMDQ_RESIZE_CQ_LVL_LAST	CMDQ_RESIZE_CQ_LVL_LVL_2
	/* page size. */
	#define CMDQ_RESIZE_CQ_PG_SIZE_MASK	UINT32_C(0x1c)
	#define CMDQ_RESIZE_CQ_PG_SIZE_SFT	2
	/* 4KB. */
		#define CMDQ_RESIZE_CQ_PG_SIZE_PG_4K	(UINT32_C(0x0) << 2)
	/* 8KB. */
		#define CMDQ_RESIZE_CQ_PG_SIZE_PG_8K	(UINT32_C(0x1) << 2)
	/* 64KB. */
		#define CMDQ_RESIZE_CQ_PG_SIZE_PG_64K	(UINT32_C(0x2) << 2)
	/* 2MB. */
		#define CMDQ_RESIZE_CQ_PG_SIZE_PG_2M	(UINT32_C(0x3) << 2)
	/* 8MB. */
		#define CMDQ_RESIZE_CQ_PG_SIZE_PG_8M	(UINT32_C(0x4) << 2)
	/* 1GB. */
		#define CMDQ_RESIZE_CQ_PG_SIZE_PG_1G	(UINT32_C(0x5) << 2)
		#define CMDQ_RESIZE_CQ_PG_SIZE_LAST	CMDQ_RESIZE_CQ_PG_SIZE_PG_1G
	/* New max number of CQ wqes. */
	#define CMDQ_RESIZE_CQ_NEW_CQ_SIZE_MASK UINT32_C(0x1fffffe0)
	#define CMDQ_RESIZE_CQ_NEW_CQ_SIZE_SFT 5
	/* CQ PBL physical address. */
	uint64_t	new_pbl;
	/* Offset of first CQE in the first Page, in 32 byte units */
	uint32_t	new_cq_fco;
	uint32_t	unused_0;
} cmdq_resize_cq_t, *pcmdq_resize_cq_t;

/* creq_resize_cq_resp (size:128b/16B) */

typedef struct creq_resize_cq_resp {
	uint8_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define CREQ_RESIZE_CQ_RESP_TYPE_MASK	UINT32_C(0x3f)
	#define CREQ_RESIZE_CQ_RESP_TYPE_SFT	0
	/* QP Async Notification */
		#define CREQ_RESIZE_CQ_RESP_TYPE_QP_EVENT  UINT32_C(0x38)
		#define CREQ_RESIZE_CQ_RESP_TYPE_LAST	CREQ_RESIZE_CQ_RESP_TYPE_QP_EVENT
	/* Status of the response. */
	uint8_t	status;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* CQ context id */
	uint32_t	xid;
	uint8_t	v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define CREQ_RESIZE_CQ_RESP_V	UINT32_C(0x1)
	/* Event or command opcode. */
	uint8_t	event;
	/* Resize CQ command response. */
	#define CREQ_RESIZE_CQ_RESP_EVENT_RESIZE_CQ UINT32_C(0xc)
	#define CREQ_RESIZE_CQ_RESP_EVENT_LAST	CREQ_RESIZE_CQ_RESP_EVENT_RESIZE_CQ
	uint8_t	reserved48[6];
} creq_resize_cq_resp_t, *pcreq_resize_cq_resp_t;

/*************
 * modify_cq *
 *************/


/* cmdq_modify_cq (size:512b/64B) */

typedef struct cmdq_modify_cq {
	/* Command opcode. */
	uint8_t	opcode;
	/* Modify CQ updates specific params in the CQ context. */
	#define CMDQ_MODIFY_CQ_OPCODE_MODIFY_CQ UINT32_C(0x90)
	#define CMDQ_MODIFY_CQ_OPCODE_LAST	CMDQ_MODIFY_CQ_OPCODE_MODIFY_CQ
	/* Size of the command in 16-byte units. */
	uint8_t	cmd_size;
	/* Flags and attribs of the command. */
	uint16_t	flags;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* Size of the response buffer in 16-byte units. */
	uint8_t	resp_size;
	uint8_t	reserved8;
	/* Host address of the response. */
	uint64_t	resp_addr;
	/* Modify mask signifies the field that is requesting the change. */
	uint32_t	modify_mask;
	/* Enable change. */
	#define CMDQ_MODIFY_CQ_MODIFY_MASK_CQ_HANDLE	UINT32_C(0x1)
	/* CNQ ID */
	#define CMDQ_MODIFY_CQ_MODIFY_MASK_CNQ_ID	UINT32_C(0x2)
	/* Offset of first CQE in the first page, in 32 byte units */
	#define CMDQ_MODIFY_CQ_MODIFY_MASK_FCO	UINT32_C(0x4)
	/* Doorbell page index */
	#define CMDQ_MODIFY_CQ_MODIFY_MASK_DPI	UINT32_C(0x8)
	/* Max number of CQ Wqes */
	#define CMDQ_MODIFY_CQ_MODIFY_MASK_CQ_SIZE	UINT32_C(0x10)
	/* CQ PBL physical address */
	#define CMDQ_MODIFY_CQ_MODIFY_MASK_PBL	UINT32_C(0x20)
	/* reserved32 is 32 b */
	uint32_t	reserved32;
	/* CQ handle. */
	uint64_t	cq_handle;
	uint32_t	cq_fco_cnq_id;
	/* cnq_id is 12 b */
	#define CMDQ_MODIFY_CQ_CNQ_ID_MASK UINT32_C(0xfff)
	#define CMDQ_MODIFY_CQ_CNQ_ID_SFT 0
	/* Offset of first CQE in the first Page, in 32 byte units */
	#define CMDQ_MODIFY_CQ_CQ_FCO_MASK UINT32_C(0xfffff000)
	#define CMDQ_MODIFY_CQ_CQ_FCO_SFT 12
	/* Doorbell page index. */
	uint32_t	dpi;
	/* Max number of CQ wqes. */
	uint32_t	cq_size;
	/* reserved32_1 is 32 b */
	uint32_t	reserved32_1;
	/* CQ PBL physical address. */
	uint64_t	pbl;
	/* reserved64 is 64 b */
	uint64_t	reserved64;
} cmdq_modify_cq_t, *pcmdq_modify_cq_t;

/* creq_modify_cq_resp (size:128b/16B) */

typedef struct creq_modify_cq_resp {
	uint8_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define CREQ_MODIFY_CQ_RESP_TYPE_MASK	UINT32_C(0x3f)
	#define CREQ_MODIFY_CQ_RESP_TYPE_SFT	0
	/* QP Async Notification */
		#define CREQ_MODIFY_CQ_RESP_TYPE_QP_EVENT  UINT32_C(0x38)
		#define CREQ_MODIFY_CQ_RESP_TYPE_LAST	CREQ_MODIFY_CQ_RESP_TYPE_QP_EVENT
	/* Status of the response. */
	uint8_t	status;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* CQ context id */
	uint32_t	xid;
	uint8_t	v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define CREQ_MODIFY_CQ_RESP_V	UINT32_C(0x1)
	/* Event or command opcode. */
	uint8_t	event;
	/* Modify CQ command response. */
	#define CREQ_MODIFY_CQ_RESP_EVENT_MODIFY_CQ UINT32_C(0x9)
	#define CREQ_MODIFY_CQ_RESP_EVENT_LAST	CREQ_MODIFY_CQ_RESP_EVENT_MODIFY_CQ
	uint8_t	reserved48[6];
} creq_modify_cq_resp_t, *pcreq_modify_cq_resp_t;

/****************
 * allocate_mrw *
 ****************/


/* cmdq_allocate_mrw (size:256b/32B) */

typedef struct cmdq_allocate_mrw {
	/* Command opcode. */
	uint8_t	opcode;
	/*
	 * Allocate MRW command allocates a MR/MW with the specified parameters
	 * and returns the region's L_KEY/R_KEY
	 */
	#define CMDQ_ALLOCATE_MRW_OPCODE_ALLOCATE_MRW UINT32_C(0xd)
	#define CMDQ_ALLOCATE_MRW_OPCODE_LAST	CMDQ_ALLOCATE_MRW_OPCODE_ALLOCATE_MRW
	/* Size of the command in 16-byte units. */
	uint8_t	cmd_size;
	/* Flags and attribs of the command. */
	uint16_t	flags;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* Size of the response buffer in 16-byte units. */
	uint8_t	resp_size;
	uint8_t	reserved8;
	/* Host address of the response. */
	uint64_t	resp_addr;
	/* MRW handle. */
	uint64_t	mrw_handle;
	uint8_t	mrw_flags;
	/* Allocate MRW flags. */
	#define CMDQ_ALLOCATE_MRW_MRW_FLAGS_MASK	UINT32_C(0xf)
	#define CMDQ_ALLOCATE_MRW_MRW_FLAGS_SFT	0
	/* Allocate Memory Region */
		#define CMDQ_ALLOCATE_MRW_MRW_FLAGS_MR	UINT32_C(0x0)
	/* Allocate Physical Memory Region */
		#define CMDQ_ALLOCATE_MRW_MRW_FLAGS_PMR	UINT32_C(0x1)
	/* Allocate Memory Window (type 1) */
		#define CMDQ_ALLOCATE_MRW_MRW_FLAGS_MW_TYPE1   UINT32_C(0x2)
	/* Allocate Memory Window (type 2A) */
		#define CMDQ_ALLOCATE_MRW_MRW_FLAGS_MW_TYPE2A  UINT32_C(0x3)
	/* Allocate Memory Window (type 2B) */
		#define CMDQ_ALLOCATE_MRW_MRW_FLAGS_MW_TYPE2B  UINT32_C(0x4)
		#define CMDQ_ALLOCATE_MRW_MRW_FLAGS_LAST	CMDQ_ALLOCATE_MRW_MRW_FLAGS_MW_TYPE2B
	/* unused4 is 4 b */
	#define CMDQ_ALLOCATE_MRW_UNUSED4_MASK	UINT32_C(0xf0)
	#define CMDQ_ALLOCATE_MRW_UNUSED4_SFT	4
	/* Access flags. */
	uint8_t	access;
	/* Consumer owns the key */
	#define CMDQ_ALLOCATE_MRW_ACCESS_CONSUMER_OWNED_KEY	UINT32_C(0x20)
	/* unused16 is 16 b */
	uint16_t	unused16;
	/* Protection domain id. */
	uint32_t	pd_id;
} cmdq_allocate_mrw_t, *pcmdq_allocate_mrw_t;

/* creq_allocate_mrw_resp (size:128b/16B) */

typedef struct creq_allocate_mrw_resp {
	uint8_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define CREQ_ALLOCATE_MRW_RESP_TYPE_MASK	UINT32_C(0x3f)
	#define CREQ_ALLOCATE_MRW_RESP_TYPE_SFT	0
	/* QP Async Notification */
		#define CREQ_ALLOCATE_MRW_RESP_TYPE_QP_EVENT  UINT32_C(0x38)
		#define CREQ_ALLOCATE_MRW_RESP_TYPE_LAST	CREQ_ALLOCATE_MRW_RESP_TYPE_QP_EVENT
	/* Status of the response. */
	uint8_t	status;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* L_KEY for MR, R_KEY for MW */
	uint32_t	xid;
	uint8_t	v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define CREQ_ALLOCATE_MRW_RESP_V	UINT32_C(0x1)
	/* Event or command opcode. */
	uint8_t	event;
	/* Allocate MRW command response. */
	#define CREQ_ALLOCATE_MRW_RESP_EVENT_ALLOCATE_MRW UINT32_C(0xd)
	#define CREQ_ALLOCATE_MRW_RESP_EVENT_LAST	CREQ_ALLOCATE_MRW_RESP_EVENT_ALLOCATE_MRW
	uint8_t	reserved48[6];
} creq_allocate_mrw_resp_t, *pcreq_allocate_mrw_resp_t;

/******************
 * deallocate_key *
 ******************/


/* cmdq_deallocate_key (size:192b/24B) */

typedef struct cmdq_deallocate_key {
	/* Command opcode. */
	uint8_t	opcode;
	/* De-allocate key command frees a MR/MW entry associated with the specified key. */
	#define CMDQ_DEALLOCATE_KEY_OPCODE_DEALLOCATE_KEY UINT32_C(0xe)
	#define CMDQ_DEALLOCATE_KEY_OPCODE_LAST	CMDQ_DEALLOCATE_KEY_OPCODE_DEALLOCATE_KEY
	/* Size of the command in 16-byte units. */
	uint8_t	cmd_size;
	/* Flags and attribs of the command. */
	uint16_t	flags;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* Size of the response buffer in 16-byte units. */
	uint8_t	resp_size;
	uint8_t	reserved8;
	/* Host address of the response. */
	uint64_t	resp_addr;
	uint8_t	mrw_flags;
	/* Deallocate MRW flags. */
	#define CMDQ_DEALLOCATE_KEY_MRW_FLAGS_MASK	UINT32_C(0xf)
	#define CMDQ_DEALLOCATE_KEY_MRW_FLAGS_SFT	0
	/* Deallocate Memory Region */
		#define CMDQ_DEALLOCATE_KEY_MRW_FLAGS_MR	UINT32_C(0x0)
	/* Deallocate Physical Memory Region */
		#define CMDQ_DEALLOCATE_KEY_MRW_FLAGS_PMR	UINT32_C(0x1)
	/* Deallocate Memory Window (type 1) */
		#define CMDQ_DEALLOCATE_KEY_MRW_FLAGS_MW_TYPE1   UINT32_C(0x2)
	/* Deallocate Memory Window (type 2A) */
		#define CMDQ_DEALLOCATE_KEY_MRW_FLAGS_MW_TYPE2A  UINT32_C(0x3)
	/* Deallocate Memory Window (type 2B) */
		#define CMDQ_DEALLOCATE_KEY_MRW_FLAGS_MW_TYPE2B  UINT32_C(0x4)
		#define CMDQ_DEALLOCATE_KEY_MRW_FLAGS_LAST	CMDQ_DEALLOCATE_KEY_MRW_FLAGS_MW_TYPE2B
	/* unused4 is 4 b */
	#define CMDQ_DEALLOCATE_KEY_UNUSED4_MASK	UINT32_C(0xf0)
	#define CMDQ_DEALLOCATE_KEY_UNUSED4_SFT	4
	/* unused24 is 24 b */
	uint8_t	unused24[3];
	/* key is 32 b */
	uint32_t	key;
} cmdq_deallocate_key_t, *pcmdq_deallocate_key_t;

/* creq_deallocate_key_resp (size:128b/16B) */

typedef struct creq_deallocate_key_resp {
	uint8_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define CREQ_DEALLOCATE_KEY_RESP_TYPE_MASK	UINT32_C(0x3f)
	#define CREQ_DEALLOCATE_KEY_RESP_TYPE_SFT	0
	/* QP Async Notification */
		#define CREQ_DEALLOCATE_KEY_RESP_TYPE_QP_EVENT  UINT32_C(0x38)
		#define CREQ_DEALLOCATE_KEY_RESP_TYPE_LAST	CREQ_DEALLOCATE_KEY_RESP_TYPE_QP_EVENT
	/* Status of the response. */
	uint8_t	status;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* L_KEY for MR, R_KEY for MW */
	uint32_t	xid;
	uint8_t	v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define CREQ_DEALLOCATE_KEY_RESP_V	UINT32_C(0x1)
	/* Event or command opcode. */
	uint8_t	event;
	/* De-allocate key command response. */
	#define CREQ_DEALLOCATE_KEY_RESP_EVENT_DEALLOCATE_KEY UINT32_C(0xe)
	#define CREQ_DEALLOCATE_KEY_RESP_EVENT_LAST	CREQ_DEALLOCATE_KEY_RESP_EVENT_DEALLOCATE_KEY
	uint16_t	reserved16;
	/*
	 * This is advisory data to facilitate eventual descruction of lingering memory regions in Windows.
	 * For memory window, it contains non-zero HWID of a region this window was bound to (without the 8-bit key portion).
	 * The host may check if the region is lingering in destroyed state and try to destroy it now.
	 * For memory region, if deallocation fails because there are windows bound to this region, this field will contain
	 * approximate number of those windows. This number is read from the context right before the
	 * deregistration is attempted and can potentially be slightly different from the current number.
	 */
	uint32_t	bound_window_info;
} creq_deallocate_key_resp_t, *pcreq_deallocate_key_resp_t;

/***************
 * register_mr *
 ***************/


/* cmdq_register_mr (size:384b/48B) */

typedef struct cmdq_register_mr {
	/* Command opcode. */
	uint8_t	opcode;
	/* Register MR command registers memory to the specified MR. */
	#define CMDQ_REGISTER_MR_OPCODE_REGISTER_MR UINT32_C(0xf)
	#define CMDQ_REGISTER_MR_OPCODE_LAST	CMDQ_REGISTER_MR_OPCODE_REGISTER_MR
	/* Size of the command in 16-byte units. */
	uint8_t	cmd_size;
	/* Flags and attribs of the command. */
	uint16_t	flags;
	/*
	 * When set, a new MR will be allocated first and then registered
	 * using the fields in this command. Note that for MR allocation
	 * the `key` field doesn't hold a valid L_KEY and is instead
	 * overloaded to hold the Protection Domain ID `pd_id`.
	 */
	#define CMDQ_REGISTER_MR_FLAGS_ALLOC_MR	UINT32_C(0x1)
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* Size of the response buffer in 16-byte units. */
	uint8_t	resp_size;
	uint8_t	reserved8;
	/* Host address of the response. */
	uint64_t	resp_addr;
	uint8_t	log2_pg_size_lvl;
	/* PBL indirect levels. */
	#define CMDQ_REGISTER_MR_LVL_MASK		UINT32_C(0x3)
	#define CMDQ_REGISTER_MR_LVL_SFT		0
	/* PBL pointer is physical start address. */
		#define CMDQ_REGISTER_MR_LVL_LVL_0		UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
		#define CMDQ_REGISTER_MR_LVL_LVL_1		UINT32_C(0x1)
	/* PBL pointer points to PDE table with each entry pointing to PTE tables. */
		#define CMDQ_REGISTER_MR_LVL_LVL_2		UINT32_C(0x2)
		#define CMDQ_REGISTER_MR_LVL_LAST		CMDQ_REGISTER_MR_LVL_LVL_2
	/* Log base 2 of page size; 12 is the minimum for 4KB. HW supported values are enumerated below. */
	#define CMDQ_REGISTER_MR_LOG2_PG_SIZE_MASK   UINT32_C(0x7c)
	#define CMDQ_REGISTER_MR_LOG2_PG_SIZE_SFT	2
	/* 4KB. */
		#define CMDQ_REGISTER_MR_LOG2_PG_SIZE_PG_4K	(UINT32_C(0xc) << 2)
	/* 8KB. */
		#define CMDQ_REGISTER_MR_LOG2_PG_SIZE_PG_8K	(UINT32_C(0xd) << 2)
	/* 64KB. */
		#define CMDQ_REGISTER_MR_LOG2_PG_SIZE_PG_64K   (UINT32_C(0x10) << 2)
	/* 256KB. */
		#define CMDQ_REGISTER_MR_LOG2_PG_SIZE_PG_256K  (UINT32_C(0x12) << 2)
	/* 1MB. */
		#define CMDQ_REGISTER_MR_LOG2_PG_SIZE_PG_1M	(UINT32_C(0x14) << 2)
	/* 2MB. */
		#define CMDQ_REGISTER_MR_LOG2_PG_SIZE_PG_2M	(UINT32_C(0x15) << 2)
	/* 4MB. */
		#define CMDQ_REGISTER_MR_LOG2_PG_SIZE_PG_4M	(UINT32_C(0x16) << 2)
	/* 1GB. */
		#define CMDQ_REGISTER_MR_LOG2_PG_SIZE_PG_1G	(UINT32_C(0x1e) << 2)
		#define CMDQ_REGISTER_MR_LOG2_PG_SIZE_LAST	CMDQ_REGISTER_MR_LOG2_PG_SIZE_PG_1G
	/* unused1 is 1 b */
	#define CMDQ_REGISTER_MR_UNUSED1		UINT32_C(0x80)
	/* Access flags. */
	uint8_t	access;
	/* Local write access. */
	#define CMDQ_REGISTER_MR_ACCESS_LOCAL_WRITE	UINT32_C(0x1)
	/* Remote read access. */
	#define CMDQ_REGISTER_MR_ACCESS_REMOTE_READ	UINT32_C(0x2)
	/* Remote write access. */
	#define CMDQ_REGISTER_MR_ACCESS_REMOTE_WRITE	UINT32_C(0x4)
	/* Remote atomic access. */
	#define CMDQ_REGISTER_MR_ACCESS_REMOTE_ATOMIC	UINT32_C(0x8)
	/* Bind access allowed. */
	#define CMDQ_REGISTER_MR_ACCESS_MW_BIND	UINT32_C(0x10)
	/* Indicate Zero Based Virtual Address (ZBVA). */
	#define CMDQ_REGISTER_MR_ACCESS_ZERO_BASED	UINT32_C(0x20)
	uint16_t	log2_pbl_pg_size;
	/* Log base 2 of PBL page size; 12 is the minimum for 4KB. HW supported values are enumerated below */
	#define CMDQ_REGISTER_MR_LOG2_PBL_PG_SIZE_MASK   UINT32_C(0x1f)
	#define CMDQ_REGISTER_MR_LOG2_PBL_PG_SIZE_SFT	0
	/* 4KB. */
		#define CMDQ_REGISTER_MR_LOG2_PBL_PG_SIZE_PG_4K	UINT32_C(0xc)
	/* 8KB. */
		#define CMDQ_REGISTER_MR_LOG2_PBL_PG_SIZE_PG_8K	UINT32_C(0xd)
	/* 64KB. */
		#define CMDQ_REGISTER_MR_LOG2_PBL_PG_SIZE_PG_64K   UINT32_C(0x10)
	/* 256KB. */
		#define CMDQ_REGISTER_MR_LOG2_PBL_PG_SIZE_PG_256K  UINT32_C(0x12)
	/* 1MB. */
		#define CMDQ_REGISTER_MR_LOG2_PBL_PG_SIZE_PG_1M	UINT32_C(0x14)
	/* 2MB. */
		#define CMDQ_REGISTER_MR_LOG2_PBL_PG_SIZE_PG_2M	UINT32_C(0x15)
	/* 4MB. */
		#define CMDQ_REGISTER_MR_LOG2_PBL_PG_SIZE_PG_4M	UINT32_C(0x16)
	/* 1GB. */
		#define CMDQ_REGISTER_MR_LOG2_PBL_PG_SIZE_PG_1G	UINT32_C(0x1e)
		#define CMDQ_REGISTER_MR_LOG2_PBL_PG_SIZE_LAST	CMDQ_REGISTER_MR_LOG2_PBL_PG_SIZE_PG_1G
	/* unused11 is 11 b */
	#define CMDQ_REGISTER_MR_UNUSED11_MASK	UINT32_C(0xffe0)
	#define CMDQ_REGISTER_MR_UNUSED11_SFT		5
	/*
	 * L_KEY of the previously allocated MR.
	 *
	 * If the `ALLOC_MR` flag is set then this field does not hold an
	 * L_KEY and instead contains the Protection Domain ID `pd_id`.
	 */
	uint32_t	key;
	/* Page table of the MR memory. */
	uint64_t	pbl;
	/* Virtual address of the MR. */
	uint64_t	va;
	/* Size of the MR. */
	uint64_t	mr_size;
} cmdq_register_mr_t, *pcmdq_register_mr_t;

/* creq_register_mr_resp (size:128b/16B) */

typedef struct creq_register_mr_resp {
	uint8_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define CREQ_REGISTER_MR_RESP_TYPE_MASK	UINT32_C(0x3f)
	#define CREQ_REGISTER_MR_RESP_TYPE_SFT	0
	/* QP Async Notification */
		#define CREQ_REGISTER_MR_RESP_TYPE_QP_EVENT  UINT32_C(0x38)
		#define CREQ_REGISTER_MR_RESP_TYPE_LAST	CREQ_REGISTER_MR_RESP_TYPE_QP_EVENT
	/* Status of the response. */
	uint8_t	status;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* L_KEY */
	uint32_t	xid;
	uint8_t	v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define CREQ_REGISTER_MR_RESP_V	UINT32_C(0x1)
	/* Event or command opcode. */
	uint8_t	event;
	/* Register MR command response. */
	#define CREQ_REGISTER_MR_RESP_EVENT_REGISTER_MR UINT32_C(0xf)
	#define CREQ_REGISTER_MR_RESP_EVENT_LAST	CREQ_REGISTER_MR_RESP_EVENT_REGISTER_MR
	uint8_t	reserved48[6];
} creq_register_mr_resp_t, *pcreq_register_mr_resp_t;

/*****************
 * deregister_mr *
 *****************/


/* cmdq_deregister_mr (size:192b/24B) */

typedef struct cmdq_deregister_mr {
	/* Command opcode. */
	uint8_t	opcode;
	/* Deregister MR command de-registers memory from the specified MR. */
	#define CMDQ_DEREGISTER_MR_OPCODE_DEREGISTER_MR UINT32_C(0x10)
	#define CMDQ_DEREGISTER_MR_OPCODE_LAST	CMDQ_DEREGISTER_MR_OPCODE_DEREGISTER_MR
	/* Size of the command in 16-byte units. */
	uint8_t	cmd_size;
	/* Flags and attribs of the command. */
	uint16_t	flags;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* Size of the response buffer in 16-byte units. */
	uint8_t	resp_size;
	uint8_t	reserved8;
	/* Host address of the response. */
	uint64_t	resp_addr;
	/* L_KEY of the MR. */
	uint32_t	lkey;
	uint32_t	unused_0;
} cmdq_deregister_mr_t, *pcmdq_deregister_mr_t;

/* creq_deregister_mr_resp (size:128b/16B) */

typedef struct creq_deregister_mr_resp {
	uint8_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define CREQ_DEREGISTER_MR_RESP_TYPE_MASK	UINT32_C(0x3f)
	#define CREQ_DEREGISTER_MR_RESP_TYPE_SFT	0
	/* QP Async Notification */
		#define CREQ_DEREGISTER_MR_RESP_TYPE_QP_EVENT  UINT32_C(0x38)
		#define CREQ_DEREGISTER_MR_RESP_TYPE_LAST	CREQ_DEREGISTER_MR_RESP_TYPE_QP_EVENT
	/* Status of the response. */
	uint8_t	status;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* L_KEY */
	uint32_t	xid;
	uint8_t	v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define CREQ_DEREGISTER_MR_RESP_V	UINT32_C(0x1)
	/* Event or command opcode. */
	uint8_t	event;
	/* Deregister MR command response. */
	#define CREQ_DEREGISTER_MR_RESP_EVENT_DEREGISTER_MR UINT32_C(0x10)
	#define CREQ_DEREGISTER_MR_RESP_EVENT_LAST	CREQ_DEREGISTER_MR_RESP_EVENT_DEREGISTER_MR
	uint16_t	reserved16;
	/*
	 * If deregister fails because there are windows bound to this region, this field will contain
	 * approximate number of those windows. This number is read from the context right before the
	 * deregistration is attempted and can potentially be slightly different from the current number.
	 */
	uint32_t	bound_windows;
} creq_deregister_mr_resp_t, *pcreq_deregister_mr_resp_t;

/***********
 * add_gid *
 ***********/


/* cmdq_add_gid (size:384b/48B) */

typedef struct cmdq_add_gid {
	/* Command opcode. */
	uint8_t	opcode;
	/* Add GID command adds a GID to the local address table. */
	#define CMDQ_ADD_GID_OPCODE_ADD_GID UINT32_C(0x11)
	#define CMDQ_ADD_GID_OPCODE_LAST   CMDQ_ADD_GID_OPCODE_ADD_GID
	/* Size of the command in 16-byte units. */
	uint8_t	cmd_size;
	/* Flags and attribs of the command. */
	uint16_t	flags;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* Size of the response buffer in 16-byte units. */
	uint8_t	resp_size;
	uint8_t	reserved8;
	/* Host address of the response. */
	uint64_t	resp_addr;
	/* GID, specified in LE format. */
	uint32_t	gid[4];
	/* Source MAC. */
	uint16_t	src_mac[3];
	/* flags. */
	uint16_t	vlan;
	#define CMDQ_ADD_GID_VLAN_VLAN_EN_TPID_VLAN_ID_MASK	UINT32_C(0xffff)
	#define CMDQ_ADD_GID_VLAN_VLAN_EN_TPID_VLAN_ID_SFT	0
	/* Source VLAN id. */
	#define CMDQ_ADD_GID_VLAN_VLAN_ID_MASK			UINT32_C(0xfff)
	#define CMDQ_ADD_GID_VLAN_VLAN_ID_SFT			0
	/* This set of bits select the TPID of the VLAN Tag. */
	#define CMDQ_ADD_GID_VLAN_TPID_MASK			UINT32_C(0x7000)
	#define CMDQ_ADD_GID_VLAN_TPID_SFT			12
	/* TPID = 0x88A8. */
		#define CMDQ_ADD_GID_VLAN_TPID_TPID_88A8			(UINT32_C(0x0) << 12)
	/* TPID = 0x8100. */
		#define CMDQ_ADD_GID_VLAN_TPID_TPID_8100			(UINT32_C(0x1) << 12)
	/* TPID = 0x9100. */
		#define CMDQ_ADD_GID_VLAN_TPID_TPID_9100			(UINT32_C(0x2) << 12)
	/* TPID = 0x9200. */
		#define CMDQ_ADD_GID_VLAN_TPID_TPID_9200			(UINT32_C(0x3) << 12)
	/* TPID = 0x9300. */
		#define CMDQ_ADD_GID_VLAN_TPID_TPID_9300			(UINT32_C(0x4) << 12)
	/* TPID = Configurable 1. */
		#define CMDQ_ADD_GID_VLAN_TPID_TPID_CFG1			(UINT32_C(0x5) << 12)
	/* TPID = Configurable 2. */
		#define CMDQ_ADD_GID_VLAN_TPID_TPID_CFG2			(UINT32_C(0x6) << 12)
	/* TPID = Configurable 3. */
		#define CMDQ_ADD_GID_VLAN_TPID_TPID_CFG3			(UINT32_C(0x7) << 12)
		#define CMDQ_ADD_GID_VLAN_TPID_LAST			CMDQ_ADD_GID_VLAN_TPID_TPID_CFG3
	/* Setting this bit to 1 enables insertion of a VLAN Tag to a RoCE header. */
	#define CMDQ_ADD_GID_VLAN_VLAN_EN				UINT32_C(0x8000)
	/* Identifier field in the IP header. */
	uint16_t	ipid;
	/* Stats context ID to use with this SGID */
	uint16_t	stats_ctx;
	#define CMDQ_ADD_GID_STATS_CTX_STATS_CTX_VALID_STATS_CTX_ID_MASK		UINT32_C(0xffff)
	#define CMDQ_ADD_GID_STATS_CTX_STATS_CTX_VALID_STATS_CTX_ID_SFT		0
	/* stats_ctx_id is 15 b */
	#define CMDQ_ADD_GID_STATS_CTX_STATS_CTX_ID_MASK				UINT32_C(0x7fff)
	#define CMDQ_ADD_GID_STATS_CTX_STATS_CTX_ID_SFT				0
	/* Setting this bit to 1 enables use of own stats context ID instead of per-function */
	#define CMDQ_ADD_GID_STATS_CTX_STATS_CTX_VALID				UINT32_C(0x8000)
	uint32_t	unused_0;
} cmdq_add_gid_t, *pcmdq_add_gid_t;

/* creq_add_gid_resp (size:128b/16B) */

typedef struct creq_add_gid_resp {
	uint8_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define CREQ_ADD_GID_RESP_TYPE_MASK	UINT32_C(0x3f)
	#define CREQ_ADD_GID_RESP_TYPE_SFT	0
	/* QP Async Notification */
		#define CREQ_ADD_GID_RESP_TYPE_QP_EVENT  UINT32_C(0x38)
		#define CREQ_ADD_GID_RESP_TYPE_LAST	CREQ_ADD_GID_RESP_TYPE_QP_EVENT
	/* Status of the response. */
	uint8_t	status;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* GID index */
	uint32_t	xid;
	uint8_t	v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define CREQ_ADD_GID_RESP_V	UINT32_C(0x1)
	/* Event or command opcode. */
	uint8_t	event;
	/* Add GID command response. */
	#define CREQ_ADD_GID_RESP_EVENT_ADD_GID UINT32_C(0x11)
	#define CREQ_ADD_GID_RESP_EVENT_LAST   CREQ_ADD_GID_RESP_EVENT_ADD_GID
	uint8_t	reserved48[6];
} creq_add_gid_resp_t, *pcreq_add_gid_resp_t;

/**************
 * delete_gid *
 **************/


/* cmdq_delete_gid (size:192b/24B) */

typedef struct cmdq_delete_gid {
	/* Command opcode. */
	uint8_t	opcode;
	/* Delete GID command deletes a GID from the local address table. */
	#define CMDQ_DELETE_GID_OPCODE_DELETE_GID UINT32_C(0x12)
	#define CMDQ_DELETE_GID_OPCODE_LAST	CMDQ_DELETE_GID_OPCODE_DELETE_GID
	/* Size of the command in 16-byte units. */
	uint8_t	cmd_size;
	/* Flags and attribs of the command. */
	uint16_t	flags;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* Size of the response buffer in 16-byte units. */
	uint8_t	resp_size;
	uint8_t	reserved8;
	/* Host address of the response. */
	uint64_t	resp_addr;
	/* GID index */
	uint16_t	gid_index;
	uint8_t	unused_0[6];
} cmdq_delete_gid_t, *pcmdq_delete_gid_t;

/* creq_delete_gid_resp (size:128b/16B) */

typedef struct creq_delete_gid_resp {
	uint8_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define CREQ_DELETE_GID_RESP_TYPE_MASK	UINT32_C(0x3f)
	#define CREQ_DELETE_GID_RESP_TYPE_SFT	0
	/* QP Async Notification */
		#define CREQ_DELETE_GID_RESP_TYPE_QP_EVENT  UINT32_C(0x38)
		#define CREQ_DELETE_GID_RESP_TYPE_LAST	CREQ_DELETE_GID_RESP_TYPE_QP_EVENT
	/* Status of the response. */
	uint8_t	status;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* GID index */
	uint32_t	xid;
	uint8_t	v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define CREQ_DELETE_GID_RESP_V	UINT32_C(0x1)
	/* Event or command opcode. */
	uint8_t	event;
	/* Delete GID command response. */
	#define CREQ_DELETE_GID_RESP_EVENT_DELETE_GID UINT32_C(0x12)
	#define CREQ_DELETE_GID_RESP_EVENT_LAST	CREQ_DELETE_GID_RESP_EVENT_DELETE_GID
	uint8_t	reserved48[6];
} creq_delete_gid_resp_t, *pcreq_delete_gid_resp_t;

/**************
 * modify_gid *
 **************/


/* cmdq_modify_gid (size:384b/48B) */

typedef struct cmdq_modify_gid {
	/* Command opcode. */
	uint8_t	opcode;
	/* Modify GID command modifies a GID in the local address table. */
	#define CMDQ_MODIFY_GID_OPCODE_MODIFY_GID UINT32_C(0x17)
	#define CMDQ_MODIFY_GID_OPCODE_LAST	CMDQ_MODIFY_GID_OPCODE_MODIFY_GID
	/* Size of the command in 16-byte units. */
	uint8_t	cmd_size;
	/* Flags and attribs of the command. */
	uint16_t	flags;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* Size of the response buffer in 16-byte units. */
	uint8_t	resp_size;
	uint8_t	reserved8;
	/* Host address of the response. */
	uint64_t	resp_addr;
	/* GID */
	uint32_t	gid[4];
	/* Source MAC. */
	uint16_t	src_mac[3];
	/* flags. */
	uint16_t	vlan;
	/* Source VLAN id. */
	#define CMDQ_MODIFY_GID_VLAN_VLAN_ID_MASK  UINT32_C(0xfff)
	#define CMDQ_MODIFY_GID_VLAN_VLAN_ID_SFT   0
	/* This set of bits select the TPID of the VLAN Tag. */
	#define CMDQ_MODIFY_GID_VLAN_TPID_MASK	UINT32_C(0x7000)
	#define CMDQ_MODIFY_GID_VLAN_TPID_SFT	12
	/* TPID = 0x88A8. */
		#define CMDQ_MODIFY_GID_VLAN_TPID_TPID_88A8  (UINT32_C(0x0) << 12)
	/* TPID = 0x8100. */
		#define CMDQ_MODIFY_GID_VLAN_TPID_TPID_8100  (UINT32_C(0x1) << 12)
	/* TPID = 0x9100. */
		#define CMDQ_MODIFY_GID_VLAN_TPID_TPID_9100  (UINT32_C(0x2) << 12)
	/* TPID = 0x9200. */
		#define CMDQ_MODIFY_GID_VLAN_TPID_TPID_9200  (UINT32_C(0x3) << 12)
	/* TPID = 0x9300. */
		#define CMDQ_MODIFY_GID_VLAN_TPID_TPID_9300  (UINT32_C(0x4) << 12)
	/* TPID = Configurable 1. */
		#define CMDQ_MODIFY_GID_VLAN_TPID_TPID_CFG1  (UINT32_C(0x5) << 12)
	/* TPID = Configurable 2. */
		#define CMDQ_MODIFY_GID_VLAN_TPID_TPID_CFG2  (UINT32_C(0x6) << 12)
	/* TPID = Configurable 3. */
		#define CMDQ_MODIFY_GID_VLAN_TPID_TPID_CFG3  (UINT32_C(0x7) << 12)
		#define CMDQ_MODIFY_GID_VLAN_TPID_LAST	CMDQ_MODIFY_GID_VLAN_TPID_TPID_CFG3
	/* Setting this bit to 1 enables insertion of a VLAN Tag to a RoCE header. */
	#define CMDQ_MODIFY_GID_VLAN_VLAN_EN	UINT32_C(0x8000)
	/* Identifier field in the IP header. */
	uint16_t	ipid;
	/* GID index */
	uint16_t	gid_index;
	/* Stats context ID to use with this SGID */
	uint16_t	stats_ctx;
	/* stats_ctx_id is 15 b */
	#define CMDQ_MODIFY_GID_STATS_CTX_STATS_CTX_ID_MASK   UINT32_C(0x7fff)
	#define CMDQ_MODIFY_GID_STATS_CTX_STATS_CTX_ID_SFT	0
	/* Setting this bit to 1 enables use of own stats context ID instead of per-function */
	#define CMDQ_MODIFY_GID_STATS_CTX_STATS_CTX_VALID	UINT32_C(0x8000)
	uint16_t	unused_0;
} cmdq_modify_gid_t, *pcmdq_modify_gid_t;

/* creq_modify_gid_resp (size:128b/16B) */

typedef struct creq_modify_gid_resp {
	uint8_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define CREQ_MODIFY_GID_RESP_TYPE_MASK	UINT32_C(0x3f)
	#define CREQ_MODIFY_GID_RESP_TYPE_SFT	0
	/* QP Async Notification */
		#define CREQ_MODIFY_GID_RESP_TYPE_QP_EVENT  UINT32_C(0x38)
		#define CREQ_MODIFY_GID_RESP_TYPE_LAST	CREQ_MODIFY_GID_RESP_TYPE_QP_EVENT
	/* Status of the response. */
	uint8_t	status;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* GID index */
	uint32_t	xid;
	uint8_t	v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define CREQ_MODIFY_GID_RESP_V	UINT32_C(0x1)
	/* Event or command opcode. */
	uint8_t	event;
	/* Add GID command response. */
	#define CREQ_MODIFY_GID_RESP_EVENT_ADD_GID UINT32_C(0x11)
	#define CREQ_MODIFY_GID_RESP_EVENT_LAST   CREQ_MODIFY_GID_RESP_EVENT_ADD_GID
	uint8_t	reserved48[6];
} creq_modify_gid_resp_t, *pcreq_modify_gid_resp_t;

/*************
 * query_gid *
 *************/


/* cmdq_query_gid (size:192b/24B) */

typedef struct cmdq_query_gid {
	/* Command opcode. */
	uint8_t	opcode;
	/* Query GID command queries a GID in the local address table. */
	#define CMDQ_QUERY_GID_OPCODE_QUERY_GID UINT32_C(0x18)
	#define CMDQ_QUERY_GID_OPCODE_LAST	CMDQ_QUERY_GID_OPCODE_QUERY_GID
	/* Size of the command in 16-byte units. */
	uint8_t	cmd_size;
	/* Flags and attribs of the command. */
	uint16_t	flags;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* Size of the response buffer in 16-byte units. */
	uint8_t	resp_size;
	uint8_t	reserved8;
	/* Host address of the response. */
	uint64_t	resp_addr;
	/* GID index */
	uint16_t	gid_index;
	/* unused16 is 16 b */
	uint8_t	unused16[6];
} cmdq_query_gid_t, *pcmdq_query_gid_t;

/* creq_query_gid_resp (size:128b/16B) */

typedef struct creq_query_gid_resp {
	uint8_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define CREQ_QUERY_GID_RESP_TYPE_MASK	UINT32_C(0x3f)
	#define CREQ_QUERY_GID_RESP_TYPE_SFT	0
	/* QP Async Notification */
		#define CREQ_QUERY_GID_RESP_TYPE_QP_EVENT  UINT32_C(0x38)
		#define CREQ_QUERY_GID_RESP_TYPE_LAST	CREQ_QUERY_GID_RESP_TYPE_QP_EVENT
	/* Status of the response. */
	uint8_t	status;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* Side buffer size in 16-byte units */
	uint32_t	size;
	uint8_t	v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define CREQ_QUERY_GID_RESP_V	UINT32_C(0x1)
	/* Event or command opcode. */
	uint8_t	event;
	/* Query GID command response. */
	#define CREQ_QUERY_GID_RESP_EVENT_QUERY_GID UINT32_C(0x18)
	#define CREQ_QUERY_GID_RESP_EVENT_LAST	CREQ_QUERY_GID_RESP_EVENT_QUERY_GID
	uint8_t	reserved48[6];
} creq_query_gid_resp_t, *pcreq_query_gid_resp_t;

/* Query GID command response side buffer structure */
/* creq_query_gid_resp_sb (size:320b/40B) */

typedef struct creq_query_gid_resp_sb {
	/* Command opcode. */
	uint8_t	opcode;
	/* Query GID command response. */
	#define CREQ_QUERY_GID_RESP_SB_OPCODE_QUERY_GID UINT32_C(0x18)
	#define CREQ_QUERY_GID_RESP_SB_OPCODE_LAST	CREQ_QUERY_GID_RESP_SB_OPCODE_QUERY_GID
	/* Status of the response. */
	uint8_t	status;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* Flags and attribs of the command. */
	uint16_t	flags;
	/* Size of the response buffer in 16-byte units. */
	uint8_t	resp_size;
	uint8_t	reserved8;
	/* GID */
	uint32_t	gid[4];
	/* Source MAC. */
	uint16_t	src_mac[3];
	/* flags. */
	uint16_t	vlan;
	#define CREQ_QUERY_GID_RESP_SB_VLAN_VLAN_EN_TPID_VLAN_ID_MASK	UINT32_C(0xffff)
	#define CREQ_QUERY_GID_RESP_SB_VLAN_VLAN_EN_TPID_VLAN_ID_SFT	0
	/* Source VLAN id. */
	#define CREQ_QUERY_GID_RESP_SB_VLAN_VLAN_ID_MASK			UINT32_C(0xfff)
	#define CREQ_QUERY_GID_RESP_SB_VLAN_VLAN_ID_SFT			0
	/* This set of bits select the TPID of the VLAN Tag. */
	#define CREQ_QUERY_GID_RESP_SB_VLAN_TPID_MASK			UINT32_C(0x7000)
	#define CREQ_QUERY_GID_RESP_SB_VLAN_TPID_SFT			12
	/* TPID = 0x88A8. */
		#define CREQ_QUERY_GID_RESP_SB_VLAN_TPID_TPID_88A8			(UINT32_C(0x0) << 12)
	/* TPID = 0x8100. */
		#define CREQ_QUERY_GID_RESP_SB_VLAN_TPID_TPID_8100			(UINT32_C(0x1) << 12)
	/* TPID = 0x9100. */
		#define CREQ_QUERY_GID_RESP_SB_VLAN_TPID_TPID_9100			(UINT32_C(0x2) << 12)
	/* TPID = 0x9200. */
		#define CREQ_QUERY_GID_RESP_SB_VLAN_TPID_TPID_9200			(UINT32_C(0x3) << 12)
	/* TPID = 0x9300. */
		#define CREQ_QUERY_GID_RESP_SB_VLAN_TPID_TPID_9300			(UINT32_C(0x4) << 12)
	/* TPID = Configurable 1. */
		#define CREQ_QUERY_GID_RESP_SB_VLAN_TPID_TPID_CFG1			(UINT32_C(0x5) << 12)
	/* TPID = Configurable 2. */
		#define CREQ_QUERY_GID_RESP_SB_VLAN_TPID_TPID_CFG2			(UINT32_C(0x6) << 12)
	/* TPID = Configurable 3. */
		#define CREQ_QUERY_GID_RESP_SB_VLAN_TPID_TPID_CFG3			(UINT32_C(0x7) << 12)
		#define CREQ_QUERY_GID_RESP_SB_VLAN_TPID_LAST			CREQ_QUERY_GID_RESP_SB_VLAN_TPID_TPID_CFG3
	/* Setting this bit to 1 enables insertion of a VLAN Tag to a RoCE header. */
	#define CREQ_QUERY_GID_RESP_SB_VLAN_VLAN_EN				UINT32_C(0x8000)
	/* Identifier field in the IP header. */
	uint16_t	ipid;
	/* GID index */
	uint16_t	gid_index;
	uint32_t	unused_0;
} creq_query_gid_resp_sb_t, *pcreq_query_gid_resp_sb_t;

/**************
 * create_qp1 *
 **************/


/* cmdq_create_qp1 (size:640b/80B) */

typedef struct cmdq_create_qp1 {
	/* Command opcode. */
	uint8_t	opcode;
	/* Create QP1 command allocates a QP1 only. */
	#define CMDQ_CREATE_QP1_OPCODE_CREATE_QP1 UINT32_C(0x13)
	#define CMDQ_CREATE_QP1_OPCODE_LAST	CMDQ_CREATE_QP1_OPCODE_CREATE_QP1
	/* Size of the command in 16-byte units. */
	uint8_t	cmd_size;
	/* Flags and attribs of the command. */
	uint16_t	flags;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* Size of the response buffer in 16-byte units. */
	uint8_t	resp_size;
	uint8_t	reserved8;
	/* Host address of the response. */
	uint64_t	resp_addr;
	/* QP1 handle. */
	uint64_t	qp_handle;
	/* Create QP1 flags. */
	uint32_t	qp_flags;
	/* SRQ is used. */
	#define CMDQ_CREATE_QP1_QP_FLAGS_SRQ_USED		UINT32_C(0x1)
	/* post CQE for all SQ WQEs. */
	#define CMDQ_CREATE_QP1_QP_FLAGS_FORCE_COMPLETION	UINT32_C(0x2)
	/* This QP can use reserved L_Key */
	#define CMDQ_CREATE_QP1_QP_FLAGS_RESERVED_LKEY_ENABLE UINT32_C(0x4)
	#define CMDQ_CREATE_QP1_QP_FLAGS_LAST		CMDQ_CREATE_QP1_QP_FLAGS_RESERVED_LKEY_ENABLE
	/* Supported QP1 types. */
	uint8_t	type;
	/* General Services Interface on QP 1. */
	#define CMDQ_CREATE_QP1_TYPE_GSI UINT32_C(0x1)
	#define CMDQ_CREATE_QP1_TYPE_LAST CMDQ_CREATE_QP1_TYPE_GSI
	uint8_t	sq_pg_size_sq_lvl;
	/* SQ PBL indirect levels. */
	#define CMDQ_CREATE_QP1_SQ_LVL_MASK	UINT32_C(0xf)
	#define CMDQ_CREATE_QP1_SQ_LVL_SFT	0
	/* PBL pointer is physical start address. */
		#define CMDQ_CREATE_QP1_SQ_LVL_LVL_0	UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
		#define CMDQ_CREATE_QP1_SQ_LVL_LVL_1	UINT32_C(0x1)
	/* PBL pointer points to PDE table with each entry pointing to PTE tables. */
		#define CMDQ_CREATE_QP1_SQ_LVL_LVL_2	UINT32_C(0x2)
		#define CMDQ_CREATE_QP1_SQ_LVL_LAST	CMDQ_CREATE_QP1_SQ_LVL_LVL_2
	/* SQ page size. */
	#define CMDQ_CREATE_QP1_SQ_PG_SIZE_MASK  UINT32_C(0xf0)
	#define CMDQ_CREATE_QP1_SQ_PG_SIZE_SFT   4
	/* 4KB. */
		#define CMDQ_CREATE_QP1_SQ_PG_SIZE_PG_4K   (UINT32_C(0x0) << 4)
	/* 8KB. */
		#define CMDQ_CREATE_QP1_SQ_PG_SIZE_PG_8K   (UINT32_C(0x1) << 4)
	/* 64KB. */
		#define CMDQ_CREATE_QP1_SQ_PG_SIZE_PG_64K  (UINT32_C(0x2) << 4)
	/* 2MB. */
		#define CMDQ_CREATE_QP1_SQ_PG_SIZE_PG_2M   (UINT32_C(0x3) << 4)
	/* 8MB. */
		#define CMDQ_CREATE_QP1_SQ_PG_SIZE_PG_8M   (UINT32_C(0x4) << 4)
	/* 1GB. */
		#define CMDQ_CREATE_QP1_SQ_PG_SIZE_PG_1G   (UINT32_C(0x5) << 4)
		#define CMDQ_CREATE_QP1_SQ_PG_SIZE_LAST   CMDQ_CREATE_QP1_SQ_PG_SIZE_PG_1G
	uint8_t	rq_pg_size_rq_lvl;
	/* RQ PBL indirect levels. */
	#define CMDQ_CREATE_QP1_RQ_LVL_MASK	UINT32_C(0xf)
	#define CMDQ_CREATE_QP1_RQ_LVL_SFT	0
	/* PBL pointer is physical start address. */
		#define CMDQ_CREATE_QP1_RQ_LVL_LVL_0	UINT32_C(0x0)
	/* PBL pointer points to PTE table. */
		#define CMDQ_CREATE_QP1_RQ_LVL_LVL_1	UINT32_C(0x1)
	/* PBL pointer points to PDE table with each entry pointing to PTE tables. */
		#define CMDQ_CREATE_QP1_RQ_LVL_LVL_2	UINT32_C(0x2)
		#define CMDQ_CREATE_QP1_RQ_LVL_LAST	CMDQ_CREATE_QP1_RQ_LVL_LVL_2
	/* RQ page size. */
	#define CMDQ_CREATE_QP1_RQ_PG_SIZE_MASK  UINT32_C(0xf0)
	#define CMDQ_CREATE_QP1_RQ_PG_SIZE_SFT   4
	/* 4KB. */
		#define CMDQ_CREATE_QP1_RQ_PG_SIZE_PG_4K   (UINT32_C(0x0) << 4)
	/* 8KB. */
		#define CMDQ_CREATE_QP1_RQ_PG_SIZE_PG_8K   (UINT32_C(0x1) << 4)
	/* 64KB. */
		#define CMDQ_CREATE_QP1_RQ_PG_SIZE_PG_64K  (UINT32_C(0x2) << 4)
	/* 2MB. */
		#define CMDQ_CREATE_QP1_RQ_PG_SIZE_PG_2M   (UINT32_C(0x3) << 4)
	/* 8MB. */
		#define CMDQ_CREATE_QP1_RQ_PG_SIZE_PG_8M   (UINT32_C(0x4) << 4)
	/* 1GB. */
		#define CMDQ_CREATE_QP1_RQ_PG_SIZE_PG_1G   (UINT32_C(0x5) << 4)
		#define CMDQ_CREATE_QP1_RQ_PG_SIZE_LAST   CMDQ_CREATE_QP1_RQ_PG_SIZE_PG_1G
	uint8_t	unused_0;
	/* Doorbell page index. */
	uint32_t	dpi;
	/* Max number of SQ wqes. */
	uint32_t	sq_size;
	/* Max number of RQ wqes. */
	uint32_t	rq_size;
	uint16_t	sq_fwo_sq_sge;
	/* Max send SGEs per SWQE. */
	#define CMDQ_CREATE_QP1_SQ_SGE_MASK UINT32_C(0xf)
	#define CMDQ_CREATE_QP1_SQ_SGE_SFT 0
	/* Offset of First WQE in the first SQ page, in 128 byte units */
	#define CMDQ_CREATE_QP1_SQ_FWO_MASK UINT32_C(0xfff0)
	#define CMDQ_CREATE_QP1_SQ_FWO_SFT 4
	uint16_t	rq_fwo_rq_sge;
	/* Max recv SGEs per RWQE (NOT SUPPORTED BY HARDWARE). */
	#define CMDQ_CREATE_QP1_RQ_SGE_MASK UINT32_C(0xf)
	#define CMDQ_CREATE_QP1_RQ_SGE_SFT 0
	/* Offset of First WQE in the first RQ page, in 128 byte units */
	#define CMDQ_CREATE_QP1_RQ_FWO_MASK UINT32_C(0xfff0)
	#define CMDQ_CREATE_QP1_RQ_FWO_SFT 4
	/* Send CQ context id. */
	uint32_t	scq_cid;
	/* Receive CQ context id. */
	uint32_t	rcq_cid;
	/* SRQ CQ context id. */
	uint32_t	srq_cid;
	/* Protection domain id. */
	uint32_t	pd_id;
	/* SQ PBL physical address. */
	uint64_t	sq_pbl;
	/* RQ PBL physical address. */
	uint64_t	rq_pbl;
} cmdq_create_qp1_t, *pcmdq_create_qp1_t;

/* creq_create_qp1_resp (size:128b/16B) */

typedef struct creq_create_qp1_resp {
	uint8_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define CREQ_CREATE_QP1_RESP_TYPE_MASK	UINT32_C(0x3f)
	#define CREQ_CREATE_QP1_RESP_TYPE_SFT	0
	/* QP Async Notification */
		#define CREQ_CREATE_QP1_RESP_TYPE_QP_EVENT  UINT32_C(0x38)
		#define CREQ_CREATE_QP1_RESP_TYPE_LAST	CREQ_CREATE_QP1_RESP_TYPE_QP_EVENT
	/* Status of the response. */
	uint8_t	status;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* QP1 context id */
	uint32_t	xid;
	uint8_t	v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define CREQ_CREATE_QP1_RESP_V	UINT32_C(0x1)
	/* Event or command opcode. */
	uint8_t	event;
	/* Create QP1 command response. */
	#define CREQ_CREATE_QP1_RESP_EVENT_CREATE_QP1 UINT32_C(0x13)
	#define CREQ_CREATE_QP1_RESP_EVENT_LAST	CREQ_CREATE_QP1_RESP_EVENT_CREATE_QP1
	uint8_t	reserved48[6];
} creq_create_qp1_resp_t, *pcreq_create_qp1_resp_t;

/***************
 * destroy_qp1 *
 ***************/


/* cmdq_destroy_qp1 (size:192b/24B) */

typedef struct cmdq_destroy_qp1 {
	/* Command opcode. */
	uint8_t	opcode;
	/* Destroy QP1 command deletes and flushes the specified QP1. */
	#define CMDQ_DESTROY_QP1_OPCODE_DESTROY_QP1 UINT32_C(0x14)
	#define CMDQ_DESTROY_QP1_OPCODE_LAST	CMDQ_DESTROY_QP1_OPCODE_DESTROY_QP1
	/* Size of the command in 16-byte units. */
	uint8_t	cmd_size;
	/* Flags and attribs of the command. */
	uint16_t	flags;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* Size of the response buffer in 16-byte units. */
	uint8_t	resp_size;
	uint8_t	reserved8;
	/* Host address of the response. */
	uint64_t	resp_addr;
	/* QP1 context id */
	uint32_t	qp1_cid;
	uint32_t	unused_0;
} cmdq_destroy_qp1_t, *pcmdq_destroy_qp1_t;

/* creq_destroy_qp1_resp (size:128b/16B) */

typedef struct creq_destroy_qp1_resp {
	uint8_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define CREQ_DESTROY_QP1_RESP_TYPE_MASK	UINT32_C(0x3f)
	#define CREQ_DESTROY_QP1_RESP_TYPE_SFT	0
	/* QP Async Notification */
		#define CREQ_DESTROY_QP1_RESP_TYPE_QP_EVENT  UINT32_C(0x38)
		#define CREQ_DESTROY_QP1_RESP_TYPE_LAST	CREQ_DESTROY_QP1_RESP_TYPE_QP_EVENT
	/* Status of the response. */
	uint8_t	status;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* QP1 context id */
	uint32_t	xid;
	uint8_t	v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define CREQ_DESTROY_QP1_RESP_V	UINT32_C(0x1)
	/* Event or command opcode. */
	uint8_t	event;
	/* Destroy QP1 command response. */
	#define CREQ_DESTROY_QP1_RESP_EVENT_DESTROY_QP1 UINT32_C(0x14)
	#define CREQ_DESTROY_QP1_RESP_EVENT_LAST	CREQ_DESTROY_QP1_RESP_EVENT_DESTROY_QP1
	uint8_t	reserved48[6];
} creq_destroy_qp1_resp_t, *pcreq_destroy_qp1_resp_t;

/*************
 * create_ah *
 *************/


/* cmdq_create_ah (size:512b/64B) */

typedef struct cmdq_create_ah {
	/* Command opcode. */
	uint8_t	opcode;
	/* Create AH command allocates an AH with the specified parameters. */
	#define CMDQ_CREATE_AH_OPCODE_CREATE_AH UINT32_C(0x15)
	#define CMDQ_CREATE_AH_OPCODE_LAST	CMDQ_CREATE_AH_OPCODE_CREATE_AH
	/* Size of the command in 16-byte units. */
	uint8_t	cmd_size;
	/* Flags and attribs of the command. */
	uint16_t	flags;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* Size of the response buffer in 16-byte units. */
	uint8_t	resp_size;
	uint8_t	reserved8;
	/* Host address of the response. */
	uint64_t	resp_addr;
	/* AH handle. */
	uint64_t	ah_handle;
	/* Destination GID, specified in BE format. */
	uint32_t	dgid[4];
	/* V1, V2IPv4 or V2IPv6. */
	uint8_t	type;
	/* V2IPv4. */
	#define CMDQ_CREATE_AH_TYPE_V1	UINT32_C(0x0)
	/* V2IPv4. */
	#define CMDQ_CREATE_AH_TYPE_V2IPV4 UINT32_C(0x2)
	/* V2IPv6. */
	#define CMDQ_CREATE_AH_TYPE_V2IPV6 UINT32_C(0x3)
	#define CMDQ_CREATE_AH_TYPE_LAST  CMDQ_CREATE_AH_TYPE_V2IPV6
	/* IPv6 Hop limit. */
	uint8_t	hop_limit;
	/* SGID index. */
	uint16_t	sgid_index;
	uint32_t	dest_vlan_id_flow_label;
	/* Flow label. */
	#define CMDQ_CREATE_AH_FLOW_LABEL_MASK  UINT32_C(0xfffff)
	#define CMDQ_CREATE_AH_FLOW_LABEL_SFT   0
	/* Destination VLAN ID. */
	#define CMDQ_CREATE_AH_DEST_VLAN_ID_MASK UINT32_C(0xfff00000)
	#define CMDQ_CREATE_AH_DEST_VLAN_ID_SFT 20
	/* Protection domain id. */
	uint32_t	pd_id;
	uint32_t	unused_0;
	/* Destination MAC address. */
	uint16_t	dest_mac[3];
	/* Traffic class. */
	uint8_t	traffic_class;
	uint8_t	enable_cc;
	/* Enable congestion control. */
	#define CMDQ_CREATE_AH_ENABLE_CC	UINT32_C(0x1)
} cmdq_create_ah_t, *pcmdq_create_ah_t;

/* creq_create_ah_resp (size:128b/16B) */

typedef struct creq_create_ah_resp {
	uint8_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define CREQ_CREATE_AH_RESP_TYPE_MASK	UINT32_C(0x3f)
	#define CREQ_CREATE_AH_RESP_TYPE_SFT	0
	/* QP Async Notification */
		#define CREQ_CREATE_AH_RESP_TYPE_QP_EVENT  UINT32_C(0x38)
		#define CREQ_CREATE_AH_RESP_TYPE_LAST	CREQ_CREATE_AH_RESP_TYPE_QP_EVENT
	/* Status of the response. */
	uint8_t	status;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* AH context id */
	uint32_t	xid;
	uint8_t	v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define CREQ_CREATE_AH_RESP_V	UINT32_C(0x1)
	/* Event or command opcode. */
	uint8_t	event;
	/* Create AH command response. */
	#define CREQ_CREATE_AH_RESP_EVENT_CREATE_AH UINT32_C(0x15)
	#define CREQ_CREATE_AH_RESP_EVENT_LAST	CREQ_CREATE_AH_RESP_EVENT_CREATE_AH
	uint8_t	reserved48[6];
} creq_create_ah_resp_t, *pcreq_create_ah_resp_t;

/**************
 * destroy_ah *
 **************/


/* cmdq_destroy_ah (size:192b/24B) */

typedef struct cmdq_destroy_ah {
	/* Command opcode. */
	uint8_t	opcode;
	/* Destroy AH command deletes the specified AH. */
	#define CMDQ_DESTROY_AH_OPCODE_DESTROY_AH UINT32_C(0x16)
	#define CMDQ_DESTROY_AH_OPCODE_LAST	CMDQ_DESTROY_AH_OPCODE_DESTROY_AH
	/* Size of the command in 16-byte units. */
	uint8_t	cmd_size;
	/* Flags and attribs of the command. */
	uint16_t	flags;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* Size of the response buffer in 16-byte units. */
	uint8_t	resp_size;
	uint8_t	reserved8;
	/* Host address of the response. */
	uint64_t	resp_addr;
	/* AH context id */
	uint32_t	ah_cid;
	uint32_t	unused_0;
} cmdq_destroy_ah_t, *pcmdq_destroy_ah_t;

/* creq_destroy_ah_resp (size:128b/16B) */

typedef struct creq_destroy_ah_resp {
	uint8_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define CREQ_DESTROY_AH_RESP_TYPE_MASK	UINT32_C(0x3f)
	#define CREQ_DESTROY_AH_RESP_TYPE_SFT	0
	/* QP Async Notification */
		#define CREQ_DESTROY_AH_RESP_TYPE_QP_EVENT  UINT32_C(0x38)
		#define CREQ_DESTROY_AH_RESP_TYPE_LAST	CREQ_DESTROY_AH_RESP_TYPE_QP_EVENT
	/* Status of the response. */
	uint8_t	status;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* AH context id */
	uint32_t	xid;
	uint8_t	v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define CREQ_DESTROY_AH_RESP_V	UINT32_C(0x1)
	/* Event or command opcode. */
	uint8_t	event;
	/* Destroy AH command response. */
	#define CREQ_DESTROY_AH_RESP_EVENT_DESTROY_AH UINT32_C(0x16)
	#define CREQ_DESTROY_AH_RESP_EVENT_LAST	CREQ_DESTROY_AH_RESP_EVENT_DESTROY_AH
	uint8_t	reserved48[6];
} creq_destroy_ah_resp_t, *pcreq_destroy_ah_resp_t;

/********************
 * query_roce_stats *
 ********************/


/* cmdq_query_roce_stats (size:192b/24B) */

typedef struct cmdq_query_roce_stats {
	/* Command opcode. */
	uint8_t	opcode;
	/* Query RoCE statistics. */
	#define CMDQ_QUERY_ROCE_STATS_OPCODE_QUERY_ROCE_STATS UINT32_C(0x8e)
	#define CMDQ_QUERY_ROCE_STATS_OPCODE_LAST		CMDQ_QUERY_ROCE_STATS_OPCODE_QUERY_ROCE_STATS
	/* Size of the command in 16-byte units. */
	uint8_t	cmd_size;
	/* Flags and attribs of the command. */
	uint16_t	flags;
	/*
	 * When this bit is set FW will use the collection_id to extract RoCE statistics.
	 * If function_id is also specified the FW will return stats corresponding to the
	 * collection for the function_id specified.
	 */
	#define CMDQ_QUERY_ROCE_STATS_FLAGS_COLLECTION_ID	UINT32_C(0x1)
	/*
	 * When this bit is set FW will use the function_id to extract RoCE statistics.
	 * When collection is specified then FW will return the specific collection
	 * stats and if the collection is not specified then FW will return the default
	 * stats which will be for all QPs.
	 */
	#define CMDQ_QUERY_ROCE_STATS_FLAGS_FUNCTION_ID	UINT32_C(0x2)
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* Size of the response buffer in 16-byte units. */
	uint8_t	resp_size;
	/* The specific statistics group being queried. */
	uint8_t	collection_id;
	/* Host address of the response. */
	uint64_t	resp_addr;
	/* Unique identifier for a function */
	uint32_t	function_id;
	/* PF number */
	#define CMDQ_QUERY_ROCE_STATS_PF_NUM_MASK  UINT32_C(0xff)
	#define CMDQ_QUERY_ROCE_STATS_PF_NUM_SFT   0
	/* VF number */
	#define CMDQ_QUERY_ROCE_STATS_VF_NUM_MASK  UINT32_C(0xffff00)
	#define CMDQ_QUERY_ROCE_STATS_VF_NUM_SFT   8
	/* When set the vf_num is valid. */
	#define CMDQ_QUERY_ROCE_STATS_VF_VALID	UINT32_C(0x1000000)
	uint32_t	reserved32;
} cmdq_query_roce_stats_t, *pcmdq_query_roce_stats_t;

/* creq_query_roce_stats_resp (size:128b/16B) */

typedef struct creq_query_roce_stats_resp {
	uint8_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define CREQ_QUERY_ROCE_STATS_RESP_TYPE_MASK	UINT32_C(0x3f)
	#define CREQ_QUERY_ROCE_STATS_RESP_TYPE_SFT	0
	/* QP Async Notification */
		#define CREQ_QUERY_ROCE_STATS_RESP_TYPE_QP_EVENT  UINT32_C(0x38)
		#define CREQ_QUERY_ROCE_STATS_RESP_TYPE_LAST	CREQ_QUERY_ROCE_STATS_RESP_TYPE_QP_EVENT
	/* Status of the response. */
	uint8_t	status;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* Side buffer size in 16-byte units */
	uint32_t	size;
	uint8_t	v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define CREQ_QUERY_ROCE_STATS_RESP_V	UINT32_C(0x1)
	/* Event or command opcode. */
	uint8_t	event;
	/* Query RoCE statistics. */
	#define CREQ_QUERY_ROCE_STATS_RESP_EVENT_QUERY_ROCE_STATS UINT32_C(0x8e)
	#define CREQ_QUERY_ROCE_STATS_RESP_EVENT_LAST		CREQ_QUERY_ROCE_STATS_RESP_EVENT_QUERY_ROCE_STATS
	uint8_t	reserved48[6];
} creq_query_roce_stats_resp_t, *pcreq_query_roce_stats_resp_t;

/* Query RoCE Stats command response side buffer structure. */
/* creq_query_roce_stats_resp_sb (size:2944b/368B) */

typedef struct creq_query_roce_stats_resp_sb {
	/* Command opcode. */
	uint8_t	opcode;
	/* Query RoCE statistics. */
	#define CREQ_QUERY_ROCE_STATS_RESP_SB_OPCODE_QUERY_ROCE_STATS UINT32_C(0x8e)
	#define CREQ_QUERY_ROCE_STATS_RESP_SB_OPCODE_LAST		CREQ_QUERY_ROCE_STATS_RESP_SB_OPCODE_QUERY_ROCE_STATS
	/* Status of the response. */
	uint8_t	status;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* Flags and attribs of the command. */
	uint16_t	flags;
	/* Size of the response buffer in 16-byte units. */
	uint8_t	resp_size;
	uint8_t	rsvd;
	uint32_t	num_counters;
	uint32_t	rsvd1;
	uint64_t	to_retransmits;
	/* seq_err_naks_rcvd is 64 b */
	uint64_t	seq_err_naks_rcvd;
	/* max_retry_exceeded is 64 b */
	uint64_t	max_retry_exceeded;
	/* rnr_naks_rcvd is 64 b */
	uint64_t	rnr_naks_rcvd;
	uint64_t	missing_resp;
	/* unrecoverable_err is 64 b */
	uint64_t	unrecoverable_err;
	/* bad_resp_err is 64 b */
	uint64_t	bad_resp_err;
	/* local_qp_op_err is 64 b */
	uint64_t	local_qp_op_err;
	/* local_protection_err is 64 b */
	uint64_t	local_protection_err;
	/* mem_mgmt_op_err is 64 b */
	uint64_t	mem_mgmt_op_err;
	/* remote_invalid_req_err is 64 b */
	uint64_t	remote_invalid_req_err;
	/* remote_access_err is 64 b */
	uint64_t	remote_access_err;
	/* remote_op_err is 64 b */
	uint64_t	remote_op_err;
	/* dup_req is 64 b */
	uint64_t	dup_req;
	/* res_exceed_max is 64 b */
	uint64_t	res_exceed_max;
	/* res_length_mismatch is 64 b */
	uint64_t	res_length_mismatch;
	/* res_exceeds_wqe is 64 b */
	uint64_t	res_exceeds_wqe;
	/* res_opcode_err is 64 b */
	uint64_t	res_opcode_err;
	/* res_rx_invalid_rkey is 64 b */
	uint64_t	res_rx_invalid_rkey;
	/* res_rx_domain_err is 64 b */
	uint64_t	res_rx_domain_err;
	/* res_rx_no_perm is 64 b */
	uint64_t	res_rx_no_perm;
	/* res_rx_range_err is 64 b */
	uint64_t	res_rx_range_err;
	/* res_tx_invalid_rkey is 64 b */
	uint64_t	res_tx_invalid_rkey;
	/* res_tx_domain_err is 64 b */
	uint64_t	res_tx_domain_err;
	/* res_tx_no_perm is 64 b */
	uint64_t	res_tx_no_perm;
	/* res_tx_range_err is 64 b */
	uint64_t	res_tx_range_err;
	/* res_irrq_oflow is 64 b */
	uint64_t	res_irrq_oflow;
	/* res_unsup_opcode is 64 b */
	uint64_t	res_unsup_opcode;
	/* res_unaligned_atomic is 64 b */
	uint64_t	res_unaligned_atomic;
	/* res_rem_inv_err is 64 b */
	uint64_t	res_rem_inv_err;
	/* res_mem_error is 64 b */
	uint64_t	res_mem_error;
	/* res_srq_err is 64 b */
	uint64_t	res_srq_err;
	/* res_cmp_err is 64 b */
	uint64_t	res_cmp_err;
	/* res_invalid_dup_rkey is 64 b */
	uint64_t	res_invalid_dup_rkey;
	/* res_wqe_format_err is 64 b */
	uint64_t	res_wqe_format_err;
	/* res_cq_load_err is 64 b */
	uint64_t	res_cq_load_err;
	/* res_srq_load_err is 64 b */
	uint64_t	res_srq_load_err;
	/* res_tx_pci_err is 64 b */
	uint64_t	res_tx_pci_err;
	/* res_rx_pci_err is 64 b */
	uint64_t	res_rx_pci_err;
	/* res_oos_drop_count is 64 b */
	uint64_t	res_oos_drop_count;
	/* active_qp_count_p0 is 64 b */
	uint64_t	active_qp_count_p0;
	/* active_qp_count_p1 is 64 b */
	uint64_t	active_qp_count_p1;
	/* active_qp_count_p2 is 64 b */
	uint64_t	active_qp_count_p2;
	/* active_qp_count_p3 is 64 b */
	uint64_t	active_qp_count_p3;
} creq_query_roce_stats_resp_sb_t, *pcreq_query_roce_stats_resp_sb_t;

/************************
 * query_roce_stats_ext *
 ************************/


/* cmdq_query_roce_stats_ext (size:192b/24B) */

typedef struct cmdq_query_roce_stats_ext {
	/* Command opcode. */
	uint8_t	opcode;
	/* Query extended RoCE statistics. */
	#define CMDQ_QUERY_ROCE_STATS_EXT_OPCODE_QUERY_ROCE_STATS UINT32_C(0x92)
	#define CMDQ_QUERY_ROCE_STATS_EXT_OPCODE_LAST		CMDQ_QUERY_ROCE_STATS_EXT_OPCODE_QUERY_ROCE_STATS
	/* Size of the command in 16-byte units. */
	uint8_t	cmd_size;
	/* Flags and attribs of the command. */
	uint16_t	flags;
	/*
	 * When this bit is set FW will use the collection_id to extract RoCE statistics.
	 * If function_id is also specified the FW will return stats corresponding to the
	 * collection for the function_id specified.
	 */
	#define CMDQ_QUERY_ROCE_STATS_EXT_FLAGS_COLLECTION_ID	UINT32_C(0x1)
	/*
	 * When this bit is set FW will use the function_id to extract RoCE statistics.
	 * When collection is specified then FW will return the specific collection
	 * stats and if the collection is not specified then FW will return the default
	 * stats which will be for all QPs.
	 */
	#define CMDQ_QUERY_ROCE_STATS_EXT_FLAGS_FUNCTION_ID	UINT32_C(0x2)
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* Size of the response buffer in 16-byte units. */
	uint8_t	resp_size;
	/* The specific statistics group being queried. */
	uint8_t	collection_id;
	/* Host address of the response. */
	uint64_t	resp_addr;
	/* Unique identifier for a function */
	uint32_t	function_id;
	/* PF number */
	#define CMDQ_QUERY_ROCE_STATS_EXT_PF_NUM_MASK  UINT32_C(0xff)
	#define CMDQ_QUERY_ROCE_STATS_EXT_PF_NUM_SFT   0
	/* VF number */
	#define CMDQ_QUERY_ROCE_STATS_EXT_VF_NUM_MASK  UINT32_C(0xffff00)
	#define CMDQ_QUERY_ROCE_STATS_EXT_VF_NUM_SFT   8
	/* When set the vf_num is valid. */
	#define CMDQ_QUERY_ROCE_STATS_EXT_VF_VALID	UINT32_C(0x1000000)
	uint32_t	reserved32;
} cmdq_query_roce_stats_ext_t, *pcmdq_query_roce_stats_ext_t;

/* creq_query_roce_stats_ext_resp (size:128b/16B) */

typedef struct creq_query_roce_stats_ext_resp {
	uint8_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define CREQ_QUERY_ROCE_STATS_EXT_RESP_TYPE_MASK	UINT32_C(0x3f)
	#define CREQ_QUERY_ROCE_STATS_EXT_RESP_TYPE_SFT	0
	/* QP Async Notification */
		#define CREQ_QUERY_ROCE_STATS_EXT_RESP_TYPE_QP_EVENT  UINT32_C(0x38)
		#define CREQ_QUERY_ROCE_STATS_EXT_RESP_TYPE_LAST	CREQ_QUERY_ROCE_STATS_EXT_RESP_TYPE_QP_EVENT
	/* Status of the response. */
	uint8_t	status;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* Side buffer size in 16-byte units */
	uint32_t	size;
	uint8_t	v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define CREQ_QUERY_ROCE_STATS_EXT_RESP_V	UINT32_C(0x1)
	/* Event or command opcode. */
	uint8_t	event;
	/* Query extended RoCE statistics. */
	#define CREQ_QUERY_ROCE_STATS_EXT_RESP_EVENT_QUERY_ROCE_STATS_EXT UINT32_C(0x92)
	#define CREQ_QUERY_ROCE_STATS_EXT_RESP_EVENT_LAST		CREQ_QUERY_ROCE_STATS_EXT_RESP_EVENT_QUERY_ROCE_STATS_EXT
	uint8_t	reserved48[6];
} creq_query_roce_stats_ext_resp_t, *pcreq_query_roce_stats_ext_resp_t;

/* Query extended RoCE Stats command response side buffer structure. */
/* creq_query_roce_stats_ext_resp_sb (size:1536b/192B) */

typedef struct creq_query_roce_stats_ext_resp_sb {
	/* Command opcode. */
	uint8_t	opcode;
	/* Query extended RoCE statistics. */
	#define CREQ_QUERY_ROCE_STATS_EXT_RESP_SB_OPCODE_QUERY_ROCE_STATS_EXT UINT32_C(0x92)
	#define CREQ_QUERY_ROCE_STATS_EXT_RESP_SB_OPCODE_LAST		CREQ_QUERY_ROCE_STATS_EXT_RESP_SB_OPCODE_QUERY_ROCE_STATS_EXT
	/* Status of the response. */
	uint8_t	status;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* Flags and attribs of the command. */
	uint16_t	flags;
	/* Size of the response buffer in 16-byte units. */
	uint8_t	resp_size;
	uint8_t	rsvd;
	/* Number of transmitted Atomic request packets. */
	uint64_t	tx_atomic_req_pkts;
	/* Number of transmitted Read request packets. */
	uint64_t	tx_read_req_pkts;
	/* Number of transmitted Read response packets. */
	uint64_t	tx_read_res_pkts;
	/* Number of transmitted Write request packets. */
	uint64_t	tx_write_req_pkts;
	/*
	 * Number of transmitted Send request packets.
	 * This is for RC QPs only.
	 */
	uint64_t	tx_send_req_pkts;
	/*
	 * Number of transmitted RoCE packets.
	 * This includes RC, UD, RawEth, and QP1 packets
	 */
	uint64_t	tx_roce_pkts;
	/*
	 * Number of transmitted RoCE header and payload bytes.
	 * This includes RC, UD, RawEth, and QP1 packets.
	 */
	uint64_t	tx_roce_bytes;
	/* Number of received Atomic request packets. */
	uint64_t	rx_atomic_req_pkts;
	/* Number of received Read request packets. */
	uint64_t	rx_read_req_pkts;
	/* Number of received Read response packets. */
	uint64_t	rx_read_res_pkts;
	/* Number of received Write request packets. */
	uint64_t	rx_write_req_pkts;
	/*
	 * Number of received Send request packets.
	 * This is for RC QPs only.
	 */
	uint64_t	rx_send_req_pkts;
	/*
	 * Number of received RoCE packets including RoCE packets with errors.
	 * This includes RC, UD, RawEth, and QP1 packets
	 */
	uint64_t	rx_roce_pkts;
	/*
	 * Number of received RoCE header and payload bytes including RoCE
	 * packets with errors.
	 * This includes RC, UD, RawEth, and QP1 packets.
	 */
	uint64_t	rx_roce_bytes;
	/*
	 * Number of received RoCE packets.
	 * This includes RC, UD, RawEth, and QP1 packets
	 */
	uint64_t	rx_roce_good_pkts;
	/*
	 * Number of received RoCE header and payload bytes.
	 * This includes RC, UD, RawEth, and QP1 packets.
	 */
	uint64_t	rx_roce_good_bytes;
	/*
	 * Number of drops that occurred to lack of buffers.
	 * This is for RC QPs only.
	 */
	uint64_t	rx_out_of_buffer_pkts;
	/* Number of packets that were received out of sequence. */
	uint64_t	rx_out_of_sequence_pkts;
	/* Number of transmitted CNP packets. */
	uint64_t	tx_cnp_pkts;
	/* Number of received CNP packets. */
	uint64_t	rx_cnp_pkts;
	/* Number of received ECN-marked RoCE packets. */
	uint64_t	rx_ecn_marked_pkts;
	/* Number of transmitted CNP bytes. */
	uint64_t	tx_cnp_bytes;
	/* Number of received CNP bytes. */
	uint64_t	rx_cnp_bytes;
} creq_query_roce_stats_ext_resp_sb_t, *pcreq_query_roce_stats_ext_resp_sb_t;

/**************
 * query_func *
 **************/


/* cmdq_query_func (size:128b/16B) */

typedef struct cmdq_query_func {
	/* Command opcode. */
	uint8_t	opcode;
	/* Query the HW capabilities for the function. */
	#define CMDQ_QUERY_FUNC_OPCODE_QUERY_FUNC UINT32_C(0x83)
	#define CMDQ_QUERY_FUNC_OPCODE_LAST	CMDQ_QUERY_FUNC_OPCODE_QUERY_FUNC
	/* Size of the command in 16-byte units. */
	uint8_t	cmd_size;
	/* Flags and attribs of the command. */
	uint16_t	flags;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* Size of the response buffer in 16-byte units. */
	uint8_t	resp_size;
	uint8_t	reserved8;
	/* Host address of the response. */
	uint64_t	resp_addr;
} cmdq_query_func_t, *pcmdq_query_func_t;

/* creq_query_func_resp (size:128b/16B) */

typedef struct creq_query_func_resp {
	uint8_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define CREQ_QUERY_FUNC_RESP_TYPE_MASK	UINT32_C(0x3f)
	#define CREQ_QUERY_FUNC_RESP_TYPE_SFT	0
	/* QP Async Notification */
		#define CREQ_QUERY_FUNC_RESP_TYPE_QP_EVENT  UINT32_C(0x38)
		#define CREQ_QUERY_FUNC_RESP_TYPE_LAST	CREQ_QUERY_FUNC_RESP_TYPE_QP_EVENT
	/* Status of the response. */
	uint8_t	status;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* Side buffer size in 16-byte units */
	uint32_t	size;
	uint8_t	v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define CREQ_QUERY_FUNC_RESP_V	UINT32_C(0x1)
	/* Event or command opcode. */
	uint8_t	event;
	/* Query info PF command response. */
	#define CREQ_QUERY_FUNC_RESP_EVENT_QUERY_FUNC UINT32_C(0x83)
	#define CREQ_QUERY_FUNC_RESP_EVENT_LAST	CREQ_QUERY_FUNC_RESP_EVENT_QUERY_FUNC
	uint8_t	reserved48[6];
} creq_query_func_resp_t, *pcreq_query_func_resp_t;

/* Query function command response side buffer structure. */
/* creq_query_func_resp_sb (size:1088b/136B) */

typedef struct creq_query_func_resp_sb {
	/* Command opcode. */
	uint8_t	opcode;
	/* Query info PF command response. */
	#define CREQ_QUERY_FUNC_RESP_SB_OPCODE_QUERY_FUNC UINT32_C(0x83)
	#define CREQ_QUERY_FUNC_RESP_SB_OPCODE_LAST	CREQ_QUERY_FUNC_RESP_SB_OPCODE_QUERY_FUNC
	/* Status of the response. */
	uint8_t	status;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* Flags and attribs of the command. */
	uint16_t	flags;
	/* Size of the response buffer in 16-byte units. */
	uint8_t	resp_size;
	uint8_t	reserved8;
	/* Max MR size supported. */
	uint64_t	max_mr_size;
	/* Max QP supported. */
	uint32_t	max_qp;
	/* Max WQEs per QP. */
	uint16_t	max_qp_wr;
	/* Device capability flags. */
	uint16_t	dev_cap_flags;
	/* Allow QP resizing. */
	#define CREQ_QUERY_FUNC_RESP_SB_RESIZE_QP			UINT32_C(0x1)
	/* Specifies Congestion Control (CC) generation. */
	#define CREQ_QUERY_FUNC_RESP_SB_CC_GENERATION_MASK		UINT32_C(0xe)
	#define CREQ_QUERY_FUNC_RESP_SB_CC_GENERATION_SFT		1
	/*
	 * Includes support for DCTCP and TCP CC algorithms,
	 * enabling operation in networks where PFC is enabled.
	 */
		#define CREQ_QUERY_FUNC_RESP_SB_CC_GENERATION_CC_GEN0		(UINT32_C(0x0) << 1)
	/*
	 * Enhances cc_gen0 support with probabilistic marking algorithm,
	 * enabling fast ramp up and convergence,
	 * as well as operation in networks where PFC is not enabled.
	 * Includes a number of parameters that are different from cc_gen0
	 * chips as well as new parameters. TCP CC algorithm is not supported.
	 */
		#define CREQ_QUERY_FUNC_RESP_SB_CC_GENERATION_CC_GEN1		(UINT32_C(0x1) << 1)
	/*
	 * Enhances cc_gen1 support for additional CC parameters:
	 * reduce_init_en, reduce_init_cong_free_rtts_th, random_no_red_en,
	 * actual_cr_shift_correction_en, quota_period_adjust_en
	 */
		#define CREQ_QUERY_FUNC_RESP_SB_CC_GENERATION_CC_GEN1_EXT	(UINT32_C(0x2) << 1)
		#define CREQ_QUERY_FUNC_RESP_SB_CC_GENERATION_LAST		CREQ_QUERY_FUNC_RESP_SB_CC_GENERATION_CC_GEN1_EXT
	/*
	 * Support for the extended RoCE statistics is available. These
	 * statistics are queried via the `query_roce_stats_ext` command
	 * and are enabled on a per-QP basis via `create_qp`.
	 */
	#define CREQ_QUERY_FUNC_RESP_SB_EXT_STATS			UINT32_C(0x10)
	/*
	 * Support for both allocating and registering a new MR via the
	 * `register_mr` command is available. With this feature the
	 * `allocate_mrw` command does not have to be called before
	 * registering.
	 */
	#define CREQ_QUERY_FUNC_RESP_SB_MR_REGISTER_ALLOC		UINT32_C(0x20)
	/*
	 * Support for optimized transmit path to lower latency for WQEs
	 * with inline data.
	 */
	#define CREQ_QUERY_FUNC_RESP_SB_OPTIMIZED_TRANSMIT_ENABLED	UINT32_C(0x40)
	/*
	 * The underlying HW uses the version 2 of the CQEs definitions for
	 * the following CQE types:
	 * RES_UD, RES_RAWETH_QP1, RES_UD_CFA
	 */
	#define CREQ_QUERY_FUNC_RESP_SB_CQE_V2			UINT32_C(0x80)
	/* Support for ping pong push mode is available. */
	#define CREQ_QUERY_FUNC_RESP_SB_PINGPONG_PUSH_MODE		UINT32_C(0x100)
	/* Max CQs supported. */
	uint32_t	max_cq;
	/* Max CQEs per CQ supported. */
	uint32_t	max_cqe;
	/* Max PDs supported. */
	uint32_t	max_pd;
	/*
	 * Max SGEs per QP WQE supported. On chips with variable-size WQE support,
	 * this field is applicable only for the backward compatible mode.
	 */
	uint8_t	max_sge;
	/* Max SGEs per SRQ WQE supported. */
	uint8_t	max_srq_sge;
	/* Max outstanding RDMA read & atomic supported. */
	uint8_t	max_qp_rd_atom;
	/* Max outstanding RDMA read & atomic that can be sent from an initiator. */
	uint8_t	max_qp_init_rd_atom;
	/* Max MRs supported. */
	uint32_t	max_mr;
	/* Max MWs supported. */
	uint32_t	max_mw;
	/* Max Raw Ethertype QPs supported. */
	uint32_t	max_raw_eth_qp;
	/* Max AHs supported. */
	uint32_t	max_ah;
	/* Max FMRs supported. */
	uint32_t	max_fmr;
	/* Max WQEs per SRQ supported. */
	uint32_t	max_srq_wr;
	/* Max PKEYs supported. */
	uint32_t	max_pkeys;
	/*
	 * Max inline data supported. On chips with variable-size WQE support,
	 * this field is applicable only for the backward compatible mode.
	 */
	uint32_t	max_inline_data;
	/* Max mappings per FMR supported. */
	uint8_t	max_map_per_fmr;
	/* L2 DB space size in pages. */
	uint8_t	l2_db_space_size;
	/* Max SRQs supported. */
	uint16_t	max_srq;
	/* Max GIDs supported. */
	uint32_t	max_gid;
	/*
	 * An array of 48 8-bit values to specify allocation multiplier for TQM host buffer regions.
	 * Each region occupies 16 MB of TQM PBL address space: 0x00000000, 0x01000000, 0x02000000, etc.
	 * The host needs to allocate (<Number of QPs>*multiplier, rounded up to page size) of physical memory for non-zero slots
	 * and map the pages to the corresponding 16MB regions.
	 * Typically there are total 3 non-zero values in this array, their values are 16, 16, 12.
	 * Cu+ will only populate up to index 11. SR may populate up to index 47.
	 */
	uint32_t	tqm_alloc_reqs[12];
	/* Max Doorbell page indices supported. */
	uint32_t	max_dpi;
	/* Max SGEs per QP WQE supported in the variable-size WQE mode. */
	uint8_t	max_sge_var_wqe;
	uint8_t	reserved_8;
	/* Max inline data supported in the variable-size WQE mode. */
	uint16_t	max_inline_data_var_wqe;
} creq_query_func_resp_sb_t, *pcreq_query_func_resp_sb_t;

/**********************
 * set_func_resources *
 **********************/


/* cmdq_set_func_resources (size:448b/56B) */

typedef struct cmdq_set_func_resources {
	/* Command opcode. */
	uint8_t	opcode;
	/*
	 * Set the following resources for the function:
	 * - Max QP, CQ, MR+MW, SRQ per PF
	 * - Max QP, CQ, MR+MW, SRQ per VF
	 */
	#define CMDQ_SET_FUNC_RESOURCES_OPCODE_SET_FUNC_RESOURCES UINT32_C(0x84)
	#define CMDQ_SET_FUNC_RESOURCES_OPCODE_LAST		CMDQ_SET_FUNC_RESOURCES_OPCODE_SET_FUNC_RESOURCES
	/* Size of the command in 16-byte units. */
	uint8_t	cmd_size;
	/* Flags and attribs of the command. */
	uint16_t	flags;
	/*
	 * When set, the 32b `max_mrw_per_vf` field is logically divided
	 * into two 16b fields, `max_mr_per_vf` and `max_av_per_vf`.
	 */
	#define CMDQ_SET_FUNC_RESOURCES_FLAGS_MRAV_RESERVATION_SPLIT	UINT32_C(0x1)
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* Size of the response buffer in 16-byte units. */
	uint8_t	resp_size;
	uint8_t	reserved8;
	/* Host address of the response. */
	uint64_t	resp_addr;
	/* Number of QPs. It is the responsibility of the host to first extend the existing PBL with new addresses to pages to handle the adjustment. Must be greater or equal to current. */
	uint32_t	number_of_qp;
	/* Number of MRWs. It is the responsibility of the host to first extend the existing PBL with new addresses to pages to handle the adjustment. Must be greater or equal to current. */
	uint32_t	number_of_mrw;
	/* Number of SRQs. It is the responsibility of the host to first extend the existing PBL with new addresses to pages to handle the adjustment. Must be greater or equal to current. */
	uint32_t	number_of_srq;
	/* Number of CQs. It is the responsibility of the host to first extend the existing PBL with new addresses to pages to handle the adjustment. Must be greater or equal to current. */
	uint32_t	number_of_cq;
	/* Number of QPs per VF. */
	uint32_t	max_qp_per_vf;
	/*
	 * If the MR/AV split reservation flag is not set, then this field
	 * represents the total number of MR plus AV entries allowed per
	 * VF. For versions of firmware that support the split reservation,
	 * when it is not specified half of the entries will be reserved
	 * for MRs and the other half for AVs.
	 *
	 * If the MR/AV split reservation flag is set, then this
	 * field is logically divided into two 16b fields. Bits `[31:16]`
	 * represents the `max_mr_per_vf` and bits `[15:0]` represents
	 * `max_av_per_vf`. The granularity of these values is defined by
	 * the `mrav_num_entries_unit` field returned by the
	 * `backing_store_qcaps` command.
	 */
	uint32_t	max_mrw_per_vf;
	/* Number of SRQs per VF. */
	uint32_t	max_srq_per_vf;
	/* Number of CQs per VF. */
	uint32_t	max_cq_per_vf;
	/* Number of GIDs per VF. */
	uint32_t	max_gid_per_vf;
	/* Statistics context index for this function. */
	uint32_t	stat_ctx_id;
} cmdq_set_func_resources_t, *pcmdq_set_func_resources_t;

/* creq_set_func_resources_resp (size:128b/16B) */

typedef struct creq_set_func_resources_resp {
	uint8_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define CREQ_SET_FUNC_RESOURCES_RESP_TYPE_MASK	UINT32_C(0x3f)
	#define CREQ_SET_FUNC_RESOURCES_RESP_TYPE_SFT	0
	/* QP Async Notification */
		#define CREQ_SET_FUNC_RESOURCES_RESP_TYPE_QP_EVENT  UINT32_C(0x38)
		#define CREQ_SET_FUNC_RESOURCES_RESP_TYPE_LAST	CREQ_SET_FUNC_RESOURCES_RESP_TYPE_QP_EVENT
	/* Status of the response. */
	uint8_t	status;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	uint32_t	reserved32;
	uint8_t	v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define CREQ_SET_FUNC_RESOURCES_RESP_V	UINT32_C(0x1)
	/* Event or command opcode. */
	uint8_t	event;
	/* Set function resources command response. */
	#define CREQ_SET_FUNC_RESOURCES_RESP_EVENT_SET_FUNC_RESOURCES UINT32_C(0x84)
	#define CREQ_SET_FUNC_RESOURCES_RESP_EVENT_LAST		CREQ_SET_FUNC_RESOURCES_RESP_EVENT_SET_FUNC_RESOURCES
	uint8_t	reserved48[6];
} creq_set_func_resources_resp_t, *pcreq_set_func_resources_resp_t;

/*************
 * stop_func *
 *************/


/* cmdq_stop_func (size:128b/16B) */

typedef struct cmdq_stop_func {
	/* Command opcode. */
	uint8_t	opcode;
	/* Stop the function */
	#define CMDQ_STOP_FUNC_OPCODE_STOP_FUNC UINT32_C(0x82)
	#define CMDQ_STOP_FUNC_OPCODE_LAST	CMDQ_STOP_FUNC_OPCODE_STOP_FUNC
	/* Size of the command in 16-byte units. */
	uint8_t	cmd_size;
	/* Flags and attribs of the command. */
	uint16_t	flags;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* Size of the response buffer in 16-byte units. */
	uint8_t	resp_size;
	uint8_t	reserved8;
	/* Host address of the response. */
	uint64_t	resp_addr;
} cmdq_stop_func_t, *pcmdq_stop_func_t;

/* creq_stop_func_resp (size:128b/16B) */

typedef struct creq_stop_func_resp {
	uint8_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define CREQ_STOP_FUNC_RESP_TYPE_MASK	UINT32_C(0x3f)
	#define CREQ_STOP_FUNC_RESP_TYPE_SFT	0
	/* QP Async Notification */
		#define CREQ_STOP_FUNC_RESP_TYPE_QP_EVENT  UINT32_C(0x38)
		#define CREQ_STOP_FUNC_RESP_TYPE_LAST	CREQ_STOP_FUNC_RESP_TYPE_QP_EVENT
	/* Status of the response. */
	uint8_t	status;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	uint32_t	reserved32;
	uint8_t	v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define CREQ_STOP_FUNC_RESP_V	UINT32_C(0x1)
	/* Event or command opcode. */
	uint8_t	event;
	/* Stop PF command response. */
	#define CREQ_STOP_FUNC_RESP_EVENT_STOP_FUNC UINT32_C(0x82)
	#define CREQ_STOP_FUNC_RESP_EVENT_LAST	CREQ_STOP_FUNC_RESP_EVENT_STOP_FUNC
	uint8_t	reserved48[6];
} creq_stop_func_resp_t, *pcreq_stop_func_resp_t;

/****************
 * read_context *
 ****************/


/* cmdq_read_context (size:192b/24B) */

typedef struct cmdq_read_context {
	/* Command opcode. */
	uint8_t	opcode;
	/* Read the current state of any internal resource context. Can only be issued from a PF. */
	#define CMDQ_READ_CONTEXT_OPCODE_READ_CONTEXT UINT32_C(0x85)
	#define CMDQ_READ_CONTEXT_OPCODE_LAST	CMDQ_READ_CONTEXT_OPCODE_READ_CONTEXT
	/* Size of the command in 16-byte units. */
	uint8_t	cmd_size;
	/* Flags and attribs of the command. */
	uint16_t	flags;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* Size of the response buffer in 16-byte units. */
	uint8_t	resp_size;
	uint8_t	reserved8;
	/* Host address of the response. */
	uint64_t	resp_addr;
	uint32_t	type_xid;
	/* Context ID */
	#define CMDQ_READ_CONTEXT_XID_MASK UINT32_C(0xffffff)
	#define CMDQ_READ_CONTEXT_XID_SFT  0
	/* Context type */
	#define CMDQ_READ_CONTEXT_TYPE_MASK UINT32_C(0xff000000)
	#define CMDQ_READ_CONTEXT_TYPE_SFT 24
	/* Read QPC. The context (448 bytes) goes to resp_addr (as is, without a header), and resp_size should be set to 28 (448/16) */
		#define CMDQ_READ_CONTEXT_TYPE_QPC   (UINT32_C(0x0) << 24)
	/* Read CQ. The context (64 bytes) goes to resp_addr (as is, without a header), and resp_size should be set to 4 (64/16) */
		#define CMDQ_READ_CONTEXT_TYPE_CQ	(UINT32_C(0x1) << 24)
	/* Read MRW. The context (128 bytes) goes to resp_addr (as is, without a header), and resp_size should be set to 8 (128/16) */
		#define CMDQ_READ_CONTEXT_TYPE_MRW   (UINT32_C(0x2) << 24)
	/* Read SRQ. The context (64 bytes) goes to resp_addr (as is, without a header), and resp_size should be set to 4 (64/16) */
		#define CMDQ_READ_CONTEXT_TYPE_SRQ   (UINT32_C(0x3) << 24)
		#define CMDQ_READ_CONTEXT_TYPE_LAST CMDQ_READ_CONTEXT_TYPE_SRQ
	uint32_t	unused_0;
} cmdq_read_context_t, *pcmdq_read_context_t;

/* creq_read_context (size:128b/16B) */

typedef struct creq_read_context {
	uint8_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B records.
	 * records.
	 */
	#define CREQ_READ_CONTEXT_TYPE_MASK	UINT32_C(0x3f)
	#define CREQ_READ_CONTEXT_TYPE_SFT	0
	/* QP Async Notification */
		#define CREQ_READ_CONTEXT_TYPE_QP_EVENT  UINT32_C(0x38)
		#define CREQ_READ_CONTEXT_TYPE_LAST	CREQ_READ_CONTEXT_TYPE_QP_EVENT
	/* Status of the response. */
	uint8_t	status;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	uint32_t	reserved32;
	uint8_t	v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define CREQ_READ_CONTEXT_V	UINT32_C(0x1)
	/* Event or command opcode. */
	uint8_t	event;
	/* Read the current state of any internal resource context. Can only be issued from a PF. */
	#define CREQ_READ_CONTEXT_EVENT_READ_CONTEXT UINT32_C(0x85)
	#define CREQ_READ_CONTEXT_EVENT_LAST	CREQ_READ_CONTEXT_EVENT_READ_CONTEXT
	uint16_t	reserved16;
	uint32_t	reserved_32;
} creq_read_context_t, *pcreq_read_context_t;

/*****************
 * map_tc_to_cos *
 *****************/


/* cmdq_map_tc_to_cos (size:192b/24B) */

typedef struct cmdq_map_tc_to_cos {
	/* Command opcode. */
	uint8_t	opcode;
	/* Map TC to COS. Can only be issued from a PF. */
	#define CMDQ_MAP_TC_TO_COS_OPCODE_MAP_TC_TO_COS UINT32_C(0x8a)
	#define CMDQ_MAP_TC_TO_COS_OPCODE_LAST	CMDQ_MAP_TC_TO_COS_OPCODE_MAP_TC_TO_COS
	/* Size of the command in 16-byte units. */
	uint8_t	cmd_size;
	/* Flags and attribs of the command. */
	uint16_t	flags;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* Size of the response buffer in 16-byte units. */
	uint8_t	resp_size;
	uint8_t	reserved8;
	/* Host address of the response. */
	uint64_t	resp_addr;
	/* 1st COS index mapped to RoCE */
	uint16_t	cos0;
	/* Don't change this COS. */
	#define CMDQ_MAP_TC_TO_COS_COS0_NO_CHANGE UINT32_C(0xffff)
	#define CMDQ_MAP_TC_TO_COS_COS0_LAST	CMDQ_MAP_TC_TO_COS_COS0_NO_CHANGE
	/* 2nd COS index mapped to RoCE */
	uint16_t	cos1;
	/* Disable this COS. */
	#define CMDQ_MAP_TC_TO_COS_COS1_DISABLE   UINT32_C(0x8000)
	/* Don't change this COS. */
	#define CMDQ_MAP_TC_TO_COS_COS1_NO_CHANGE UINT32_C(0xffff)
	#define CMDQ_MAP_TC_TO_COS_COS1_LAST	CMDQ_MAP_TC_TO_COS_COS1_NO_CHANGE
	uint32_t	unused_0;
} cmdq_map_tc_to_cos_t, *pcmdq_map_tc_to_cos_t;

/* creq_map_tc_to_cos_resp (size:128b/16B) */

typedef struct creq_map_tc_to_cos_resp {
	uint8_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define CREQ_MAP_TC_TO_COS_RESP_TYPE_MASK	UINT32_C(0x3f)
	#define CREQ_MAP_TC_TO_COS_RESP_TYPE_SFT	0
	/* QP Async Notification */
		#define CREQ_MAP_TC_TO_COS_RESP_TYPE_QP_EVENT  UINT32_C(0x38)
		#define CREQ_MAP_TC_TO_COS_RESP_TYPE_LAST	CREQ_MAP_TC_TO_COS_RESP_TYPE_QP_EVENT
	/* Status of the response. */
	uint8_t	status;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	uint32_t	reserved32;
	uint8_t	v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define CREQ_MAP_TC_TO_COS_RESP_V	UINT32_C(0x1)
	/* Event or command opcode. */
	uint8_t	event;
	/* Map TC to COS response. */
	#define CREQ_MAP_TC_TO_COS_RESP_EVENT_MAP_TC_TO_COS UINT32_C(0x8a)
	#define CREQ_MAP_TC_TO_COS_RESP_EVENT_LAST	CREQ_MAP_TC_TO_COS_RESP_EVENT_MAP_TC_TO_COS
	uint8_t	reserved48[6];
} creq_map_tc_to_cos_resp_t, *pcreq_map_tc_to_cos_resp_t;

/*****************
 * query_roce_cc *
 *****************/


/* cmdq_query_roce_cc (size:128b/16B) */

typedef struct cmdq_query_roce_cc {
	/* Command opcode. */
	uint8_t	opcode;
	/* Query congestion control. */
	#define CMDQ_QUERY_ROCE_CC_OPCODE_QUERY_ROCE_CC UINT32_C(0x8d)
	#define CMDQ_QUERY_ROCE_CC_OPCODE_LAST	CMDQ_QUERY_ROCE_CC_OPCODE_QUERY_ROCE_CC
	/* Size of the command in 16-byte units. */
	uint8_t	cmd_size;
	/* Flags and attribs of the command. */
	uint16_t	flags;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* Size of the response buffer in 16-byte units. */
	uint8_t	resp_size;
	uint8_t	reserved8;
	/* Host address of the response. */
	uint64_t	resp_addr;
} cmdq_query_roce_cc_t, *pcmdq_query_roce_cc_t;

/* creq_query_roce_cc_resp (size:128b/16B) */

typedef struct creq_query_roce_cc_resp {
	uint8_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define CREQ_QUERY_ROCE_CC_RESP_TYPE_MASK	UINT32_C(0x3f)
	#define CREQ_QUERY_ROCE_CC_RESP_TYPE_SFT	0
	/* QP Async Notification */
		#define CREQ_QUERY_ROCE_CC_RESP_TYPE_QP_EVENT  UINT32_C(0x38)
		#define CREQ_QUERY_ROCE_CC_RESP_TYPE_LAST	CREQ_QUERY_ROCE_CC_RESP_TYPE_QP_EVENT
	/* Status of the response. */
	uint8_t	status;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* Side buffer size in 16-byte units */
	uint32_t	size;
	uint8_t	v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define CREQ_QUERY_ROCE_CC_RESP_V	UINT32_C(0x1)
	/* Event or command opcode. */
	uint8_t	event;
	/* Query congestion control response. */
	#define CREQ_QUERY_ROCE_CC_RESP_EVENT_QUERY_ROCE_CC UINT32_C(0x8d)
	#define CREQ_QUERY_ROCE_CC_RESP_EVENT_LAST	CREQ_QUERY_ROCE_CC_RESP_EVENT_QUERY_ROCE_CC
	uint8_t	reserved48[6];
} creq_query_roce_cc_resp_t, *pcreq_query_roce_cc_resp_t;

/* Query congestion control command response side buffer structure. */
/* creq_query_roce_cc_resp_sb (size:256b/32B) */

typedef struct creq_query_roce_cc_resp_sb {
	/* Command opcode. */
	uint8_t	opcode;
	/* Query congestion control response. */
	#define CREQ_QUERY_ROCE_CC_RESP_SB_OPCODE_QUERY_ROCE_CC UINT32_C(0x8d)
	#define CREQ_QUERY_ROCE_CC_RESP_SB_OPCODE_LAST	CREQ_QUERY_ROCE_CC_RESP_SB_OPCODE_QUERY_ROCE_CC
	/* Status of the response. */
	uint8_t	status;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* Flags and attribs of the command. */
	uint16_t	flags;
	/* Size of the response buffer in 16-byte units. */
	uint8_t	resp_size;
	uint8_t	reserved8;
	uint8_t	enable_cc;
	/* Enable. */
	#define CREQ_QUERY_ROCE_CC_RESP_SB_ENABLE_CC	UINT32_C(0x1)
	/* unused7 is 7 b */
	#define CREQ_QUERY_ROCE_CC_RESP_SB_UNUSED7_MASK  UINT32_C(0xfe)
	#define CREQ_QUERY_ROCE_CC_RESP_SB_UNUSED7_SFT   1
	uint8_t	tos_dscp_tos_ecn;
	/* IP TOS ECN. */
	#define CREQ_QUERY_ROCE_CC_RESP_SB_TOS_ECN_MASK UINT32_C(0x3)
	#define CREQ_QUERY_ROCE_CC_RESP_SB_TOS_ECN_SFT  0
	/* IP TOS DSCP. */
	#define CREQ_QUERY_ROCE_CC_RESP_SB_TOS_DSCP_MASK UINT32_C(0xfc)
	#define CREQ_QUERY_ROCE_CC_RESP_SB_TOS_DSCP_SFT 2
	/* Congestion Probability averaging factor. */
	uint8_t	g;
	/* Number of phases in Fast Recovery and Active Increase. */
	uint8_t	num_phases_per_state;
	/* The starting value of rate. */
	uint16_t	init_cr;
	/* The starting value of target rate. */
	uint16_t	init_tr;
	uint8_t	alt_vlan_pcp;
	/* Alternate vlan pcp value for CNP packets. */
	#define CREQ_QUERY_ROCE_CC_RESP_SB_ALT_VLAN_PCP_MASK UINT32_C(0x7)
	#define CREQ_QUERY_ROCE_CC_RESP_SB_ALT_VLAN_PCP_SFT 0
	/* rsvd1 is 5 b */
	#define CREQ_QUERY_ROCE_CC_RESP_SB_RSVD1_MASK	UINT32_C(0xf8)
	#define CREQ_QUERY_ROCE_CC_RESP_SB_RSVD1_SFT	3
	uint8_t	alt_tos_dscp;
	/* Alternate IP TOS DSCP. */
	#define CREQ_QUERY_ROCE_CC_RESP_SB_ALT_TOS_DSCP_MASK UINT32_C(0x3f)
	#define CREQ_QUERY_ROCE_CC_RESP_SB_ALT_TOS_DSCP_SFT 0
	/* rsvd4 is 2 b */
	#define CREQ_QUERY_ROCE_CC_RESP_SB_RSVD4_MASK	UINT32_C(0xc0)
	#define CREQ_QUERY_ROCE_CC_RESP_SB_RSVD4_SFT	6
	uint8_t	cc_mode;
	/* DCTCP CC algorithm. */
	#define CREQ_QUERY_ROCE_CC_RESP_SB_CC_MODE_DCTCP	UINT32_C(0x0)
	/*
	 * Probabilistic marking CC algorithm. On chips with CC Gen 0
	 * support this will be TCP CC algorithm.
	 */
	#define CREQ_QUERY_ROCE_CC_RESP_SB_CC_MODE_PROBABILISTIC UINT32_C(0x1)
	#define CREQ_QUERY_ROCE_CC_RESP_SB_CC_MODE_LAST	CREQ_QUERY_ROCE_CC_RESP_SB_CC_MODE_PROBABILISTIC
	/* Specifies the RoCE Tx Queue to use for sending CNP packets. */
	uint8_t	tx_queue;
	uint16_t	rtt;
	/* Round trip time in units of usecs */
	#define CREQ_QUERY_ROCE_CC_RESP_SB_RTT_MASK  UINT32_C(0x3fff)
	#define CREQ_QUERY_ROCE_CC_RESP_SB_RTT_SFT   0
	/* rsvd5 is 2 b */
	#define CREQ_QUERY_ROCE_CC_RESP_SB_RSVD5_MASK UINT32_C(0xc000)
	#define CREQ_QUERY_ROCE_CC_RESP_SB_RSVD5_SFT 14
	uint16_t	tcp_cp;
	/* The value used as CP when cc_mode is 1(TCP) */
	#define CREQ_QUERY_ROCE_CC_RESP_SB_TCP_CP_MASK UINT32_C(0x3ff)
	#define CREQ_QUERY_ROCE_CC_RESP_SB_TCP_CP_SFT 0
	/* rsvd6 is 6 b */
	#define CREQ_QUERY_ROCE_CC_RESP_SB_RSVD6_MASK UINT32_C(0xfc00)
	#define CREQ_QUERY_ROCE_CC_RESP_SB_RSVD6_SFT  10
	/* Inactivity time after which QP CC parameters are initialized */
	uint16_t	inactivity_th;
	/* Number of packets per phase. Max is 255. */
	uint8_t	pkts_per_phase;
	/* Amount of time per phase in units of ms. Max is 15 */
	uint8_t	time_per_phase;
	uint32_t	reserved32;
} creq_query_roce_cc_resp_sb_t, *pcreq_query_roce_cc_resp_sb_t;

/*
 * TLV encapsulated Query congestion control command response
 * side buffer, with extended TLV record included for specifying
 * the extended configuration for CC level 1.
 */
/* creq_query_roce_cc_resp_sb_tlv (size:384b/48B) */

typedef struct creq_query_roce_cc_resp_sb_tlv {
	/*
	 * The command discriminator is used to differentiate between various
	 * types of HWRM messages. This includes legacy HWRM and RoCE slowpath
	 * command messages as well as newer TLV encapsulated HWRM commands.
	 *
	 * For TLV encapsulated messages this field must be 0x8000.
	 */
	uint16_t	cmd_discr;
	uint8_t	reserved_8b;
	uint8_t	tlv_flags;
	/*
	 * Indicates the presence of additional TLV encapsulated data
	 * follows this TLV.
	 */
	#define CREQ_QUERY_ROCE_CC_RESP_SB_TLV_TLV_FLAGS_MORE	UINT32_C(0x1)
	/* Last TLV in a sequence of TLVs. */
		#define CREQ_QUERY_ROCE_CC_RESP_SB_TLV_TLV_FLAGS_MORE_LAST	UINT32_C(0x0)
	/* More TLVs follow this TLV. */
		#define CREQ_QUERY_ROCE_CC_RESP_SB_TLV_TLV_FLAGS_MORE_NOT_LAST  UINT32_C(0x1)
	/*
	 * When an HWRM receiver detects a TLV type that it does not
	 * support with the TLV required flag set, the receiver must
	 * reject the HWRM message with an error code indicating an
	 * unsupported TLV type.
	 */
	#define CREQ_QUERY_ROCE_CC_RESP_SB_TLV_TLV_FLAGS_REQUIRED	UINT32_C(0x2)
	/* No */
		#define CREQ_QUERY_ROCE_CC_RESP_SB_TLV_TLV_FLAGS_REQUIRED_NO	(UINT32_C(0x0) << 1)
	/* Yes */
		#define CREQ_QUERY_ROCE_CC_RESP_SB_TLV_TLV_FLAGS_REQUIRED_YES   (UINT32_C(0x1) << 1)
		#define CREQ_QUERY_ROCE_CC_RESP_SB_TLV_TLV_FLAGS_REQUIRED_LAST CREQ_QUERY_ROCE_CC_RESP_SB_TLV_TLV_FLAGS_REQUIRED_YES
	/*
	 * This field defines the TLV type value which is divided into
	 * two ranges to differentiate between global and local TLV types.
	 * Global TLV types must be unique across all defined TLV types.
	 * Local TLV types are valid only for extensions to a given
	 * HWRM message and may be repeated across different HWRM message
	 * types. There is a direct correlation of each HWRM message type
	 * to a single global TLV type value.
	 *
	 * Global TLV range: `0 - (63k-1)`
	 *
	 * Local TLV range: `63k - (64k-1)`
	 */
	uint16_t	tlv_type;
	/*
	 * Length of the message data encapsulated by this TLV in bytes.
	 * This length does not include the size of the TLV header itself
	 * and it must be an integer multiple of 8B.
	 */
	uint16_t	length;
	/*
	 * Size of the tlv encapsulated response,
	 * including all tlvs and extension data in 16-byte units.
	 */
	uint8_t	total_size;
	uint8_t	reserved56[7];
	/* Command opcode. */
	uint8_t	opcode;
	/* Query congestion control response. */
	#define CREQ_QUERY_ROCE_CC_RESP_SB_TLV_OPCODE_QUERY_ROCE_CC UINT32_C(0x8d)
	#define CREQ_QUERY_ROCE_CC_RESP_SB_TLV_OPCODE_LAST	CREQ_QUERY_ROCE_CC_RESP_SB_TLV_OPCODE_QUERY_ROCE_CC
	/* Status of the response. */
	uint8_t	status;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* Flags and attribs of the command. */
	uint16_t	flags;
	/* Size of the response buffer in 16-byte units. */
	uint8_t	resp_size;
	uint8_t	reserved8;
	uint8_t	enable_cc;
	/* Enable. */
	#define CREQ_QUERY_ROCE_CC_RESP_SB_TLV_ENABLE_CC	UINT32_C(0x1)
	/* unused7 is 7 b */
	#define CREQ_QUERY_ROCE_CC_RESP_SB_TLV_UNUSED7_MASK  UINT32_C(0xfe)
	#define CREQ_QUERY_ROCE_CC_RESP_SB_TLV_UNUSED7_SFT   1
	uint8_t	tos_dscp_tos_ecn;
	/* IP TOS ECN. */
	#define CREQ_QUERY_ROCE_CC_RESP_SB_TLV_TOS_ECN_MASK UINT32_C(0x3)
	#define CREQ_QUERY_ROCE_CC_RESP_SB_TLV_TOS_ECN_SFT  0
	/* IP TOS DSCP. */
	#define CREQ_QUERY_ROCE_CC_RESP_SB_TLV_TOS_DSCP_MASK UINT32_C(0xfc)
	#define CREQ_QUERY_ROCE_CC_RESP_SB_TLV_TOS_DSCP_SFT 2
	/* Congestion Probability averaging factor. */
	uint8_t	g;
	/* Number of phases in Fast Recovery and Active Increase. */
	uint8_t	num_phases_per_state;
	/* The starting value of rate. */
	uint16_t	init_cr;
	/* The starting value of target rate. */
	uint16_t	init_tr;
	uint8_t	alt_vlan_pcp;
	/* Alternate vlan pcp value for CNP packets. */
	#define CREQ_QUERY_ROCE_CC_RESP_SB_TLV_ALT_VLAN_PCP_MASK UINT32_C(0x7)
	#define CREQ_QUERY_ROCE_CC_RESP_SB_TLV_ALT_VLAN_PCP_SFT 0
	/* rsvd1 is 5 b */
	#define CREQ_QUERY_ROCE_CC_RESP_SB_TLV_RSVD1_MASK	UINT32_C(0xf8)
	#define CREQ_QUERY_ROCE_CC_RESP_SB_TLV_RSVD1_SFT	3
	uint8_t	alt_tos_dscp;
	/* Alternate IP TOS DSCP. */
	#define CREQ_QUERY_ROCE_CC_RESP_SB_TLV_ALT_TOS_DSCP_MASK UINT32_C(0x3f)
	#define CREQ_QUERY_ROCE_CC_RESP_SB_TLV_ALT_TOS_DSCP_SFT 0
	/* rsvd4 is 2 b */
	#define CREQ_QUERY_ROCE_CC_RESP_SB_TLV_RSVD4_MASK	UINT32_C(0xc0)
	#define CREQ_QUERY_ROCE_CC_RESP_SB_TLV_RSVD4_SFT	6
	uint8_t	cc_mode;
	/* DCTCP CC algorithm. */
	#define CREQ_QUERY_ROCE_CC_RESP_SB_TLV_CC_MODE_DCTCP	UINT32_C(0x0)
	/*
	 * Probabilistic marking CC algorithm. On chips with CC Gen 0
	 * support this will be TCP CC algorithm.
	 */
	#define CREQ_QUERY_ROCE_CC_RESP_SB_TLV_CC_MODE_PROBABILISTIC UINT32_C(0x1)
	#define CREQ_QUERY_ROCE_CC_RESP_SB_TLV_CC_MODE_LAST	CREQ_QUERY_ROCE_CC_RESP_SB_TLV_CC_MODE_PROBABILISTIC
	/* Specifies the RoCE Tx Queue to use for sending CNP packets. */
	uint8_t	tx_queue;
	uint16_t	rtt;
	/* Round trip time in units of usecs */
	#define CREQ_QUERY_ROCE_CC_RESP_SB_TLV_RTT_MASK  UINT32_C(0x3fff)
	#define CREQ_QUERY_ROCE_CC_RESP_SB_TLV_RTT_SFT   0
	/* rsvd5 is 2 b */
	#define CREQ_QUERY_ROCE_CC_RESP_SB_TLV_RSVD5_MASK UINT32_C(0xc000)
	#define CREQ_QUERY_ROCE_CC_RESP_SB_TLV_RSVD5_SFT 14
	uint16_t	tcp_cp;
	/* The value used as CP when cc_mode is 1(TCP) */
	#define CREQ_QUERY_ROCE_CC_RESP_SB_TLV_TCP_CP_MASK UINT32_C(0x3ff)
	#define CREQ_QUERY_ROCE_CC_RESP_SB_TLV_TCP_CP_SFT 0
	/* rsvd6 is 6 b */
	#define CREQ_QUERY_ROCE_CC_RESP_SB_TLV_RSVD6_MASK UINT32_C(0xfc00)
	#define CREQ_QUERY_ROCE_CC_RESP_SB_TLV_RSVD6_SFT  10
	/* Inactivity time after which QP CC parameters are initialized */
	uint16_t	inactivity_th;
	/* Number of packets per phase. Max is 255. */
	uint8_t	pkts_per_phase;
	/* Amount of time per phase in units of ms. Max is 15 */
	uint8_t	time_per_phase;
	uint32_t	reserved32;
} creq_query_roce_cc_resp_sb_tlv_t, *pcreq_query_roce_cc_resp_sb_tlv_t;

/* creq_query_roce_cc_gen1_resp_sb_tlv (size:704b/88B) */

typedef struct creq_query_roce_cc_gen1_resp_sb_tlv {
	/*
	 * The command discriminator is used to differentiate between various
	 * types of HWRM messages. This includes legacy HWRM and RoCE slowpath
	 * command messages as well as newer TLV encapsulated HWRM commands.
	 *
	 * For TLV encapsulated messages this field must be 0x8000.
	 */
	uint16_t	cmd_discr;
	uint8_t	reserved_8b;
	uint8_t	tlv_flags;
	/*
	 * Indicates the presence of additional TLV encapsulated data
	 * follows this TLV.
	 */
	#define CREQ_QUERY_ROCE_CC_GEN1_RESP_SB_TLV_TLV_FLAGS_MORE	UINT32_C(0x1)
	/* Last TLV in a sequence of TLVs. */
		#define CREQ_QUERY_ROCE_CC_GEN1_RESP_SB_TLV_TLV_FLAGS_MORE_LAST	UINT32_C(0x0)
	/* More TLVs follow this TLV. */
		#define CREQ_QUERY_ROCE_CC_GEN1_RESP_SB_TLV_TLV_FLAGS_MORE_NOT_LAST  UINT32_C(0x1)
	/*
	 * When an HWRM receiver detects a TLV type that it does not
	 * support with the TLV required flag set, the receiver must
	 * reject the HWRM message with an error code indicating an
	 * unsupported TLV type.
	 */
	#define CREQ_QUERY_ROCE_CC_GEN1_RESP_SB_TLV_TLV_FLAGS_REQUIRED	UINT32_C(0x2)
	/* No */
		#define CREQ_QUERY_ROCE_CC_GEN1_RESP_SB_TLV_TLV_FLAGS_REQUIRED_NO	(UINT32_C(0x0) << 1)
	/* Yes */
		#define CREQ_QUERY_ROCE_CC_GEN1_RESP_SB_TLV_TLV_FLAGS_REQUIRED_YES   (UINT32_C(0x1) << 1)
		#define CREQ_QUERY_ROCE_CC_GEN1_RESP_SB_TLV_TLV_FLAGS_REQUIRED_LAST CREQ_QUERY_ROCE_CC_GEN1_RESP_SB_TLV_TLV_FLAGS_REQUIRED_YES
	/*
	 * This field defines the TLV type value which is divided into
	 * two ranges to differentiate between global and local TLV types.
	 * Global TLV types must be unique across all defined TLV types.
	 * Local TLV types are valid only for extensions to a given
	 * HWRM message and may be repeated across different HWRM message
	 * types. There is a direct correlation of each HWRM message type
	 * to a single global TLV type value.
	 *
	 * Global TLV range: `0 - (63k-1)`
	 *
	 * Local TLV range: `63k - (64k-1)`
	 */
	uint16_t	tlv_type;
	/*
	 * Length of the message data encapsulated by this TLV in bytes.
	 * This length does not include the size of the TLV header itself
	 * and it must be an integer multiple of 8B.
	 */
	uint16_t	length;
	uint64_t	reserved64;
	/* High order bits of inactivity threshold. */
	uint16_t	inactivity_th_hi;
	/* The number of uS between generation of CNPs when cc_mode is probabilistic marking. */
	uint16_t	min_time_between_cnps;
	/* The starting value of congestion probability. Input range is 0 - 1023. */
	uint16_t	init_cp;
	/*
	 * In tr_update_mode 0, Target Rate (TR) is updated to
	 * halfway between the Current Rate (CR) before and after reduction.
	 * In tr_update_mode 1, TR is updated to CR's value before reduction.
	 */
	uint8_t	tr_update_mode;
	/*
	 * Determine for how many RTTs with CNPs in a row, TR is being updated.
	 * 0: TR is updated when QPC. rtts_with_cnps == 0
	 * 1-6: TR is updated if QPC. rtts_with_cnps <= tr_update_cycles
	 * 7: TR is updated on all reductions.
	 */
	uint8_t	tr_update_cycles;
	/* Number of RTTs in Fast Recovery stage. */
	uint8_t	fr_num_rtts;
	/* Time increment to increase TR in active increase phase. */
	uint8_t	ai_rate_increase;
	/*
	 * Indicates for how many RTTs with CNPs after the first one
	 * to not reduce rate even if CNPs are received.
	 */
	uint16_t	reduction_relax_rtts_th;
	/*
	 * For low rates, additional number of RTTS with CNPs
	 * for which no rate reduction is made.
	 * num_bits: 14
	 */
	uint16_t	additional_relax_cr_th;
	/*
	 * If CR is less than or equal to this value,
	 * then the actual CR average is set to this value
	 * (shifted by bw_avg_weight).
	 */
	uint16_t	cr_min_th;
	/* Log based averaging weight for QPC variable actual_cr_avg. */
	uint8_t	bw_avg_weight;
	/*
	 * Used to compare CR to this factor times QPC.actual_cr_average
	 * as a reduction reference. Values between 0 and 6 represent factor of
	 * 1.125, 1.25, 1.5, 1.75, 2, 2.25, 2.5 respectively.
	 */
	uint8_t	actual_cr_factor;
	/* The level of CR above which CP is set to maximum level. */
	uint16_t	max_cp_cr_th;
	/*
	 * Enable adding fraction of CR to CP.
	 * 0 for disable, 1 for enable.
	 */
	uint8_t	cp_bias_en;
	/* Log based fraction of cr to add to CP when cp_bias_en is 1. */
	uint8_t	cp_bias;
	/*
	 * The value of ECN bits in a CNP packet generated by hardware.
	 * ECN-Capabale Transport (ECT) codepoints supported include:
	 * 0 for not_ect, 1 for ect_0, 2 for ect_1
	 */
	uint8_t	cnp_ecn;
	/* Not ECN capable Transport */
	#define CREQ_QUERY_ROCE_CC_GEN1_RESP_SB_TLV_CNP_ECN_NOT_ECT UINT32_C(0x0)
	/* ECN Capable Transport-1 */
	#define CREQ_QUERY_ROCE_CC_GEN1_RESP_SB_TLV_CNP_ECN_ECT_1   UINT32_C(0x1)
	/* ECN Capable Transport-0 */
	#define CREQ_QUERY_ROCE_CC_GEN1_RESP_SB_TLV_CNP_ECN_ECT_0   UINT32_C(0x2)
	#define CREQ_QUERY_ROCE_CC_GEN1_RESP_SB_TLV_CNP_ECN_LAST   CREQ_QUERY_ROCE_CC_GEN1_RESP_SB_TLV_CNP_ECN_ECT_0
	/* Enables jitter in RTT. */
	uint8_t	rtt_jitter_en;
	/*
	 * Number of bytes per usec, dependant on port speed.
	 * 200 Gbps: 25,000
	 * 100 Gbps: 12,500
	 * 50 Gbps: 6,250
	 * 25 Gbps: 3125
	 * 10 Gbps: 1250
	 */
	uint16_t	link_bytes_per_usec;
	/*
	 * If CR is greater than or equal to this threshold,
	 * QPC's CC state is reset to its initial state.
	 */
	uint16_t	reset_cc_cr_th;
	/*
	 * The number of valid lsbits in CR and TR.
	 * Supported values include 10 through 14 to support 2^cr_width rate.
	 */
	uint8_t	cr_width;
	/* Lower end of random selection of quota_period. */
	uint8_t	quota_period_min;
	/* Upper end of random selection of quota_period. */
	uint8_t	quota_period_max;
	/*
	 * The absolute maximum possible quota_period,
	 * applicable when rate table for lower 24 levels is used.
	 */
	uint8_t	quota_period_abs_max;
	/* TR never goes below this level. */
	uint16_t	tr_lower_bound;
	/* Factor on probability threshold for adding 0.5 to CR randomly. */
	uint8_t	cr_prob_factor;
	/* Factor on probability threshold for adding 0.5 to TR randomly. */
	uint8_t	tr_prob_factor;
	/*
	 * Threshold to ensure fairness between requester and responder.
	 * If CR is less than the fairness threshold and a quota period has passed
	 * priority will be given to the path that did not last transfer data.
	 */
	uint16_t	fairness_cr_th;
	/* Log based rate reduction divider. */
	uint8_t	red_div;
	/* Threshold for rate reductions when CNPS received over last RTT. */
	uint8_t	cnp_ratio_th;
	/*
	 * Extended number of RTTS to wait, when there is no congestion,
	 * to start doubling the rate.
	 */
	uint16_t	exp_ai_rtts;
	/* Log based CR to CP ratio used in exponential increase. */
	uint8_t	exp_ai_cr_cp_ratio;
	/* Enable use of lowest 24 rate levels rate_table. */
	uint8_t	use_rate_table;
	/*
	 * Determines after how many congestion free RTTs to start
	 * updating CP to track CR.
	 */
	uint16_t	cp_exp_update_th;
	/* The threshold on congestion free RTTs above which AI can increase to 16. */
	uint16_t	high_exp_ai_rtts_th1;
	/* The threshold on congestion free RTTs above which AI can increase to 32. */
	uint16_t	high_exp_ai_rtts_th2;
	/*
	 * The number of congestion free RTTs above which
	 * reduction based on actual rate is enabled.
	 */
	uint16_t	actual_cr_cong_free_rtts_th;
	/*
	 * If rtts_with_cong is greater than 7 (severe congestion) and
	 * CR level post reduction is above this threshold,
	 * then TR is capped to 1.5 times CR..
	 */
	uint16_t	severe_cong_cr_th1;
	/*
	 * If rtts_with_cong is greater than 7 (severe congestion) and
	 * CR level post reduction is above this threshold,
	 * then TR is capped to 1.25 times CR..
	 */
	uint16_t	severe_cong_cr_th2;
	/*
	 * The maximum number of 64B that can be transmitted during RTT time,
	 * including all headers and Inter Packet Gap.
	 */
	uint32_t	link64B_per_rtt;
	/*
	 * The number of bytes to subtract from QPC.cc_bucket
	 * when an ack is scheduled.
	 */
	uint8_t	cc_ack_bytes;
	/*
	 * Enables reduction of CR, TR, and CP to init values when
	 * congestion free RTTs is greater than reduce2_init_cong_free_rtts_th.
	 */
	uint8_t	reduce_init_en;
	/*
	 * Minimum threshold value for number of congestion free RTTs before reducing
	 * to init values for CR, TR, and CP when reduce_init_en is enabled.
	 */
	uint16_t	reduce_init_cong_free_rtts_th;
	/* Enables random no reduction of CR. */
	uint8_t	random_no_red_en;
	/* Enables coarse correction to actual CR when actual RTT is longer than nominal. */
	uint8_t	actual_cr_shift_correction_en;
	/* Enables adjustment to refill quota. */
	uint8_t	quota_period_adjust_en;
	uint8_t	reserved[5];
} creq_query_roce_cc_gen1_resp_sb_tlv_t, *pcreq_query_roce_cc_gen1_resp_sb_tlv_t;

/***********************
 * cmdq_modify_roce_cc *
 ***********************/


/* cmdq_modify_roce_cc (size:448b/56B) */

typedef struct cmdq_modify_roce_cc {
	/* Command opcode. */
	uint8_t	opcode;
	/* Modify congestion control. Can only be issued from a PF. */
	#define CMDQ_MODIFY_ROCE_CC_OPCODE_MODIFY_ROCE_CC UINT32_C(0x8c)
	#define CMDQ_MODIFY_ROCE_CC_OPCODE_LAST	CMDQ_MODIFY_ROCE_CC_OPCODE_MODIFY_ROCE_CC
	/* Size of the command in 16-byte units. */
	uint8_t	cmd_size;
	/* Flags and attribs of the command. */
	uint16_t	flags;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* Size of the response buffer in 16-byte units. */
	uint8_t	resp_size;
	uint8_t	reserved8;
	/* Host address of the response. */
	uint64_t	resp_addr;
	/* Modify mask signifies the field that is requesting the change. */
	uint32_t	modify_mask;
	/* Enable change. */
	#define CMDQ_MODIFY_ROCE_CC_MODIFY_MASK_ENABLE_CC		UINT32_C(0x1)
	/* Running average weight change. */
	#define CMDQ_MODIFY_ROCE_CC_MODIFY_MASK_G			UINT32_C(0x2)
	/* Number of phases in Fast Recovery. */
	#define CMDQ_MODIFY_ROCE_CC_MODIFY_MASK_NUMPHASEPERSTATE	UINT32_C(0x4)
	/* The starting value of rate change. */
	#define CMDQ_MODIFY_ROCE_CC_MODIFY_MASK_INIT_CR		UINT32_C(0x8)
	/* The starting value of target rate change. */
	#define CMDQ_MODIFY_ROCE_CC_MODIFY_MASK_INIT_TR		UINT32_C(0x10)
	/* IP TOS ECN change */
	#define CMDQ_MODIFY_ROCE_CC_MODIFY_MASK_TOS_ECN		UINT32_C(0x20)
	/* IP TOS DSCP change */
	#define CMDQ_MODIFY_ROCE_CC_MODIFY_MASK_TOS_DSCP		UINT32_C(0x40)
	/* Alternate IP TOS ECN change */
	#define CMDQ_MODIFY_ROCE_CC_MODIFY_MASK_ALT_VLAN_PCP	UINT32_C(0x80)
	/* Alternate IP TOS DSCP change */
	#define CMDQ_MODIFY_ROCE_CC_MODIFY_MASK_ALT_TOS_DSCP	UINT32_C(0x100)
	/* Round trip time in units of usecs */
	#define CMDQ_MODIFY_ROCE_CC_MODIFY_MASK_RTT		UINT32_C(0x200)
	/* Congestion Control mode */
	#define CMDQ_MODIFY_ROCE_CC_MODIFY_MASK_CC_MODE		UINT32_C(0x400)
	/* The value used as CP when cc_mode is 1(TCP) */
	#define CMDQ_MODIFY_ROCE_CC_MODIFY_MASK_TCP_CP		UINT32_C(0x800)
	/* Specifies the RoCE Tx Queue to use for sending CNP packets */
	#define CMDQ_MODIFY_ROCE_CC_MODIFY_MASK_TX_QUEUE		UINT32_C(0x1000)
	/* Inactivity time after which QP CC parameters are initialized */
	#define CMDQ_MODIFY_ROCE_CC_MODIFY_MASK_INACTIVITY_CP	UINT32_C(0x2000)
	/* Amount of time per phase in units of ms. Max is 15. */
	#define CMDQ_MODIFY_ROCE_CC_MODIFY_MASK_TIME_PER_PHASE	UINT32_C(0x4000)
	/* Number of packets per phase. Max is 255. */
	#define CMDQ_MODIFY_ROCE_CC_MODIFY_MASK_PKTS_PER_PHASE	UINT32_C(0x8000)
	uint8_t	enable_cc;
	/* Enable. */
	#define CMDQ_MODIFY_ROCE_CC_ENABLE_CC	UINT32_C(0x1)
	/* rsvd1 is 7 b */
	#define CMDQ_MODIFY_ROCE_CC_RSVD1_MASK	UINT32_C(0xfe)
	#define CMDQ_MODIFY_ROCE_CC_RSVD1_SFT	1
	/* Congestion Probability averaging factor. */
	uint8_t	g;
	/* Number of phases in Fast Recovery. */
	uint8_t	num_phases_per_state;
	/* Number of packets per phase. Max is 255. */
	uint8_t	pkts_per_phase;
	/*
	 * The starting value of rate.
	 * The max value supported for CC support level 1 is 1024.
	 */
	uint16_t	init_cr;
	/*
	 * The starting value of target rate.
	 * The max value supported for CC support level 1 is 1024.
	 */
	uint16_t	init_tr;
	uint8_t	tos_dscp_tos_ecn;
	/* IP TOS ECN. Valid values are 1 or 2 when ECN is enabled. */
	#define CMDQ_MODIFY_ROCE_CC_TOS_ECN_MASK UINT32_C(0x3)
	#define CMDQ_MODIFY_ROCE_CC_TOS_ECN_SFT  0
	/* IP TOS DSCP. */
	#define CMDQ_MODIFY_ROCE_CC_TOS_DSCP_MASK UINT32_C(0xfc)
	#define CMDQ_MODIFY_ROCE_CC_TOS_DSCP_SFT 2
	uint8_t	alt_vlan_pcp;
	/* Alternate vlan pcp value for CNP packets. */
	#define CMDQ_MODIFY_ROCE_CC_ALT_VLAN_PCP_MASK UINT32_C(0x7)
	#define CMDQ_MODIFY_ROCE_CC_ALT_VLAN_PCP_SFT 0
	/* rsvd3 is 5 b */
	#define CMDQ_MODIFY_ROCE_CC_RSVD3_MASK	UINT32_C(0xf8)
	#define CMDQ_MODIFY_ROCE_CC_RSVD3_SFT	3
	uint16_t	alt_tos_dscp;
	/* Alternate IP TOS DSCP. */
	#define CMDQ_MODIFY_ROCE_CC_ALT_TOS_DSCP_MASK UINT32_C(0x3f)
	#define CMDQ_MODIFY_ROCE_CC_ALT_TOS_DSCP_SFT 0
	/* rsvd4 is 10 b */
	#define CMDQ_MODIFY_ROCE_CC_RSVD4_MASK	UINT32_C(0xffc0)
	#define CMDQ_MODIFY_ROCE_CC_RSVD4_SFT	6
	uint16_t	rtt;
	/*
	 * Round trip time in units of usecs.
	 * The max value supported for CC support level 1 is 2047.
	 */
	#define CMDQ_MODIFY_ROCE_CC_RTT_MASK  UINT32_C(0x3fff)
	#define CMDQ_MODIFY_ROCE_CC_RTT_SFT   0
	/* rsvd5 is 2 b */
	#define CMDQ_MODIFY_ROCE_CC_RSVD5_MASK UINT32_C(0xc000)
	#define CMDQ_MODIFY_ROCE_CC_RSVD5_SFT 14
	uint16_t	tcp_cp;
	/* The value used as CP when cc_mode is 1(TCP) */
	#define CMDQ_MODIFY_ROCE_CC_TCP_CP_MASK UINT32_C(0x3ff)
	#define CMDQ_MODIFY_ROCE_CC_TCP_CP_SFT 0
	/* rsvd6 is 6 b */
	#define CMDQ_MODIFY_ROCE_CC_RSVD6_MASK UINT32_C(0xfc00)
	#define CMDQ_MODIFY_ROCE_CC_RSVD6_SFT  10
	uint8_t	cc_mode;
	/* DCTCP */
	#define CMDQ_MODIFY_ROCE_CC_CC_MODE_DCTCP_CC_MODE	UINT32_C(0x0)
	/*
	 * Probabilistic marking. On chips with CC Gen 0 support this
	 * will be TCP CC algorithm.
	 */
	#define CMDQ_MODIFY_ROCE_CC_CC_MODE_PROBABILISTIC_CC_MODE UINT32_C(0x1)
	#define CMDQ_MODIFY_ROCE_CC_CC_MODE_LAST		CMDQ_MODIFY_ROCE_CC_CC_MODE_PROBABILISTIC_CC_MODE
	/*
	 * Specifies the RoCE Tx Queue to use for sending CNP packets.
	 * CC support level 0 support 0 to 3 Tx queues.
	 * CC support level 1 supports 0 to 7 Tx queues.
	 */
	uint8_t	tx_queue;
	/* Inactivity time after which QP CC parameters are initialized */
	uint16_t	inactivity_th;
	/* Amount of time per phase in units of ms. Max is 15 */
	uint8_t	time_per_phase;
	/* reserved8 is 8 b */
	uint8_t	reserved8_1;
	/* reserved16 is 16 b */
	uint16_t	reserved16;
	uint32_t	reserved32;
	uint64_t	reserved64;
} cmdq_modify_roce_cc_t, *pcmdq_modify_roce_cc_t;

/*
 * TLV encapsulated modify CC command, with extended TLV record
 * included for specifying the extended configuration for CC level 1.
 */
/* cmdq_modify_roce_cc_tlv (size:640b/80B) */

typedef struct cmdq_modify_roce_cc_tlv {
	/*
	 * The command discriminator is used to differentiate between various
	 * types of HWRM messages. This includes legacy HWRM and RoCE slowpath
	 * command messages as well as newer TLV encapsulated HWRM commands.
	 *
	 * For TLV encapsulated messages this field must be 0x8000.
	 */
	uint16_t	cmd_discr;
	uint8_t	reserved_8b;
	uint8_t	tlv_flags;
	/*
	 * Indicates the presence of additional TLV encapsulated data
	 * follows this TLV.
	 */
	#define CMDQ_MODIFY_ROCE_CC_TLV_TLV_FLAGS_MORE	UINT32_C(0x1)
	/* Last TLV in a sequence of TLVs. */
		#define CMDQ_MODIFY_ROCE_CC_TLV_TLV_FLAGS_MORE_LAST	UINT32_C(0x0)
	/* More TLVs follow this TLV. */
		#define CMDQ_MODIFY_ROCE_CC_TLV_TLV_FLAGS_MORE_NOT_LAST  UINT32_C(0x1)
	/*
	 * When an HWRM receiver detects a TLV type that it does not
	 * support with the TLV required flag set, the receiver must
	 * reject the HWRM message with an error code indicating an
	 * unsupported TLV type.
	 */
	#define CMDQ_MODIFY_ROCE_CC_TLV_TLV_FLAGS_REQUIRED	UINT32_C(0x2)
	/* No */
		#define CMDQ_MODIFY_ROCE_CC_TLV_TLV_FLAGS_REQUIRED_NO	(UINT32_C(0x0) << 1)
	/* Yes */
		#define CMDQ_MODIFY_ROCE_CC_TLV_TLV_FLAGS_REQUIRED_YES   (UINT32_C(0x1) << 1)
		#define CMDQ_MODIFY_ROCE_CC_TLV_TLV_FLAGS_REQUIRED_LAST CMDQ_MODIFY_ROCE_CC_TLV_TLV_FLAGS_REQUIRED_YES
	/*
	 * This field defines the TLV type value which is divided into
	 * two ranges to differentiate between global and local TLV types.
	 * Global TLV types must be unique across all defined TLV types.
	 * Local TLV types are valid only for extensions to a given
	 * HWRM message and may be repeated across different HWRM message
	 * types. There is a direct correlation of each HWRM message type
	 * to a single global TLV type value.
	 *
	 * Global TLV range: `0 - (63k-1)`
	 *
	 * Local TLV range: `63k - (64k-1)`
	 */
	uint16_t	tlv_type;
	/*
	 * Length of the message data encapsulated by this TLV in bytes.
	 * This length does not include the size of the TLV header itself
	 * and it must be an integer multiple of 8B.
	 */
	uint16_t	length;
	/* Size of the tlv encapsulated command, including all tlvs and extension data in 16-byte units. */
	uint8_t	total_size;
	uint8_t	reserved56[7];
	/* Command opcode. */
	uint8_t	opcode;
	/* Modify congestion control. Can only be issued from a PF. */
	#define CMDQ_MODIFY_ROCE_CC_TLV_OPCODE_MODIFY_ROCE_CC UINT32_C(0x8c)
	#define CMDQ_MODIFY_ROCE_CC_TLV_OPCODE_LAST	CMDQ_MODIFY_ROCE_CC_TLV_OPCODE_MODIFY_ROCE_CC
	/* Size of the command in 16-byte units. */
	uint8_t	cmd_size;
	/* Flags and attribs of the command. */
	uint16_t	flags;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* Size of the response buffer in 16-byte units. */
	uint8_t	resp_size;
	uint8_t	reserved8;
	/* Host address of the response. */
	uint64_t	resp_addr;
	/* Modify mask signifies the field that is requesting the change. */
	uint32_t	modify_mask;
	/* Enable change. */
	#define CMDQ_MODIFY_ROCE_CC_TLV_MODIFY_MASK_ENABLE_CC		UINT32_C(0x1)
	/* Running average weight change. */
	#define CMDQ_MODIFY_ROCE_CC_TLV_MODIFY_MASK_G			UINT32_C(0x2)
	/* Number of phases in Fast Recovery. */
	#define CMDQ_MODIFY_ROCE_CC_TLV_MODIFY_MASK_NUMPHASEPERSTATE	UINT32_C(0x4)
	/* The starting value of rate change. */
	#define CMDQ_MODIFY_ROCE_CC_TLV_MODIFY_MASK_INIT_CR		UINT32_C(0x8)
	/* The starting value of target rate change. */
	#define CMDQ_MODIFY_ROCE_CC_TLV_MODIFY_MASK_INIT_TR		UINT32_C(0x10)
	/* IP TOS ECN change */
	#define CMDQ_MODIFY_ROCE_CC_TLV_MODIFY_MASK_TOS_ECN		UINT32_C(0x20)
	/* IP TOS DSCP change */
	#define CMDQ_MODIFY_ROCE_CC_TLV_MODIFY_MASK_TOS_DSCP		UINT32_C(0x40)
	/* Alternate IP TOS ECN change */
	#define CMDQ_MODIFY_ROCE_CC_TLV_MODIFY_MASK_ALT_VLAN_PCP	UINT32_C(0x80)
	/* Alternate IP TOS DSCP change */
	#define CMDQ_MODIFY_ROCE_CC_TLV_MODIFY_MASK_ALT_TOS_DSCP	UINT32_C(0x100)
	/* Round trip time in units of usecs */
	#define CMDQ_MODIFY_ROCE_CC_TLV_MODIFY_MASK_RTT		UINT32_C(0x200)
	/* Congestion Control mode */
	#define CMDQ_MODIFY_ROCE_CC_TLV_MODIFY_MASK_CC_MODE		UINT32_C(0x400)
	/* The value used as CP when cc_mode is 1(TCP) */
	#define CMDQ_MODIFY_ROCE_CC_TLV_MODIFY_MASK_TCP_CP		UINT32_C(0x800)
	/* Specifies the RoCE Tx Queue to use for sending CNP packets */
	#define CMDQ_MODIFY_ROCE_CC_TLV_MODIFY_MASK_TX_QUEUE		UINT32_C(0x1000)
	/* Inactivity time after which QP CC parameters are initialized */
	#define CMDQ_MODIFY_ROCE_CC_TLV_MODIFY_MASK_INACTIVITY_CP	UINT32_C(0x2000)
	/* Amount of time per phase in units of ms. Max is 15. */
	#define CMDQ_MODIFY_ROCE_CC_TLV_MODIFY_MASK_TIME_PER_PHASE	UINT32_C(0x4000)
	/* Number of packets per phase. Max is 255. */
	#define CMDQ_MODIFY_ROCE_CC_TLV_MODIFY_MASK_PKTS_PER_PHASE	UINT32_C(0x8000)
	uint8_t	enable_cc;
	/* Enable. */
	#define CMDQ_MODIFY_ROCE_CC_TLV_ENABLE_CC	UINT32_C(0x1)
	/* rsvd1 is 7 b */
	#define CMDQ_MODIFY_ROCE_CC_TLV_RSVD1_MASK	UINT32_C(0xfe)
	#define CMDQ_MODIFY_ROCE_CC_TLV_RSVD1_SFT	1
	/* Congestion Probability averaging factor. */
	uint8_t	g;
	/* Number of phases in Fast Recovery. */
	uint8_t	num_phases_per_state;
	/* Number of packets per phase. Max is 255. */
	uint8_t	pkts_per_phase;
	/*
	 * The starting value of rate.
	 * The max value supported for CC support level 1 is 1024.
	 */
	uint16_t	init_cr;
	/*
	 * The starting value of target rate.
	 * The max value supported for CC support level 1 is 1024.
	 */
	uint16_t	init_tr;
	uint8_t	tos_dscp_tos_ecn;
	/* IP TOS ECN. Valid values are 1 or 2 when ECN is enabled. */
	#define CMDQ_MODIFY_ROCE_CC_TLV_TOS_ECN_MASK UINT32_C(0x3)
	#define CMDQ_MODIFY_ROCE_CC_TLV_TOS_ECN_SFT  0
	/* IP TOS DSCP. */
	#define CMDQ_MODIFY_ROCE_CC_TLV_TOS_DSCP_MASK UINT32_C(0xfc)
	#define CMDQ_MODIFY_ROCE_CC_TLV_TOS_DSCP_SFT 2
	uint8_t	alt_vlan_pcp;
	/* Alternate vlan pcp value for CNP packets. */
	#define CMDQ_MODIFY_ROCE_CC_TLV_ALT_VLAN_PCP_MASK UINT32_C(0x7)
	#define CMDQ_MODIFY_ROCE_CC_TLV_ALT_VLAN_PCP_SFT 0
	/* rsvd3 is 5 b */
	#define CMDQ_MODIFY_ROCE_CC_TLV_RSVD3_MASK	UINT32_C(0xf8)
	#define CMDQ_MODIFY_ROCE_CC_TLV_RSVD3_SFT	3
	uint16_t	alt_tos_dscp;
	/* Alternate IP TOS DSCP. */
	#define CMDQ_MODIFY_ROCE_CC_TLV_ALT_TOS_DSCP_MASK UINT32_C(0x3f)
	#define CMDQ_MODIFY_ROCE_CC_TLV_ALT_TOS_DSCP_SFT 0
	/* rsvd4 is 10 b */
	#define CMDQ_MODIFY_ROCE_CC_TLV_RSVD4_MASK	UINT32_C(0xffc0)
	#define CMDQ_MODIFY_ROCE_CC_TLV_RSVD4_SFT	6
	uint16_t	rtt;
	/*
	 * Round trip time in units of usecs.
	 * The max value supported for CC support level 1 is 2047.
	 */
	#define CMDQ_MODIFY_ROCE_CC_TLV_RTT_MASK  UINT32_C(0x3fff)
	#define CMDQ_MODIFY_ROCE_CC_TLV_RTT_SFT   0
	/* rsvd5 is 2 b */
	#define CMDQ_MODIFY_ROCE_CC_TLV_RSVD5_MASK UINT32_C(0xc000)
	#define CMDQ_MODIFY_ROCE_CC_TLV_RSVD5_SFT 14
	uint16_t	tcp_cp;
	/* The value used as CP when cc_mode is 1(TCP) */
	#define CMDQ_MODIFY_ROCE_CC_TLV_TCP_CP_MASK UINT32_C(0x3ff)
	#define CMDQ_MODIFY_ROCE_CC_TLV_TCP_CP_SFT 0
	/* rsvd6 is 6 b */
	#define CMDQ_MODIFY_ROCE_CC_TLV_RSVD6_MASK UINT32_C(0xfc00)
	#define CMDQ_MODIFY_ROCE_CC_TLV_RSVD6_SFT  10
	uint8_t	cc_mode;
	/* DCTCP */
	#define CMDQ_MODIFY_ROCE_CC_TLV_CC_MODE_DCTCP_CC_MODE	UINT32_C(0x0)
	/*
	 * Probabilistic marking. On chips with CC Gen 0 support this
	 * will be TCP CC algorithm.
	 */
	#define CMDQ_MODIFY_ROCE_CC_TLV_CC_MODE_PROBABILISTIC_CC_MODE UINT32_C(0x1)
	#define CMDQ_MODIFY_ROCE_CC_TLV_CC_MODE_LAST		CMDQ_MODIFY_ROCE_CC_TLV_CC_MODE_PROBABILISTIC_CC_MODE
	/*
	 * Specifies the RoCE Tx Queue to use for sending CNP packets.
	 * CC support level 0 support 0 to 3 Tx queues.
	 * CC support level 1 supports 0 to 7 Tx queues.
	 */
	uint8_t	tx_queue;
	/* Inactivity time after which QP CC parameters are initialized */
	uint16_t	inactivity_th;
	/* Amount of time per phase in units of ms. Max is 15 */
	uint8_t	time_per_phase;
	/* reserved8 is 8 b */
	uint8_t	reserved8_1;
	/* reserved16 is 16 b */
	uint16_t	reserved16;
	uint32_t	reserved32;
	uint64_t	reserved64;
	uint64_t	reservedtlvpad;
} cmdq_modify_roce_cc_tlv_t, *pcmdq_modify_roce_cc_tlv_t;

/* cmdq_modify_roce_cc_gen1_tlv (size:768b/96B) */

typedef struct cmdq_modify_roce_cc_gen1_tlv {
	/*
	 * The command discriminator is used to differentiate between various
	 * types of HWRM messages. This includes legacy HWRM and RoCE slowpath
	 * command messages as well as newer TLV encapsulated HWRM commands.
	 *
	 * For TLV encapsulated messages this field must be 0x8000.
	 */
	uint16_t	cmd_discr;
	uint8_t	reserved_8b;
	uint8_t	tlv_flags;
	/*
	 * Indicates the presence of additional TLV encapsulated data
	 * follows this TLV.
	 */
	#define CMDQ_MODIFY_ROCE_CC_GEN1_TLV_TLV_FLAGS_MORE	UINT32_C(0x1)
	/* Last TLV in a sequence of TLVs. */
		#define CMDQ_MODIFY_ROCE_CC_GEN1_TLV_TLV_FLAGS_MORE_LAST	UINT32_C(0x0)
	/* More TLVs follow this TLV. */
		#define CMDQ_MODIFY_ROCE_CC_GEN1_TLV_TLV_FLAGS_MORE_NOT_LAST  UINT32_C(0x1)
	/*
	 * When an HWRM receiver detects a TLV type that it does not
	 * support with the TLV required flag set, the receiver must
	 * reject the HWRM message with an error code indicating an
	 * unsupported TLV type.
	 */
	#define CMDQ_MODIFY_ROCE_CC_GEN1_TLV_TLV_FLAGS_REQUIRED	UINT32_C(0x2)
	/* No */
		#define CMDQ_MODIFY_ROCE_CC_GEN1_TLV_TLV_FLAGS_REQUIRED_NO	(UINT32_C(0x0) << 1)
	/* Yes */
		#define CMDQ_MODIFY_ROCE_CC_GEN1_TLV_TLV_FLAGS_REQUIRED_YES   (UINT32_C(0x1) << 1)
		#define CMDQ_MODIFY_ROCE_CC_GEN1_TLV_TLV_FLAGS_REQUIRED_LAST CMDQ_MODIFY_ROCE_CC_GEN1_TLV_TLV_FLAGS_REQUIRED_YES
	/*
	 * This field defines the TLV type value which is divided into
	 * two ranges to differentiate between global and local TLV types.
	 * Global TLV types must be unique across all defined TLV types.
	 * Local TLV types are valid only for extensions to a given
	 * HWRM message and may be repeated across different HWRM message
	 * types. There is a direct correlation of each HWRM message type
	 * to a single global TLV type value.
	 *
	 * Global TLV range: `0 - (63k-1)`
	 *
	 * Local TLV range: `63k - (64k-1)`
	 */
	uint16_t	tlv_type;
	/*
	 * Length of the message data encapsulated by this TLV in bytes.
	 * This length does not include the size of the TLV header itself
	 * and it must be an integer multiple of 8B.
	 */
	uint16_t	length;
	uint64_t	reserved64;
	/* Modify mask signifies the field that is requesting the change. */
	uint64_t	modify_mask;
	/* Update the number of uS between generation of CNPs for probabilistic marking mode. */
	#define CMDQ_MODIFY_ROCE_CC_GEN1_TLV_MODIFY_MASK_MIN_TIME_BETWEEN_CNPS		UINT32_C(0x1)
	/*
	 * Update starting value of Congestion Probability (CP).
	 * Maximum value supported is 1023.
	 */
	#define CMDQ_MODIFY_ROCE_CC_GEN1_TLV_MODIFY_MASK_INIT_CP			UINT32_C(0x2)
	/* Update Target Rate (TR) Update Mode. */
	#define CMDQ_MODIFY_ROCE_CC_GEN1_TLV_MODIFY_MASK_TR_UPDATE_MODE			UINT32_C(0x4)
	/* Update number of RTTs with CNPs in a row for TR update. */
	#define CMDQ_MODIFY_ROCE_CC_GEN1_TLV_MODIFY_MASK_TR_UPDATE_CYCLES		UINT32_C(0x8)
	/* Update number of RTTs in Fast Recovery stage. */
	#define CMDQ_MODIFY_ROCE_CC_GEN1_TLV_MODIFY_MASK_FR_NUM_RTTS			UINT32_C(0x10)
	/* Update time increment to increase TR in active increase phase. */
	#define CMDQ_MODIFY_ROCE_CC_GEN1_TLV_MODIFY_MASK_AI_RATE_INCREASE		UINT32_C(0x20)
	/*
	 * Update count of RTTs with CNPs, received after
	 * the first one, to wait, before reducing rate.
	 */
	#define CMDQ_MODIFY_ROCE_CC_GEN1_TLV_MODIFY_MASK_REDUCTION_RELAX_RTTS_TH	UINT32_C(0x40)
	/*
	 * Update additional number of RTTS with CNPs, to wait,
	 * before further rate reduction, for low rates.
	 */
	#define CMDQ_MODIFY_ROCE_CC_GEN1_TLV_MODIFY_MASK_ADDITIONAL_RELAX_CR_TH		UINT32_C(0x80)
	/* Update threshold for update to Actual Current Rate (CR) */
	#define CMDQ_MODIFY_ROCE_CC_GEN1_TLV_MODIFY_MASK_CR_MIN_TH			UINT32_C(0x100)
	/* Update log based averaging weight for QPC variable actual_cr */
	#define CMDQ_MODIFY_ROCE_CC_GEN1_TLV_MODIFY_MASK_BW_AVG_WEIGHT			UINT32_C(0x200)
	/* Update factor used in the computation of rate reduction. */
	#define CMDQ_MODIFY_ROCE_CC_GEN1_TLV_MODIFY_MASK_ACTUAL_CR_FACTOR		UINT32_C(0x400)
	/* Update the level of CR above which CP is set to maximum level. */
	#define CMDQ_MODIFY_ROCE_CC_GEN1_TLV_MODIFY_MASK_MAX_CP_CR_TH			UINT32_C(0x800)
	/* Enable adding fraction of CR to CP. */
	#define CMDQ_MODIFY_ROCE_CC_GEN1_TLV_MODIFY_MASK_CP_BIAS_EN			UINT32_C(0x1000)
	/*
	 * Update log based fraction of CR to add to CP
	 * when cp_bias_en is 1.
	 */
	#define CMDQ_MODIFY_ROCE_CC_GEN1_TLV_MODIFY_MASK_CP_BIAS			UINT32_C(0x2000)
	/* Update ECN bits in a CNP packet generated by hardware. */
	#define CMDQ_MODIFY_ROCE_CC_GEN1_TLV_MODIFY_MASK_CNP_ECN			UINT32_C(0x4000)
	/* Update enable of jitter in RTT. */
	#define CMDQ_MODIFY_ROCE_CC_GEN1_TLV_MODIFY_MASK_RTT_JITTER_EN			UINT32_C(0x8000)
	/* Update number of bytes per usec. */
	#define CMDQ_MODIFY_ROCE_CC_GEN1_TLV_MODIFY_MASK_LINK_BYTES_PER_USEC		UINT32_C(0x10000)
	/* Update threshold used to reset QPC CC state to its initial state. */
	#define CMDQ_MODIFY_ROCE_CC_GEN1_TLV_MODIFY_MASK_RESET_CC_CR_TH			UINT32_C(0x20000)
	/* Update number of valid lsbits in CR and TR */
	#define CMDQ_MODIFY_ROCE_CC_GEN1_TLV_MODIFY_MASK_CR_WIDTH			UINT32_C(0x40000)
	/* Update lower end of random selection of quota_period. */
	#define CMDQ_MODIFY_ROCE_CC_GEN1_TLV_MODIFY_MASK_QUOTA_PERIOD_MIN		UINT32_C(0x80000)
	/* Update upper end of random selection of quota_period. */
	#define CMDQ_MODIFY_ROCE_CC_GEN1_TLV_MODIFY_MASK_QUOTA_PERIOD_MAX		UINT32_C(0x100000)
	/*
	 * Update absolute maximum possible quota_period,
	 * when rate table for lower 24 levels is used.
	 */
	#define CMDQ_MODIFY_ROCE_CC_GEN1_TLV_MODIFY_MASK_QUOTA_PERIOD_ABS_MAX		UINT32_C(0x200000)
	/* Update lower bound of TR. */
	#define CMDQ_MODIFY_ROCE_CC_GEN1_TLV_MODIFY_MASK_TR_LOWER_BOUND			UINT32_C(0x400000)
	/*
	 * Update factor on probability threshold for adding
	 * 0.5 to CR randomly.
	 */
	#define CMDQ_MODIFY_ROCE_CC_GEN1_TLV_MODIFY_MASK_CR_PROB_FACTOR			UINT32_C(0x800000)
	/*
	 * Update factor on probability threshold for adding
	 * 0.5 to TR randomly.
	 */
	#define CMDQ_MODIFY_ROCE_CC_GEN1_TLV_MODIFY_MASK_TR_PROB_FACTOR			UINT32_C(0x1000000)
	/*
	 * Update threshold that ensures fairness between requester
	 * and responder
	 */
	#define CMDQ_MODIFY_ROCE_CC_GEN1_TLV_MODIFY_MASK_FAIRNESS_CR_TH			UINT32_C(0x2000000)
	/* Update log based rate reduction divider. */
	#define CMDQ_MODIFY_ROCE_CC_GEN1_TLV_MODIFY_MASK_RED_DIV			UINT32_C(0x4000000)
	/*
	 * Update threshold for rate reductions when CNPS received
	 * over last RTT.
	 */
	#define CMDQ_MODIFY_ROCE_CC_GEN1_TLV_MODIFY_MASK_CNP_RATIO_TH			UINT32_C(0x8000000)
	/*
	 * Update extended number of RTTS to wait,
	 * when there is no congestion, to start doubling the rate.
	 */
	#define CMDQ_MODIFY_ROCE_CC_GEN1_TLV_MODIFY_MASK_EXP_AI_RTTS			UINT32_C(0x10000000)
	/* Update log based CR to CP ratio used in exponential increase. */
	#define CMDQ_MODIFY_ROCE_CC_GEN1_TLV_MODIFY_MASK_EXP_AI_CR_CP_RATIO		UINT32_C(0x20000000)
	/*
	 * Update threshold, in congestion free RTTs,
	 * that triggers start of CP update to track CR.
	 */
	#define CMDQ_MODIFY_ROCE_CC_GEN1_TLV_MODIFY_MASK_CP_EXP_UPDATE_TH		UINT32_C(0x40000000)
	/*
	 * Update threshold on congestion free RTTs above
	 * which AI can increase to 16.
	 */
	#define CMDQ_MODIFY_ROCE_CC_GEN1_TLV_MODIFY_MASK_HIGH_EXP_AI_RTTS_TH1		UINT32_C(0x80000000)
	/*
	 * Update threshold on congestion free RTTs above
	 * which AI can increase to 32.
	 */
	#define CMDQ_MODIFY_ROCE_CC_GEN1_TLV_MODIFY_MASK_HIGH_EXP_AI_RTTS_TH2		UINT32_C(0x100000000)L
	/* Update use of lowest 24 rate levels rate_table. */
	#define CMDQ_MODIFY_ROCE_CC_GEN1_TLV_MODIFY_MASK_USE_RATE_TABLE			UINT32_C(0x200000000)L
	/*
	 * Update the maximum number of 64B that can be transmitted
	 * during RTT time.
	 */
	#define CMDQ_MODIFY_ROCE_CC_GEN1_TLV_MODIFY_MASK_LINK64B_PER_RTT		UINT32_C(0x400000000)L
	/*
	 * Update number of congestion free RTTs above which
	 * reduction based on actual rate is enabled.
	 */
	#define CMDQ_MODIFY_ROCE_CC_GEN1_TLV_MODIFY_MASK_ACTUAL_CR_CONG_FREE_RTTS_TH	UINT32_C(0x800000000)L
	/*
	 * Update threshold used in severe congestion for
	 * limiting TR to 1.5 times CR.
	 */
	#define CMDQ_MODIFY_ROCE_CC_GEN1_TLV_MODIFY_MASK_SEVERE_CONG_CR_TH1		UINT32_C(0x1000000000)L
	/*
	 * Update threshold used in severe congestion for
	 * limiting TR to 1.25 times CR.
	 */
	#define CMDQ_MODIFY_ROCE_CC_GEN1_TLV_MODIFY_MASK_SEVERE_CONG_CR_TH2		UINT32_C(0x2000000000)L
	/*
	 * Update number of bytes to subtract from QPC.cc_bucket
	 * when an ack is scheduled.
	 */
	#define CMDQ_MODIFY_ROCE_CC_GEN1_TLV_MODIFY_MASK_CC_ACK_BYTES			UINT32_C(0x4000000000)L
	/* Update enable of reduction of CR, TR, and CP to init values. */
	#define CMDQ_MODIFY_ROCE_CC_GEN1_TLV_MODIFY_MASK_REDUCE_INIT_EN			UINT32_C(0x8000000000)L
	/* Update threshold used for reduction of CR, TR, and CP to init values. */
	#define CMDQ_MODIFY_ROCE_CC_GEN1_TLV_MODIFY_MASK_REDUCE_INIT_CONG_FREE_RTTS_TH	UINT32_C(0x10000000000)L
	/* Update enable of random no reduction of CR. */
	#define CMDQ_MODIFY_ROCE_CC_GEN1_TLV_MODIFY_MASK_RANDOM_NO_RED_EN		UINT32_C(0x20000000000)L
	/* Update enable of coarse correction to actual CR. */
	#define CMDQ_MODIFY_ROCE_CC_GEN1_TLV_MODIFY_MASK_ACTUAL_CR_SHIFT_CORRECTION_EN	UINT32_C(0x40000000000)L
	/* Update enable of adjustment to refill quota. */
	#define CMDQ_MODIFY_ROCE_CC_GEN1_TLV_MODIFY_MASK_QUOTA_PERIOD_ADJUST_EN		UINT32_C(0x80000000000)L
	/* High order bits of inactivity threshold. */
	uint16_t	inactivity_th_hi;
	/* The number of uS between generation of CNPs when cc_mode is probabilistic marking. */
	uint16_t	min_time_between_cnps;
	/* The starting value of congestion probability. Input range is 0 - 1023. */
	uint16_t	init_cp;
	/*
	 * In tr_update_mode 0, Target Rate (TR) is updated to
	 * halfway between the Current Rate (CR) before and after reduction.
	 * In tr_update_mode 1, TR is updated to CR's value before reduction.
	 */
	uint8_t	tr_update_mode;
	/*
	 * Determine for how many RTTs with CNPs in a row, TR is being updated.
	 * 0: TR is updated when QPC. rtts_with_cnps == 0
	 * 1-6: TR is updated if QPC. rtts_with_cnps <= tr_update_cycles
	 * 7: TR is updated on all reductions.
	 */
	uint8_t	tr_update_cycles;
	/* Number of RTTs in Fast Recovery stage. */
	uint8_t	fr_num_rtts;
	/* Time increment to increase TR in active increase phase. */
	uint8_t	ai_rate_increase;
	/*
	 * Indicates for how many RTTs with CNPs after the first one
	 * to not reduce rate even if CNPs are received.
	 */
	uint16_t	reduction_relax_rtts_th;
	/*
	 * For low rates, additional number of RTTS with CNPs
	 * for which no rate reduction is made.
	 * num_bits: 14
	 */
	uint16_t	additional_relax_cr_th;
	/*
	 * If CR is less than or equal to this value,
	 * then the actual CR average is set to this value
	 * (shifted by bw_avg_weight).
	 */
	uint16_t	cr_min_th;
	/* Log based averaging weight for QPC variable actual_cr_avg. */
	uint8_t	bw_avg_weight;
	/*
	 * Used to compare CR to this factor times QPC.actual_cr_average
	 * as a reduction reference. Values between 0 and 6 represent factor of
	 * 1.125, 1.25, 1.5, 1.75, 2, 2.25, 2.5 respectively.
	 */
	uint8_t	actual_cr_factor;
	/* The level of CR above which CP is set to maximum level. */
	uint16_t	max_cp_cr_th;
	/*
	 * Enable adding fraction of CR to CP.
	 * 0 for disable, 1 for enable.
	 */
	uint8_t	cp_bias_en;
	/* Log based fraction of cr to add to CP when cp_bias_en is 1. */
	uint8_t	cp_bias;
	/*
	 * The value of ECN bits in a CNP packet generated by hardware.
	 * ECN-Capabale Transport (ECT) codepoints supported include:
	 * 0 for not_ect, 1 for ect_0, 2 for ect_1
	 */
	uint8_t	cnp_ecn;
	/* Not ECN capable Transport */
	#define CMDQ_MODIFY_ROCE_CC_GEN1_TLV_CNP_ECN_NOT_ECT UINT32_C(0x0)
	/* ECN Capable Transport-1 */
	#define CMDQ_MODIFY_ROCE_CC_GEN1_TLV_CNP_ECN_ECT_1   UINT32_C(0x1)
	/* ECN Capable Transport-0 */
	#define CMDQ_MODIFY_ROCE_CC_GEN1_TLV_CNP_ECN_ECT_0   UINT32_C(0x2)
	#define CMDQ_MODIFY_ROCE_CC_GEN1_TLV_CNP_ECN_LAST   CMDQ_MODIFY_ROCE_CC_GEN1_TLV_CNP_ECN_ECT_0
	/* Enables jitter in RTT. */
	uint8_t	rtt_jitter_en;
	/*
	 * Number of bytes per usec, dependant on port speed.
	 * 200 Gbps: 25,000
	 * 100 Gbps: 12,500
	 * 50 Gbps: 6,250
	 * 25 Gbps: 3125
	 * 10 Gbps: 1250
	 */
	uint16_t	link_bytes_per_usec;
	/*
	 * If CR is greater than or equal to this threshold,
	 * QPC's CC state is reset to its initial state.
	 */
	uint16_t	reset_cc_cr_th;
	/*
	 * The number of valid lsbits in CR and TR.
	 * Supported values include 10 through 14 to support 2^cr_width rate.
	 */
	uint8_t	cr_width;
	/* Lower end of random selection of quota_period. */
	uint8_t	quota_period_min;
	/* Upper end of random selection of quota_period. */
	uint8_t	quota_period_max;
	/*
	 * The absolute maximum possible quota_period,
	 * applicable when rate table for lower 24 levels is used.
	 */
	uint8_t	quota_period_abs_max;
	/* TR never goes below this level. */
	uint16_t	tr_lower_bound;
	/* Factor on probability threshold for adding 0.5 to CR randomly. */
	uint8_t	cr_prob_factor;
	/* Factor on probability threshold for adding 0.5 to TR randomly. */
	uint8_t	tr_prob_factor;
	/*
	 * Threshold to ensure fairness between requester and responder.
	 * If CR is less than the fairness threshold and a quota period has passed
	 * priority will be given to the path that did not last transfer data.
	 */
	uint16_t	fairness_cr_th;
	/* Log based rate reduction divider. */
	uint8_t	red_div;
	/* Threshold for rate reductions when CNPS received over last RTT. */
	uint8_t	cnp_ratio_th;
	/*
	 * Extended number of RTTS to wait, when there is no congestion,
	 * to start doubling the rate.
	 */
	uint16_t	exp_ai_rtts;
	/* Log based CR to CP ratio used in exponential increase. */
	uint8_t	exp_ai_cr_cp_ratio;
	/* Enable use of lowest 24 rate levels rate_table. */
	uint8_t	use_rate_table;
	/*
	 * Determines after how many congestion free RTTs to start
	 * updating CP to track CR.
	 */
	uint16_t	cp_exp_update_th;
	/* The threshold on congestion free RTTs above which AI can increase to 16. */
	uint16_t	high_exp_ai_rtts_th1;
	/* The threshold on congestion free RTTs above which AI can increase to 32. */
	uint16_t	high_exp_ai_rtts_th2;
	/*
	 * The number of congestion free RTTs above which
	 * reduction based on actual rate is enabled.
	 */
	uint16_t	actual_cr_cong_free_rtts_th;
	/*
	 * If rtts_with_cong is greater than 7 (severe congestion) and
	 * CR level post reduction is above this threshold,
	 * then TR is capped to 1.5 times CR..
	 */
	uint16_t	severe_cong_cr_th1;
	/*
	 * If rtts_with_cong is greater than 7 (severe congestion) and
	 * CR level post reduction is above this threshold,
	 * then TR is capped to 1.25 times CR..
	 */
	uint16_t	severe_cong_cr_th2;
	/*
	 * The maximum number of 64B that can be transmitted during RTT time,
	 * including all headers and Inter Packet Gap.
	 */
	uint32_t	link64B_per_rtt;
	/*
	 * The number of bytes to subtract from QPC.cc_bucket
	 * when an ack is scheduled.
	 */
	uint8_t	cc_ack_bytes;
	/*
	 * Enables reduction of CR, TR, and CP to init values when
	 * congestion free RTTs is greater than reduce2_init_cong_free_rtts_th.
	 */
	uint8_t	reduce_init_en;
	/*
	 * Minimum threshold value for number of congestion free RTTs before reducing
	 * to init values for CR, TR, and CP when reduce_init_en is enabled.
	 */
	uint16_t	reduce_init_cong_free_rtts_th;
	/* Enables random no reduction of CR. */
	uint8_t	random_no_red_en;
	/* Enables coarse correction to actual CR when actual RTT is longer than nominal. */
	uint8_t	actual_cr_shift_correction_en;
	/* Enables adjustment to refill quota. */
	uint8_t	quota_period_adjust_en;
	uint8_t	reserved[5];
} cmdq_modify_roce_cc_gen1_tlv_t, *pcmdq_modify_roce_cc_gen1_tlv_t;

/* creq_modify_roce_cc_resp (size:128b/16B) */

typedef struct creq_modify_roce_cc_resp {
	uint8_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define CREQ_MODIFY_ROCE_CC_RESP_TYPE_MASK	UINT32_C(0x3f)
	#define CREQ_MODIFY_ROCE_CC_RESP_TYPE_SFT	0
	/* QP Async Notification */
		#define CREQ_MODIFY_ROCE_CC_RESP_TYPE_QP_EVENT  UINT32_C(0x38)
		#define CREQ_MODIFY_ROCE_CC_RESP_TYPE_LAST	CREQ_MODIFY_ROCE_CC_RESP_TYPE_QP_EVENT
	/* Status of the response. */
	uint8_t	status;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	uint32_t	reserved32;
	uint8_t	v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define CREQ_MODIFY_ROCE_CC_RESP_V	UINT32_C(0x1)
	/* Event or command opcode. */
	uint8_t	event;
	/* Modify congestion control response. */
	#define CREQ_MODIFY_ROCE_CC_RESP_EVENT_MODIFY_ROCE_CC UINT32_C(0x8c)
	#define CREQ_MODIFY_ROCE_CC_RESP_EVENT_LAST	CREQ_MODIFY_ROCE_CC_RESP_EVENT_MODIFY_ROCE_CC
	uint8_t	reserved48[6];
} creq_modify_roce_cc_resp_t, *pcreq_modify_roce_cc_resp_t;

/******************************
 * cmdq_set_link_aggr_mode_cc *
 ******************************/


/* cmdq_set_link_aggr_mode_cc (size:320b/40B) */

typedef struct cmdq_set_link_aggr_mode_cc {
	/* Command opcode. */
	uint8_t	opcode;
	/* Set LAG mode. */
	#define CMDQ_SET_LINK_AGGR_MODE_OPCODE_SET_LINK_AGGR_MODE UINT32_C(0x8f)
	#define CMDQ_SET_LINK_AGGR_MODE_OPCODE_LAST		CMDQ_SET_LINK_AGGR_MODE_OPCODE_SET_LINK_AGGR_MODE
	/* Size of the command in 16-byte units. */
	uint8_t	cmd_size;
	/* Flags and attribs of the command. */
	uint16_t	flags;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* Size of the response buffer in 16-byte units. */
	uint8_t	resp_size;
	uint8_t	reserved8;
	/* Host address of the response. */
	uint64_t	resp_addr;
	/* Modify mask signifies the field that is requesting the change. */
	uint32_t	modify_mask;
	/* Enable Link aggregation. */
	#define CMDQ_SET_LINK_AGGR_MODE_MODIFY_MASK_AGGR_EN		UINT32_C(0x1)
	/* Bitmap of ports that are eligible to transmit RoCE traffic. */
	#define CMDQ_SET_LINK_AGGR_MODE_MODIFY_MASK_ACTIVE_PORT_MAP	UINT32_C(0x2)
	/* Bitmap of ports that are members of the RoCE LAG. */
	#define CMDQ_SET_LINK_AGGR_MODE_MODIFY_MASK_MEMBER_PORT_MAP	UINT32_C(0x4)
	/* Link aggregation mode being used. */
	#define CMDQ_SET_LINK_AGGR_MODE_MODIFY_MASK_AGGR_MODE	UINT32_C(0x8)
	/* Stat context ID for all the ports. */
	#define CMDQ_SET_LINK_AGGR_MODE_MODIFY_MASK_STAT_CTX_ID	UINT32_C(0x10)
	uint8_t	aggr_enable;
	/* Enable Link aggregation. */
	#define CMDQ_SET_LINK_AGGR_MODE_AGGR_ENABLE	UINT32_C(0x1)
	/* rsvd1 is 7 b */
	#define CMDQ_SET_LINK_AGGR_MODE_RSVD1_MASK	UINT32_C(0xfe)
	#define CMDQ_SET_LINK_AGGR_MODE_RSVD1_SFT	1
	uint8_t	active_port_map;
	/* Bitmap of ports that are eligible to transmit RoCE traffic. */
	#define CMDQ_SET_LINK_AGGR_MODE_ACTIVE_PORT_MAP_MASK UINT32_C(0xf)
	#define CMDQ_SET_LINK_AGGR_MODE_ACTIVE_PORT_MAP_SFT 0
	/* rsvd2 is 4 b */
	#define CMDQ_SET_LINK_AGGR_MODE_RSVD2_MASK	UINT32_C(0xf0)
	#define CMDQ_SET_LINK_AGGR_MODE_RSVD2_SFT	4
	/* Bitmap of ports that are members of the RoCE LAG. */
	uint8_t	member_port_map;
	/* Link aggregation mode being used. */
	uint8_t	link_aggr_mode;
	/* active active mode. */
	#define CMDQ_SET_LINK_AGGR_MODE_AGGR_MODE_ACTIVE_ACTIVE UINT32_C(0x1)
	/* active backup mode. */
	#define CMDQ_SET_LINK_AGGR_MODE_AGGR_MODE_ACTIVE_BACKUP UINT32_C(0x2)
	/* Balance XOR mode. */
	#define CMDQ_SET_LINK_AGGR_MODE_AGGR_MODE_BALANCE_XOR   UINT32_C(0x3)
	/* 802.3AD mode. */
	#define CMDQ_SET_LINK_AGGR_MODE_AGGR_MODE_802_3_AD	UINT32_C(0x4)
	#define CMDQ_SET_LINK_AGGR_MODE_AGGR_MODE_LAST	CMDQ_SET_LINK_AGGR_MODE_AGGR_MODE_802_3_AD
	/* Stat context IDs for all 4 ports. */
	uint16_t	stat_ctx_id[4];
	uint64_t	rsvd1;
} cmdq_set_link_aggr_mode_cc_t, *pcmdq_set_link_aggr_mode_cc_t;

/* creq_set_link_aggr_mode_resources_resp (size:128b/16B) */

typedef struct creq_set_link_aggr_mode_resources_resp {
	uint8_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define CREQ_SET_LINK_AGGR_MODE_RESP_TYPE_MASK	UINT32_C(0x3f)
	#define CREQ_SET_LINK_AGGR_MODE_RESP_TYPE_SFT	0
	/* QP Async Notification */
		#define CREQ_SET_LINK_AGGR_MODE_RESP_TYPE_QP_EVENT  UINT32_C(0x38)
		#define CREQ_SET_LINK_AGGR_MODE_RESP_TYPE_LAST	CREQ_SET_LINK_AGGR_MODE_RESP_TYPE_QP_EVENT
	/* Status of the response. */
	uint8_t	status;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	uint32_t	reserved32;
	uint8_t	v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define CREQ_SET_LINK_AGGR_MODE_RESP_V	UINT32_C(0x1)
	/* Event or command opcode. */
	uint8_t	event;
	/* Set LAG mode. */
	#define CREQ_SET_LINK_AGGR_MODE_RESP_EVENT_SET_LINK_AGGR_MODE UINT32_C(0x8f)
	#define CREQ_SET_LINK_AGGR_MODE_RESP_EVENT_LAST		CREQ_SET_LINK_AGGR_MODE_RESP_EVENT_SET_LINK_AGGR_MODE
	uint8_t	reserved48[6];
} creq_set_link_aggr_mode_resources_resp_t, *pcreq_set_link_aggr_mode_resources_resp_t;

/* Send a request from VF to pass a command to the PF. VF HSI is suspended. */
/* cmdq_vf_backchannel_request (size:256b/32B) */

typedef struct cmdq_vf_backchannel_request {
	/* Command opcode. */
	uint8_t	opcode;
	/* Send a request from VF to pass a command to the PF. VF HSI is suspended until the PF returns the response */
	#define CMDQ_VF_BACKCHANNEL_REQUEST_OPCODE_VF_BACKCHANNEL_REQUEST UINT32_C(0x86)
	#define CMDQ_VF_BACKCHANNEL_REQUEST_OPCODE_LAST		CMDQ_VF_BACKCHANNEL_REQUEST_OPCODE_VF_BACKCHANNEL_REQUEST
	/* Size of the command in 16-byte units. */
	uint8_t	cmd_size;
	/* Flags and attribs of the command. */
	uint16_t	flags;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* Size of the response buffer in 16-byte units. */
	uint8_t	resp_size;
	uint8_t	reserved8;
	/* Host address of the response. */
	uint64_t	resp_addr;
	/* Address of command request structure in VF space */
	uint64_t	command_addr;
	/* Command request length (up to 4K). An optional address of the extended response buffer should be provided in the request */
	uint16_t	command_length;
	uint8_t	unused_0[6];
} cmdq_vf_backchannel_request_t, *pcmdq_vf_backchannel_request_t;

/* Read VF memory (primarily to get the backchannel request blob). */
/* cmdq_read_vf_memory (size:256b/32B) */

typedef struct cmdq_read_vf_memory {
	/* Command opcode. */
	uint8_t	opcode;
	/* Read VF memory (primarily to get the backchannel request blob). Can only be issued from a PF. */
	#define CMDQ_READ_VF_MEMORY_OPCODE_READ_VF_MEMORY UINT32_C(0x87)
	#define CMDQ_READ_VF_MEMORY_OPCODE_LAST	CMDQ_READ_VF_MEMORY_OPCODE_READ_VF_MEMORY
	/* Size of the command in 16-byte units. */
	uint8_t	cmd_size;
	/* Flags and attribs of the command. */
	uint16_t	flags;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* Size of the response buffer in 16-byte units. */
	uint8_t	resp_size;
	uint8_t	reserved8;
	/* Host address of the response. */
	uint64_t	resp_addr;
	/* Address of memory in VF space to read */
	uint64_t	addr;
	/* VF id, as provided in 0xC0 VF request notification */
	uint16_t	vf_id;
	/* Length to read, up to 4K */
	uint16_t	length;
	uint32_t	unused_0;
} cmdq_read_vf_memory_t, *pcmdq_read_vf_memory_t;

/* Write VF memory (primarily to put the backchannel response blob). */
/* cmdq_complete_vf_request (size:320b/40B) */

typedef struct cmdq_complete_vf_request {
	/* Command opcode. */
	uint8_t	opcode;
	/* Write VF memory (primarily to put the backchannel response blob), and reenable VF HSI (post a CAG completion to it). Can only be issued from a PF. */
	#define CMDQ_COMPLETE_VF_REQUEST_OPCODE_COMPLETE_VF_REQUEST UINT32_C(0x88)
	#define CMDQ_COMPLETE_VF_REQUEST_OPCODE_LAST		CMDQ_COMPLETE_VF_REQUEST_OPCODE_COMPLETE_VF_REQUEST
	/* Size of the command in 16-byte units. */
	uint8_t	cmd_size;
	/* Flags and attribs of the command. */
	uint16_t	flags;
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	/* Size of the response buffer in 16-byte units. */
	uint8_t	resp_size;
	uint8_t	reserved8;
	/* Host address of the response. */
	uint64_t	resp_addr;
	/* Optional address of extended response in VF space to write. Length is in resp_size in 16 byte units. */
	uint64_t	addr;
	/* Completion misc field to VF CREQ */
	uint32_t	vf_misc;
	/* VF id, as provided in 0xC0 VF request notification */
	uint16_t	vf_id;
	/* Completion cookie for the VF command, goes to VF CREQ */
	uint16_t	vf_cookie;
	/* Completion status for the VF command, goes to VF CREQ */
	uint8_t	vf_status;
	uint8_t	unused_0[3];
	uint32_t	unused_1;
} cmdq_complete_vf_request_t, *pcmdq_complete_vf_request_t;

/* RoCE function async event notifications. */
/* creq_func_event (size:128b/16B) */

typedef struct creq_func_event {
	uint8_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define CREQ_FUNC_EVENT_TYPE_MASK	UINT32_C(0x3f)
	#define CREQ_FUNC_EVENT_TYPE_SFT	0
	/* Function Async Notification */
		#define CREQ_FUNC_EVENT_TYPE_FUNC_EVENT  UINT32_C(0x3a)
		#define CREQ_FUNC_EVENT_TYPE_LAST	CREQ_FUNC_EVENT_TYPE_FUNC_EVENT
	uint8_t	reserved56[7];
	uint8_t	v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define CREQ_FUNC_EVENT_V	UINT32_C(0x1)
	/*
	 * This value defines what type of async event has occurred
	 * on the function.
	 */
	uint8_t	event;
	/*
	 * Invalid PBL or PCIE UR response occurred
	 * in SQ WQE or IRRQ read access.
	 */
	#define CREQ_FUNC_EVENT_EVENT_TX_WQE_ERROR	UINT32_C(0x1)
	/*
	 * Invalid PBL or PCIE UR response occurred
	 * during data read access.
	 */
	#define CREQ_FUNC_EVENT_EVENT_TX_DATA_ERROR	UINT32_C(0x2)
	/*
	 * Invalid PBL or PCIE UR response occurred
	 * in RQ/SRQ WQE or ORRQ read access.
	 */
	#define CREQ_FUNC_EVENT_EVENT_RX_WQE_ERROR	UINT32_C(0x3)
	/* Invalid PBL occurred during data write access. */
	#define CREQ_FUNC_EVENT_EVENT_RX_DATA_ERROR	UINT32_C(0x4)
	/* Invalid PBL occurred during CQ write access. */
	#define CREQ_FUNC_EVENT_EVENT_CQ_ERROR	UINT32_C(0x5)
	/*
	 * Invalid PBL or PCIE UR response occurred in TQM
	 * read access.
	 */
	#define CREQ_FUNC_EVENT_EVENT_TQM_ERROR	UINT32_C(0x6)
	/* PCIE UR response occurred in CFC read access. */
	#define CREQ_FUNC_EVENT_EVENT_CFCQ_ERROR	UINT32_C(0x7)
	/* PCIE UR response occurred in CFC read access. */
	#define CREQ_FUNC_EVENT_EVENT_CFCS_ERROR	UINT32_C(0x8)
	/* PCIE UR response occurred in CFC read access. */
	#define CREQ_FUNC_EVENT_EVENT_CFCC_ERROR	UINT32_C(0x9)
	/* PCIE UR response occurred in CFC read access. */
	#define CREQ_FUNC_EVENT_EVENT_CFCM_ERROR	UINT32_C(0xa)
	/*
	 * Invalid PBL or
	 * PCIE UR response
	 * occurred on timer read access.
	 */
	#define CREQ_FUNC_EVENT_EVENT_TIM_ERROR	UINT32_C(0xb)
	/* A VF sent a backchannel command request */
	#define CREQ_FUNC_EVENT_EVENT_VF_COMM_REQUEST	UINT32_C(0x80)
	/* Communication resource (QPC, CQ, SRQ, MRW) exhausted, and resource array extension is enabled */
	#define CREQ_FUNC_EVENT_EVENT_RESOURCE_EXHAUSTED UINT32_C(0x81)
	#define CREQ_FUNC_EVENT_EVENT_LAST		CREQ_FUNC_EVENT_EVENT_RESOURCE_EXHAUSTED
	uint8_t	reserved48[6];
} creq_func_event_t, *pcreq_func_event_t;

/* RoCE slowpath command completion events. */
/* creq_qp_event (size:128b/16B) */

typedef struct creq_qp_event {
	uint8_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define CREQ_QP_EVENT_TYPE_MASK	UINT32_C(0x3f)
	#define CREQ_QP_EVENT_TYPE_SFT	0
	/* QP Async Notification */
		#define CREQ_QP_EVENT_TYPE_QP_EVENT  UINT32_C(0x38)
		#define CREQ_QP_EVENT_TYPE_LAST	CREQ_QP_EVENT_TYPE_QP_EVENT
	/* Status of the response. */
	uint8_t	status;
	/* Success. */
	#define CREQ_QP_EVENT_STATUS_SUCCESS	UINT32_C(0x0)
	/* Fail. */
	#define CREQ_QP_EVENT_STATUS_FAIL		UINT32_C(0x1)
	/* Resources. */
	#define CREQ_QP_EVENT_STATUS_RESOURCES	UINT32_C(0x2)
	/* Invalid command. */
	#define CREQ_QP_EVENT_STATUS_INVALID_CMD	UINT32_C(0x3)
	/* Not implemented. */
	#define CREQ_QP_EVENT_STATUS_NOT_IMPLEMENTED   UINT32_C(0x4)
	/* Invalid parameter. */
	#define CREQ_QP_EVENT_STATUS_INVALID_PARAMETER UINT32_C(0x5)
	/* Hardware operation failed. */
	#define CREQ_QP_EVENT_STATUS_HARDWARE_ERROR	UINT32_C(0x6)
	/* Firmware operation failed due to internal error. */
	#define CREQ_QP_EVENT_STATUS_INTERNAL_ERROR	UINT32_C(0x7)
	#define CREQ_QP_EVENT_STATUS_LAST		CREQ_QP_EVENT_STATUS_INTERNAL_ERROR
	/* Driver supplied handle to associate the command and the response. */
	uint16_t	cookie;
	uint32_t	reserved32;
	uint8_t	v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define CREQ_QP_EVENT_V	UINT32_C(0x1)
	/* Event or command opcode. */
	uint8_t	event;
	/* Create QP command response. */
	#define CREQ_QP_EVENT_EVENT_CREATE_QP		UINT32_C(0x1)
	/* Destroy QP command response. */
	#define CREQ_QP_EVENT_EVENT_DESTROY_QP		UINT32_C(0x2)
	/* Modify QP command response. */
	#define CREQ_QP_EVENT_EVENT_MODIFY_QP		UINT32_C(0x3)
	/* Query QP command response. */
	#define CREQ_QP_EVENT_EVENT_QUERY_QP		UINT32_C(0x4)
	/* Create SRQ command response. */
	#define CREQ_QP_EVENT_EVENT_CREATE_SRQ		UINT32_C(0x5)
	/* Destroy SRQ command response. */
	#define CREQ_QP_EVENT_EVENT_DESTROY_SRQ	UINT32_C(0x6)
	/* Query SRQ command response. */
	#define CREQ_QP_EVENT_EVENT_QUERY_SRQ		UINT32_C(0x8)
	/* Create CQ command response. */
	#define CREQ_QP_EVENT_EVENT_CREATE_CQ		UINT32_C(0x9)
	/* Destroy CQ command response. */
	#define CREQ_QP_EVENT_EVENT_DESTROY_CQ		UINT32_C(0xa)
	/* Resize CQ command response. */
	#define CREQ_QP_EVENT_EVENT_RESIZE_CQ		UINT32_C(0xc)
	/* Allocate MRW command response. */
	#define CREQ_QP_EVENT_EVENT_ALLOCATE_MRW	UINT32_C(0xd)
	/* De-allocate key command response. */
	#define CREQ_QP_EVENT_EVENT_DEALLOCATE_KEY	UINT32_C(0xe)
	/* Register MR command response. */
	#define CREQ_QP_EVENT_EVENT_REGISTER_MR	UINT32_C(0xf)
	/* Deregister MR command response. */
	#define CREQ_QP_EVENT_EVENT_DEREGISTER_MR	UINT32_C(0x10)
	/* Add GID command response. */
	#define CREQ_QP_EVENT_EVENT_ADD_GID		UINT32_C(0x11)
	/* Delete GID command response. */
	#define CREQ_QP_EVENT_EVENT_DELETE_GID		UINT32_C(0x12)
	/* Modify GID command response. */
	#define CREQ_QP_EVENT_EVENT_MODIFY_GID		UINT32_C(0x17)
	/* Query GID command response. */
	#define CREQ_QP_EVENT_EVENT_QUERY_GID		UINT32_C(0x18)
	/* Create QP1 command response. */
	#define CREQ_QP_EVENT_EVENT_CREATE_QP1		UINT32_C(0x13)
	/* Destroy QP1 command response. */
	#define CREQ_QP_EVENT_EVENT_DESTROY_QP1	UINT32_C(0x14)
	/* Create AH command response. */
	#define CREQ_QP_EVENT_EVENT_CREATE_AH		UINT32_C(0x15)
	/* Destroy AH command response. */
	#define CREQ_QP_EVENT_EVENT_DESTROY_AH		UINT32_C(0x16)
	/* Initialize firmware command response. */
	#define CREQ_QP_EVENT_EVENT_INITIALIZE_FW	UINT32_C(0x80)
	/* De-initialize firmware command response. */
	#define CREQ_QP_EVENT_EVENT_DEINITIALIZE_FW	UINT32_C(0x81)
	/* Stop PF command response. */
	#define CREQ_QP_EVENT_EVENT_STOP_FUNC		UINT32_C(0x82)
	/* Query info PF command response. */
	#define CREQ_QP_EVENT_EVENT_QUERY_FUNC		UINT32_C(0x83)
	/* Set function resources command response. */
	#define CREQ_QP_EVENT_EVENT_SET_FUNC_RESOURCES	UINT32_C(0x84)
	/* Read the current state of any internal resource context. Can only be issued from a PF. */
	#define CREQ_QP_EVENT_EVENT_READ_CONTEXT	UINT32_C(0x85)
	/* Map TC to COS response. */
	#define CREQ_QP_EVENT_EVENT_MAP_TC_TO_COS	UINT32_C(0x8a)
	/* Query firmware and interface version response. */
	#define CREQ_QP_EVENT_EVENT_QUERY_VERSION	UINT32_C(0x8b)
	/* Modify congestion control response. */
	#define CREQ_QP_EVENT_EVENT_MODIFY_CC		UINT32_C(0x8c)
	/* Query congestion control response. */
	#define CREQ_QP_EVENT_EVENT_QUERY_CC		UINT32_C(0x8d)
	/* Query RoCE statistics. */
	#define CREQ_QP_EVENT_EVENT_QUERY_ROCE_STATS	UINT32_C(0x8e)
	/* Set LAG mode. */
	#define CREQ_QP_EVENT_EVENT_SET_LINK_AGGR_MODE	UINT32_C(0x8f)
	/*
	 * Query QP for a PF other than the requesting PF. Also can query for more
	 * than one QP.
	 */
	#define CREQ_QP_EVENT_EVENT_QUERY_QP_EXTEND	UINT32_C(0x91)
	/* QP error notification event. */
	#define CREQ_QP_EVENT_EVENT_QP_ERROR_NOTIFICATION UINT32_C(0xc0)
	/* CQ error notification event. */
	#define CREQ_QP_EVENT_EVENT_CQ_ERROR_NOTIFICATION UINT32_C(0xc1)
	#define CREQ_QP_EVENT_EVENT_LAST		CREQ_QP_EVENT_EVENT_CQ_ERROR_NOTIFICATION
	uint8_t	reserved48[6];
} creq_qp_event_t, *pcreq_qp_event_t;

/* QP error notification event. */
/* creq_qp_error_notification (size:128b/16B) */

typedef struct creq_qp_error_notification {
	uint8_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define CREQ_QP_ERROR_NOTIFICATION_TYPE_MASK	UINT32_C(0x3f)
	#define CREQ_QP_ERROR_NOTIFICATION_TYPE_SFT	0
	/* QP Async Notification */
		#define CREQ_QP_ERROR_NOTIFICATION_TYPE_QP_EVENT  UINT32_C(0x38)
		#define CREQ_QP_ERROR_NOTIFICATION_TYPE_LAST	CREQ_QP_ERROR_NOTIFICATION_TYPE_QP_EVENT
	/* Status of the response. */
	uint8_t	status;
	/* requestor slow path state */
	uint8_t	req_slow_path_state;
	/* requestor error reason */
	uint8_t	req_err_state_reason;
	/* QP context id */
	uint32_t	xid;
	uint8_t	v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define CREQ_QP_ERROR_NOTIFICATION_V	UINT32_C(0x1)
	/* Event or command opcode. */
	uint8_t	event;
	/* QP error notification event. */
	#define CREQ_QP_ERROR_NOTIFICATION_EVENT_QP_ERROR_NOTIFICATION UINT32_C(0xc0)
	#define CREQ_QP_ERROR_NOTIFICATION_EVENT_LAST		CREQ_QP_ERROR_NOTIFICATION_EVENT_QP_ERROR_NOTIFICATION
	/* responder slow path state */
	uint8_t	res_slow_path_state;
	uint8_t	res_err_state_reason;
	/*
	 * Final SQ Consumer Index value. Any additional SQ WQEs will
	 * have to be completed by the user provider.
	 */
	uint16_t	sq_cons_idx;
	/*
	 * Final RQ Consumer Index value. Any additional RQ WQEs will
	 * have to be completed by the user provider.
	 */
	uint16_t	rq_cons_idx;
} creq_qp_error_notification_t, *pcreq_qp_error_notification_t;

/* CQ error notification event. */
/* creq_cq_error_notification (size:128b/16B) */

typedef struct creq_cq_error_notification {
	uint8_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units. Even values indicate 16B
	 * records. Odd values indicate 32B
	 * records.
	 */
	#define CREQ_CQ_ERROR_NOTIFICATION_TYPE_MASK	UINT32_C(0x3f)
	#define CREQ_CQ_ERROR_NOTIFICATION_TYPE_SFT	0
	/* CQ Async Notification */
		#define CREQ_CQ_ERROR_NOTIFICATION_TYPE_CQ_EVENT  UINT32_C(0x38)
		#define CREQ_CQ_ERROR_NOTIFICATION_TYPE_LAST	CREQ_CQ_ERROR_NOTIFICATION_TYPE_CQ_EVENT
	/* Status of the response. */
	uint8_t	status;
	/* CQ error reason code. */
	uint8_t	cq_err_reason;
	/* Requester completion error for invalid CQ state. */
	#define CREQ_CQ_ERROR_NOTIFICATION_CQ_ERR_REASON_REQ_CQ_INVALID_ERROR  UINT32_C(0x1)
	/* Requester completion error for CQ overflow. */
	#define CREQ_CQ_ERROR_NOTIFICATION_CQ_ERR_REASON_REQ_CQ_OVERFLOW_ERROR UINT32_C(0x2)
	/* Attempt to load CQ context resulted in error. */
	#define CREQ_CQ_ERROR_NOTIFICATION_CQ_ERR_REASON_REQ_CQ_LOAD_ERROR	UINT32_C(0x3)
	/* Responder completion error for invalid CQ state. */
	#define CREQ_CQ_ERROR_NOTIFICATION_CQ_ERR_REASON_RES_CQ_INVALID_ERROR  UINT32_C(0x4)
	/* Responder completion error for CQ overflow. */
	#define CREQ_CQ_ERROR_NOTIFICATION_CQ_ERR_REASON_RES_CQ_OVERFLOW_ERROR UINT32_C(0x5)
	/* Attempt to load CQ context resulted in error. */
	#define CREQ_CQ_ERROR_NOTIFICATION_CQ_ERR_REASON_RES_CQ_LOAD_ERROR	UINT32_C(0x6)
	#define CREQ_CQ_ERROR_NOTIFICATION_CQ_ERR_REASON_LAST		CREQ_CQ_ERROR_NOTIFICATION_CQ_ERR_REASON_RES_CQ_LOAD_ERROR
	uint8_t	reserved8;
	/* CQ context id */
	uint32_t	xid;
	uint8_t	v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue. The even passes
	 * will write 1. The odd passes will write 0.
	 */
	#define CREQ_CQ_ERROR_NOTIFICATION_V	UINT32_C(0x1)
	/* Event or command opcode. */
	uint8_t	event;
	/* CQ error notification event. */
	#define CREQ_CQ_ERROR_NOTIFICATION_EVENT_CQ_ERROR_NOTIFICATION UINT32_C(0xc1)
	#define CREQ_CQ_ERROR_NOTIFICATION_EVENT_LAST		CREQ_CQ_ERROR_NOTIFICATION_EVENT_CQ_ERROR_NOTIFICATION
	uint8_t	reserved48[6];
} creq_cq_error_notification_t, *pcreq_cq_error_notification_t;

/* sq_base (size:64b/8B) */

typedef struct sq_base {
	/* This field defines the type of SQ WQE. */
	uint8_t	wqe_type;
	/* Send */
	#define SQ_BASE_WQE_TYPE_SEND	UINT32_C(0x0)
	/*
	 * Send with Immediate
	 *
	 * Allowed only on reliable connection (RC) and
	 * unreliable datagram (UD) SQs.
	 */
	#define SQ_BASE_WQE_TYPE_SEND_W_IMMEAD  UINT32_C(0x1)
	/*
	 * Send with Invalidate.
	 *
	 * Allowed only on reliable connection (RC) SQs.
	 */
	#define SQ_BASE_WQE_TYPE_SEND_W_INVALID UINT32_C(0x2)
	/*
	 * RDMA Write.
	 *
	 * Allowed only on reliable connection (RC) SQs.
	 */
	#define SQ_BASE_WQE_TYPE_WRITE_WQE	UINT32_C(0x4)
	/*
	 * RDMA Write with Immediate.
	 *
	 * Allowed only on reliable connection (RC) SQs.
	 */
	#define SQ_BASE_WQE_TYPE_WRITE_W_IMMEAD UINT32_C(0x5)
	/*
	 * RDMA Read.
	 *
	 * Allowed only on reliable connection (RC) SQs.
	 */
	#define SQ_BASE_WQE_TYPE_READ_WQE	UINT32_C(0x6)
	/*
	 * Atomic Compare/Swap.
	 *
	 * Allowed only on reliable connection (RC) SQs.
	 */
	#define SQ_BASE_WQE_TYPE_ATOMIC_CS	UINT32_C(0x8)
	/*
	 * Atomic Fetch/Add.
	 *
	 * Allowed only on reliable connection (RC) SQs.
	 */
	#define SQ_BASE_WQE_TYPE_ATOMIC_FA	UINT32_C(0xb)
	/*
	 * Local Invalidate.
	 *
	 * Allowed only on reliable connection (RC) SQs.
	 */
	#define SQ_BASE_WQE_TYPE_LOCAL_INVALID  UINT32_C(0xc)
	/*
	 * FR-PMR (Fast Register Physical Memory Region)
	 *
	 * Allowed only on reliable connection (RC) SQs.
	 */
	#define SQ_BASE_WQE_TYPE_FR_PMR	UINT32_C(0xd)
	/*
	 * Memory Bind
	 *
	 * Allowed only on reliable connection (RC) SQs.
	 */
	#define SQ_BASE_WQE_TYPE_BIND	UINT32_C(0xe)
	/*
	 * FR-PPMR (Fast Register Proxy Physical Memory Region)
	 *
	 * Allowed only on reliable connection (RC) SQs.
	 */
	#define SQ_BASE_WQE_TYPE_FR_PPMR	UINT32_C(0xf)
	#define SQ_BASE_WQE_TYPE_LAST	SQ_BASE_WQE_TYPE_FR_PPMR
	uint8_t	unused_0[7];
} sq_base_t, *psq_base_t;

/* sq_sge (size:128b/16B) */

typedef struct sq_sge {
	/*
	 * The virtual address in local memory or a physical address
	 * when l_key value is a reserved value of a physical address.
	 * Driver configures this value in the chip and the chip compares
	 * l_key in SGEs with that reserved value, if equal it access
	 * the physical address specified. The chip however MUST verify
	 * that the QP allows the use reserved key.
	 */
	uint64_t	va_or_pa;
	/*
	 * Local Key associated with this registered MR; The 24 msb of
	 * the key used to index the MRW Table and the 8 lsb are compared
	 * with the 8 bits key part stored in the MRWC. The PBL in the
	 * MRW Context is used to translate the above VA to physical
	 * address.
	 */
	uint32_t	l_key;
	/*
	 * Size of SGE in bytes; Based on page size of the system the
	 * chip knows how many entries are in the PBL
	 */
	uint32_t	size;
} sq_sge_t, *psq_sge_t;

/* sq_psn_search (size:64b/8B) */

typedef struct sq_psn_search {
	/* Start PSN. */
	uint32_t	opcode_start_psn;
	/* Start PSN. */
	#define SQ_PSN_SEARCH_START_PSN_MASK UINT32_C(0xffffff)
	#define SQ_PSN_SEARCH_START_PSN_SFT 0
	/* The opcodes are software defined. */
	#define SQ_PSN_SEARCH_OPCODE_MASK   UINT32_C(0xff000000)
	#define SQ_PSN_SEARCH_OPCODE_SFT	24
	uint32_t	flags_next_psn;
	/* Next PSN. Equal to the start PSN of the next WQE. */
	#define SQ_PSN_SEARCH_NEXT_PSN_MASK UINT32_C(0xffffff)
	#define SQ_PSN_SEARCH_NEXT_PSN_SFT 0
	/* Opcode specific flags. */
	#define SQ_PSN_SEARCH_FLAGS_MASK   UINT32_C(0xff000000)
	#define SQ_PSN_SEARCH_FLAGS_SFT	24
} sq_psn_search_t, *psq_psn_search_t;

/* This PSN table structure is used only on devices where variable size WQEs are supported. */
/* sq_psn_search_ext (size:128b/16B) */

typedef struct sq_psn_search_ext {
	/* Start PSN. */
	uint32_t	opcode_start_psn;
	/* Start PSN. */
	#define SQ_PSN_SEARCH_EXT_START_PSN_MASK UINT32_C(0xffffff)
	#define SQ_PSN_SEARCH_EXT_START_PSN_SFT 0
	/* The opcodes are software defined. */
	#define SQ_PSN_SEARCH_EXT_OPCODE_MASK   UINT32_C(0xff000000)
	#define SQ_PSN_SEARCH_EXT_OPCODE_SFT	24
	uint32_t	flags_next_psn;
	/* Next PSN. Equal to the start PSN of the next WQE. */
	#define SQ_PSN_SEARCH_EXT_NEXT_PSN_MASK UINT32_C(0xffffff)
	#define SQ_PSN_SEARCH_EXT_NEXT_PSN_SFT 0
	/* Opcode specific flags. */
	#define SQ_PSN_SEARCH_EXT_FLAGS_MASK   UINT32_C(0xff000000)
	#define SQ_PSN_SEARCH_EXT_FLAGS_SFT	24
	/*
	 * This field is used only when variable sized WQEs are being used.
	 * This indicates the starting slot index of the corresponding WQE.
	 */
	uint16_t	start_slot_idx;
	/* reserved16 is 16 b */
	uint16_t	reserved16;
	/* reserved32 is 32 b */
	uint32_t	reserved32;
} sq_psn_search_ext_t, *psq_psn_search_ext_t;

/* Send SQ WQE */
/* sq_send (size:1024b/128B) */

typedef struct sq_send {
	/* This field defines the type of SQ WQE. */
	uint8_t	wqe_type;
	/* Send */
	#define SQ_SEND_WQE_TYPE_SEND	UINT32_C(0x0)
	/*
	 * Send with Immediate
	 *
	 * Allowed only on reliable connection (RC) and
	 * unreliable datagram (UD) SQs.
	 */
	#define SQ_SEND_WQE_TYPE_SEND_W_IMMEAD  UINT32_C(0x1)
	/*
	 * Send with Invalidate.
	 *
	 * Allowed only on reliable connection (RC) SQs.
	 */
	#define SQ_SEND_WQE_TYPE_SEND_W_INVALID UINT32_C(0x2)
	#define SQ_SEND_WQE_TYPE_LAST	SQ_SEND_WQE_TYPE_SEND_W_INVALID
	uint8_t	flags;
	#define SQ_SEND_FLAGS_INLINE_SE_UC_FENCE_RD_OR_ATOMIC_FENCE_SIGNAL_COMP_MASK		UINT32_C(0xff)
	#define SQ_SEND_FLAGS_INLINE_SE_UC_FENCE_RD_OR_ATOMIC_FENCE_SIGNAL_COMP_SFT			0
	/*
	 * Set if completion signaling is requested. If this bit is
	 * 0, and the SQ is configured to support Unsignaled completion
	 * the controller should not generate a CQE unless there was
	 * an error. This refers to the CQE on the sender side. (The se
	 * flag refers to the receiver side).
	 */
	#define SQ_SEND_FLAGS_SIGNAL_COMP								UINT32_C(0x1)
	/*
	 * Indication to complete all previous RDMA Read or Atomic WQEs
	 * on the SQ before executing this WQE.
	 *
	 * This flag must be zero for a UD send.
	 */
	#define SQ_SEND_FLAGS_RD_OR_ATOMIC_FENCE							UINT32_C(0x2)
	/*
	 * For local invalidate request. Indication to complete all
	 * previous SQ's WQEs before executing this WQE.
	 *
	 * This flag must be zero for a UD send.
	 */
	#define SQ_SEND_FLAGS_UC_FENCE								UINT32_C(0x4)
	/*
	 * Solicit event flag. Indication sent in BTH header to the
	 * receiver to generate a Completion Event Notification, i.e.
	 * CNQE. This bit should be set only in the last (or only) packet
	 * of the message.
	 */
	#define SQ_SEND_FLAGS_SE									UINT32_C(0x8)
	/*
	 * Indicate that inline data is posted to the SQ in the data
	 * area of this WQE.
	 */
	#define SQ_SEND_FLAGS_INLINE								UINT32_C(0x10)
	/*
	 * If set to 1, then the timestamp from the WQE is used. If
	 * cleared to 0, then TWE provides the timestamp.
	 */
	#define SQ_SEND_FLAGS_WQE_TS_EN								UINT32_C(0x20)
	/*
	 * When set to '1', this operation will cause a trace capture in
	 * each block it passes through.
	 */
	#define SQ_SEND_FLAGS_DEBUG_TRACE								UINT32_C(0x40)
	/*
	 * The number of 16 bytes chunks of data including this first
	 * word of the request that are a valid part of the request. The
	 * valid 16 bytes units other than the WQE structure can be
	 * SGEs (Scatter Gather Elements) OR inline data.
	 *
	 * While this field defines the valid WQE size.  The actual
	 * total WQE size is always 128B.
	 */
	uint8_t	wqe_size;
	uint8_t	reserved8_1;
	/*
	 * Either invalidate key (R_Key of the remote host) that will
	 * be send with IETH (Invalidate ETH) if wqe_type is of Send
	 * with Invalidate, or immediate value that will be sent with
	 * ImmDt header if wqe_type is Send with Immediate.
	 */
	uint32_t	inv_key_or_imm_data;
	/* This field represents a 32-bit total data length, in bytes. */
	uint32_t	length;
	/*
	 * When in the SQ of a UD QP, indicates the q_key to be used in
	 * the transmitted packet.  However, if the most significant bit
	 * of this field is set, then the q_key will be taken from QP
	 * context, rather than from this field.
	 *
	 * When in the SQ of a non-UD QP, this field is reserved and
	 * should be filled with zeros.
	 */
	uint32_t	q_key;
	/*
	 * When in the SQ of a UD QP, indicates the destination QP to be
	 * used in the transmitted packet.
	 *
	 * When in the SQ of a non-UD QP, this field is reserved and
	 * should be filled with zeros.
	 */
	uint32_t	dst_qp;
	#define SQ_SEND_DST_QP_MASK UINT32_C(0xffffff)
	#define SQ_SEND_DST_QP_SFT 0
	uint32_t	avid;
	/*
	 * If the serv_type is 'UD', then this field supplies the AVID
	 * (Address Vector ID).
	 */
	#define SQ_SEND_AVID_MASK UINT32_C(0xfffff)
	#define SQ_SEND_AVID_SFT 0
	uint32_t	reserved32;
	uint32_t	timestamp;
	/*
	 * This field specifies a 24-bit timestamp that can be passed
	 * down the TX path and optionally logged in the TXP timestamp
	 * histogram.
	 */
	#define SQ_SEND_TIMESTAMP_MASK UINT32_C(0xffffff)
	#define SQ_SEND_TIMESTAMP_SFT 0
	/*
	 * When inline=0, then this area is filled with from 1 to 6
	 * SGEs based on the wqe_size field.
	 *
	 * When inline=1, this area is filled with payload data for the
	 * send based on the length_or_AVID field.  Bits [7:0] of word 0
	 * hold the first byte to go out on the wire.
	 */
	uint32_t	data[24];
} sq_send_t, *psq_send_t;

/* Send SQ WQE header. */
/* sq_send_hdr (size:256b/32B) */

typedef struct sq_send_hdr {
	/* This field defines the type of SQ WQE. */
	uint8_t	wqe_type;
	/* Send */
	#define SQ_SEND_HDR_WQE_TYPE_SEND	UINT32_C(0x0)
	/*
	 * Send with Immediate
	 *
	 * Allowed only on reliable connection (RC) and
	 * unreliable datagram (UD) SQs.
	 */
	#define SQ_SEND_HDR_WQE_TYPE_SEND_W_IMMEAD  UINT32_C(0x1)
	/*
	 * Send with Invalidate.
	 *
	 * Allowed only on reliable connection (RC) SQs.
	 */
	#define SQ_SEND_HDR_WQE_TYPE_SEND_W_INVALID UINT32_C(0x2)
	#define SQ_SEND_HDR_WQE_TYPE_LAST	SQ_SEND_HDR_WQE_TYPE_SEND_W_INVALID
	uint8_t	flags;
	#define SQ_SEND_HDR_FLAGS_INLINE_SE_UC_FENCE_RD_OR_ATOMIC_FENCE_SIGNAL_COMP_MASK		UINT32_C(0xff)
	#define SQ_SEND_HDR_FLAGS_INLINE_SE_UC_FENCE_RD_OR_ATOMIC_FENCE_SIGNAL_COMP_SFT			0
	/*
	 * Set if completion signaling is requested. If this bit is
	 * 0, and the SQ is configured to support Unsignaled completion
	 * the controller should not generate a CQE unless there was
	 * an error. This refers to the CQE on the sender side. (The se
	 * flag refers to the receiver side).
	 */
	#define SQ_SEND_HDR_FLAGS_SIGNAL_COMP								UINT32_C(0x1)
	/*
	 * Indication to complete all previous RDMA Read or Atomic WQEs
	 * on the SQ before executing this WQE.
	 *
	 * This flag must be zero for a UD send.
	 */
	#define SQ_SEND_HDR_FLAGS_RD_OR_ATOMIC_FENCE							UINT32_C(0x2)
	/*
	 * For local invalidate request. Indication to complete all
	 * previous SQ's WQEs before executing this WQE.
	 *
	 * This flag must be zero for a UD send.
	 */
	#define SQ_SEND_HDR_FLAGS_UC_FENCE								UINT32_C(0x4)
	/*
	 * Solicit event flag. Indication sent in BTH header to the
	 * receiver to generate a Completion Event Notification, i.e.
	 * CNQE. This bit should be set only in the last (or only) packet
	 * of the message.
	 */
	#define SQ_SEND_HDR_FLAGS_SE									UINT32_C(0x8)
	/*
	 * Indicate that inline data is posted to the SQ in the data
	 * area of this WQE.
	 */
	#define SQ_SEND_HDR_FLAGS_INLINE								UINT32_C(0x10)
	/*
	 * If set to 1, then the timestamp from the WQE is used. If
	 * cleared to 0, then TWE provides the timestamp.
	 */
	#define SQ_SEND_HDR_FLAGS_WQE_TS_EN								UINT32_C(0x20)
	/*
	 * When set to '1', this operation will cause a trace capture in
	 * each block it passes through.
	 */
	#define SQ_SEND_HDR_FLAGS_DEBUG_TRACE								UINT32_C(0x40)
	/*
	 * The number of 16 bytes chunks of data including this first
	 * word of the request that are a valid part of the request. The
	 * valid 16 bytes units other than the WQE structure can be
	 * SGEs (Scatter Gather Elements) OR inline data.
	 *
	 * While this field defines the valid WQE size.  The actual
	 * total WQE size is always 128B.
	 */
	uint8_t	wqe_size;
	uint8_t	reserved8_1;
	/*
	 * Either invalidate key (R_Key of the remote host) that will
	 * be send with IETH (Invalidate ETH) if wqe_type is of Send
	 * with Invalidate, or immediate value that will be sent with
	 * ImmDt header if wqe_type is Send with Immediate.
	 */
	uint32_t	inv_key_or_imm_data;
	/* This field represents a 32-bit total data length, in bytes. */
	uint32_t	length;
	/*
	 * When in the SQ of a UD QP, indicates the q_key to be used in
	 * the transmitted packet.  However, if the most significant bit
	 * of this field is set, then the q_key will be taken from QP
	 * context, rather than from this field.
	 *
	 * When in the SQ of a non-UD QP, this field is reserved and
	 * should be filled with zeros.
	 */
	uint32_t	q_key;
	/*
	 * When in the SQ of a UD QP, indicates the destination QP to be
	 * used in the transmitted packet.
	 *
	 * When in the SQ of a non-UD QP, this field is reserved and
	 * should be filled with zeros.
	 */
	uint32_t	dst_qp;
	#define SQ_SEND_HDR_DST_QP_MASK UINT32_C(0xffffff)
	#define SQ_SEND_HDR_DST_QP_SFT 0
	uint32_t	avid;
	/*
	 * If the serv_type is 'UD', then this field supplies the AVID
	 * (Address Vector ID).
	 */
	#define SQ_SEND_HDR_AVID_MASK UINT32_C(0xfffff)
	#define SQ_SEND_HDR_AVID_SFT 0
	uint32_t	reserved32;
	uint32_t	timestamp;
	/*
	 * This field specifies a 24-bit timestamp that can be passed
	 * down the TX path and optionally logged in the TXP timestamp
	 * histogram.
	 */
	#define SQ_SEND_HDR_TIMESTAMP_MASK UINT32_C(0xffffff)
	#define SQ_SEND_HDR_TIMESTAMP_SFT 0
} sq_send_hdr_t, *psq_send_hdr_t;

/* Send Raw Ethernet and QP1 SQ WQE */
/* sq_send_raweth_qp1 (size:1024b/128B) */

typedef struct sq_send_raweth_qp1 {
	/* This field defines the type of SQ WQE. */
	uint8_t	wqe_type;
	/* Send */
	#define SQ_SEND_RAWETH_QP1_WQE_TYPE_SEND UINT32_C(0x0)
	#define SQ_SEND_RAWETH_QP1_WQE_TYPE_LAST SQ_SEND_RAWETH_QP1_WQE_TYPE_SEND
	uint8_t	flags;
	#define SQ_SEND_RAWETH_QP1_FLAGS_INLINE_SE_UC_FENCE_RD_OR_ATOMIC_FENCE_SIGNAL_COMP_MASK		UINT32_C(0xff)
	#define SQ_SEND_RAWETH_QP1_FLAGS_INLINE_SE_UC_FENCE_RD_OR_ATOMIC_FENCE_SIGNAL_COMP_SFT			0
	/*
	 * Set if completion signaling is requested. If this bit is
	 * 0, and the SQ is configured to support Unsignaled completion
	 * the controller should not generate a CQE unless there was
	 * an error. This refers to the CQE on the sender side. (The se
	 * flag refers to the receiver side).
	 */
	#define SQ_SEND_RAWETH_QP1_FLAGS_SIGNAL_COMP								UINT32_C(0x1)
	/* This flag must be zero for a Raweth or QP1 send. */
	#define SQ_SEND_RAWETH_QP1_FLAGS_RD_OR_ATOMIC_FENCE							UINT32_C(0x2)
	/* This flag must be zero for a Raweth or QP1 send. */
	#define SQ_SEND_RAWETH_QP1_FLAGS_UC_FENCE								UINT32_C(0x4)
	/* This flag must be zero for a Raweth or QP1 send. */
	#define SQ_SEND_RAWETH_QP1_FLAGS_SE									UINT32_C(0x8)
	/*
	 * Indicate that inline data is posted to the SQ in the data
	 * area of this WQE.
	 */
	#define SQ_SEND_RAWETH_QP1_FLAGS_INLINE								UINT32_C(0x10)
	/*
	 * If set to 1, then the timestamp from the WQE is used. If
	 * cleared to 0, then TWE provides the timestamp.
	 */
	#define SQ_SEND_RAWETH_QP1_FLAGS_WQE_TS_EN								UINT32_C(0x20)
	/*
	 * When set to '1', this operation will cause a trace capture in
	 * each block it passes through.
	 */
	#define SQ_SEND_RAWETH_QP1_FLAGS_DEBUG_TRACE								UINT32_C(0x40)
	/*
	 * The number of 16 bytes chunks of data including this first
	 * word of the request that are a valid part of the request. The
	 * valid 16 bytes units other than the WQE structure can be
	 * SGEs (Scatter Gather Elements) OR inline data.
	 *
	 * While this field defines the valid WQE size.  The actual
	 * total WQE size is always 128B.
	 */
	uint8_t	wqe_size;
	uint8_t	reserved8;
	/*
	 * All bits in this field must be valid on the first BD of a packet.
	 * Their value on other BDs of the packet will be ignored.
	 */
	uint16_t	lflags;
	/*
	 * If set to 1, the controller replaces the TCP/UPD checksum
	 * fields of normal TCP/UPD checksum, or the inner TCP/UDP
	 * checksum field of the encapsulated TCP/UDP packets with the
	 * hardware calculated TCP/UDP checksum for the packet associated
	 * with this descriptor.
	 *
	 * This bit must be valid on the first BD of a packet.
	 */
	#define SQ_SEND_RAWETH_QP1_LFLAGS_TCP_UDP_CHKSUM	UINT32_C(0x1)
	/*
	 * If set to 1,  the controller replaces the IP checksum of the
	 * normal packets, or the inner IP checksum of the encapsulated
	 * packets with the hardware calculated IP checksum for the
	 * packet associated with this descriptor.
	 *
	 * This bit must be valid on the first BD of a packet.
	 */
	#define SQ_SEND_RAWETH_QP1_LFLAGS_IP_CHKSUM	UINT32_C(0x2)
	/*
	 * If set to 1, the controller will not append an Ethernet CRC
	 * to the end of the frame.
	 *
	 * This bit must be valid on the first BD of a packet.
	 *
	 * Packet must be 64B or longer when this flag is set.  It is not
	 * usefull to use this bit with any form of TX offload such as
	 * CSO or LSO.  The intent is that the packet from the host already
	 * has a valid Ethernet CRC on the packet.
	 */
	#define SQ_SEND_RAWETH_QP1_LFLAGS_NOCRC		UINT32_C(0x4)
	/*
	 * If set to 1, the device will record the time at which the packet
	 * was actually transmitted at the TX MAC.
	 *
	 * This bit must be valid on the first BD of a packet.
	 */
	#define SQ_SEND_RAWETH_QP1_LFLAGS_STAMP		UINT32_C(0x8)
	/*
	 * If set to 1, The controller replaces the tunnel IP checksum
	 * field with hardware calculated IP checksum for the IP header
	 * of the packet associated with this descriptor.  In case of
	 * VXLAN, the controller also replaces the outer header UDP
	 * checksum with hardware calculated UDP checksum for the packet
	 * associated with this descriptor.
	 */
	#define SQ_SEND_RAWETH_QP1_LFLAGS_T_IP_CHKSUM	UINT32_C(0x10)
	/*
	 * If set to '1', then the RoCE ICRC will be appended to the
	 * packet.  Packet must be a valid RoCE format packet.
	 */
	#define SQ_SEND_RAWETH_QP1_LFLAGS_ROCE_CRC	UINT32_C(0x100)
	/*
	 * If set to '1', then the FCoE CRC will be appended to the
	 * packet.  Packet must be a valid FCoE format packet.
	 */
	#define SQ_SEND_RAWETH_QP1_LFLAGS_FCOE_CRC	UINT32_C(0x200)
	/*
	 * This value selects a CFA action to perform on the packet.
	 * Set this value to zero if no CFA action is desired.
	 *
	 * This value must be valid on the first BD of a packet.
	 */
	uint16_t	cfa_action;
	/*
	 * This field represents a 32-bit total data length, in bytes.
	 * Note, however, that the length cannot exceed the MTU.
	 */
	uint32_t	length;
	uint32_t	reserved32_1;
	/*
	 * This value is action meta-data that defines CFA edit operations
	 * that are done in addition to any action editing.
	 */
	uint32_t	cfa_meta;
	/* When key=1, This is the VLAN tag VID value. */
	#define SQ_SEND_RAWETH_QP1_CFA_META_VLAN_VID_MASK	UINT32_C(0xfff)
	#define SQ_SEND_RAWETH_QP1_CFA_META_VLAN_VID_SFT	0
	/* When key=1, This is the VLAN tag DE value. */
	#define SQ_SEND_RAWETH_QP1_CFA_META_VLAN_DE	UINT32_C(0x1000)
	/* When key=1, This is the VLAN tag PRI value. */
	#define SQ_SEND_RAWETH_QP1_CFA_META_VLAN_PRI_MASK	UINT32_C(0xe000)
	#define SQ_SEND_RAWETH_QP1_CFA_META_VLAN_PRI_SFT	13
	/* When key=1, This is the VLAN tag TPID select value. */
	#define SQ_SEND_RAWETH_QP1_CFA_META_VLAN_TPID_MASK	UINT32_C(0x70000)
	#define SQ_SEND_RAWETH_QP1_CFA_META_VLAN_TPID_SFT	16
	/* 0x88a8 */
		#define SQ_SEND_RAWETH_QP1_CFA_META_VLAN_TPID_TPID88A8  (UINT32_C(0x0) << 16)
	/* 0x8100 */
		#define SQ_SEND_RAWETH_QP1_CFA_META_VLAN_TPID_TPID8100  (UINT32_C(0x1) << 16)
	/* 0x9100 */
		#define SQ_SEND_RAWETH_QP1_CFA_META_VLAN_TPID_TPID9100  (UINT32_C(0x2) << 16)
	/* 0x9200 */
		#define SQ_SEND_RAWETH_QP1_CFA_META_VLAN_TPID_TPID9200  (UINT32_C(0x3) << 16)
	/* 0x9300 */
		#define SQ_SEND_RAWETH_QP1_CFA_META_VLAN_TPID_TPID9300  (UINT32_C(0x4) << 16)
	/* Value programmed in CFA VLANTPID register. */
		#define SQ_SEND_RAWETH_QP1_CFA_META_VLAN_TPID_TPIDCFG   (UINT32_C(0x5) << 16)
		#define SQ_SEND_RAWETH_QP1_CFA_META_VLAN_TPID_LAST	SQ_SEND_RAWETH_QP1_CFA_META_VLAN_TPID_TPIDCFG
	/* When key=1, This is the VLAN tag TPID select value. */
	#define SQ_SEND_RAWETH_QP1_CFA_META_VLAN_RESERVED_MASK UINT32_C(0xff80000)
	#define SQ_SEND_RAWETH_QP1_CFA_META_VLAN_RESERVED_SFT 19
	/*
	 * This field identifies the type of edit to be performed
	 * on the packet.
	 *
	 * This value must be valid on the first BD of a packet.
	 */
	#define SQ_SEND_RAWETH_QP1_CFA_META_KEY_MASK	UINT32_C(0xf0000000)
	#define SQ_SEND_RAWETH_QP1_CFA_META_KEY_SFT	28
	/* No editing */
		#define SQ_SEND_RAWETH_QP1_CFA_META_KEY_NONE		(UINT32_C(0x0) << 28)
	/*
	 * - meta[17:16] - TPID select value (0 = 0x8100).
	 * - meta[15:12] - PRI/DE value.
	 * - meta[11:0] - VID value.
	 */
		#define SQ_SEND_RAWETH_QP1_CFA_META_KEY_VLAN_TAG	(UINT32_C(0x1) << 28)
		#define SQ_SEND_RAWETH_QP1_CFA_META_KEY_LAST	SQ_SEND_RAWETH_QP1_CFA_META_KEY_VLAN_TAG
	uint32_t	reserved32_2;
	uint32_t	reserved32_3;
	uint32_t	timestamp;
	/*
	 * This field specifies a 24-bit timestamp that can be passed
	 * down the TX path and optionally logged in the TXP timestamp
	 * histogram.
	 */
	#define SQ_SEND_RAWETH_QP1_TIMESTAMP_MASK UINT32_C(0xffffff)
	#define SQ_SEND_RAWETH_QP1_TIMESTAMP_SFT 0
	/*
	 * When inline=0, then this area is filled with from 1 to 6
	 * SGEs based on the wqe_size field.
	 *
	 * When inline=1, this area is filled with payload data for the
	 * send based on the length_or_AVID field.  Bits [7:0] of word 0
	 * hold the first byte to go out on the wire.
	 */
	uint32_t	data[24];
} sq_send_raweth_qp1_t, *psq_send_raweth_qp1_t;

/* Send Raw Ethernet and QP1 SQ WQE header. */
/* sq_send_raweth_qp1_hdr (size:256b/32B) */

typedef struct sq_send_raweth_qp1_hdr {
	/* This field defines the type of SQ WQE. */
	uint8_t	wqe_type;
	/* Send */
	#define SQ_SEND_RAWETH_QP1_HDR_WQE_TYPE_SEND UINT32_C(0x0)
	#define SQ_SEND_RAWETH_QP1_HDR_WQE_TYPE_LAST SQ_SEND_RAWETH_QP1_HDR_WQE_TYPE_SEND
	uint8_t	flags;
	#define SQ_SEND_RAWETH_QP1_HDR_FLAGS_INLINE_SE_UC_FENCE_RD_OR_ATOMIC_FENCE_SIGNAL_COMP_MASK		UINT32_C(0xff)
	#define SQ_SEND_RAWETH_QP1_HDR_FLAGS_INLINE_SE_UC_FENCE_RD_OR_ATOMIC_FENCE_SIGNAL_COMP_SFT			0
	/*
	 * Set if completion signaling is requested. If this bit is
	 * 0, and the SQ is configured to support Unsignaled completion
	 * the controller should not generate a CQE unless there was
	 * an error. This refers to the CQE on the sender side. (The se
	 * flag refers to the receiver side).
	 */
	#define SQ_SEND_RAWETH_QP1_HDR_FLAGS_SIGNAL_COMP								UINT32_C(0x1)
	/* This flag must be zero for a Raweth or QP1 send. */
	#define SQ_SEND_RAWETH_QP1_HDR_FLAGS_RD_OR_ATOMIC_FENCE							UINT32_C(0x2)
	/* This flag must be zero for a Raweth or QP1 send. */
	#define SQ_SEND_RAWETH_QP1_HDR_FLAGS_UC_FENCE								UINT32_C(0x4)
	/* This flag must be zero for a Raweth or QP1 send. */
	#define SQ_SEND_RAWETH_QP1_HDR_FLAGS_SE									UINT32_C(0x8)
	/*
	 * Indicate that inline data is posted to the SQ in the data
	 * area of this WQE.
	 */
	#define SQ_SEND_RAWETH_QP1_HDR_FLAGS_INLINE								UINT32_C(0x10)
	/*
	 * If set to 1, then the timestamp from the WQE is used. If
	 * cleared to 0, then TWE provides the timestamp.
	 */
	#define SQ_SEND_RAWETH_QP1_HDR_FLAGS_WQE_TS_EN								UINT32_C(0x20)
	/*
	 * When set to '1', this operation will cause a trace capture in
	 * each block it passes through.
	 */
	#define SQ_SEND_RAWETH_QP1_HDR_FLAGS_DEBUG_TRACE								UINT32_C(0x40)
	/*
	 * The number of 16 bytes chunks of data including this first
	 * word of the request that are a valid part of the request. The
	 * valid 16 bytes units other than the WQE structure can be
	 * SGEs (Scatter Gather Elements) OR inline data.
	 *
	 * While this field defines the valid WQE size.  The actual
	 * total WQE size is always 128B.
	 */
	uint8_t	wqe_size;
	uint8_t	reserved8;
	/*
	 * All bits in this field must be valid on the first BD of a packet.
	 * Their value on other BDs of the packet will be ignored.
	 */
	uint16_t	lflags;
	/*
	 * If set to 1, the controller replaces the TCP/UPD checksum
	 * fields of normal TCP/UPD checksum, or the inner TCP/UDP
	 * checksum field of the encapsulated TCP/UDP packets with the
	 * hardware calculated TCP/UDP checksum for the packet associated
	 * with this descriptor.
	 *
	 * This bit must be valid on the first BD of a packet.
	 */
	#define SQ_SEND_RAWETH_QP1_HDR_LFLAGS_TCP_UDP_CHKSUM	UINT32_C(0x1)
	/*
	 * If set to 1,  the controller replaces the IP checksum of the
	 * normal packets, or the inner IP checksum of the encapsulated
	 * packets with the hardware calculated IP checksum for the
	 * packet associated with this descriptor.
	 *
	 * This bit must be valid on the first BD of a packet.
	 */
	#define SQ_SEND_RAWETH_QP1_HDR_LFLAGS_IP_CHKSUM	UINT32_C(0x2)
	/*
	 * If set to 1, the controller will not append an Ethernet CRC
	 * to the end of the frame.
	 *
	 * This bit must be valid on the first BD of a packet.
	 *
	 * Packet must be 64B or longer when this flag is set.  It is not
	 * usefull to use this bit with any form of TX offload such as
	 * CSO or LSO.  The intent is that the packet from the host already
	 * has a valid Ethernet CRC on the packet.
	 */
	#define SQ_SEND_RAWETH_QP1_HDR_LFLAGS_NOCRC		UINT32_C(0x4)
	/*
	 * If set to 1, the device will record the time at which the packet
	 * was actually transmitted at the TX MAC.
	 *
	 * This bit must be valid on the first BD of a packet.
	 */
	#define SQ_SEND_RAWETH_QP1_HDR_LFLAGS_STAMP		UINT32_C(0x8)
	/*
	 * If set to 1, The controller replaces the tunnel IP checksum
	 * field with hardware calculated IP checksum for the IP header
	 * of the packet associated with this descriptor.  In case of
	 * VXLAN, the controller also replaces the outer header UDP
	 * checksum with hardware calculated UDP checksum for the packet
	 * associated with this descriptor.
	 */
	#define SQ_SEND_RAWETH_QP1_HDR_LFLAGS_T_IP_CHKSUM	UINT32_C(0x10)
	/*
	 * If set to '1', then the RoCE ICRC will be appended to the
	 * packet.  Packet must be a valid RoCE format packet.
	 */
	#define SQ_SEND_RAWETH_QP1_HDR_LFLAGS_ROCE_CRC	UINT32_C(0x100)
	/*
	 * If set to '1', then the FCoE CRC will be appended to the
	 * packet.  Packet must be a valid FCoE format packet.
	 */
	#define SQ_SEND_RAWETH_QP1_HDR_LFLAGS_FCOE_CRC	UINT32_C(0x200)
	/*
	 * This value selects a CFA action to perform on the packet.
	 * Set this value to zero if no CFA action is desired.
	 *
	 * This value must be valid on the first BD of a packet.
	 */
	uint16_t	cfa_action;
	/*
	 * This field represents a 32-bit total data length, in bytes.
	 * Note, however, that the length cannot exceed the MTU.
	 */
	uint32_t	length;
	uint32_t	reserved32_1;
	/*
	 * This value is action meta-data that defines CFA edit operations
	 * that are done in addition to any action editing.
	 */
	uint32_t	cfa_meta;
	/* When key=1, This is the VLAN tag VID value. */
	#define SQ_SEND_RAWETH_QP1_HDR_CFA_META_VLAN_VID_MASK	UINT32_C(0xfff)
	#define SQ_SEND_RAWETH_QP1_HDR_CFA_META_VLAN_VID_SFT	0
	/* When key=1, This is the VLAN tag DE value. */
	#define SQ_SEND_RAWETH_QP1_HDR_CFA_META_VLAN_DE	UINT32_C(0x1000)
	/* When key=1, This is the VLAN tag PRI value. */
	#define SQ_SEND_RAWETH_QP1_HDR_CFA_META_VLAN_PRI_MASK	UINT32_C(0xe000)
	#define SQ_SEND_RAWETH_QP1_HDR_CFA_META_VLAN_PRI_SFT	13
	/* When key=1, This is the VLAN tag TPID select value. */
	#define SQ_SEND_RAWETH_QP1_HDR_CFA_META_VLAN_TPID_MASK	UINT32_C(0x70000)
	#define SQ_SEND_RAWETH_QP1_HDR_CFA_META_VLAN_TPID_SFT	16
	/* 0x88a8 */
		#define SQ_SEND_RAWETH_QP1_HDR_CFA_META_VLAN_TPID_TPID88A8  (UINT32_C(0x0) << 16)
	/* 0x8100 */
		#define SQ_SEND_RAWETH_QP1_HDR_CFA_META_VLAN_TPID_TPID8100  (UINT32_C(0x1) << 16)
	/* 0x9100 */
		#define SQ_SEND_RAWETH_QP1_HDR_CFA_META_VLAN_TPID_TPID9100  (UINT32_C(0x2) << 16)
	/* 0x9200 */
		#define SQ_SEND_RAWETH_QP1_HDR_CFA_META_VLAN_TPID_TPID9200  (UINT32_C(0x3) << 16)
	/* 0x9300 */
		#define SQ_SEND_RAWETH_QP1_HDR_CFA_META_VLAN_TPID_TPID9300  (UINT32_C(0x4) << 16)
	/* Value programmed in CFA VLANTPID register. */
		#define SQ_SEND_RAWETH_QP1_HDR_CFA_META_VLAN_TPID_TPIDCFG   (UINT32_C(0x5) << 16)
		#define SQ_SEND_RAWETH_QP1_HDR_CFA_META_VLAN_TPID_LAST	SQ_SEND_RAWETH_QP1_HDR_CFA_META_VLAN_TPID_TPIDCFG
	/* When key=1, This is the VLAN tag TPID select value. */
	#define SQ_SEND_RAWETH_QP1_HDR_CFA_META_VLAN_RESERVED_MASK UINT32_C(0xff80000)
	#define SQ_SEND_RAWETH_QP1_HDR_CFA_META_VLAN_RESERVED_SFT 19
	/*
	 * This field identifies the type of edit to be performed
	 * on the packet.
	 *
	 * This value must be valid on the first BD of a packet.
	 */
	#define SQ_SEND_RAWETH_QP1_HDR_CFA_META_KEY_MASK	UINT32_C(0xf0000000)
	#define SQ_SEND_RAWETH_QP1_HDR_CFA_META_KEY_SFT	28
	/* No editing */
		#define SQ_SEND_RAWETH_QP1_HDR_CFA_META_KEY_NONE		(UINT32_C(0x0) << 28)
	/*
	 * - meta[17:16] - TPID select value (0 = 0x8100).
	 * - meta[15:12] - PRI/DE value.
	 * - meta[11:0] - VID value.
	 */
		#define SQ_SEND_RAWETH_QP1_HDR_CFA_META_KEY_VLAN_TAG	(UINT32_C(0x1) << 28)
		#define SQ_SEND_RAWETH_QP1_HDR_CFA_META_KEY_LAST	SQ_SEND_RAWETH_QP1_HDR_CFA_META_KEY_VLAN_TAG
	uint32_t	reserved32_2;
	uint32_t	reserved32_3;
	uint32_t	timestamp;
	/*
	 * This field specifies a 24-bit timestamp that can be passed
	 * down the TX path and optionally logged in the TXP timestamp
	 * histogram.
	 */
	#define SQ_SEND_RAWETH_QP1_HDR_TIMESTAMP_MASK UINT32_C(0xffffff)
	#define SQ_SEND_RAWETH_QP1_HDR_TIMESTAMP_SFT 0
} sq_send_raweth_qp1_hdr_t, *psq_send_raweth_qp1_hdr_t;

/* RDMA SQ WQE */
/* sq_rdma (size:1024b/128B) */

typedef struct sq_rdma {
	/* This field defines the type of SQ WQE. */
	uint8_t	wqe_type;
	/*
	 * RDMA Write.
	 *
	 * Allowed only on reliable connection (RC) SQs.
	 */
	#define SQ_RDMA_WQE_TYPE_WRITE_WQE	UINT32_C(0x4)
	/*
	 * RDMA Write with Immediate.
	 *
	 * Allowed only on reliable connection (RC) SQs.
	 */
	#define SQ_RDMA_WQE_TYPE_WRITE_W_IMMEAD UINT32_C(0x5)
	/*
	 * RDMA Read.
	 *
	 * Allowed only on reliable connection (RC) SQs.
	 */
	#define SQ_RDMA_WQE_TYPE_READ_WQE	UINT32_C(0x6)
	#define SQ_RDMA_WQE_TYPE_LAST	SQ_RDMA_WQE_TYPE_READ_WQE
	uint8_t	flags;
	#define SQ_RDMA_FLAGS_INLINE_SE_UC_FENCE_RD_OR_ATOMIC_FENCE_SIGNAL_COMP_MASK		UINT32_C(0xff)
	#define SQ_RDMA_FLAGS_INLINE_SE_UC_FENCE_RD_OR_ATOMIC_FENCE_SIGNAL_COMP_SFT			0
	/*
	 * Set if completion signaling is requested. If this bit is
	 * 0, and the SQ is configured to support Unsignaled
	 * completion the controller should not generate a CQE
	 * unless there was an error. This refers to CQE on the
	 * sender side (se_flag refers to the receiver side)
	 */
	#define SQ_RDMA_FLAGS_SIGNAL_COMP								UINT32_C(0x1)
	/*
	 * Indication to complete all previous RDMA Read or Atomic
	 * WQEs on the SQ before executing this WQE
	 */
	#define SQ_RDMA_FLAGS_RD_OR_ATOMIC_FENCE							UINT32_C(0x2)
	/*
	 * Unconditional fence. Indication to complete all previous
	 * SQ's WQEs before executing this WQE.
	 */
	#define SQ_RDMA_FLAGS_UC_FENCE								UINT32_C(0x4)
	/*
	 * Solicit event. Indication sent in BTH header to the
	 * receiver to generate a Completion Event Notification,
	 * i.e. CNQE. This bit should be set only in the last (or
	 * only) packet of the message.
	 */
	#define SQ_RDMA_FLAGS_SE									UINT32_C(0x8)
	/*
	 * Indicate that inline data is posted to the SQ following
	 * this WQE.  This bit may be 1 only for write operations.
	 */
	#define SQ_RDMA_FLAGS_INLINE								UINT32_C(0x10)
	/*
	 * If set to 1, then the timestamp from the WQE is used. If
	 * cleared to 0, then TWE provides the timestamp.
	 */
	#define SQ_RDMA_FLAGS_WQE_TS_EN								UINT32_C(0x20)
	/*
	 * When set to '1', this operation will cause a trace capture in
	 * each block it passes through.
	 */
	#define SQ_RDMA_FLAGS_DEBUG_TRACE								UINT32_C(0x40)
	/*
	 * The number of 16 bytes chunks of data including this first
	 * wqe of the request that are a valid part of the request. The
	 * valid 16 bytes units other than the WQE structure can be
	 * SGEs (Scatter Gather Elements) OR inline data.
	 *
	 * While this field defines the valid WQE size.  The actual
	 * total WQE size is always 128B.
	 */
	uint8_t	wqe_size;
	uint8_t	reserved8;
	/*
	 * Immediate data - valid for RDMA Write with immediate and
	 * causes the controller to add immDt header with this value
	 */
	uint32_t	imm_data;
	/* Total data length in bytes */
	uint32_t	length;
	uint32_t	reserved32_1;
	/* Remote VA sent to the destination QP */
	uint64_t	remote_va;
	/*
	 * R_Key provided by remote node when the connection was
	 * established and placed in the RETH header. It identify the
	 * MRW on the remote host
	 */
	uint32_t	remote_key;
	uint32_t	timestamp;
	/*
	 * This field specifies a 24-bit timestamp that can be passed
	 * down the TX path and optionally logged in the TXP timestamp
	 * histogram.
	 */
	#define SQ_RDMA_TIMESTAMP_MASK UINT32_C(0xffffff)
	#define SQ_RDMA_TIMESTAMP_SFT 0
	/*
	 * When inline=0, then this area is filled with from 1 to 6
	 * SGEs based on the wqe_size field.
	 *
	 * When inline=1, this area is filled with payload data for the
	 * write based on the length field.  Bits [7:0] of word 0
	 * hold the first byte to go out on the wire.
	 */
	uint32_t	data[24];
} sq_rdma_t, *psq_rdma_t;

/* RDMA SQ WQE header. */
/* sq_rdma_hdr (size:256b/32B) */

typedef struct sq_rdma_hdr {
	/* This field defines the type of SQ WQE. */
	uint8_t	wqe_type;
	/*
	 * RDMA Write.
	 *
	 * Allowed only on reliable connection (RC) SQs.
	 */
	#define SQ_RDMA_HDR_WQE_TYPE_WRITE_WQE	UINT32_C(0x4)
	/*
	 * RDMA Write with Immediate.
	 *
	 * Allowed only on reliable connection (RC) SQs.
	 */
	#define SQ_RDMA_HDR_WQE_TYPE_WRITE_W_IMMEAD UINT32_C(0x5)
	/*
	 * RDMA Read.
	 *
	 * Allowed only on reliable connection (RC) SQs.
	 */
	#define SQ_RDMA_HDR_WQE_TYPE_READ_WQE	UINT32_C(0x6)
	#define SQ_RDMA_HDR_WQE_TYPE_LAST	SQ_RDMA_HDR_WQE_TYPE_READ_WQE
	uint8_t	flags;
	#define SQ_RDMA_HDR_FLAGS_INLINE_SE_UC_FENCE_RD_OR_ATOMIC_FENCE_SIGNAL_COMP_MASK		UINT32_C(0xff)
	#define SQ_RDMA_HDR_FLAGS_INLINE_SE_UC_FENCE_RD_OR_ATOMIC_FENCE_SIGNAL_COMP_SFT			0
	/*
	 * Set if completion signaling is requested. If this bit is
	 * 0, and the SQ is configured to support Unsignaled
	 * completion the controller should not generate a CQE
	 * unless there was an error. This refers to CQE on the
	 * sender side (se_flag refers to the receiver side)
	 */
	#define SQ_RDMA_HDR_FLAGS_SIGNAL_COMP								UINT32_C(0x1)
	/*
	 * Indication to complete all previous RDMA Read or Atomic
	 * WQEs on the SQ before executing this WQE
	 */
	#define SQ_RDMA_HDR_FLAGS_RD_OR_ATOMIC_FENCE							UINT32_C(0x2)
	/*
	 * Unconditional fence. Indication to complete all previous
	 * SQ's WQEs before executing this WQE.
	 */
	#define SQ_RDMA_HDR_FLAGS_UC_FENCE								UINT32_C(0x4)
	/*
	 * Solicit event. Indication sent in BTH header to the
	 * receiver to generate a Completion Event Notification,
	 * i.e. CNQE. This bit should be set only in the last (or
	 * only) packet of the message.
	 */
	#define SQ_RDMA_HDR_FLAGS_SE									UINT32_C(0x8)
	/*
	 * Indicate that inline data is posted to the SQ following
	 * this WQE.  This bit may be 1 only for write operations.
	 */
	#define SQ_RDMA_HDR_FLAGS_INLINE								UINT32_C(0x10)
	/*
	 * If set to 1, then the timestamp from the WQE is used. If
	 * cleared to 0, then TWE provides the timestamp.
	 */
	#define SQ_RDMA_HDR_FLAGS_WQE_TS_EN								UINT32_C(0x20)
	/*
	 * When set to '1', this operation will cause a trace capture in
	 * each block it passes through.
	 */
	#define SQ_RDMA_HDR_FLAGS_DEBUG_TRACE								UINT32_C(0x40)
	/*
	 * The number of 16 bytes chunks of data including this first
	 * wqe of the request that are a valid part of the request. The
	 * valid 16 bytes units other than the WQE structure can be
	 * SGEs (Scatter Gather Elements) OR inline data.
	 *
	 * While this field defines the valid WQE size.  The actual
	 * total WQE size is always 128B.
	 */
	uint8_t	wqe_size;
	uint8_t	reserved8;
	/*
	 * Immediate data - valid for RDMA Write with immediate and
	 * causes the controller to add immDt header with this value
	 */
	uint32_t	imm_data;
	/* Total data length in bytes */
	uint32_t	length;
	uint32_t	reserved32_1;
	/* Remote VA sent to the destination QP */
	uint64_t	remote_va;
	/*
	 * R_Key provided by remote node when the connection was
	 * established and placed in the RETH header. It identify the
	 * MRW on the remote host
	 */
	uint32_t	remote_key;
	uint32_t	timestamp;
	/*
	 * This field specifies a 24-bit timestamp that can be passed
	 * down the TX path and optionally logged in the TXP timestamp
	 * histogram.
	 */
	#define SQ_RDMA_HDR_TIMESTAMP_MASK UINT32_C(0xffffff)
	#define SQ_RDMA_HDR_TIMESTAMP_SFT 0
} sq_rdma_hdr_t, *psq_rdma_hdr_t;

/* Atomic SQ WQE */
/* sq_atomic (size:1024b/128B) */

typedef struct sq_atomic {
	/* This field defines the type of SQ WQE. */
	uint8_t	wqe_type;
	/*
	 * Atomic Compare/Swap.
	 *
	 * Allowed only on reliable connection (RC) SQs.
	 */
	#define SQ_ATOMIC_WQE_TYPE_ATOMIC_CS UINT32_C(0x8)
	/*
	 * Atomic Fetch/Add.
	 *
	 * Allowed only on reliable connection (RC) SQs.
	 */
	#define SQ_ATOMIC_WQE_TYPE_ATOMIC_FA UINT32_C(0xb)
	#define SQ_ATOMIC_WQE_TYPE_LAST	SQ_ATOMIC_WQE_TYPE_ATOMIC_FA
	uint8_t	flags;
	#define SQ_ATOMIC_FLAGS_INLINE_SE_UC_FENCE_RD_OR_ATOMIC_FENCE_SIGNAL_COMP_MASK		UINT32_C(0xff)
	#define SQ_ATOMIC_FLAGS_INLINE_SE_UC_FENCE_RD_OR_ATOMIC_FENCE_SIGNAL_COMP_SFT			0
	/*
	 * Set if completion signaling is requested. If this bit is
	 * 0, and the SQ is configured to support Unsignaled
	 * completion the controller should not generate a CQE
	 * unless there was an error. This refers to CQE on the
	 * sender side (se_flag refers to the receiver side)
	 */
	#define SQ_ATOMIC_FLAGS_SIGNAL_COMP								UINT32_C(0x1)
	/*
	 * Indication to complete all previous RDMA Read or Atomic
	 * WQEs on the SQ before executing this WQE
	 */
	#define SQ_ATOMIC_FLAGS_RD_OR_ATOMIC_FENCE							UINT32_C(0x2)
	/*
	 * Unconditional fence. Indication to complete all previous
	 * SQ's WQEs before executing this WQE.
	 */
	#define SQ_ATOMIC_FLAGS_UC_FENCE								UINT32_C(0x4)
	/*
	 * Solicit event. Indication sent in BTH header to the
	 * receiver to generate a Completion Event Notification,
	 * i.e. CNQE. This bit should be set only in the last (or
	 * only) packet of the message.
	 */
	#define SQ_ATOMIC_FLAGS_SE									UINT32_C(0x8)
	/* NA for this WQE */
	#define SQ_ATOMIC_FLAGS_INLINE								UINT32_C(0x10)
	/*
	 * The atomic WQE does not have a timestamp field, so this field is
	 * ignored and should be zero.
	 */
	#define SQ_ATOMIC_FLAGS_WQE_TS_EN								UINT32_C(0x20)
	/*
	 * When set to '1', this operation will cause a trace capture in
	 * each block it passes through.
	 */
	#define SQ_ATOMIC_FLAGS_DEBUG_TRACE								UINT32_C(0x40)
	uint16_t	reserved16;
	/*
	 * R_Key provided by remote node when the connection was
	 * established and placed in the AETH header. It identify the
	 * MRW on the remote host
	 */
	uint32_t	remote_key;
	/* Remote VA sent to the destination QP */
	uint64_t	remote_va;
	/* Data value to be placed in remote host specified address */
	uint64_t	swap_data;
	/*
	 * Data value to be compared with the value in the remote host
	 * specified address
	 */
	uint64_t	cmp_data;
	/*
	 * The first 16B of the data field must be filled with a single
	 * SGE. This will be used to store the return value from the
	 * Atomic Ack response.  The size of the single SGE must be 8B.
	 */
	uint32_t	data[24];
} sq_atomic_t, *psq_atomic_t;

/* Atomic SQ WQE header. */
/* sq_atomic_hdr (size:256b/32B) */

typedef struct sq_atomic_hdr {
	/* This field defines the type of SQ WQE. */
	uint8_t	wqe_type;
	/*
	 * Atomic Compare/Swap.
	 *
	 * Allowed only on reliable connection (RC) SQs.
	 */
	#define SQ_ATOMIC_HDR_WQE_TYPE_ATOMIC_CS UINT32_C(0x8)
	/*
	 * Atomic Fetch/Add.
	 *
	 * Allowed only on reliable connection (RC) SQs.
	 */
	#define SQ_ATOMIC_HDR_WQE_TYPE_ATOMIC_FA UINT32_C(0xb)
	#define SQ_ATOMIC_HDR_WQE_TYPE_LAST	SQ_ATOMIC_HDR_WQE_TYPE_ATOMIC_FA
	uint8_t	flags;
	#define SQ_ATOMIC_HDR_FLAGS_INLINE_SE_UC_FENCE_RD_OR_ATOMIC_FENCE_SIGNAL_COMP_MASK		UINT32_C(0xff)
	#define SQ_ATOMIC_HDR_FLAGS_INLINE_SE_UC_FENCE_RD_OR_ATOMIC_FENCE_SIGNAL_COMP_SFT			0
	/*
	 * Set if completion signaling is requested. If this bit is
	 * 0, and the SQ is configured to support Unsignaled
	 * completion the controller should not generate a CQE
	 * unless there was an error. This refers to CQE on the
	 * sender side (se_flag refers to the receiver side)
	 */
	#define SQ_ATOMIC_HDR_FLAGS_SIGNAL_COMP								UINT32_C(0x1)
	/*
	 * Indication to complete all previous RDMA Read or Atomic
	 * WQEs on the SQ before executing this WQE
	 */
	#define SQ_ATOMIC_HDR_FLAGS_RD_OR_ATOMIC_FENCE							UINT32_C(0x2)
	/*
	 * Unconditional fence. Indication to complete all previous
	 * SQ's WQEs before executing this WQE.
	 */
	#define SQ_ATOMIC_HDR_FLAGS_UC_FENCE								UINT32_C(0x4)
	/*
	 * Solicit event. Indication sent in BTH header to the
	 * receiver to generate a Completion Event Notification,
	 * i.e. CNQE. This bit should be set only in the last (or
	 * only) packet of the message.
	 */
	#define SQ_ATOMIC_HDR_FLAGS_SE									UINT32_C(0x8)
	/* NA for this WQE */
	#define SQ_ATOMIC_HDR_FLAGS_INLINE								UINT32_C(0x10)
	/*
	 * The atomic WQE does not have a timestamp field, so this field is
	 * ignored and should be zero.
	 */
	#define SQ_ATOMIC_HDR_FLAGS_WQE_TS_EN								UINT32_C(0x20)
	/*
	 * When set to '1', this operation will cause a trace capture in
	 * each block it passes through.
	 */
	#define SQ_ATOMIC_HDR_FLAGS_DEBUG_TRACE								UINT32_C(0x40)
	uint16_t	reserved16;
	/*
	 * R_Key provided by remote node when the connection was
	 * established and placed in the AETH header. It identify the
	 * MRW on the remote host
	 */
	uint32_t	remote_key;
	/* Remote VA sent to the destination QP */
	uint64_t	remote_va;
	/* Data value to be placed in remote host specified address */
	uint64_t	swap_data;
	/*
	 * Data value to be compared with the value in the remote host
	 * specified address
	 */
	uint64_t	cmp_data;
} sq_atomic_hdr_t, *psq_atomic_hdr_t;

/* Local Invalidate SQ WQE */
/* sq_localinvalidate (size:1024b/128B) */

typedef struct sq_localinvalidate {
	/* This field defines the type of SQ WQE. */
	uint8_t	wqe_type;
	/*
	 * Local Invalidate.
	 *
	 * Allowed only on reliable connection (RC) SQs.
	 */
	#define SQ_LOCALINVALIDATE_WQE_TYPE_LOCAL_INVALID UINT32_C(0xc)
	#define SQ_LOCALINVALIDATE_WQE_TYPE_LAST	SQ_LOCALINVALIDATE_WQE_TYPE_LOCAL_INVALID
	uint8_t	flags;
	#define SQ_LOCALINVALIDATE_FLAGS_INLINE_SE_UC_FENCE_RD_OR_ATOMIC_FENCE_SIGNAL_COMP_MASK		UINT32_C(0xff)
	#define SQ_LOCALINVALIDATE_FLAGS_INLINE_SE_UC_FENCE_RD_OR_ATOMIC_FENCE_SIGNAL_COMP_SFT			0
	/*
	 * Set if completion signaling is requested. If this bit is
	 * 0, and the SQ is configured to support Unsignaled
	 * completion the controller should not generate a CQE
	 * unless there was an error. This refers to CQE on the
	 * sender side (se_flag refers to the receiver side)
	 */
	#define SQ_LOCALINVALIDATE_FLAGS_SIGNAL_COMP								UINT32_C(0x1)
	/*
	 * Indication to complete all previous RDMA Read or Atomic
	 * WQEs on the SQ before executing this WQE
	 */
	#define SQ_LOCALINVALIDATE_FLAGS_RD_OR_ATOMIC_FENCE							UINT32_C(0x2)
	/*
	 * Unconditional fence. Indication to complete all previous
	 * SQ's WQEs before executing this WQE.
	 */
	#define SQ_LOCALINVALIDATE_FLAGS_UC_FENCE								UINT32_C(0x4)
	/*
	 * Solicit event. Indication sent in BTH header to the
	 * receiver to generate a Completion Event Notification,
	 * i.e. CNQE. This bit should be set only in the last (or
	 * only) packet of the message.
	 */
	#define SQ_LOCALINVALIDATE_FLAGS_SE									UINT32_C(0x8)
	/* NA for this WQE */
	#define SQ_LOCALINVALIDATE_FLAGS_INLINE								UINT32_C(0x10)
	/*
	 * This flag is not applicable and should be 0 for a local memory
	 * operation WQE.
	 */
	#define SQ_LOCALINVALIDATE_FLAGS_WQE_TS_EN								UINT32_C(0x20)
	/*
	 * When set to '1', this operation will cause a trace capture in
	 * each block it passes through.
	 */
	#define SQ_LOCALINVALIDATE_FLAGS_DEBUG_TRACE								UINT32_C(0x40)
	uint16_t	reserved16;
	/*
	 * The local key for the MR/W to invalidate; 24 msb of the key
	 * are used to index the MRW table, 8 lsb are compared with the
	 * 8 bit key in the MRWC
	 */
	uint32_t	inv_l_key;
	uint64_t	reserved64;
	uint8_t	reserved128[16];
	/* The data field for local invalidate is not used. */
	uint32_t	data[24];
} sq_localinvalidate_t, *psq_localinvalidate_t;

/* Local Invalidate SQ WQE header. */
/* sq_localinvalidate_hdr (size:256b/32B) */

typedef struct sq_localinvalidate_hdr {
	/* This field defines the type of SQ WQE. */
	uint8_t	wqe_type;
	/*
	 * Local Invalidate.
	 *
	 * Allowed only on reliable connection (RC) SQs.
	 */
	#define SQ_LOCALINVALIDATE_HDR_WQE_TYPE_LOCAL_INVALID UINT32_C(0xc)
	#define SQ_LOCALINVALIDATE_HDR_WQE_TYPE_LAST	SQ_LOCALINVALIDATE_HDR_WQE_TYPE_LOCAL_INVALID
	uint8_t	flags;
	#define SQ_LOCALINVALIDATE_HDR_FLAGS_INLINE_SE_UC_FENCE_RD_OR_ATOMIC_FENCE_SIGNAL_COMP_MASK		UINT32_C(0xff)
	#define SQ_LOCALINVALIDATE_HDR_FLAGS_INLINE_SE_UC_FENCE_RD_OR_ATOMIC_FENCE_SIGNAL_COMP_SFT			0
	/*
	 * Set if completion signaling is requested. If this bit is
	 * 0, and the SQ is configured to support Unsignaled
	 * completion the controller should not generate a CQE
	 * unless there was an error. This refers to CQE on the
	 * sender side (se_flag refers to the receiver side)
	 */
	#define SQ_LOCALINVALIDATE_HDR_FLAGS_SIGNAL_COMP								UINT32_C(0x1)
	/*
	 * Indication to complete all previous RDMA Read or Atomic
	 * WQEs on the SQ before executing this WQE
	 */
	#define SQ_LOCALINVALIDATE_HDR_FLAGS_RD_OR_ATOMIC_FENCE							UINT32_C(0x2)
	/*
	 * Unconditional fence. Indication to complete all previous
	 * SQ's WQEs before executing this WQE.
	 */
	#define SQ_LOCALINVALIDATE_HDR_FLAGS_UC_FENCE								UINT32_C(0x4)
	/*
	 * Solicit event. Indication sent in BTH header to the
	 * receiver to generate a Completion Event Notification,
	 * i.e. CNQE. This bit should be set only in the last (or
	 * only) packet of the message.
	 */
	#define SQ_LOCALINVALIDATE_HDR_FLAGS_SE									UINT32_C(0x8)
	/* NA for this WQE */
	#define SQ_LOCALINVALIDATE_HDR_FLAGS_INLINE								UINT32_C(0x10)
	/*
	 * This flag is not applicable and should be 0 for a local memory
	 * operation WQE.
	 */
	#define SQ_LOCALINVALIDATE_HDR_FLAGS_WQE_TS_EN								UINT32_C(0x20)
	/*
	 * When set to '1', this operation will cause a trace capture in
	 * each block it passes through.
	 */
	#define SQ_LOCALINVALIDATE_HDR_FLAGS_DEBUG_TRACE								UINT32_C(0x40)
	uint16_t	reserved16;
	/*
	 * The local key for the MR/W to invalidate; 24 msb of the key
	 * are used to index the MRW table, 8 lsb are compared with the
	 * 8 bit key in the MRWC
	 */
	uint32_t	inv_l_key;
	uint64_t	reserved64;
	uint8_t	reserved128[16];
} sq_localinvalidate_hdr_t, *psq_localinvalidate_hdr_t;

/* FR-PMR SQ WQE */
/* sq_fr_pmr (size:1024b/128B) */

typedef struct sq_fr_pmr {
	/* This field defines the type of SQ WQE. */
	uint8_t	wqe_type;
	/*
	 * FR-PMR (Fast Register Physical Memory Region)
	 *
	 * Allowed only on reliable connection (RC) SQs.
	 */
	#define SQ_FR_PMR_WQE_TYPE_FR_PMR UINT32_C(0xd)
	#define SQ_FR_PMR_WQE_TYPE_LAST  SQ_FR_PMR_WQE_TYPE_FR_PMR
	uint8_t	flags;
	/*
	 * Set if completion signaling is requested. If this bit is
	 * 0, and the SQ is configured to support Unsignaled
	 * completion the controller should not generate a CQE
	 * unless there was an error. This refers to CQE on the
	 * sender side (se_flag refers to the receiver side)
	 */
	#define SQ_FR_PMR_FLAGS_SIGNAL_COMP		UINT32_C(0x1)
	/*
	 * Indication to complete all previous RDMA Read or Atomic
	 * WQEs on the SQ before executing this WQE
	 */
	#define SQ_FR_PMR_FLAGS_RD_OR_ATOMIC_FENCE	UINT32_C(0x2)
	/*
	 * Unconditional fence. Indication to complete all previous
	 * SQ's WQEs before executing this WQE.
	 */
	#define SQ_FR_PMR_FLAGS_UC_FENCE		UINT32_C(0x4)
	/* Not Applicable for FR_PMR. Nothing is sent */
	#define SQ_FR_PMR_FLAGS_SE			UINT32_C(0x8)
	/* NA */
	#define SQ_FR_PMR_FLAGS_INLINE		UINT32_C(0x10)
	/*
	 * This flag is not applicable and should be 0 for a local memory
	 * operation WQE.
	 */
	#define SQ_FR_PMR_FLAGS_WQE_TS_EN		UINT32_C(0x20)
	/*
	 * When set to '1', this operation will cause a trace capture in
	 * each block it passes through.
	 */
	#define SQ_FR_PMR_FLAGS_DEBUG_TRACE		UINT32_C(0x40)
	/*
	 * This is the new access control for the MR.  '1' means
	 * the operation is allowed.  '0' means operation is
	 * not allowed.
	 */
	uint8_t	access_cntl;
	/* Local Write Access */
	#define SQ_FR_PMR_ACCESS_CNTL_LOCAL_WRITE	UINT32_C(0x1)
	/* Remote Read Access */
	#define SQ_FR_PMR_ACCESS_CNTL_REMOTE_READ	UINT32_C(0x2)
	/* Remote Write Access */
	#define SQ_FR_PMR_ACCESS_CNTL_REMOTE_WRITE	UINT32_C(0x4)
	/* Remote Atomic Access */
	#define SQ_FR_PMR_ACCESS_CNTL_REMOTE_ATOMIC	UINT32_C(0x8)
	/* Window Binding Allowed */
	#define SQ_FR_PMR_ACCESS_CNTL_WINDOW_BIND	UINT32_C(0x10)
	uint8_t	zero_based_page_size_log;
	/* Page size. 0 for 4KB page size, ... to 8TB. */
	#define SQ_FR_PMR_PAGE_SIZE_LOG_MASK	UINT32_C(0x1f)
	#define SQ_FR_PMR_PAGE_SIZE_LOG_SFT	0
	/* Page size is 4KB. */
		#define SQ_FR_PMR_PAGE_SIZE_LOG_PGSZ_4K	UINT32_C(0x0)
	/* Page size is 8KB. */
		#define SQ_FR_PMR_PAGE_SIZE_LOG_PGSZ_8K	UINT32_C(0x1)
	/* Page size is 16KB. */
		#define SQ_FR_PMR_PAGE_SIZE_LOG_PGSZ_16K   UINT32_C(0x2)
	/* Page size is 32KB. */
		#define SQ_FR_PMR_PAGE_SIZE_LOG_PGSZ_32K   UINT32_C(0x3)
	/* Page size is 64KB. */
		#define SQ_FR_PMR_PAGE_SIZE_LOG_PGSZ_64K   UINT32_C(0x4)
	/* Page size is 128KB. */
		#define SQ_FR_PMR_PAGE_SIZE_LOG_PGSZ_128K  UINT32_C(0x5)
	/* Page size is 256KB. */
		#define SQ_FR_PMR_PAGE_SIZE_LOG_PGSZ_256K  UINT32_C(0x6)
	/* Page size is 512KB. */
		#define SQ_FR_PMR_PAGE_SIZE_LOG_PGSZ_512K  UINT32_C(0x7)
	/* Page size is 1MB. */
		#define SQ_FR_PMR_PAGE_SIZE_LOG_PGSZ_1M	UINT32_C(0x8)
	/* Page size is 2MB. */
		#define SQ_FR_PMR_PAGE_SIZE_LOG_PGSZ_2M	UINT32_C(0x9)
	/* Page size is 4MB. */
		#define SQ_FR_PMR_PAGE_SIZE_LOG_PGSZ_4M	UINT32_C(0xa)
	/* Page size is 8MB. */
		#define SQ_FR_PMR_PAGE_SIZE_LOG_PGSZ_8M	UINT32_C(0xb)
	/* Page size is 16MB. */
		#define SQ_FR_PMR_PAGE_SIZE_LOG_PGSZ_16M   UINT32_C(0xc)
	/* Page size is 32MB. */
		#define SQ_FR_PMR_PAGE_SIZE_LOG_PGSZ_32M   UINT32_C(0xd)
	/* Page size is 64MB. */
		#define SQ_FR_PMR_PAGE_SIZE_LOG_PGSZ_64M   UINT32_C(0xe)
	/* Page size is 128MB. */
		#define SQ_FR_PMR_PAGE_SIZE_LOG_PGSZ_128M  UINT32_C(0xf)
	/* Page size is 256MB. */
		#define SQ_FR_PMR_PAGE_SIZE_LOG_PGSZ_256M  UINT32_C(0x10)
	/* Page size is 512MB. */
		#define SQ_FR_PMR_PAGE_SIZE_LOG_PGSZ_512M  UINT32_C(0x11)
	/* Page size is 1GB. */
		#define SQ_FR_PMR_PAGE_SIZE_LOG_PGSZ_1G	UINT32_C(0x12)
	/* Page size is 2GB. */
		#define SQ_FR_PMR_PAGE_SIZE_LOG_PGSZ_2G	UINT32_C(0x13)
	/* Page size is 4GB. */
		#define SQ_FR_PMR_PAGE_SIZE_LOG_PGSZ_4G	UINT32_C(0x14)
	/* Page size is 8GB. */
		#define SQ_FR_PMR_PAGE_SIZE_LOG_PGSZ_8G	UINT32_C(0x15)
	/* Page size is 16GB. */
		#define SQ_FR_PMR_PAGE_SIZE_LOG_PGSZ_16G   UINT32_C(0x16)
	/* Page size is 32GB. */
		#define SQ_FR_PMR_PAGE_SIZE_LOG_PGSZ_32G   UINT32_C(0x17)
	/* Page size is 64GB. */
		#define SQ_FR_PMR_PAGE_SIZE_LOG_PGSZ_64G   UINT32_C(0x18)
	/* Page size is 128GB. */
		#define SQ_FR_PMR_PAGE_SIZE_LOG_PGSZ_128G  UINT32_C(0x19)
	/* Page size is 256GB. */
		#define SQ_FR_PMR_PAGE_SIZE_LOG_PGSZ_256G  UINT32_C(0x1a)
	/* Page size is 512GB. */
		#define SQ_FR_PMR_PAGE_SIZE_LOG_PGSZ_512G  UINT32_C(0x1b)
	/* Page size is 1TB. */
		#define SQ_FR_PMR_PAGE_SIZE_LOG_PGSZ_1T	UINT32_C(0x1c)
	/* Page size is 2TB. */
		#define SQ_FR_PMR_PAGE_SIZE_LOG_PGSZ_2T	UINT32_C(0x1d)
	/* Page size is 4TB. */
		#define SQ_FR_PMR_PAGE_SIZE_LOG_PGSZ_4T	UINT32_C(0x1e)
	/* Page size is 8TB. */
		#define SQ_FR_PMR_PAGE_SIZE_LOG_PGSZ_8T	UINT32_C(0x1f)
		#define SQ_FR_PMR_PAGE_SIZE_LOG_LAST	SQ_FR_PMR_PAGE_SIZE_LOG_PGSZ_8T
	/* Indicate the MR is ZBVA (Zero Base VA) */
	#define SQ_FR_PMR_ZERO_BASED		UINT32_C(0x20)
	/*
	 * Local Key; 24 msb of the key are used to index the MRW
	 * table, 8 lsb are assigned to the 8 bit key_lsb field in
	 * the MRWC.
	 */
	uint32_t	l_key;
	/* Length in bytes of registered MR */
	uint8_t	length[5];
	uint8_t	reserved8_1;
	uint8_t	reserved8_2;
	uint8_t	numlevels_pbl_page_size_log;
	/* PBL page size. 0 for 4KB page size, ... to 8TB. */
	#define SQ_FR_PMR_PBL_PAGE_SIZE_LOG_MASK	UINT32_C(0x1f)
	#define SQ_FR_PMR_PBL_PAGE_SIZE_LOG_SFT	0
	/* Page size is 4KB. */
		#define SQ_FR_PMR_PBL_PAGE_SIZE_LOG_PGSZ_4K	UINT32_C(0x0)
	/* Page size is 8KB. */
		#define SQ_FR_PMR_PBL_PAGE_SIZE_LOG_PGSZ_8K	UINT32_C(0x1)
	/* Page size is 16KB. */
		#define SQ_FR_PMR_PBL_PAGE_SIZE_LOG_PGSZ_16K   UINT32_C(0x2)
	/* Page size is 32KB. */
		#define SQ_FR_PMR_PBL_PAGE_SIZE_LOG_PGSZ_32K   UINT32_C(0x3)
	/* Page size is 64KB. */
		#define SQ_FR_PMR_PBL_PAGE_SIZE_LOG_PGSZ_64K   UINT32_C(0x4)
	/* Page size is 128KB. */
		#define SQ_FR_PMR_PBL_PAGE_SIZE_LOG_PGSZ_128K  UINT32_C(0x5)
	/* Page size is 256KB. */
		#define SQ_FR_PMR_PBL_PAGE_SIZE_LOG_PGSZ_256K  UINT32_C(0x6)
	/* Page size is 512KB. */
		#define SQ_FR_PMR_PBL_PAGE_SIZE_LOG_PGSZ_512K  UINT32_C(0x7)
	/* Page size is 1MB. */
		#define SQ_FR_PMR_PBL_PAGE_SIZE_LOG_PGSZ_1M	UINT32_C(0x8)
	/* Page size is 2MB. */
		#define SQ_FR_PMR_PBL_PAGE_SIZE_LOG_PGSZ_2M	UINT32_C(0x9)
	/* Page size is 4MB. */
		#define SQ_FR_PMR_PBL_PAGE_SIZE_LOG_PGSZ_4M	UINT32_C(0xa)
	/* Page size is 8MB. */
		#define SQ_FR_PMR_PBL_PAGE_SIZE_LOG_PGSZ_8M	UINT32_C(0xb)
	/* Page size is 16MB. */
		#define SQ_FR_PMR_PBL_PAGE_SIZE_LOG_PGSZ_16M   UINT32_C(0xc)
	/* Page size is 32MB. */
		#define SQ_FR_PMR_PBL_PAGE_SIZE_LOG_PGSZ_32M   UINT32_C(0xd)
	/* Page size is 64MB. */
		#define SQ_FR_PMR_PBL_PAGE_SIZE_LOG_PGSZ_64M   UINT32_C(0xe)
	/* Page size is 128MB. */
		#define SQ_FR_PMR_PBL_PAGE_SIZE_LOG_PGSZ_128M  UINT32_C(0xf)
	/* Page size is 256MB. */
		#define SQ_FR_PMR_PBL_PAGE_SIZE_LOG_PGSZ_256M  UINT32_C(0x10)
	/* Page size is 512MB. */
		#define SQ_FR_PMR_PBL_PAGE_SIZE_LOG_PGSZ_512M  UINT32_C(0x11)
	/* Page size is 1GB. */
		#define SQ_FR_PMR_PBL_PAGE_SIZE_LOG_PGSZ_1G	UINT32_C(0x12)
	/* Page size is 2GB. */
		#define SQ_FR_PMR_PBL_PAGE_SIZE_LOG_PGSZ_2G	UINT32_C(0x13)
	/* Page size is 4GB. */
		#define SQ_FR_PMR_PBL_PAGE_SIZE_LOG_PGSZ_4G	UINT32_C(0x14)
	/* Page size is 8GB. */
		#define SQ_FR_PMR_PBL_PAGE_SIZE_LOG_PGSZ_8G	UINT32_C(0x15)
	/* Page size is 16GB. */
		#define SQ_FR_PMR_PBL_PAGE_SIZE_LOG_PGSZ_16G   UINT32_C(0x16)
	/* Page size is 32GB. */
		#define SQ_FR_PMR_PBL_PAGE_SIZE_LOG_PGSZ_32G   UINT32_C(0x17)
	/* Page size is 64GB. */
		#define SQ_FR_PMR_PBL_PAGE_SIZE_LOG_PGSZ_64G   UINT32_C(0x18)
	/* Page size is 128GB. */
		#define SQ_FR_PMR_PBL_PAGE_SIZE_LOG_PGSZ_128G  UINT32_C(0x19)
	/* Page size is 256GB. */
		#define SQ_FR_PMR_PBL_PAGE_SIZE_LOG_PGSZ_256G  UINT32_C(0x1a)
	/* Page size is 512GB. */
		#define SQ_FR_PMR_PBL_PAGE_SIZE_LOG_PGSZ_512G  UINT32_C(0x1b)
	/* Page size is 1TB. */
		#define SQ_FR_PMR_PBL_PAGE_SIZE_LOG_PGSZ_1T	UINT32_C(0x1c)
	/* Page size is 2TB. */
		#define SQ_FR_PMR_PBL_PAGE_SIZE_LOG_PGSZ_2T	UINT32_C(0x1d)
	/* Page size is 4TB. */
		#define SQ_FR_PMR_PBL_PAGE_SIZE_LOG_PGSZ_4T	UINT32_C(0x1e)
	/* Page size is 8TB. */
		#define SQ_FR_PMR_PBL_PAGE_SIZE_LOG_PGSZ_8T	UINT32_C(0x1f)
		#define SQ_FR_PMR_PBL_PAGE_SIZE_LOG_LAST	SQ_FR_PMR_PBL_PAGE_SIZE_LOG_PGSZ_8T
	/* Number of levels of PBL for translation */
	#define SQ_FR_PMR_NUMLEVELS_MASK		UINT32_C(0xc0)
	#define SQ_FR_PMR_NUMLEVELS_SFT		6
	/*
	 * A zero level PBL means that the VA is the physical address used
	 * for the operation.  No translation is done by the PTU.
	 */
		#define SQ_FR_PMR_NUMLEVELS_PHYSICAL	(UINT32_C(0x0) << 6)
	/*
	 * A one layer translation is provided between the logical and
	 * physical address.  The PBL points to a physical page that contains
	 * PBE values that point to actual pg_size physical pages.
	 */
		#define SQ_FR_PMR_NUMLEVELS_LAYER1		(UINT32_C(0x1) << 6)
	/*
	 * A two layer translation is provided between the logical and
	 * physical address. The PBL points to a physical page that contains
	 * PDE values that in turn point to pbl_pg_size physical pages that contain
	 * PBE values that point to actual physical pages.
	 */
		#define SQ_FR_PMR_NUMLEVELS_LAYER2		(UINT32_C(0x2) << 6)
		#define SQ_FR_PMR_NUMLEVELS_LAST		SQ_FR_PMR_NUMLEVELS_LAYER2
	/* Pointer to the PBL, or PDL depending on number of levels */
	uint64_t	pblptr;
	/* Local Virtual Address */
	uint64_t	va;
	/* The data field for FR-PMR is not used. */
	uint32_t	data[24];
} sq_fr_pmr_t, *psq_fr_pmr_t;

/* FR-PMR SQ WQE header. */
/* sq_fr_pmr_hdr (size:256b/32B) */

typedef struct sq_fr_pmr_hdr {
	/* This field defines the type of SQ WQE. */
	uint8_t	wqe_type;
	/*
	 * FR-PMR (Fast Register Physical Memory Region)
	 *
	 * Allowed only on reliable connection (RC) SQs.
	 */
	#define SQ_FR_PMR_HDR_WQE_TYPE_FR_PMR UINT32_C(0xd)
	#define SQ_FR_PMR_HDR_WQE_TYPE_LAST  SQ_FR_PMR_HDR_WQE_TYPE_FR_PMR
	uint8_t	flags;
	/*
	 * Set if completion signaling is requested. If this bit is
	 * 0, and the SQ is configured to support Unsignaled
	 * completion the controller should not generate a CQE
	 * unless there was an error. This refers to CQE on the
	 * sender side (se_flag refers to the receiver side)
	 */
	#define SQ_FR_PMR_HDR_FLAGS_SIGNAL_COMP		UINT32_C(0x1)
	/*
	 * Indication to complete all previous RDMA Read or Atomic
	 * WQEs on the SQ before executing this WQE
	 */
	#define SQ_FR_PMR_HDR_FLAGS_RD_OR_ATOMIC_FENCE	UINT32_C(0x2)
	/*
	 * Unconditional fence. Indication to complete all previous
	 * SQ's WQEs before executing this WQE.
	 */
	#define SQ_FR_PMR_HDR_FLAGS_UC_FENCE		UINT32_C(0x4)
	/* Not Applicable for FR_PMR. Nothing is sent */
	#define SQ_FR_PMR_HDR_FLAGS_SE			UINT32_C(0x8)
	/* NA */
	#define SQ_FR_PMR_HDR_FLAGS_INLINE		UINT32_C(0x10)
	/*
	 * This flag is not applicable and should be 0 for a local memory
	 * operation WQE.
	 */
	#define SQ_FR_PMR_HDR_FLAGS_WQE_TS_EN		UINT32_C(0x20)
	/*
	 * When set to '1', this operation will cause a trace capture in
	 * each block it passes through.
	 */
	#define SQ_FR_PMR_HDR_FLAGS_DEBUG_TRACE		UINT32_C(0x40)
	/*
	 * This is the new access control for the MR.  '1' means
	 * the operation is allowed.  '0' means operation is
	 * not allowed.
	 */
	uint8_t	access_cntl;
	/* Local Write Access */
	#define SQ_FR_PMR_HDR_ACCESS_CNTL_LOCAL_WRITE	UINT32_C(0x1)
	/* Remote Read Access */
	#define SQ_FR_PMR_HDR_ACCESS_CNTL_REMOTE_READ	UINT32_C(0x2)
	/* Remote Write Access */
	#define SQ_FR_PMR_HDR_ACCESS_CNTL_REMOTE_WRITE	UINT32_C(0x4)
	/* Remote Atomic Access */
	#define SQ_FR_PMR_HDR_ACCESS_CNTL_REMOTE_ATOMIC	UINT32_C(0x8)
	/* Window Binding Allowed */
	#define SQ_FR_PMR_HDR_ACCESS_CNTL_WINDOW_BIND	UINT32_C(0x10)
	uint8_t	zero_based_page_size_log;
	/* Page size. 0 for 4KB page size, ... to 8TB. */
	#define SQ_FR_PMR_HDR_PAGE_SIZE_LOG_MASK	UINT32_C(0x1f)
	#define SQ_FR_PMR_HDR_PAGE_SIZE_LOG_SFT	0
	/* Page size is 4KB. */
		#define SQ_FR_PMR_HDR_PAGE_SIZE_LOG_PGSZ_4K	UINT32_C(0x0)
	/* Page size is 8KB. */
		#define SQ_FR_PMR_HDR_PAGE_SIZE_LOG_PGSZ_8K	UINT32_C(0x1)
	/* Page size is 16KB. */
		#define SQ_FR_PMR_HDR_PAGE_SIZE_LOG_PGSZ_16K   UINT32_C(0x2)
	/* Page size is 32KB. */
		#define SQ_FR_PMR_HDR_PAGE_SIZE_LOG_PGSZ_32K   UINT32_C(0x3)
	/* Page size is 64KB. */
		#define SQ_FR_PMR_HDR_PAGE_SIZE_LOG_PGSZ_64K   UINT32_C(0x4)
	/* Page size is 128KB. */
		#define SQ_FR_PMR_HDR_PAGE_SIZE_LOG_PGSZ_128K  UINT32_C(0x5)
	/* Page size is 256KB. */
		#define SQ_FR_PMR_HDR_PAGE_SIZE_LOG_PGSZ_256K  UINT32_C(0x6)
	/* Page size is 512KB. */
		#define SQ_FR_PMR_HDR_PAGE_SIZE_LOG_PGSZ_512K  UINT32_C(0x7)
	/* Page size is 1MB. */
		#define SQ_FR_PMR_HDR_PAGE_SIZE_LOG_PGSZ_1M	UINT32_C(0x8)
	/* Page size is 2MB. */
		#define SQ_FR_PMR_HDR_PAGE_SIZE_LOG_PGSZ_2M	UINT32_C(0x9)
	/* Page size is 4MB. */
		#define SQ_FR_PMR_HDR_PAGE_SIZE_LOG_PGSZ_4M	UINT32_C(0xa)
	/* Page size is 8MB. */
		#define SQ_FR_PMR_HDR_PAGE_SIZE_LOG_PGSZ_8M	UINT32_C(0xb)
	/* Page size is 16MB. */
		#define SQ_FR_PMR_HDR_PAGE_SIZE_LOG_PGSZ_16M   UINT32_C(0xc)
	/* Page size is 32MB. */
		#define SQ_FR_PMR_HDR_PAGE_SIZE_LOG_PGSZ_32M   UINT32_C(0xd)
	/* Page size is 64MB. */
		#define SQ_FR_PMR_HDR_PAGE_SIZE_LOG_PGSZ_64M   UINT32_C(0xe)
	/* Page size is 128MB. */
		#define SQ_FR_PMR_HDR_PAGE_SIZE_LOG_PGSZ_128M  UINT32_C(0xf)
	/* Page size is 256MB. */
		#define SQ_FR_PMR_HDR_PAGE_SIZE_LOG_PGSZ_256M  UINT32_C(0x10)
	/* Page size is 512MB. */
		#define SQ_FR_PMR_HDR_PAGE_SIZE_LOG_PGSZ_512M  UINT32_C(0x11)
	/* Page size is 1GB. */
		#define SQ_FR_PMR_HDR_PAGE_SIZE_LOG_PGSZ_1G	UINT32_C(0x12)
	/* Page size is 2GB. */
		#define SQ_FR_PMR_HDR_PAGE_SIZE_LOG_PGSZ_2G	UINT32_C(0x13)
	/* Page size is 4GB. */
		#define SQ_FR_PMR_HDR_PAGE_SIZE_LOG_PGSZ_4G	UINT32_C(0x14)
	/* Page size is 8GB. */
		#define SQ_FR_PMR_HDR_PAGE_SIZE_LOG_PGSZ_8G	UINT32_C(0x15)
	/* Page size is 16GB. */
		#define SQ_FR_PMR_HDR_PAGE_SIZE_LOG_PGSZ_16G   UINT32_C(0x16)
	/* Page size is 32GB. */
		#define SQ_FR_PMR_HDR_PAGE_SIZE_LOG_PGSZ_32G   UINT32_C(0x17)
	/* Page size is 64GB. */
		#define SQ_FR_PMR_HDR_PAGE_SIZE_LOG_PGSZ_64G   UINT32_C(0x18)
	/* Page size is 128GB. */
		#define SQ_FR_PMR_HDR_PAGE_SIZE_LOG_PGSZ_128G  UINT32_C(0x19)
	/* Page size is 256GB. */
		#define SQ_FR_PMR_HDR_PAGE_SIZE_LOG_PGSZ_256G  UINT32_C(0x1a)
	/* Page size is 512GB. */
		#define SQ_FR_PMR_HDR_PAGE_SIZE_LOG_PGSZ_512G  UINT32_C(0x1b)
	/* Page size is 1TB. */
		#define SQ_FR_PMR_HDR_PAGE_SIZE_LOG_PGSZ_1T	UINT32_C(0x1c)
	/* Page size is 2TB. */
		#define SQ_FR_PMR_HDR_PAGE_SIZE_LOG_PGSZ_2T	UINT32_C(0x1d)
	/* Page size is 4TB. */
		#define SQ_FR_PMR_HDR_PAGE_SIZE_LOG_PGSZ_4T	UINT32_C(0x1e)
	/* Page size is 8TB. */
		#define SQ_FR_PMR_HDR_PAGE_SIZE_LOG_PGSZ_8T	UINT32_C(0x1f)
		#define SQ_FR_PMR_HDR_PAGE_SIZE_LOG_LAST	SQ_FR_PMR_HDR_PAGE_SIZE_LOG_PGSZ_8T
	/* Indicate the MR is ZBVA (Zero Base VA) */
	#define SQ_FR_PMR_HDR_ZERO_BASED		UINT32_C(0x20)
	/*
	 * Local Key; 24 msb of the key are used to index the MRW
	 * table, 8 lsb are assigned to the 8 bit key_lsb field in
	 * the MRWC.
	 */
	uint32_t	l_key;
	/* Length in bytes of registered MR */
	uint8_t	length[5];
	uint8_t	reserved8_1;
	uint8_t	reserved8_2;
	uint8_t	numlevels_pbl_page_size_log;
	/* PBL page size. 0 for 4KB page size, ... to 8TB. */
	#define SQ_FR_PMR_HDR_PBL_PAGE_SIZE_LOG_MASK	UINT32_C(0x1f)
	#define SQ_FR_PMR_HDR_PBL_PAGE_SIZE_LOG_SFT	0
	/* Page size is 4KB. */
		#define SQ_FR_PMR_HDR_PBL_PAGE_SIZE_LOG_PGSZ_4K	UINT32_C(0x0)
	/* Page size is 8KB. */
		#define SQ_FR_PMR_HDR_PBL_PAGE_SIZE_LOG_PGSZ_8K	UINT32_C(0x1)
	/* Page size is 16KB. */
		#define SQ_FR_PMR_HDR_PBL_PAGE_SIZE_LOG_PGSZ_16K   UINT32_C(0x2)
	/* Page size is 32KB. */
		#define SQ_FR_PMR_HDR_PBL_PAGE_SIZE_LOG_PGSZ_32K   UINT32_C(0x3)
	/* Page size is 64KB. */
		#define SQ_FR_PMR_HDR_PBL_PAGE_SIZE_LOG_PGSZ_64K   UINT32_C(0x4)
	/* Page size is 128KB. */
		#define SQ_FR_PMR_HDR_PBL_PAGE_SIZE_LOG_PGSZ_128K  UINT32_C(0x5)
	/* Page size is 256KB. */
		#define SQ_FR_PMR_HDR_PBL_PAGE_SIZE_LOG_PGSZ_256K  UINT32_C(0x6)
	/* Page size is 512KB. */
		#define SQ_FR_PMR_HDR_PBL_PAGE_SIZE_LOG_PGSZ_512K  UINT32_C(0x7)
	/* Page size is 1MB. */
		#define SQ_FR_PMR_HDR_PBL_PAGE_SIZE_LOG_PGSZ_1M	UINT32_C(0x8)
	/* Page size is 2MB. */
		#define SQ_FR_PMR_HDR_PBL_PAGE_SIZE_LOG_PGSZ_2M	UINT32_C(0x9)
	/* Page size is 4MB. */
		#define SQ_FR_PMR_HDR_PBL_PAGE_SIZE_LOG_PGSZ_4M	UINT32_C(0xa)
	/* Page size is 8MB. */
		#define SQ_FR_PMR_HDR_PBL_PAGE_SIZE_LOG_PGSZ_8M	UINT32_C(0xb)
	/* Page size is 16MB. */
		#define SQ_FR_PMR_HDR_PBL_PAGE_SIZE_LOG_PGSZ_16M   UINT32_C(0xc)
	/* Page size is 32MB. */
		#define SQ_FR_PMR_HDR_PBL_PAGE_SIZE_LOG_PGSZ_32M   UINT32_C(0xd)
	/* Page size is 64MB. */
		#define SQ_FR_PMR_HDR_PBL_PAGE_SIZE_LOG_PGSZ_64M   UINT32_C(0xe)
	/* Page size is 128MB. */
		#define SQ_FR_PMR_HDR_PBL_PAGE_SIZE_LOG_PGSZ_128M  UINT32_C(0xf)
	/* Page size is 256MB. */
		#define SQ_FR_PMR_HDR_PBL_PAGE_SIZE_LOG_PGSZ_256M  UINT32_C(0x10)
	/* Page size is 512MB. */
		#define SQ_FR_PMR_HDR_PBL_PAGE_SIZE_LOG_PGSZ_512M  UINT32_C(0x11)
	/* Page size is 1GB. */
		#define SQ_FR_PMR_HDR_PBL_PAGE_SIZE_LOG_PGSZ_1G	UINT32_C(0x12)
	/* Page size is 2GB. */
		#define SQ_FR_PMR_HDR_PBL_PAGE_SIZE_LOG_PGSZ_2G	UINT32_C(0x13)
	/* Page size is 4GB. */
		#define SQ_FR_PMR_HDR_PBL_PAGE_SIZE_LOG_PGSZ_4G	UINT32_C(0x14)
	/* Page size is 8GB. */
		#define SQ_FR_PMR_HDR_PBL_PAGE_SIZE_LOG_PGSZ_8G	UINT32_C(0x15)
	/* Page size is 16GB. */
		#define SQ_FR_PMR_HDR_PBL_PAGE_SIZE_LOG_PGSZ_16G   UINT32_C(0x16)
	/* Page size is 32GB. */
		#define SQ_FR_PMR_HDR_PBL_PAGE_SIZE_LOG_PGSZ_32G   UINT32_C(0x17)
	/* Page size is 64GB. */
		#define SQ_FR_PMR_HDR_PBL_PAGE_SIZE_LOG_PGSZ_64G   UINT32_C(0x18)
	/* Page size is 128GB. */
		#define SQ_FR_PMR_HDR_PBL_PAGE_SIZE_LOG_PGSZ_128G  UINT32_C(0x19)
	/* Page size is 256GB. */
		#define SQ_FR_PMR_HDR_PBL_PAGE_SIZE_LOG_PGSZ_256G  UINT32_C(0x1a)
	/* Page size is 512GB. */
		#define SQ_FR_PMR_HDR_PBL_PAGE_SIZE_LOG_PGSZ_512G  UINT32_C(0x1b)
	/* Page size is 1TB. */
		#define SQ_FR_PMR_HDR_PBL_PAGE_SIZE_LOG_PGSZ_1T	UINT32_C(0x1c)
	/* Page size is 2TB. */
		#define SQ_FR_PMR_HDR_PBL_PAGE_SIZE_LOG_PGSZ_2T	UINT32_C(0x1d)
	/* Page size is 4TB. */
		#define SQ_FR_PMR_HDR_PBL_PAGE_SIZE_LOG_PGSZ_4T	UINT32_C(0x1e)
	/* Page size is 8TB. */
		#define SQ_FR_PMR_HDR_PBL_PAGE_SIZE_LOG_PGSZ_8T	UINT32_C(0x1f)
		#define SQ_FR_PMR_HDR_PBL_PAGE_SIZE_LOG_LAST	SQ_FR_PMR_HDR_PBL_PAGE_SIZE_LOG_PGSZ_8T
	/* Number of levels of PBL for translation */
	#define SQ_FR_PMR_HDR_NUMLEVELS_MASK		UINT32_C(0xc0)
	#define SQ_FR_PMR_HDR_NUMLEVELS_SFT		6
	/*
	 * A zero level PBL means that the VA is the physical address used
	 * for the operation.  No translation is done by the PTU.
	 */
		#define SQ_FR_PMR_HDR_NUMLEVELS_PHYSICAL	(UINT32_C(0x0) << 6)
	/*
	 * A one layer translation is provided between the logical and
	 * physical address.  The PBL points to a physical page that contains
	 * PBE values that point to actual pg_size physical pages.
	 */
		#define SQ_FR_PMR_HDR_NUMLEVELS_LAYER1		(UINT32_C(0x1) << 6)
	/*
	 * A two layer translation is provided between the logical and
	 * physical address. The PBL points to a physical page that contains
	 * PDE values that in turn point to pbl_pg_size physical pages that contain
	 * PBE values that point to actual physical pages.
	 */
		#define SQ_FR_PMR_HDR_NUMLEVELS_LAYER2		(UINT32_C(0x2) << 6)
		#define SQ_FR_PMR_HDR_NUMLEVELS_LAST		SQ_FR_PMR_HDR_NUMLEVELS_LAYER2
	/* Pointer to the PBL, or PDL depending on number of levels */
	uint64_t	pblptr;
	/* Local Virtual Address */
	uint64_t	va;
} sq_fr_pmr_hdr_t, *psq_fr_pmr_hdr_t;

/* FR-PPMR SQ WQE */
/* sq_fr_ppmr (size:1024b/128B) */

typedef struct sq_fr_ppmr {
	/* This field defines the type of SQ WQE. */
	uint8_t	wqe_type;
	/*
	 * FR-PPMR (Fast Register Proxy Physical Memory Region)
	 *
	 * Allowed only on reliable connection (RC) SQs.
	 */
	#define SQ_FR_PPMR_WQE_TYPE_FR_PPMR UINT32_C(0xf)
	#define SQ_FR_PPMR_WQE_TYPE_LAST   SQ_FR_PPMR_WQE_TYPE_FR_PPMR
	uint8_t	flags;
	/*
	 * Set if completion signaling is requested. If this bit is
	 * 0, and the SQ is configured to support Unsignaled
	 * completion the controller should not generate a CQE
	 * unless there was an error. This refers to CQE on the
	 * sender side (se_flag refers to the receiver side)
	 */
	#define SQ_FR_PPMR_FLAGS_SIGNAL_COMP		UINT32_C(0x1)
	/*
	 * Indication to complete all previous RDMA Read or Atomic
	 * WQEs on the SQ before executing this WQE
	 */
	#define SQ_FR_PPMR_FLAGS_RD_OR_ATOMIC_FENCE	UINT32_C(0x2)
	/*
	 * Unconditional fence. Indication to complete all previous
	 * SQ's WQEs before executing this WQE.
	 */
	#define SQ_FR_PPMR_FLAGS_UC_FENCE		UINT32_C(0x4)
	/* Not Applicable for FR_PPMR. Nothing is sent */
	#define SQ_FR_PPMR_FLAGS_SE			UINT32_C(0x8)
	/* NA */
	#define SQ_FR_PPMR_FLAGS_INLINE		UINT32_C(0x10)
	/*
	 * This flag is not applicable and should be 0 for a local memory
	 * operation WQE.
	 */
	#define SQ_FR_PPMR_FLAGS_WQE_TS_EN		UINT32_C(0x20)
	/*
	 * When set to '1', this operation will cause a trace capture in
	 * each block it passes through.
	 */
	#define SQ_FR_PPMR_FLAGS_DEBUG_TRACE		UINT32_C(0x40)
	/*
	 * This is the new access control for the MR.  '1' means
	 * the operation is allowed.  '0' means operation is
	 * not allowed.
	 */
	uint8_t	access_cntl;
	/* Local Write Access */
	#define SQ_FR_PPMR_ACCESS_CNTL_LOCAL_WRITE	UINT32_C(0x1)
	/* Remote Read Access */
	#define SQ_FR_PPMR_ACCESS_CNTL_REMOTE_READ	UINT32_C(0x2)
	/* Remote Write Access */
	#define SQ_FR_PPMR_ACCESS_CNTL_REMOTE_WRITE	UINT32_C(0x4)
	/* Remote Atomic Access */
	#define SQ_FR_PPMR_ACCESS_CNTL_REMOTE_ATOMIC	UINT32_C(0x8)
	/* Window Binding Allowed */
	#define SQ_FR_PPMR_ACCESS_CNTL_WINDOW_BIND	UINT32_C(0x10)
	uint8_t	zero_based_page_size_log;
	/* Page size. 0 for 4KB page size, ... to 8TB. */
	#define SQ_FR_PPMR_PAGE_SIZE_LOG_MASK	UINT32_C(0x1f)
	#define SQ_FR_PPMR_PAGE_SIZE_LOG_SFT	0
	/* Page size is 4KB. */
		#define SQ_FR_PPMR_PAGE_SIZE_LOG_PGSZ_4K	UINT32_C(0x0)
	/* Page size is 8KB. */
		#define SQ_FR_PPMR_PAGE_SIZE_LOG_PGSZ_8K	UINT32_C(0x1)
	/* Page size is 16KB. */
		#define SQ_FR_PPMR_PAGE_SIZE_LOG_PGSZ_16K   UINT32_C(0x2)
	/* Page size is 32KB. */
		#define SQ_FR_PPMR_PAGE_SIZE_LOG_PGSZ_32K   UINT32_C(0x3)
	/* Page size is 64KB. */
		#define SQ_FR_PPMR_PAGE_SIZE_LOG_PGSZ_64K   UINT32_C(0x4)
	/* Page size is 128KB. */
		#define SQ_FR_PPMR_PAGE_SIZE_LOG_PGSZ_128K  UINT32_C(0x5)
	/* Page size is 256KB. */
		#define SQ_FR_PPMR_PAGE_SIZE_LOG_PGSZ_256K  UINT32_C(0x6)
	/* Page size is 512KB. */
		#define SQ_FR_PPMR_PAGE_SIZE_LOG_PGSZ_512K  UINT32_C(0x7)
	/* Page size is 1MB. */
		#define SQ_FR_PPMR_PAGE_SIZE_LOG_PGSZ_1M	UINT32_C(0x8)
	/* Page size is 2MB. */
		#define SQ_FR_PPMR_PAGE_SIZE_LOG_PGSZ_2M	UINT32_C(0x9)
	/* Page size is 4MB. */
		#define SQ_FR_PPMR_PAGE_SIZE_LOG_PGSZ_4M	UINT32_C(0xa)
	/* Page size is 8MB. */
		#define SQ_FR_PPMR_PAGE_SIZE_LOG_PGSZ_8M	UINT32_C(0xb)
	/* Page size is 16MB. */
		#define SQ_FR_PPMR_PAGE_SIZE_LOG_PGSZ_16M   UINT32_C(0xc)
	/* Page size is 32MB. */
		#define SQ_FR_PPMR_PAGE_SIZE_LOG_PGSZ_32M   UINT32_C(0xd)
	/* Page size is 64MB. */
		#define SQ_FR_PPMR_PAGE_SIZE_LOG_PGSZ_64M   UINT32_C(0xe)
	/* Page size is 128MB. */
		#define SQ_FR_PPMR_PAGE_SIZE_LOG_PGSZ_128M  UINT32_C(0xf)
	/* Page size is 256MB. */
		#define SQ_FR_PPMR_PAGE_SIZE_LOG_PGSZ_256M  UINT32_C(0x10)
	/* Page size is 512MB. */
		#define SQ_FR_PPMR_PAGE_SIZE_LOG_PGSZ_512M  UINT32_C(0x11)
	/* Page size is 1GB. */
		#define SQ_FR_PPMR_PAGE_SIZE_LOG_PGSZ_1G	UINT32_C(0x12)
	/* Page size is 2GB. */
		#define SQ_FR_PPMR_PAGE_SIZE_LOG_PGSZ_2G	UINT32_C(0x13)
	/* Page size is 4GB. */
		#define SQ_FR_PPMR_PAGE_SIZE_LOG_PGSZ_4G	UINT32_C(0x14)
	/* Page size is 8GB. */
		#define SQ_FR_PPMR_PAGE_SIZE_LOG_PGSZ_8G	UINT32_C(0x15)
	/* Page size is 16GB. */
		#define SQ_FR_PPMR_PAGE_SIZE_LOG_PGSZ_16G   UINT32_C(0x16)
	/* Page size is 32GB. */
		#define SQ_FR_PPMR_PAGE_SIZE_LOG_PGSZ_32G   UINT32_C(0x17)
	/* Page size is 64GB. */
		#define SQ_FR_PPMR_PAGE_SIZE_LOG_PGSZ_64G   UINT32_C(0x18)
	/* Page size is 128GB. */
		#define SQ_FR_PPMR_PAGE_SIZE_LOG_PGSZ_128G  UINT32_C(0x19)
	/* Page size is 256GB. */
		#define SQ_FR_PPMR_PAGE_SIZE_LOG_PGSZ_256G  UINT32_C(0x1a)
	/* Page size is 512GB. */
		#define SQ_FR_PPMR_PAGE_SIZE_LOG_PGSZ_512G  UINT32_C(0x1b)
	/* Page size is 1TB. */
		#define SQ_FR_PPMR_PAGE_SIZE_LOG_PGSZ_1T	UINT32_C(0x1c)
	/* Page size is 2TB. */
		#define SQ_FR_PPMR_PAGE_SIZE_LOG_PGSZ_2T	UINT32_C(0x1d)
	/* Page size is 4TB. */
		#define SQ_FR_PPMR_PAGE_SIZE_LOG_PGSZ_4T	UINT32_C(0x1e)
	/* Page size is 8TB. */
		#define SQ_FR_PPMR_PAGE_SIZE_LOG_PGSZ_8T	UINT32_C(0x1f)
		#define SQ_FR_PPMR_PAGE_SIZE_LOG_LAST	SQ_FR_PPMR_PAGE_SIZE_LOG_PGSZ_8T
	/* Indicate the MR is ZBVA (Zero Base VA) */
	#define SQ_FR_PPMR_ZERO_BASED		UINT32_C(0x20)
	/*
	 * Local Key; 24 msb of the key are used to index the MRW
	 * table, 8 lsb are assigned to the 8 bit key_lsb field in
	 * the MRWC.
	 */
	uint32_t	l_key;
	/* Length in bytes of registered MR */
	uint32_t	length;
	/* Sets the proxy_vfid field of the physical memory region. */
	uint16_t	proxy_vfid;
	/* Sets the proxy_pfid field of the physical memory region. */
	uint8_t	proxy_pfid;
	uint8_t	numlevels_pbl_page_size_log;
	/* PBL page size. 0 for 4KB page size, ... to 8TB. */
	#define SQ_FR_PPMR_PBL_PAGE_SIZE_LOG_MASK	UINT32_C(0x1f)
	#define SQ_FR_PPMR_PBL_PAGE_SIZE_LOG_SFT	0
	/* Page size is 4KB. */
		#define SQ_FR_PPMR_PBL_PAGE_SIZE_LOG_PGSZ_4K	UINT32_C(0x0)
	/* Page size is 8KB. */
		#define SQ_FR_PPMR_PBL_PAGE_SIZE_LOG_PGSZ_8K	UINT32_C(0x1)
	/* Page size is 16KB. */
		#define SQ_FR_PPMR_PBL_PAGE_SIZE_LOG_PGSZ_16K   UINT32_C(0x2)
	/* Page size is 32KB. */
		#define SQ_FR_PPMR_PBL_PAGE_SIZE_LOG_PGSZ_32K   UINT32_C(0x3)
	/* Page size is 64KB. */
		#define SQ_FR_PPMR_PBL_PAGE_SIZE_LOG_PGSZ_64K   UINT32_C(0x4)
	/* Page size is 128KB. */
		#define SQ_FR_PPMR_PBL_PAGE_SIZE_LOG_PGSZ_128K  UINT32_C(0x5)
	/* Page size is 256KB. */
		#define SQ_FR_PPMR_PBL_PAGE_SIZE_LOG_PGSZ_256K  UINT32_C(0x6)
	/* Page size is 512KB. */
		#define SQ_FR_PPMR_PBL_PAGE_SIZE_LOG_PGSZ_512K  UINT32_C(0x7)
	/* Page size is 1MB. */
		#define SQ_FR_PPMR_PBL_PAGE_SIZE_LOG_PGSZ_1M	UINT32_C(0x8)
	/* Page size is 2MB. */
		#define SQ_FR_PPMR_PBL_PAGE_SIZE_LOG_PGSZ_2M	UINT32_C(0x9)
	/* Page size is 4MB. */
		#define SQ_FR_PPMR_PBL_PAGE_SIZE_LOG_PGSZ_4M	UINT32_C(0xa)
	/* Page size is 8MB. */
		#define SQ_FR_PPMR_PBL_PAGE_SIZE_LOG_PGSZ_8M	UINT32_C(0xb)
	/* Page size is 16MB. */
		#define SQ_FR_PPMR_PBL_PAGE_SIZE_LOG_PGSZ_16M   UINT32_C(0xc)
	/* Page size is 32MB. */
		#define SQ_FR_PPMR_PBL_PAGE_SIZE_LOG_PGSZ_32M   UINT32_C(0xd)
	/* Page size is 64MB. */
		#define SQ_FR_PPMR_PBL_PAGE_SIZE_LOG_PGSZ_64M   UINT32_C(0xe)
	/* Page size is 128MB. */
		#define SQ_FR_PPMR_PBL_PAGE_SIZE_LOG_PGSZ_128M  UINT32_C(0xf)
	/* Page size is 256MB. */
		#define SQ_FR_PPMR_PBL_PAGE_SIZE_LOG_PGSZ_256M  UINT32_C(0x10)
	/* Page size is 512MB. */
		#define SQ_FR_PPMR_PBL_PAGE_SIZE_LOG_PGSZ_512M  UINT32_C(0x11)
	/* Page size is 1GB. */
		#define SQ_FR_PPMR_PBL_PAGE_SIZE_LOG_PGSZ_1G	UINT32_C(0x12)
	/* Page size is 2GB. */
		#define SQ_FR_PPMR_PBL_PAGE_SIZE_LOG_PGSZ_2G	UINT32_C(0x13)
	/* Page size is 4GB. */
		#define SQ_FR_PPMR_PBL_PAGE_SIZE_LOG_PGSZ_4G	UINT32_C(0x14)
	/* Page size is 8GB. */
		#define SQ_FR_PPMR_PBL_PAGE_SIZE_LOG_PGSZ_8G	UINT32_C(0x15)
	/* Page size is 16GB. */
		#define SQ_FR_PPMR_PBL_PAGE_SIZE_LOG_PGSZ_16G   UINT32_C(0x16)
	/* Page size is 32GB. */
		#define SQ_FR_PPMR_PBL_PAGE_SIZE_LOG_PGSZ_32G   UINT32_C(0x17)
	/* Page size is 64GB. */
		#define SQ_FR_PPMR_PBL_PAGE_SIZE_LOG_PGSZ_64G   UINT32_C(0x18)
	/* Page size is 128GB. */
		#define SQ_FR_PPMR_PBL_PAGE_SIZE_LOG_PGSZ_128G  UINT32_C(0x19)
	/* Page size is 256GB. */
		#define SQ_FR_PPMR_PBL_PAGE_SIZE_LOG_PGSZ_256G  UINT32_C(0x1a)
	/* Page size is 512GB. */
		#define SQ_FR_PPMR_PBL_PAGE_SIZE_LOG_PGSZ_512G  UINT32_C(0x1b)
	/* Page size is 1TB. */
		#define SQ_FR_PPMR_PBL_PAGE_SIZE_LOG_PGSZ_1T	UINT32_C(0x1c)
	/* Page size is 2TB. */
		#define SQ_FR_PPMR_PBL_PAGE_SIZE_LOG_PGSZ_2T	UINT32_C(0x1d)
	/* Page size is 4TB. */
		#define SQ_FR_PPMR_PBL_PAGE_SIZE_LOG_PGSZ_4T	UINT32_C(0x1e)
	/* Page size is 8TB. */
		#define SQ_FR_PPMR_PBL_PAGE_SIZE_LOG_PGSZ_8T	UINT32_C(0x1f)
		#define SQ_FR_PPMR_PBL_PAGE_SIZE_LOG_LAST	SQ_FR_PPMR_PBL_PAGE_SIZE_LOG_PGSZ_8T
	/* Sets the proxy_vf_valid field of the physical memory region. */
	#define SQ_FR_PPMR_PROXY_VF_VALID		UINT32_C(0x20)
	/* Number of levels of PBL for translation */
	#define SQ_FR_PPMR_NUMLEVELS_MASK		UINT32_C(0xc0)
	#define SQ_FR_PPMR_NUMLEVELS_SFT		6
	/*
	 * A zero level PBL means that the VA is the physical address used
	 * for the operation.  No translation is done by the PTU.
	 */
		#define SQ_FR_PPMR_NUMLEVELS_PHYSICAL	(UINT32_C(0x0) << 6)
	/*
	 * A one layer translation is provided between the logical and
	 * physical address.  The PBL points to a physical page that contains
	 * PBE values that point to actual pg_size physical pages.
	 */
		#define SQ_FR_PPMR_NUMLEVELS_LAYER1		(UINT32_C(0x1) << 6)
	/*
	 * A two layer translation is provided between the logical and
	 * physical address. The PBL points to a physical page that contains
	 * PDE values that in turn point to pbl_pg_size physical pages that contain
	 * PBE values that point to actual physical pages.
	 */
		#define SQ_FR_PPMR_NUMLEVELS_LAYER2		(UINT32_C(0x2) << 6)
		#define SQ_FR_PPMR_NUMLEVELS_LAST		SQ_FR_PPMR_NUMLEVELS_LAYER2
	/* Pointer to the PBL, or PDL depending on number of levels */
	uint64_t	pblptr;
	/* Local Virtual Address */
	uint64_t	va;
	/* The data field for FR-PPMR is not used. */
	uint32_t	data[24];
} sq_fr_ppmr_t, *psq_fr_ppmr_t;

/* FR-PPMR SQ WQE header. */
/* sq_fr_ppmr_hdr (size:256b/32B) */

typedef struct sq_fr_ppmr_hdr {
	/* This field defines the type of SQ WQE. */
	uint8_t	wqe_type;
	/*
	 * FR-PPMR (Fast Register Proxy Physical Memory Region)
	 *
	 * Allowed only on reliable connection (RC) SQs.
	 */
	#define SQ_FR_PPMR_HDR_WQE_TYPE_FR_PPMR UINT32_C(0xf)
	#define SQ_FR_PPMR_HDR_WQE_TYPE_LAST   SQ_FR_PPMR_HDR_WQE_TYPE_FR_PPMR
	uint8_t	flags;
	/*
	 * Set if completion signaling is requested. If this bit is
	 * 0, and the SQ is configured to support Unsignaled
	 * completion the controller should not generate a CQE
	 * unless there was an error. This refers to CQE on the
	 * sender side (se_flag refers to the receiver side)
	 */
	#define SQ_FR_PPMR_HDR_FLAGS_SIGNAL_COMP		UINT32_C(0x1)
	/*
	 * Indication to complete all previous RDMA Read or Atomic
	 * WQEs on the SQ before executing this WQE
	 */
	#define SQ_FR_PPMR_HDR_FLAGS_RD_OR_ATOMIC_FENCE	UINT32_C(0x2)
	/*
	 * Unconditional fence. Indication to complete all previous
	 * SQ's WQEs before executing this WQE.
	 */
	#define SQ_FR_PPMR_HDR_FLAGS_UC_FENCE		UINT32_C(0x4)
	/* Not Applicable for FR_PPMR. Nothing is sent */
	#define SQ_FR_PPMR_HDR_FLAGS_SE			UINT32_C(0x8)
	/* NA */
	#define SQ_FR_PPMR_HDR_FLAGS_INLINE		UINT32_C(0x10)
	/*
	 * This flag is not applicable and should be 0 for a local memory
	 * operation WQE.
	 */
	#define SQ_FR_PPMR_HDR_FLAGS_WQE_TS_EN		UINT32_C(0x20)
	/*
	 * When set to '1', this operation will cause a trace capture in
	 * each block it passes through.
	 */
	#define SQ_FR_PPMR_HDR_FLAGS_DEBUG_TRACE		UINT32_C(0x40)
	/*
	 * This is the new access control for the MR.  '1' means
	 * the operation is allowed.  '0' means operation is
	 * not allowed.
	 */
	uint8_t	access_cntl;
	/* Local Write Access */
	#define SQ_FR_PPMR_HDR_ACCESS_CNTL_LOCAL_WRITE	UINT32_C(0x1)
	/* Remote Read Access */
	#define SQ_FR_PPMR_HDR_ACCESS_CNTL_REMOTE_READ	UINT32_C(0x2)
	/* Remote Write Access */
	#define SQ_FR_PPMR_HDR_ACCESS_CNTL_REMOTE_WRITE	UINT32_C(0x4)
	/* Remote Atomic Access */
	#define SQ_FR_PPMR_HDR_ACCESS_CNTL_REMOTE_ATOMIC	UINT32_C(0x8)
	/* Window Binding Allowed */
	#define SQ_FR_PPMR_HDR_ACCESS_CNTL_WINDOW_BIND	UINT32_C(0x10)
	uint8_t	zero_based_page_size_log;
	/* Page size. 0 for 4KB page size, ... to 8TB. */
	#define SQ_FR_PPMR_HDR_PAGE_SIZE_LOG_MASK	UINT32_C(0x1f)
	#define SQ_FR_PPMR_HDR_PAGE_SIZE_LOG_SFT	0
	/* Page size is 4KB. */
		#define SQ_FR_PPMR_HDR_PAGE_SIZE_LOG_PGSZ_4K	UINT32_C(0x0)
	/* Page size is 8KB. */
		#define SQ_FR_PPMR_HDR_PAGE_SIZE_LOG_PGSZ_8K	UINT32_C(0x1)
	/* Page size is 16KB. */
		#define SQ_FR_PPMR_HDR_PAGE_SIZE_LOG_PGSZ_16K   UINT32_C(0x2)
	/* Page size is 32KB. */
		#define SQ_FR_PPMR_HDR_PAGE_SIZE_LOG_PGSZ_32K   UINT32_C(0x3)
	/* Page size is 64KB. */
		#define SQ_FR_PPMR_HDR_PAGE_SIZE_LOG_PGSZ_64K   UINT32_C(0x4)
	/* Page size is 128KB. */
		#define SQ_FR_PPMR_HDR_PAGE_SIZE_LOG_PGSZ_128K  UINT32_C(0x5)
	/* Page size is 256KB. */
		#define SQ_FR_PPMR_HDR_PAGE_SIZE_LOG_PGSZ_256K  UINT32_C(0x6)
	/* Page size is 512KB. */
		#define SQ_FR_PPMR_HDR_PAGE_SIZE_LOG_PGSZ_512K  UINT32_C(0x7)
	/* Page size is 1MB. */
		#define SQ_FR_PPMR_HDR_PAGE_SIZE_LOG_PGSZ_1M	UINT32_C(0x8)
	/* Page size is 2MB. */
		#define SQ_FR_PPMR_HDR_PAGE_SIZE_LOG_PGSZ_2M	UINT32_C(0x9)
	/* Page size is 4MB. */
		#define SQ_FR_PPMR_HDR_PAGE_SIZE_LOG_PGSZ_4M	UINT32_C(0xa)
	/* Page size is 8MB. */
		#define SQ_FR_PPMR_HDR_PAGE_SIZE_LOG_PGSZ_8M	UINT32_C(0xb)
	/* Page size is 16MB. */
		#define SQ_FR_PPMR_HDR_PAGE_SIZE_LOG_PGSZ_16M   UINT32_C(0xc)
	/* Page size is 32MB. */
		#define SQ_FR_PPMR_HDR_PAGE_SIZE_LOG_PGSZ_32M   UINT32_C(0xd)
	/* Page size is 64MB. */
		#define SQ_FR_PPMR_HDR_PAGE_SIZE_LOG_PGSZ_64M   UINT32_C(0xe)
	/* Page size is 128MB. */
		#define SQ_FR_PPMR_HDR_PAGE_SIZE_LOG_PGSZ_128M  UINT32_C(0xf)
	/* Page size is 256MB. */
		#define SQ_FR_PPMR_HDR_PAGE_SIZE_LOG_PGSZ_256M  UINT32_C(0x10)
	/* Page size is 512MB. */
		#define SQ_FR_PPMR_HDR_PAGE_SIZE_LOG_PGSZ_512M  UINT32_C(0x11)
	/* Page size is 1GB. */
		#define SQ_FR_PPMR_HDR_PAGE_SIZE_LOG_PGSZ_1G	UINT32_C(0x12)
	/* Page size is 2GB. */
		#define SQ_FR_PPMR_HDR_PAGE_SIZE_LOG_PGSZ_2G	UINT32_C(0x13)
	/* Page size is 4GB. */
		#define SQ_FR_PPMR_HDR_PAGE_SIZE_LOG_PGSZ_4G	UINT32_C(0x14)
	/* Page size is 8GB. */
		#define SQ_FR_PPMR_HDR_PAGE_SIZE_LOG_PGSZ_8G	UINT32_C(0x15)
	/* Page size is 16GB. */
		#define SQ_FR_PPMR_HDR_PAGE_SIZE_LOG_PGSZ_16G   UINT32_C(0x16)
	/* Page size is 32GB. */
		#define SQ_FR_PPMR_HDR_PAGE_SIZE_LOG_PGSZ_32G   UINT32_C(0x17)
	/* Page size is 64GB. */
		#define SQ_FR_PPMR_HDR_PAGE_SIZE_LOG_PGSZ_64G   UINT32_C(0x18)
	/* Page size is 128GB. */
		#define SQ_FR_PPMR_HDR_PAGE_SIZE_LOG_PGSZ_128G  UINT32_C(0x19)
	/* Page size is 256GB. */
		#define SQ_FR_PPMR_HDR_PAGE_SIZE_LOG_PGSZ_256G  UINT32_C(0x1a)
	/* Page size is 512GB. */
		#define SQ_FR_PPMR_HDR_PAGE_SIZE_LOG_PGSZ_512G  UINT32_C(0x1b)
	/* Page size is 1TB. */
		#define SQ_FR_PPMR_HDR_PAGE_SIZE_LOG_PGSZ_1T	UINT32_C(0x1c)
	/* Page size is 2TB. */
		#define SQ_FR_PPMR_HDR_PAGE_SIZE_LOG_PGSZ_2T	UINT32_C(0x1d)
	/* Page size is 4TB. */
		#define SQ_FR_PPMR_HDR_PAGE_SIZE_LOG_PGSZ_4T	UINT32_C(0x1e)
	/* Page size is 8TB. */
		#define SQ_FR_PPMR_HDR_PAGE_SIZE_LOG_PGSZ_8T	UINT32_C(0x1f)
		#define SQ_FR_PPMR_HDR_PAGE_SIZE_LOG_LAST	SQ_FR_PPMR_HDR_PAGE_SIZE_LOG_PGSZ_8T
	/* Indicate the MR is ZBVA (Zero Base VA) */
	#define SQ_FR_PPMR_HDR_ZERO_BASED		UINT32_C(0x20)
	/*
	 * Local Key; 24 msb of the key are used to index the MRW
	 * table, 8 lsb are assigned to the 8 bit key_lsb field in
	 * the MRWC.
	 */
	uint32_t	l_key;
	/* Length in bytes of registered MR */
	uint32_t	length;
	/* Sets the proxy_vfid field of the physical memory region. */
	uint16_t	proxy_vfid;
	/* Sets the proxy_pfid field of the physical memory region. */
	uint8_t	proxy_pfid;
	uint8_t	numlevels_pbl_page_size_log;
	/* PBL page size. 0 for 4KB page size, ... to 8TB. */
	#define SQ_FR_PPMR_HDR_PBL_PAGE_SIZE_LOG_MASK	UINT32_C(0x1f)
	#define SQ_FR_PPMR_HDR_PBL_PAGE_SIZE_LOG_SFT	0
	/* Page size is 4KB. */
		#define SQ_FR_PPMR_HDR_PBL_PAGE_SIZE_LOG_PGSZ_4K	UINT32_C(0x0)
	/* Page size is 8KB. */
		#define SQ_FR_PPMR_HDR_PBL_PAGE_SIZE_LOG_PGSZ_8K	UINT32_C(0x1)
	/* Page size is 16KB. */
		#define SQ_FR_PPMR_HDR_PBL_PAGE_SIZE_LOG_PGSZ_16K   UINT32_C(0x2)
	/* Page size is 32KB. */
		#define SQ_FR_PPMR_HDR_PBL_PAGE_SIZE_LOG_PGSZ_32K   UINT32_C(0x3)
	/* Page size is 64KB. */
		#define SQ_FR_PPMR_HDR_PBL_PAGE_SIZE_LOG_PGSZ_64K   UINT32_C(0x4)
	/* Page size is 128KB. */
		#define SQ_FR_PPMR_HDR_PBL_PAGE_SIZE_LOG_PGSZ_128K  UINT32_C(0x5)
	/* Page size is 256KB. */
		#define SQ_FR_PPMR_HDR_PBL_PAGE_SIZE_LOG_PGSZ_256K  UINT32_C(0x6)
	/* Page size is 512KB. */
		#define SQ_FR_PPMR_HDR_PBL_PAGE_SIZE_LOG_PGSZ_512K  UINT32_C(0x7)
	/* Page size is 1MB. */
		#define SQ_FR_PPMR_HDR_PBL_PAGE_SIZE_LOG_PGSZ_1M	UINT32_C(0x8)
	/* Page size is 2MB. */
		#define SQ_FR_PPMR_HDR_PBL_PAGE_SIZE_LOG_PGSZ_2M	UINT32_C(0x9)
	/* Page size is 4MB. */
		#define SQ_FR_PPMR_HDR_PBL_PAGE_SIZE_LOG_PGSZ_4M	UINT32_C(0xa)
	/* Page size is 8MB. */
		#define SQ_FR_PPMR_HDR_PBL_PAGE_SIZE_LOG_PGSZ_8M	UINT32_C(0xb)
	/* Page size is 16MB. */
		#define SQ_FR_PPMR_HDR_PBL_PAGE_SIZE_LOG_PGSZ_16M   UINT32_C(0xc)
	/* Page size is 32MB. */
		#define SQ_FR_PPMR_HDR_PBL_PAGE_SIZE_LOG_PGSZ_32M   UINT32_C(0xd)
	/* Page size is 64MB. */
		#define SQ_FR_PPMR_HDR_PBL_PAGE_SIZE_LOG_PGSZ_64M   UINT32_C(0xe)
	/* Page size is 128MB. */
		#define SQ_FR_PPMR_HDR_PBL_PAGE_SIZE_LOG_PGSZ_128M  UINT32_C(0xf)
	/* Page size is 256MB. */
		#define SQ_FR_PPMR_HDR_PBL_PAGE_SIZE_LOG_PGSZ_256M  UINT32_C(0x10)
	/* Page size is 512MB. */
		#define SQ_FR_PPMR_HDR_PBL_PAGE_SIZE_LOG_PGSZ_512M  UINT32_C(0x11)
	/* Page size is 1GB. */
		#define SQ_FR_PPMR_HDR_PBL_PAGE_SIZE_LOG_PGSZ_1G	UINT32_C(0x12)
	/* Page size is 2GB. */
		#define SQ_FR_PPMR_HDR_PBL_PAGE_SIZE_LOG_PGSZ_2G	UINT32_C(0x13)
	/* Page size is 4GB. */
		#define SQ_FR_PPMR_HDR_PBL_PAGE_SIZE_LOG_PGSZ_4G	UINT32_C(0x14)
	/* Page size is 8GB. */
		#define SQ_FR_PPMR_HDR_PBL_PAGE_SIZE_LOG_PGSZ_8G	UINT32_C(0x15)
	/* Page size is 16GB. */
		#define SQ_FR_PPMR_HDR_PBL_PAGE_SIZE_LOG_PGSZ_16G   UINT32_C(0x16)
	/* Page size is 32GB. */
		#define SQ_FR_PPMR_HDR_PBL_PAGE_SIZE_LOG_PGSZ_32G   UINT32_C(0x17)
	/* Page size is 64GB. */
		#define SQ_FR_PPMR_HDR_PBL_PAGE_SIZE_LOG_PGSZ_64G   UINT32_C(0x18)
	/* Page size is 128GB. */
		#define SQ_FR_PPMR_HDR_PBL_PAGE_SIZE_LOG_PGSZ_128G  UINT32_C(0x19)
	/* Page size is 256GB. */
		#define SQ_FR_PPMR_HDR_PBL_PAGE_SIZE_LOG_PGSZ_256G  UINT32_C(0x1a)
	/* Page size is 512GB. */
		#define SQ_FR_PPMR_HDR_PBL_PAGE_SIZE_LOG_PGSZ_512G  UINT32_C(0x1b)
	/* Page size is 1TB. */
		#define SQ_FR_PPMR_HDR_PBL_PAGE_SIZE_LOG_PGSZ_1T	UINT32_C(0x1c)
	/* Page size is 2TB. */
		#define SQ_FR_PPMR_HDR_PBL_PAGE_SIZE_LOG_PGSZ_2T	UINT32_C(0x1d)
	/* Page size is 4TB. */
		#define SQ_FR_PPMR_HDR_PBL_PAGE_SIZE_LOG_PGSZ_4T	UINT32_C(0x1e)
	/* Page size is 8TB. */
		#define SQ_FR_PPMR_HDR_PBL_PAGE_SIZE_LOG_PGSZ_8T	UINT32_C(0x1f)
		#define SQ_FR_PPMR_HDR_PBL_PAGE_SIZE_LOG_LAST	SQ_FR_PPMR_HDR_PBL_PAGE_SIZE_LOG_PGSZ_8T
	/* Sets the proxy_vf_valid field of the physical memory region. */
	#define SQ_FR_PPMR_HDR_PROXY_VF_VALID		UINT32_C(0x20)
	/* Number of levels of PBL for translation */
	#define SQ_FR_PPMR_HDR_NUMLEVELS_MASK		UINT32_C(0xc0)
	#define SQ_FR_PPMR_HDR_NUMLEVELS_SFT		6
	/*
	 * A zero level PBL means that the VA is the physical address used
	 * for the operation.  No translation is done by the PTU.
	 */
		#define SQ_FR_PPMR_HDR_NUMLEVELS_PHYSICAL	(UINT32_C(0x0) << 6)
	/*
	 * A one layer translation is provided between the logical and
	 * physical address.  The PBL points to a physical page that contains
	 * PBE values that point to actual pg_size physical pages.
	 */
		#define SQ_FR_PPMR_HDR_NUMLEVELS_LAYER1		(UINT32_C(0x1) << 6)
	/*
	 * A two layer translation is provided between the logical and
	 * physical address. The PBL points to a physical page that contains
	 * PDE values that in turn point to pbl_pg_size physical pages that contain
	 * PBE values that point to actual physical pages.
	 */
		#define SQ_FR_PPMR_HDR_NUMLEVELS_LAYER2		(UINT32_C(0x2) << 6)
		#define SQ_FR_PPMR_HDR_NUMLEVELS_LAST		SQ_FR_PPMR_HDR_NUMLEVELS_LAYER2
	/* Pointer to the PBL, or PDL depending on number of levels */
	uint64_t	pblptr;
	/* Local Virtual Address */
	uint64_t	va;
} sq_fr_ppmr_hdr_t, *psq_fr_ppmr_hdr_t;

/*
 * Bind SQ WQE. This WQE can perform either:
 * * type1 "bind memory window", if mw_type==Type1
 * * type2 "post send bind memory window", if mw_type==Type2
 */
/* sq_bind (size:1024b/128B) */

typedef struct sq_bind {
	/* This field defines the type of SQ WQE. */
	uint8_t	wqe_type;
	/*
	 * Memory Bind
	 *
	 * Allowed only on reliable connection (RC) SQs.
	 */
	#define SQ_BIND_WQE_TYPE_BIND UINT32_C(0xe)
	#define SQ_BIND_WQE_TYPE_LAST SQ_BIND_WQE_TYPE_BIND
	uint8_t	flags;
	#define SQ_BIND_FLAGS_INLINE_SE_UC_FENCE_RD_OR_ATOMIC_FENCE_SIGNAL_COMP_MASK		UINT32_C(0xff)
	#define SQ_BIND_FLAGS_INLINE_SE_UC_FENCE_RD_OR_ATOMIC_FENCE_SIGNAL_COMP_SFT			0
	/*
	 * Set if completion signaling is requested. If this bit is
	 * 0, and the SQ is configured to support Unsignaled
	 * completion the controller should not generate a CQE
	 * unless there was an error. This refers to CQE on the
	 * sender side (se_flag refers to the receiver side)
	 */
	#define SQ_BIND_FLAGS_SIGNAL_COMP								UINT32_C(0x1)
	/*
	 * Indication to complete all previous RDMA Read or Atomic
	 * WQEs on the SQ before executing this WQE
	 */
	#define SQ_BIND_FLAGS_RD_OR_ATOMIC_FENCE							UINT32_C(0x2)
	/*
	 * Unconditional fence. Indication to complete all previous
	 * SQ's WQEs before executing this WQE.
	 */
	#define SQ_BIND_FLAGS_UC_FENCE								UINT32_C(0x4)
	/* NA, nothing is sent. */
	#define SQ_BIND_FLAGS_SE									UINT32_C(0x8)
	/* NA */
	#define SQ_BIND_FLAGS_INLINE								UINT32_C(0x10)
	/*
	 * This flag is not applicable and should be 0 for a local memory
	 * operation WQE.
	 */
	#define SQ_BIND_FLAGS_WQE_TS_EN								UINT32_C(0x20)
	/*
	 * When set to '1', this operation will cause a trace capture in
	 * each block it passes through.
	 */
	#define SQ_BIND_FLAGS_DEBUG_TRACE								UINT32_C(0x40)
	/*
	 * This is the new access control for the MR.  '1' means
	 * the operation is allowed.  '0' means operation is
	 * not allowed.
	 */
	uint8_t	access_cntl;
	#define SQ_BIND_ACCESS_CNTL_WINDOW_BIND_REMOTE_ATOMIC_REMOTE_WRITE_REMOTE_READ_LOCAL_WRITE_MASK		UINT32_C(0xff)
	#define SQ_BIND_ACCESS_CNTL_WINDOW_BIND_REMOTE_ATOMIC_REMOTE_WRITE_REMOTE_READ_LOCAL_WRITE_SFT		0
	/*
	 * Local Write Access.
	 *
	 * Local accesses are never allowed for memory windows, so this
	 * bit must always be zero in a bind WQE.  If this bit is ever
	 * set, the bind will fail with an errored completion.
	 */
	#define SQ_BIND_ACCESS_CNTL_LOCAL_WRITE									UINT32_C(0x1)
	/* Remote Read Access */
	#define SQ_BIND_ACCESS_CNTL_REMOTE_READ									UINT32_C(0x2)
	/*
	 * Remote Write Access.
	 *
	 * Note that, if this bit is set, then the parent region to which
	 * the window is being bound must allow local writes.  If this is not
	 * the case, then the bind will fail with an errored completion.
	 */
	#define SQ_BIND_ACCESS_CNTL_REMOTE_WRITE									UINT32_C(0x4)
	/*
	 * Remote Atomic Access.
	 *
	 * Note that, if this bit is set, then the parent region to which
	 * the window is being bound must allow local writes.  If this is not
	 * the case, then the bind will fail with an errored completion.
	 */
	#define SQ_BIND_ACCESS_CNTL_REMOTE_ATOMIC									UINT32_C(0x8)
	/*
	 * Window Binding Allowed.
	 *
	 * It is never allowed to bind windows to windows, so this bit
	 * must always be zero in a bind WQE.  If this bit is ever set,
	 * the bind will fail with an errored completion.
	 */
	#define SQ_BIND_ACCESS_CNTL_WINDOW_BIND									UINT32_C(0x10)
	/* reserved8_1 is 8 b */
	uint8_t	reserved8_1;
	uint8_t	mw_type_zero_based;
	/*
	 * If this bit is set, then the newly-bound memory window will be
	 * zero-based.  If clear, then the newly-bound memory window will be
	 * non-zero-based.
	 */
	#define SQ_BIND_ZERO_BASED	UINT32_C(0x1)
	/*
	 * If type1 is specified, then this WQE performs a "bind memory window"
	 * operation on a type1 window.  If type2 is specified, then this WQE
	 * performs a "post send bind memory window" operation on a type2
	 * window.
	 *
	 * Note that the bind WQE cannot change the type of the memory window.
	 *
	 * If a "bind memory window" operation is attempted on a memory window
	 * that was allocated as type2, then the bind will fail with an errored
	 * completion, as "bind memory window" is allowed only on type1 memory
	 * windows.
	 *
	 * Similarly, if a "post send bind memory window" operation is attempted
	 * on a memory window that was allocated as type1, then the bind will fail
	 * with an errored completions, as "post send bind memory window" is allowed
	 * only on type2 memory windows.
	 */
	#define SQ_BIND_MW_TYPE	UINT32_C(0x2)
	/* Type 1 Bind Memory Window */
		#define SQ_BIND_MW_TYPE_TYPE1	(UINT32_C(0x0) << 1)
	/* Type 2 Post Send Bind Memory Window */
		#define SQ_BIND_MW_TYPE_TYPE2	(UINT32_C(0x1) << 1)
		#define SQ_BIND_MW_TYPE_LAST	SQ_BIND_MW_TYPE_TYPE2
	uint8_t	reserved8_2;
	uint16_t	reserved16;
	/*
	 * The L_Key of the parent MR; 24 msb of the key are used to
	 * index the MRW table, 8 lsb are compared with the 8 bit key
	 * in the MRWC.
	 */
	uint32_t	parent_l_key;
	/*
	 * Local Key; 24 msb of the key are used to index the memory
	 * window being bound in the MRW table, 8 lsb are assign to the
	 * 8 bit key_lsb field in the MRWC.
	 */
	uint32_t	l_key;
	/* Local Virtual Address */
	uint64_t	va;
	/*
	 * Length in bytes of registered MW; 40 bits as this is the max
	 * size of an MR/W
	 */
	uint8_t	length[5];
	uint8_t	reserved24[3];
	/* The data field for Bind is not used. */
	uint32_t	data[24];
} sq_bind_t, *psq_bind_t;

/*
 * Bind SQ WQE header. This WQE can perform either:
 * * type1 "bind memory window", if mw_type==Type1
 * * type2 "post send bind memory window", if mw_type==Type2
 */
/* sq_bind_hdr (size:256b/32B) */

typedef struct sq_bind_hdr {
	/* This field defines the type of SQ WQE. */
	uint8_t	wqe_type;
	/*
	 * Memory Bind
	 *
	 * Allowed only on reliable connection (RC) SQs.
	 */
	#define SQ_BIND_HDR_WQE_TYPE_BIND UINT32_C(0xe)
	#define SQ_BIND_HDR_WQE_TYPE_LAST SQ_BIND_HDR_WQE_TYPE_BIND
	uint8_t	flags;
	#define SQ_BIND_HDR_FLAGS_INLINE_SE_UC_FENCE_RD_OR_ATOMIC_FENCE_SIGNAL_COMP_MASK		UINT32_C(0xff)
	#define SQ_BIND_HDR_FLAGS_INLINE_SE_UC_FENCE_RD_OR_ATOMIC_FENCE_SIGNAL_COMP_SFT			0
	/*
	 * Set if completion signaling is requested. If this bit is
	 * 0, and the SQ is configured to support Unsignaled
	 * completion the controller should not generate a CQE
	 * unless there was an error. This refers to CQE on the
	 * sender side (se_flag refers to the receiver side)
	 */
	#define SQ_BIND_HDR_FLAGS_SIGNAL_COMP								UINT32_C(0x1)
	/*
	 * Indication to complete all previous RDMA Read or Atomic
	 * WQEs on the SQ before executing this WQE
	 */
	#define SQ_BIND_HDR_FLAGS_RD_OR_ATOMIC_FENCE							UINT32_C(0x2)
	/*
	 * Unconditional fence. Indication to complete all previous
	 * SQ's WQEs before executing this WQE.
	 */
	#define SQ_BIND_HDR_FLAGS_UC_FENCE								UINT32_C(0x4)
	/* NA, nothing is sent. */
	#define SQ_BIND_HDR_FLAGS_SE									UINT32_C(0x8)
	/* NA */
	#define SQ_BIND_HDR_FLAGS_INLINE								UINT32_C(0x10)
	/*
	 * This flag is not applicable and should be 0 for a local memory
	 * operation WQE.
	 */
	#define SQ_BIND_HDR_FLAGS_WQE_TS_EN								UINT32_C(0x20)
	/*
	 * When set to '1', this operation will cause a trace capture in
	 * each block it passes through.
	 */
	#define SQ_BIND_HDR_FLAGS_DEBUG_TRACE								UINT32_C(0x40)
	/*
	 * This is the new access control for the MR.  '1' means
	 * the operation is allowed.  '0' means operation is
	 * not allowed.
	 */
	uint8_t	access_cntl;
	#define SQ_BIND_HDR_ACCESS_CNTL_WINDOW_BIND_REMOTE_ATOMIC_REMOTE_WRITE_REMOTE_READ_LOCAL_WRITE_MASK		UINT32_C(0xff)
	#define SQ_BIND_HDR_ACCESS_CNTL_WINDOW_BIND_REMOTE_ATOMIC_REMOTE_WRITE_REMOTE_READ_LOCAL_WRITE_SFT		0
	/*
	 * Local Write Access.
	 *
	 * Local accesses are never allowed for memory windows, so this
	 * bit must always be zero in a bind WQE.  If this bit is ever
	 * set, the bind will fail with an errored completion.
	 */
	#define SQ_BIND_HDR_ACCESS_CNTL_LOCAL_WRITE									UINT32_C(0x1)
	/* Remote Read Access */
	#define SQ_BIND_HDR_ACCESS_CNTL_REMOTE_READ									UINT32_C(0x2)
	/*
	 * Remote Write Access.
	 *
	 * Note that, if this bit is set, then the parent region to which
	 * the window is being bound must allow local writes.  If this is not
	 * the case, then the bind will fail with an errored completion.
	 */
	#define SQ_BIND_HDR_ACCESS_CNTL_REMOTE_WRITE									UINT32_C(0x4)
	/*
	 * Remote Atomic Access.
	 *
	 * Note that, if this bit is set, then the parent region to which
	 * the window is being bound must allow local writes.  If this is not
	 * the case, then the bind will fail with an errored completion.
	 */
	#define SQ_BIND_HDR_ACCESS_CNTL_REMOTE_ATOMIC									UINT32_C(0x8)
	/*
	 * Window Binding Allowed.
	 *
	 * It is never allowed to bind windows to windows, so this bit
	 * must always be zero in a bind WQE.  If this bit is ever set,
	 * the bind will fail with an errored completion.
	 */
	#define SQ_BIND_HDR_ACCESS_CNTL_WINDOW_BIND									UINT32_C(0x10)
	/* reserved8_1 is 8 b */
	uint8_t	reserved8_1;
	uint8_t	mw_type_zero_based;
	/*
	 * If this bit is set, then the newly-bound memory window will be
	 * zero-based.  If clear, then the newly-bound memory window will be
	 * non-zero-based.
	 */
	#define SQ_BIND_HDR_ZERO_BASED	UINT32_C(0x1)
	/*
	 * If type1 is specified, then this WQE performs a "bind memory window"
	 * operation on a type1 window.  If type2 is specified, then this WQE
	 * performs a "post send bind memory window" operation on a type2
	 * window.
	 *
	 * Note that the bind WQE cannot change the type of the memory window.
	 *
	 * If a "bind memory window" operation is attempted on a memory window
	 * that was allocated as type2, then the bind will fail with an errored
	 * completion, as "bind memory window" is allowed only on type1 memory
	 * windows.
	 *
	 * Similarly, if a "post send bind memory window" operation is attempted
	 * on a memory window that was allocated as type1, then the bind will fail
	 * with an errored completions, as "post send bind memory window" is allowed
	 * only on type2 memory windows.
	 */
	#define SQ_BIND_HDR_MW_TYPE	UINT32_C(0x2)
	/* Type 1 Bind Memory Window */
		#define SQ_BIND_HDR_MW_TYPE_TYPE1	(UINT32_C(0x0) << 1)
	/* Type 2 Post Send Bind Memory Window */
		#define SQ_BIND_HDR_MW_TYPE_TYPE2	(UINT32_C(0x1) << 1)
		#define SQ_BIND_HDR_MW_TYPE_LAST	SQ_BIND_HDR_MW_TYPE_TYPE2
	uint8_t	reserved8_2;
	uint16_t	reserved16;
	/*
	 * The L_Key of the parent MR; 24 msb of the key are used to
	 * index the MRW table, 8 lsb are compared with the 8 bit key
	 * in the MRWC.
	 */
	uint32_t	parent_l_key;
	/*
	 * Local Key; 24 msb of the key are used to index the memory
	 * window being bound in the MRW table, 8 lsb are assign to the
	 * 8 bit key_lsb field in the MRWC.
	 */
	uint32_t	l_key;
	/* Local Virtual Address */
	uint64_t	va;
	/*
	 * Length in bytes of registered MW; 40 bits as this is the max
	 * size of an MR/W
	 */
	uint8_t	length[5];
	uint8_t	reserved24[3];
} sq_bind_hdr_t, *psq_bind_hdr_t;

/* RQ/SRQ WQE */
/* rq_wqe (size:1024b/128B) */

typedef struct rq_wqe {
	/* wqe_type is 8 b */
	uint8_t	wqe_type;
	/*
	 * RQ/SRQ WQE.   This WQE is used for posting buffers on
	 * an RQ or SRQ.
	 */
	#define RQ_WQE_WQE_TYPE_RCV UINT32_C(0x80)
	#define RQ_WQE_WQE_TYPE_LAST RQ_WQE_WQE_TYPE_RCV
	/* No flags supported for this WQE type. */
	uint8_t	flags;
	/*
	 * Specify the total number 16B chunks that make up the valid
	 * portion of the WQE.  This includes the first chunk that is the
	 * WQE structure and up to 6 SGE structures.
	 *
	 * While the valid area is defined by the wqe_size field, the
	 * actual WQE size is fixed at 128B.
	 */
	uint8_t	wqe_size;
	uint8_t	reserved8;
	uint32_t	reserved32;
	uint64_t	wr_id;
	/*
	 * Opaque value used by upper layer SW to identify the id of the
	 * WR which generated the WQE. Used in CQE. Valid in the first
	 * SGE of an SRQ WQE.
	 */
	#define RQ_WQE_WR_ID_MASK UINT32_C(0xfffff)
	#define RQ_WQE_WR_ID_SFT 0
	uint8_t	reserved128[16];
	/*
	 * The data field for RQ WQE is filled with from 1 to 6 SGE
	 * structures as defined by the wqe_size field.
	 */
	uint32_t	data[24];
} rq_wqe_t, *prq_wqe_t;

/* RQ/SRQ WQE header. */
/* rq_wqe_hdr (size:256b/32B) */

typedef struct rq_wqe_hdr {
	/* wqe_type is 8 b */
	uint8_t	wqe_type;
	/*
	 * RQ/SRQ WQE.   This WQE is used for posting buffers on
	 * an RQ or SRQ.
	 */
	#define RQ_WQE_HDR_WQE_TYPE_RCV UINT32_C(0x80)
	#define RQ_WQE_HDR_WQE_TYPE_LAST RQ_WQE_HDR_WQE_TYPE_RCV
	/* No flags supported for this WQE type. */
	uint8_t	flags;
	/*
	 * Specify the total number 16B chunks that make up the valid
	 * portion of the WQE.  This includes the first chunk that is the
	 * WQE structure and up to 6 SGE structures.
	 *
	 * While the valid area is defined by the wqe_size field, the
	 * actual WQE size is fixed at 128B.
	 */
	uint8_t	wqe_size;
	uint8_t	reserved8;
	uint32_t	reserved32;
	uint64_t	wr_id;
	/*
	 * Opaque value used by upper layer SW to identify the id of the
	 * WR which generated the WQE. Used in CQE. Valid in the first
	 * SGE of an SRQ WQE.
	 */
	#define RQ_WQE_HDR_WR_ID_MASK UINT32_C(0xfffff)
	#define RQ_WQE_HDR_WR_ID_SFT 0
	uint8_t	reserved128[16];
} rq_wqe_hdr_t, *prq_wqe_hdr_t;

/* cq_base (size:256b/32B) */

typedef struct cq_base {
	uint64_t	reserved64_1;
	uint64_t	reserved64_2;
	uint64_t	reserved64_3;
	uint8_t	cqe_type_toggle;
	/*
	 * Indicate valid completion - written by the chip. Cumulus
	 * toggle this bit each time it finished consuming all PBL
	 * entries
	 */
	#define CQ_BASE_TOGGLE		UINT32_C(0x1)
	/* This field defines the type of SQ WQE. */
	#define CQ_BASE_CQE_TYPE_MASK	UINT32_C(0x1e)
	#define CQ_BASE_CQE_TYPE_SFT	1
	/*
	 * Requester completion - This is used for both RC and UD SQ
	 * completions.
	 */
		#define CQ_BASE_CQE_TYPE_REQ		(UINT32_C(0x0) << 1)
	/*
	 * Responder RC Completion - This is used for both RQ and SRQ
	 * completions for RC service QPs.
	 */
		#define CQ_BASE_CQE_TYPE_RES_RC	(UINT32_C(0x1) << 1)
	/*
	 * Responder UD Completion - This is used for both RQ and SRQ
	 * completion for UD service QPs.
	 */
		#define CQ_BASE_CQE_TYPE_RES_UD	(UINT32_C(0x2) << 1)
	/*
	 * Responder RawEth and QP1 Completion - This is used for RQ
	 * completion for RawEth service and QP1 service QPs.
	 */
		#define CQ_BASE_CQE_TYPE_RES_RAWETH_QP1  (UINT32_C(0x3) << 1)
	/*
	 * Responder UD completion with CFA. This is used for both RQ
	 * and SQ completion for UD service QPs. It includes cfa fields
	 * (some of which carry VLAN information), in place of QP handle.
	 */
		#define CQ_BASE_CQE_TYPE_RES_UD_CFA	(UINT32_C(0x4) << 1)
	/*
	 * NO_OP completion - This is used to indicate that no
	 * operation completion.
	 */
		#define CQ_BASE_CQE_TYPE_NO_OP	(UINT32_C(0xd) << 1)
	/*
	 * Terminal completion - This is used to indicate that no
	 * further completions will be made for this QP on this CQ.
	 */
		#define CQ_BASE_CQE_TYPE_TERMINAL	(UINT32_C(0xe) << 1)
	/* Cut off CQE; for CQ resize see CQ and SRQ Resize */
		#define CQ_BASE_CQE_TYPE_CUT_OFF	(UINT32_C(0xf) << 1)
		#define CQ_BASE_CQE_TYPE_LAST	CQ_BASE_CQE_TYPE_CUT_OFF
	/* This field indicates the status for the CQE. */
	uint8_t	status;
	uint16_t	reserved16;
	uint32_t	reserved32;
} cq_base_t, *pcq_base_t;

/* Requester CQ CQE */
/* cq_req (size:256b/32B) */

typedef struct cq_req {
	/*
	 * This is an application level ID used to identify the
	 * QP and its SQ and RQ.
	 */
	uint64_t	qp_handle;
	/*
	 * SQ Consumer Index - points to the entry just past the last WQE
	 * that has been completed by the chip.  Wraps around at
	 * QPC.sq_size (i.e. the valid range of the SQ Consumer Index is 0
	 * to (QPC.sq_size - 1)).
	 */
	uint16_t	sq_cons_idx;
	uint16_t	reserved16_1;
	uint32_t	reserved32_2;
	uint64_t	reserved64;
	uint8_t	cqe_type_toggle;
	/*
	 * Indicate valid completion - written by the chip. Cumulus
	 * toggle this bit each time it finished consuming all PBL
	 * entries
	 */
	#define CQ_REQ_TOGGLE	UINT32_C(0x1)
	/* This field defines the type of SQ WQE. */
	#define CQ_REQ_CQE_TYPE_MASK UINT32_C(0x1e)
	#define CQ_REQ_CQE_TYPE_SFT 1
	/*
	 * Requester completion - This is used for both RC and UD SQ
	 * completions.
	 */
		#define CQ_REQ_CQE_TYPE_REQ   (UINT32_C(0x0) << 1)
		#define CQ_REQ_CQE_TYPE_LAST CQ_REQ_CQE_TYPE_REQ
	/*
	 * When this bit is '1', it indicates that the packet completed
	 * was transmitted using the push accelerated data provided by
	 * the driver. When this bit is '0', it indicates that the packet
	 * had not push acceleration data written or was executed as a
	 * normal packet even though push data was provided.
	 * This field is intended to be used for driver-generated push
	 * statistics. It is not applicable for RC since not all RC packets
	 * return a CQE.
	 */
	#define CQ_REQ_PUSH	UINT32_C(0x20)
	/* This field indicates the status for the CQE. */
	uint8_t	status;
	/* OK is 0 */
	#define CQ_REQ_STATUS_OK			UINT32_C(0x0)
	/* BAD_RESPONSE_ERR is 1 */
	#define CQ_REQ_STATUS_BAD_RESPONSE_ERR	UINT32_C(0x1)
	/* LOCAL_LENGTH_ERR is 2 */
	#define CQ_REQ_STATUS_LOCAL_LENGTH_ERR	UINT32_C(0x2)
	/* LOCAL_QP_OPERATION_ERR is 3 */
	#define CQ_REQ_STATUS_LOCAL_QP_OPERATION_ERR	UINT32_C(0x3)
	/* LOCAL_PROTECTION_ERR is 4 */
	#define CQ_REQ_STATUS_LOCAL_PROTECTION_ERR	UINT32_C(0x4)
	/* MEMORY_MGT_OPERATION_ERR is 5 */
	#define CQ_REQ_STATUS_MEMORY_MGT_OPERATION_ERR   UINT32_C(0x5)
	/* REMOTE_INVALID_REQUEST_ERR is 6 */
	#define CQ_REQ_STATUS_REMOTE_INVALID_REQUEST_ERR UINT32_C(0x6)
	/* REMOTE_ACCESS_ERR is 7 */
	#define CQ_REQ_STATUS_REMOTE_ACCESS_ERR	UINT32_C(0x7)
	/* REMOTE_OPERATION_ERR is 8 */
	#define CQ_REQ_STATUS_REMOTE_OPERATION_ERR	UINT32_C(0x8)
	/* RNR_NAK_RETRY_CNT_ERR is 9 */
	#define CQ_REQ_STATUS_RNR_NAK_RETRY_CNT_ERR	UINT32_C(0x9)
	/* TRANSPORT_RETRY_CNT_ERR is 10 */
	#define CQ_REQ_STATUS_TRANSPORT_RETRY_CNT_ERR	UINT32_C(0xa)
	/* WORK_REQUEST_FLUSHED_ERR is 11 */
	#define CQ_REQ_STATUS_WORK_REQUEST_FLUSHED_ERR   UINT32_C(0xb)
	#define CQ_REQ_STATUS_LAST			CQ_REQ_STATUS_WORK_REQUEST_FLUSHED_ERR
	uint16_t	reserved16_2;
	uint32_t	reserved32_1;
} cq_req_t, *pcq_req_t;

/* Responder RC CQE */
/* cq_res_rc (size:256b/32B) */

typedef struct cq_res_rc {
	/*
	 * The length of the message's payload in bytes, stored in
	 * the SGEs
	 */
	uint32_t	length;
	/*
	 * Immediate data in case the imm_flag set, R_Key to be
	 * invalidated in case inv_flag is set.
	 */
	uint32_t	imm_data_or_inv_r_key;
	/*
	 * This is an application level ID used to identify the
	 * QP and its SQ and RQ.
	 */
	uint64_t	qp_handle;
	/*
	 * Opaque value - valid when inv_flag is set. Used by driver
	 * to reference the buffer used to store PBL when the MR was
	 * fast registered. The driver can reclaim this buffer after
	 * an MR was remotely invalidated. The controller take that
	 * value from the MR referenced by R_Key
	 */
	uint64_t	mr_handle;
	uint8_t	cqe_type_toggle;
	/*
	 * Indicate valid completion - written by the chip. Cumulus
	 * toggle this bit each time it finished consuming all PBL
	 * entries
	 */
	#define CQ_RES_RC_TOGGLE	UINT32_C(0x1)
	/* This field defines the type of SQ WQE. */
	#define CQ_RES_RC_CQE_TYPE_MASK  UINT32_C(0x1e)
	#define CQ_RES_RC_CQE_TYPE_SFT   1
	/*
	 * Responder RC Completion - This is used for both RQ and SRQ
	 * completions for RC service QPs.
	 */
		#define CQ_RES_RC_CQE_TYPE_RES_RC  (UINT32_C(0x1) << 1)
		#define CQ_RES_RC_CQE_TYPE_LAST   CQ_RES_RC_CQE_TYPE_RES_RC
	/* This field indicates the status for the CQE. */
	uint8_t	status;
	/* OK is 0 */
	#define CQ_RES_RC_STATUS_OK			UINT32_C(0x0)
	/* LOCAL_ACCESS_ERROR is 1 */
	#define CQ_RES_RC_STATUS_LOCAL_ACCESS_ERROR	UINT32_C(0x1)
	/* LOCAL_LENGTH_ERR is 2 */
	#define CQ_RES_RC_STATUS_LOCAL_LENGTH_ERR	UINT32_C(0x2)
	/* LOCAL_PROTECTION_ERR is 3 */
	#define CQ_RES_RC_STATUS_LOCAL_PROTECTION_ERR	UINT32_C(0x3)
	/* LOCAL_QP_OPERATION_ERR is 4 */
	#define CQ_RES_RC_STATUS_LOCAL_QP_OPERATION_ERR	UINT32_C(0x4)
	/* MEMORY_MGT_OPERATION_ERR is 5 */
	#define CQ_RES_RC_STATUS_MEMORY_MGT_OPERATION_ERR   UINT32_C(0x5)
	/* REMOTE_INVALID_REQUEST_ERR is 6 */
	#define CQ_RES_RC_STATUS_REMOTE_INVALID_REQUEST_ERR UINT32_C(0x6)
	/* WORK_REQUEST_FLUSHED_ERR is 7 */
	#define CQ_RES_RC_STATUS_WORK_REQUEST_FLUSHED_ERR   UINT32_C(0x7)
	/* HW_FLUSH_ERR is 8 */
	#define CQ_RES_RC_STATUS_HW_FLUSH_ERR		UINT32_C(0x8)
	#define CQ_RES_RC_STATUS_LAST			CQ_RES_RC_STATUS_HW_FLUSH_ERR
	uint16_t	flags;
	/*
	 * This flag indicates that the completion is for a SRQ entry
	 * rather than for an RQ entry.
	 */
	#define CQ_RES_RC_FLAGS_SRQ		UINT32_C(0x1)
	/* CQE relates to RQ WQE. */
		#define CQ_RES_RC_FLAGS_SRQ_RQ	UINT32_C(0x0)
	/* CQE relates to SRQ WQE. */
		#define CQ_RES_RC_FLAGS_SRQ_SRQ	UINT32_C(0x1)
		#define CQ_RES_RC_FLAGS_SRQ_LAST	CQ_RES_RC_FLAGS_SRQ_SRQ
	/* Immediate data indicator */
	#define CQ_RES_RC_FLAGS_IMM		UINT32_C(0x2)
	/* R_Key invalidate indicator */
	#define CQ_RES_RC_FLAGS_INV		UINT32_C(0x4)
	#define CQ_RES_RC_FLAGS_RDMA	UINT32_C(0x8)
	/* CQE relates to an incoming Send request */
		#define CQ_RES_RC_FLAGS_RDMA_SEND	(UINT32_C(0x0) << 3)
	/* CQE relates to incoming RDMA Write request */
		#define CQ_RES_RC_FLAGS_RDMA_RDMA_WRITE  (UINT32_C(0x1) << 3)
		#define CQ_RES_RC_FLAGS_RDMA_LAST	CQ_RES_RC_FLAGS_RDMA_RDMA_WRITE
	uint32_t	srq_or_rq_wr_id;
	/*
	 * Opaque value from RQ or SRQ WQE. Used by driver/lib to
	 * reference the WQE in order to claim the received data
	 * and reuse the WQE space
	 */
	#define CQ_RES_RC_SRQ_OR_RQ_WR_ID_MASK UINT32_C(0xfffff)
	#define CQ_RES_RC_SRQ_OR_RQ_WR_ID_SFT 0
} cq_res_rc_t, *pcq_res_rc_t;

/* Responder UD CQE */
/* cq_res_ud (size:256b/32B) */

typedef struct cq_res_ud {
	uint16_t	length;
	/*
	 * The length of the message's payload in bytes, stored in
	 * the SGEs
	 */
	#define CQ_RES_UD_LENGTH_MASK UINT32_C(0x3fff)
	#define CQ_RES_UD_LENGTH_SFT 0
	/*
	 * This is data from the CFA or VNIC block as indicated by the
	 * ext_meta_format and meta_format fields.
	 */
	uint16_t	cfa_metadata;
	/* When meta_format=1, this value is the VLAN VID. */
	#define CQ_RES_UD_CFA_METADATA_VID_MASK UINT32_C(0xfff)
	#define CQ_RES_UD_CFA_METADATA_VID_SFT 0
	/* When meta_format=1, this value is the VLAN DE. */
	#define CQ_RES_UD_CFA_METADATA_DE	UINT32_C(0x1000)
	/* When meta_format=1, this value is the VLAN PRI. */
	#define CQ_RES_UD_CFA_METADATA_PRI_MASK UINT32_C(0xe000)
	#define CQ_RES_UD_CFA_METADATA_PRI_SFT 13
	/* Immediate data in case the imm_flag set. */
	uint32_t	imm_data;
	/*
	 * This is an application level ID used to identify the
	 * QP and its SQ and RQ.
	 */
	uint64_t	qp_handle;
	/*
	 * Source MAC address for the UD message placed in the WQE
	 * that is completed by this CQE.
	 */
	uint16_t	src_mac[3];
	/* Lower 16b of the Source QP value from the DETH header. */
	uint16_t	src_qp_low;
	uint8_t	cqe_type_toggle;
	/*
	 * Indicate valid completion - written by the chip. Cumulus
	 * toggle this bit each time it finished consuming all PBL
	 * entries
	 */
	#define CQ_RES_UD_TOGGLE	UINT32_C(0x1)
	/* This field defines the type of SQ WQE. */
	#define CQ_RES_UD_CQE_TYPE_MASK  UINT32_C(0x1e)
	#define CQ_RES_UD_CQE_TYPE_SFT   1
	/*
	 * Responder UD Completion - This is used for both RQ and SRQ
	 * completion for UD service QPs.
	 */
		#define CQ_RES_UD_CQE_TYPE_RES_UD  (UINT32_C(0x2) << 1)
		#define CQ_RES_UD_CQE_TYPE_LAST   CQ_RES_UD_CQE_TYPE_RES_UD
	/* This field indicates the status for the CQE. */
	uint8_t	status;
	/*
	 * This indicates that the completion is without error.
	 * All fields are valid.
	 */
	#define CQ_RES_UD_STATUS_OK			UINT32_C(0x0)
	/*
	 * This indicates that write access was not allowed for
	 * at least one of the SGEs in the WQE.
	 *
	 * This is a fatal error.  Only the srq_or_rq_wr_id is field
	 * is valid.
	 */
	#define CQ_RES_UD_STATUS_LOCAL_ACCESS_ERROR	UINT32_C(0x1)
	/*
	 * This indicates that the packet was too long for the WQE
	 * provided on the SRQ/RQ.
	 *
	 * This is not a fatal error.  All the fields are valid.
	 */
	#define CQ_RES_UD_STATUS_HW_LOCAL_LENGTH_ERR	UINT32_C(0x2)
	/* LOCAL_PROTECTION_ERR is 3 */
	#define CQ_RES_UD_STATUS_LOCAL_PROTECTION_ERR	UINT32_C(0x3)
	/* LOCAL_QP_OPERATION_ERR is 4 */
	#define CQ_RES_UD_STATUS_LOCAL_QP_OPERATION_ERR   UINT32_C(0x4)
	/* MEMORY_MGT_OPERATION_ERR is 5 */
	#define CQ_RES_UD_STATUS_MEMORY_MGT_OPERATION_ERR UINT32_C(0x5)
	/* WORK_REQUEST_FLUSHED_ERR is 7 */
	#define CQ_RES_UD_STATUS_WORK_REQUEST_FLUSHED_ERR UINT32_C(0x7)
	/* HW_FLUSH_ERR is 8 */
	#define CQ_RES_UD_STATUS_HW_FLUSH_ERR		UINT32_C(0x8)
	#define CQ_RES_UD_STATUS_LAST			CQ_RES_UD_STATUS_HW_FLUSH_ERR
	uint16_t	flags;
	/*
	 * This flag indicates that the completion is for a SRQ entry
	 * rather than for an RQ entry.
	 */
	#define CQ_RES_UD_FLAGS_SRQ		UINT32_C(0x1)
	/* CQE relates to RQ WQE. */
		#define CQ_RES_UD_FLAGS_SRQ_RQ		UINT32_C(0x0)
	/* CQE relates to SRQ WQE. */
		#define CQ_RES_UD_FLAGS_SRQ_SRQ		UINT32_C(0x1)
		#define CQ_RES_UD_FLAGS_SRQ_LAST		CQ_RES_UD_FLAGS_SRQ_SRQ
	/* Immediate data indicator */
	#define CQ_RES_UD_FLAGS_IMM		UINT32_C(0x2)
	#define CQ_RES_UD_FLAGS_UNUSED_MASK	UINT32_C(0xc)
	#define CQ_RES_UD_FLAGS_UNUSED_SFT		2
	#define CQ_RES_UD_FLAGS_ROCE_IP_VER_MASK	UINT32_C(0x30)
	#define CQ_RES_UD_FLAGS_ROCE_IP_VER_SFT	4
	/* RoCEv1 Message */
		#define CQ_RES_UD_FLAGS_ROCE_IP_VER_V1	(UINT32_C(0x0) << 4)
	/* RoCEv2 IPv4 Message */
		#define CQ_RES_UD_FLAGS_ROCE_IP_VER_V2IPV4	(UINT32_C(0x2) << 4)
	/* RoCEv2 IPv6 Message */
		#define CQ_RES_UD_FLAGS_ROCE_IP_VER_V2IPV6	(UINT32_C(0x3) << 4)
		#define CQ_RES_UD_FLAGS_ROCE_IP_VER_LAST	CQ_RES_UD_FLAGS_ROCE_IP_VER_V2IPV6
	/*
	 * The combination of this value and ext_meta_format indicates
	 * what format the metadata field is.
	 */
	#define CQ_RES_UD_FLAGS_META_FORMAT_MASK	UINT32_C(0x3c0)
	#define CQ_RES_UD_FLAGS_META_FORMAT_SFT	6
	/* No metadata information.  Value is zero. */
		#define CQ_RES_UD_FLAGS_META_FORMAT_NONE	(UINT32_C(0x0) << 6)
	/*
	 * The metadata field contains the VLAN tag and TPID value.
	 * - metadata[11:0] contains the vlan VID value.
	 * - metadata[12] contains the vlan DE value.
	 * - metadata[15:13] contains the vlan PRI value.
	 */
		#define CQ_RES_UD_FLAGS_META_FORMAT_VLAN	(UINT32_C(0x1) << 6)
	/*
	 * If ext_meta_format is equal to 1, the metadata field
	 * contains the lower 16b of the tunnel ID value, justified
	 * to LSB
	 * - VXLAN = VNI[23:0] -> VXLAN Network ID
	 * - Geneve (NGE) = VNI[23:0] -> Virtual Network Identifier.
	 * - NVGRE = TNI[23:0] -> Tenant Network ID
	 * - GRE = KEY[31:0] -> key field with bit mask. zero if K = 0
	 * - IPV4 = 0 (not populated)
	 * - IPV6 = Flow Label[19:0]
	 * - PPPoE = sessionID[15:0]
	 * - MPLs = Outer label[19:0]
	 * - UPAR = Selected[31:0] with bit mask
	 */
		#define CQ_RES_UD_FLAGS_META_FORMAT_TUNNEL_ID   (UINT32_C(0x2) << 6)
	/*
	 * if ext_meta_format is equal to 1, metadata field contains
	 * 16b metadata from the prepended header (chdr_data).
	 */
		#define CQ_RES_UD_FLAGS_META_FORMAT_CHDR_DATA   (UINT32_C(0x3) << 6)
	/*
	 * If ext_meta_format is equal to 1, the metadata field contains
	 * the outer_l3_offset and lower 7 bits of the inner_l2_offset,
	 * - metadata[8:0] contains the outer_l3_offset.
	 * - metadata[15:9] contains the inner_l2_offset[6:0]
	 */
		#define CQ_RES_UD_FLAGS_META_FORMAT_HDR_OFFSET  (UINT32_C(0x4) << 6)
		#define CQ_RES_UD_FLAGS_META_FORMAT_LAST	CQ_RES_UD_FLAGS_META_FORMAT_HDR_OFFSET
	/*
	 * The combination of this value and meta_format indicates what
	 * format the metadata field is
	 */
	#define CQ_RES_UD_FLAGS_EXT_META_FORMAT_MASK  UINT32_C(0xc00)
	#define CQ_RES_UD_FLAGS_EXT_META_FORMAT_SFT   10
	uint32_t	src_qp_high_srq_or_rq_wr_id;
	/*
	 * Opaque value from RQ or SRQ WQE. Used by driver/lib to
	 * reference the WQE in order to claim the received data
	 * and reuse the WQE space
	 */
	#define CQ_RES_UD_SRQ_OR_RQ_WR_ID_MASK UINT32_C(0xfffff)
	#define CQ_RES_UD_SRQ_OR_RQ_WR_ID_SFT 0
	/* Upper 8b of the Source QP value from the DETH header. */
	#define CQ_RES_UD_SRC_QP_HIGH_MASK	UINT32_C(0xff000000)
	#define CQ_RES_UD_SRC_QP_HIGH_SFT	24
} cq_res_ud_t, *pcq_res_ud_t;

/* Responder UD CQE version 2 */
/* cq_res_ud_v2 (size:256b/32B) */

typedef struct cq_res_ud_v2 {
	uint16_t	length;
	/*
	 * The length of the message's payload in bytes, stored in
	 * the SGEs
	 */
	#define CQ_RES_UD_V2_LENGTH_MASK UINT32_C(0x3fff)
	#define CQ_RES_UD_V2_LENGTH_SFT 0
	/* This is data from the CFA as indicated by the meta_format field. */
	uint16_t	cfa_metadata0;
	/* When meta_format=1, this value is the VLAN VID. */
	#define CQ_RES_UD_V2_CFA_METADATA0_VID_MASK UINT32_C(0xfff)
	#define CQ_RES_UD_V2_CFA_METADATA0_VID_SFT 0
	/* When meta_format=1, this value is the VLAN DE. */
	#define CQ_RES_UD_V2_CFA_METADATA0_DE	UINT32_C(0x1000)
	/* When meta_format=1, this value is the VLAN PRI. */
	#define CQ_RES_UD_V2_CFA_METADATA0_PRI_MASK UINT32_C(0xe000)
	#define CQ_RES_UD_V2_CFA_METADATA0_PRI_SFT 13
	/* Immediate data in case the imm_flag set. */
	uint32_t	imm_data;
	/*
	 * This is an application level ID used to identify the
	 * QP and its SQ and RQ.
	 */
	uint64_t	qp_handle;
	/*
	 * Source MAC address for the UD message placed in the WQE
	 * that is completed by this CQE.
	 */
	uint16_t	src_mac[3];
	/* Lower 16b of the Source QP value from the DETH header. */
	uint16_t	src_qp_low;
	uint8_t	cqe_type_toggle;
	/*
	 * Indicate valid completion - written by the chip. Cumulus
	 * toggle this bit each time it finished consuming all PBL
	 * entries
	 */
	#define CQ_RES_UD_V2_TOGGLE	UINT32_C(0x1)
	/* This field defines the type of SQ WQE. */
	#define CQ_RES_UD_V2_CQE_TYPE_MASK  UINT32_C(0x1e)
	#define CQ_RES_UD_V2_CQE_TYPE_SFT   1
	/*
	 * Responder UD Completion - This is used for both RQ and SRQ
	 * completion for UD service QPs.
	 */
		#define CQ_RES_UD_V2_CQE_TYPE_RES_UD  (UINT32_C(0x2) << 1)
		#define CQ_RES_UD_V2_CQE_TYPE_LAST   CQ_RES_UD_V2_CQE_TYPE_RES_UD
	/* This field indicates the status for the CQE. */
	uint8_t	status;
	/*
	 * This indicates that the completion is without error.
	 * All fields are valid.
	 */
	#define CQ_RES_UD_V2_STATUS_OK			UINT32_C(0x0)
	/*
	 * This indicates that write access was not allowed for
	 * at least one of the SGEs in the WQE.
	 *
	 * This is a fatal error.  Only the srq_or_rq_wr_id is field
	 * is valid.
	 */
	#define CQ_RES_UD_V2_STATUS_LOCAL_ACCESS_ERROR	UINT32_C(0x1)
	/*
	 * This indicates that the packet was too long for the WQE
	 * provided on the SRQ/RQ.
	 *
	 * This is not a fatal error.  All the fields are valid.
	 */
	#define CQ_RES_UD_V2_STATUS_HW_LOCAL_LENGTH_ERR	UINT32_C(0x2)
	/* LOCAL_PROTECTION_ERR is 3 */
	#define CQ_RES_UD_V2_STATUS_LOCAL_PROTECTION_ERR	UINT32_C(0x3)
	/* LOCAL_QP_OPERATION_ERR is 4 */
	#define CQ_RES_UD_V2_STATUS_LOCAL_QP_OPERATION_ERR   UINT32_C(0x4)
	/* MEMORY_MGT_OPERATION_ERR is 5 */
	#define CQ_RES_UD_V2_STATUS_MEMORY_MGT_OPERATION_ERR UINT32_C(0x5)
	/* WORK_REQUEST_FLUSHED_ERR is 7 */
	#define CQ_RES_UD_V2_STATUS_WORK_REQUEST_FLUSHED_ERR UINT32_C(0x7)
	/* HW_FLUSH_ERR is 8 */
	#define CQ_RES_UD_V2_STATUS_HW_FLUSH_ERR		UINT32_C(0x8)
	#define CQ_RES_UD_V2_STATUS_LAST			CQ_RES_UD_V2_STATUS_HW_FLUSH_ERR
	uint16_t	flags;
	/*
	 * This flag indicates that the completion is for a SRQ entry
	 * rather than for an RQ entry.
	 */
	#define CQ_RES_UD_V2_FLAGS_SRQ			UINT32_C(0x1)
	/* CQE relates to RQ WQE. */
		#define CQ_RES_UD_V2_FLAGS_SRQ_RQ		UINT32_C(0x0)
	/* CQE relates to SRQ WQE. */
		#define CQ_RES_UD_V2_FLAGS_SRQ_SRQ		UINT32_C(0x1)
		#define CQ_RES_UD_V2_FLAGS_SRQ_LAST		CQ_RES_UD_V2_FLAGS_SRQ_SRQ
	/* Immediate data indicator */
	#define CQ_RES_UD_V2_FLAGS_IMM			UINT32_C(0x2)
	#define CQ_RES_UD_V2_FLAGS_UNUSED_MASK		UINT32_C(0xc)
	#define CQ_RES_UD_V2_FLAGS_UNUSED_SFT		2
	#define CQ_RES_UD_V2_FLAGS_ROCE_IP_VER_MASK	UINT32_C(0x30)
	#define CQ_RES_UD_V2_FLAGS_ROCE_IP_VER_SFT	4
	/* RoCEv1 Message */
		#define CQ_RES_UD_V2_FLAGS_ROCE_IP_VER_V1	(UINT32_C(0x0) << 4)
	/* RoCEv2 IPv4 Message */
		#define CQ_RES_UD_V2_FLAGS_ROCE_IP_VER_V2IPV4	(UINT32_C(0x2) << 4)
	/* RoCEv2 IPv6 Message */
		#define CQ_RES_UD_V2_FLAGS_ROCE_IP_VER_V2IPV6	(UINT32_C(0x3) << 4)
		#define CQ_RES_UD_V2_FLAGS_ROCE_IP_VER_LAST	CQ_RES_UD_V2_FLAGS_ROCE_IP_VER_V2IPV6
	/* The field indicates what format the metadata field is. */
	#define CQ_RES_UD_V2_FLAGS_META_FORMAT_MASK	UINT32_C(0x3c0)
	#define CQ_RES_UD_V2_FLAGS_META_FORMAT_SFT	6
	/* No metadata information.  Value is zero. */
		#define CQ_RES_UD_V2_FLAGS_META_FORMAT_NONE	(UINT32_C(0x0) << 6)
	/*
	 * The {metadata1, metadata0} fields contain the vtag
	 * information: - vtag[19:0] = {valid, tpid_sel[2:0], pri[2:0],
	 * de, vid[11:0]} The metadata2 field contains the table scope
	 * and action record pointer. - metadata2[25:0] contains the
	 * action record pointer. - metadata2[31:26] contains the table
	 * scope.
	 */
		#define CQ_RES_UD_V2_FLAGS_META_FORMAT_ACT_REC_PTR  (UINT32_C(0x1) << 6)
	/*
	 * The {metadata1, metadata0} fields contain the vtag
	 * information:
	 * - vtag[19:0] = {valid, tpid_sel[2:0], pri[2:0], de, vid[11:0]}
	 * The metadata2 field contains the Tunnel ID
	 * value, justified to LSB. i
	 * - VXLAN = VNI[23:0] -> VXLAN Network ID
	 * - Geneve (NGE) = VNI[23:0] a-> Virtual Network Identifier
	 * - NVGRE = TNI[23:0] -> Tenant Network ID
	 * - GRE = KEY[31:0] -> key field with bit mask. zero if K=0
	 * - IPv4 = 0 (not populated)
	 * - IPv6 = Flow Label[19:0]
	 * - PPPoE = sessionID[15:0]
	 * - MPLs = Outer label[19:0]
	 * - UPAR = Selected[31:0] with bit mask
	 */
		#define CQ_RES_UD_V2_FLAGS_META_FORMAT_TUNNEL_ID	(UINT32_C(0x2) << 6)
	/*
	 * The {metadata1, metadata0} fields contain the vtag
	 * information:
	 * - vtag[19:0] = {valid, tpid_sel[2:0], pri[2:0],de, vid[11:0]}
	 * The metadata2 field contains the 32b metadata from the
	 * prepended header (chdr_data).
	 */
		#define CQ_RES_UD_V2_FLAGS_META_FORMAT_CHDR_DATA	(UINT32_C(0x3) << 6)
	/*
	 * If ext_meta_format is equal to 1, the metadata field contains
	 * the outer_l3_offset and lower 7 bits of the inner_l2_offset,
	 * - metadata[8:0] contains the outer_l3_offset.
	 * - metadata[15:9] contains the inner_l2_offset[6:0]
	 */
		#define CQ_RES_UD_V2_FLAGS_META_FORMAT_HDR_OFFSET   (UINT32_C(0x4) << 6)
		#define CQ_RES_UD_V2_FLAGS_META_FORMAT_LAST	CQ_RES_UD_V2_FLAGS_META_FORMAT_HDR_OFFSET
	uint32_t	src_qp_high_srq_or_rq_wr_id;
	/*
	 * Opaque value from RQ or SRQ WQE. Used by driver/lib to
	 * reference the WQE in order to claim the received data
	 * and reuse the WQE space
	 */
	#define CQ_RES_UD_V2_SRQ_OR_RQ_WR_ID_MASK	UINT32_C(0xfffff)
	#define CQ_RES_UD_V2_SRQ_OR_RQ_WR_ID_SFT		0
	#define CQ_RES_UD_V2_CFA_METADATA1_MASK		UINT32_C(0xf00000)
	#define CQ_RES_UD_V2_CFA_METADATA1_SFT		20
	/* When meta_format != 0, this value is the VLAN TPID_SEL. */
	#define CQ_RES_UD_V2_CFA_METADATA1_TPID_SEL_MASK	UINT32_C(0x700000)
	#define CQ_RES_UD_V2_CFA_METADATA1_TPID_SEL_SFT	20
	/* 0x88a8 */
		#define CQ_RES_UD_V2_CFA_METADATA1_TPID_SEL_TPID88A8   (UINT32_C(0x0) << 20)
	/* 0x8100 */
		#define CQ_RES_UD_V2_CFA_METADATA1_TPID_SEL_TPID8100   (UINT32_C(0x1) << 20)
	/* 0x9100 */
		#define CQ_RES_UD_V2_CFA_METADATA1_TPID_SEL_TPID9100   (UINT32_C(0x2) << 20)
	/* 0x9200 */
		#define CQ_RES_UD_V2_CFA_METADATA1_TPID_SEL_TPID9200   (UINT32_C(0x3) << 20)
	/* 0x9300 */
		#define CQ_RES_UD_V2_CFA_METADATA1_TPID_SEL_TPID9300   (UINT32_C(0x4) << 20)
	/* Value programmed in CFA VLANTPID register. */
		#define CQ_RES_UD_V2_CFA_METADATA1_TPID_SEL_TPIDCFG	(UINT32_C(0x5) << 20)
		#define CQ_RES_UD_V2_CFA_METADATA1_TPID_SEL_LAST	CQ_RES_UD_V2_CFA_METADATA1_TPID_SEL_TPIDCFG
	/* When meta_format != 0, this value is the VLAN valid. */
	#define CQ_RES_UD_V2_CFA_METADATA1_VALID		UINT32_C(0x800000)
	/* Upper 8b of the Source QP value from the DETH header. */
	#define CQ_RES_UD_V2_SRC_QP_HIGH_MASK		UINT32_C(0xff000000)
	#define CQ_RES_UD_V2_SRC_QP_HIGH_SFT		24
} cq_res_ud_v2_t, *pcq_res_ud_v2_t;

/* Responder UD with CFA CQE */
/* cq_res_ud_cfa (size:256b/32B) */

typedef struct cq_res_ud_cfa {
	uint16_t	length;
	/*
	 * The length of the message's payload in bytes, stored in
	 * the SGEs
	 */
	#define CQ_RES_UD_CFA_LENGTH_MASK UINT32_C(0x3fff)
	#define CQ_RES_UD_CFA_LENGTH_SFT 0
	/*
	 * This field identifies the CFA action rule that was used
	 * for this packet.
	 */
	uint16_t	cfa_code;
	/* Immediate data in case the imm_flag set. */
	uint32_t	imm_data;
	uint32_t	qid;
	/*
	 * This value indicates the QPID associated with this operation.
	 * The driver will use the qid from thie CQE to map a QP handle
	 * in the completion record returned to the application.
	 */
	#define CQ_RES_UD_CFA_QID_MASK UINT32_C(0xfffff)
	#define CQ_RES_UD_CFA_QID_SFT 0
	/*
	 * This is data from the CFA or VNIC block as indicated by the
	 * ext_meta_format and meta_format fields.
	 */
	uint32_t	cfa_metadata;
	/* When meta_format=1, this value is the VLAN VID. */
	#define CQ_RES_UD_CFA_CFA_METADATA_VID_MASK UINT32_C(0xfff)
	#define CQ_RES_UD_CFA_CFA_METADATA_VID_SFT  0
	/* When meta_format=1, this value is the VLAN DE. */
	#define CQ_RES_UD_CFA_CFA_METADATA_DE	UINT32_C(0x1000)
	/* When meta_format=1, this value is the VLAN PRI. */
	#define CQ_RES_UD_CFA_CFA_METADATA_PRI_MASK UINT32_C(0xe000)
	#define CQ_RES_UD_CFA_CFA_METADATA_PRI_SFT  13
	/* When meta_format=1, this value is the VLAN TPID. */
	#define CQ_RES_UD_CFA_CFA_METADATA_TPID_MASK UINT32_C(0xffff0000)
	#define CQ_RES_UD_CFA_CFA_METADATA_TPID_SFT 16
	/*
	 * Source MAC address for the UD message placed in the WQE
	 * that is completed by this CQE.
	 */
	uint16_t	src_mac[3];
	/* Lower 16b of the Source QP value from the DETH header. */
	uint16_t	src_qp_low;
	uint8_t	cqe_type_toggle;
	/*
	 * Indicate valid completion - written by the chip. Cumulus
	 * toggle this bit each time it finished consuming all PBL
	 * entries
	 */
	#define CQ_RES_UD_CFA_TOGGLE		UINT32_C(0x1)
	/* This field defines the type of SQ WQE. */
	#define CQ_RES_UD_CFA_CQE_TYPE_MASK	UINT32_C(0x1e)
	#define CQ_RES_UD_CFA_CQE_TYPE_SFT	1
	/*
	 * Responder UD Completion with CFA - This is used for both RQ
	 * and SRQ completion for UD service QPs. It includes cfa fields
	 * (some of which carry VLAN information), in place of the QP
	 * handle. It is also used for QP1 QPs that are treated as UD.
	 */
		#define CQ_RES_UD_CFA_CQE_TYPE_RES_UD_CFA  (UINT32_C(0x4) << 1)
		#define CQ_RES_UD_CFA_CQE_TYPE_LAST	CQ_RES_UD_CFA_CQE_TYPE_RES_UD_CFA
	/* This field indicates the status for the CQE. */
	uint8_t	status;
	/*
	 * This indicates that the completion is without error.
	 * All fields are valid.
	 */
	#define CQ_RES_UD_CFA_STATUS_OK			UINT32_C(0x0)
	/*
	 * This indicates that write access was not allowed for
	 * at least one of the SGEs in the WQE.
	 *
	 * This is a fatal error. Only the srq_or_rq_wr_id is field
	 * is valid.
	 */
	#define CQ_RES_UD_CFA_STATUS_LOCAL_ACCESS_ERROR	UINT32_C(0x1)
	/*
	 * This indicates that the packet was too long for the WQE
	 * provided on the SRQ/RQ.
	 *
	 * This is not a fatal error. All the fields are valid.
	 */
	#define CQ_RES_UD_CFA_STATUS_HW_LOCAL_LENGTH_ERR	UINT32_C(0x2)
	/* LOCAL_PROTECTION_ERR is 3 */
	#define CQ_RES_UD_CFA_STATUS_LOCAL_PROTECTION_ERR	UINT32_C(0x3)
	/* LOCAL_QP_OPERATION_ERR is 4 */
	#define CQ_RES_UD_CFA_STATUS_LOCAL_QP_OPERATION_ERR   UINT32_C(0x4)
	/* MEMORY_MGT_OPERATION_ERR is 5 */
	#define CQ_RES_UD_CFA_STATUS_MEMORY_MGT_OPERATION_ERR UINT32_C(0x5)
	/* WORK_REQUEST_FLUSHED_ERR is 7 */
	#define CQ_RES_UD_CFA_STATUS_WORK_REQUEST_FLUSHED_ERR UINT32_C(0x7)
	/* HW_FLUSH_ERR is 8 */
	#define CQ_RES_UD_CFA_STATUS_HW_FLUSH_ERR		UINT32_C(0x8)
	#define CQ_RES_UD_CFA_STATUS_LAST			CQ_RES_UD_CFA_STATUS_HW_FLUSH_ERR
	uint16_t	flags;
	/*
	 * This flag indicates that the completion is for a SRQ entry
	 * rather than for an RQ entry.
	 */
	#define CQ_RES_UD_CFA_FLAGS_SRQ		UINT32_C(0x1)
	/* CQE relates to RQ WQE. */
		#define CQ_RES_UD_CFA_FLAGS_SRQ_RQ		UINT32_C(0x0)
	/* CQE relates to SRQ WQE. */
		#define CQ_RES_UD_CFA_FLAGS_SRQ_SRQ		UINT32_C(0x1)
		#define CQ_RES_UD_CFA_FLAGS_SRQ_LAST		CQ_RES_UD_CFA_FLAGS_SRQ_SRQ
	/* Immediate data indicator */
	#define CQ_RES_UD_CFA_FLAGS_IMM		UINT32_C(0x2)
	#define CQ_RES_UD_CFA_FLAGS_UNUSED_MASK	UINT32_C(0xc)
	#define CQ_RES_UD_CFA_FLAGS_UNUSED_SFT		2
	#define CQ_RES_UD_CFA_FLAGS_ROCE_IP_VER_MASK	UINT32_C(0x30)
	#define CQ_RES_UD_CFA_FLAGS_ROCE_IP_VER_SFT	4
	/* RoCEv1 Message */
		#define CQ_RES_UD_CFA_FLAGS_ROCE_IP_VER_V1	(UINT32_C(0x0) << 4)
	/* RoCEv2 IPv4 Message */
		#define CQ_RES_UD_CFA_FLAGS_ROCE_IP_VER_V2IPV4	(UINT32_C(0x2) << 4)
	/* RoCEv2 IPv6 Message */
		#define CQ_RES_UD_CFA_FLAGS_ROCE_IP_VER_V2IPV6	(UINT32_C(0x3) << 4)
		#define CQ_RES_UD_CFA_FLAGS_ROCE_IP_VER_LAST	CQ_RES_UD_CFA_FLAGS_ROCE_IP_VER_V2IPV6
	/*
	 * The combination of this value and ext_meta_format indicates
	 * what format the metadata field is.
	 */
	#define CQ_RES_UD_CFA_FLAGS_META_FORMAT_MASK	UINT32_C(0x3c0)
	#define CQ_RES_UD_CFA_FLAGS_META_FORMAT_SFT	6
	/*
	 * If ext_meta_format is equal to 0, there is no metadata
	 * information. Value is zero.
	 */
		#define CQ_RES_UD_CFA_FLAGS_META_FORMAT_NONE	(UINT32_C(0x0) << 6)
	/*
	 * If ext_meta_format is equal to 0, the metadata field contains
	 * the VLAN tag and TPID value.
	 * - metadata[11:0] contains the vlan VID value.
	 * - metadata[12] contains the vlan DE value.
	 * - metadata[15:13] contains the vlan PRI value.
	 * - metadata[31:16] contains the vlan TPID value.
	 */
		#define CQ_RES_UD_CFA_FLAGS_META_FORMAT_VLAN	(UINT32_C(0x1) << 6)
	/*
	 * If ext_meta_format is equal to 1, the metadata field contains
	 * the Tunnel ID value, justified to LSB.
	 * - VXLAN = VNI[23:0] -> VXLAN Network ID
	 * - Geneve (NGE) = VNI[23:0] -> Virtual Network Identifier
	 * - NVGRE = TNI[23:0] -> Tenant Network ID
	 * - GRE = KEY[31:0] -> key field with bit mask. zero if K = 0
	 * - IPV4 = 0 (not populated)
	 * - IPV6 = Flow Label[19:0]
	 * - PPPoE = sessionID[15:0]
	 * - MPLs = Outer label[19:0]
	 * - UPAR = Selected[31:0] with bit mask
	 */
		#define CQ_RES_UD_CFA_FLAGS_META_FORMAT_TUNNEL_ID   (UINT32_C(0x2) << 6)
	/*
	 * if ext_meta_format is equal to 1, metadata field contains
	 * 16b metadata from the prepended header (chdr_data).
	 */
		#define CQ_RES_UD_CFA_FLAGS_META_FORMAT_CHDR_DATA   (UINT32_C(0x3) << 6)
	/*
	 * If ext_meta_format is equal to 1, the metadata field contains
	 * the outer_l3_offset, inner_l2_offset, inner_l3_offset, and
	 * inner_l4_size.
	 * - metadata[8:0] contains the outer_l3_offset.
	 * - metadata[17:9] contains the inner_l2_offset.
	 * - metadata[26:18] contains the inner_l3_offset.
	 * - metadata[31:27] contains the inner_l4_size.
	 */
		#define CQ_RES_UD_CFA_FLAGS_META_FORMAT_HDR_OFFSET  (UINT32_C(0x4) << 6)
		#define CQ_RES_UD_CFA_FLAGS_META_FORMAT_LAST	CQ_RES_UD_CFA_FLAGS_META_FORMAT_HDR_OFFSET
	/*
	 * The combination of this value and meta_format indicates what
	 * format the metadata field is
	 */
	#define CQ_RES_UD_CFA_FLAGS_EXT_META_FORMAT_MASK  UINT32_C(0xc00)
	#define CQ_RES_UD_CFA_FLAGS_EXT_META_FORMAT_SFT   10
	uint32_t	src_qp_high_srq_or_rq_wr_id;
	/*
	 * Opaque value from RQ or SRQ WQE. Used by driver/lib to
	 * reference the WQE in order to claim the received data
	 * and reuse the WQE space
	 */
	#define CQ_RES_UD_CFA_SRQ_OR_RQ_WR_ID_MASK UINT32_C(0xfffff)
	#define CQ_RES_UD_CFA_SRQ_OR_RQ_WR_ID_SFT 0
	/* Upper 8b of the Source QP value from the DETH header. */
	#define CQ_RES_UD_CFA_SRC_QP_HIGH_MASK	UINT32_C(0xff000000)
	#define CQ_RES_UD_CFA_SRC_QP_HIGH_SFT	24
} cq_res_ud_cfa_t, *pcq_res_ud_cfa_t;

/* Responder UD with CFA CQE version 2 */
/* cq_res_ud_cfa_v2 (size:256b/32B) */

typedef struct cq_res_ud_cfa_v2 {
	uint16_t	length;
	/*
	 * The length of the message's payload in bytes, stored in
	 * the SGEs
	 */
	#define CQ_RES_UD_CFA_V2_LENGTH_MASK UINT32_C(0x3fff)
	#define CQ_RES_UD_CFA_V2_LENGTH_SFT 0
	/* This is data from the CFA as indicated by the meta_format field. */
	uint16_t	cfa_metadata0;
	/* When meta_format=1, this value is the VLAN VID. */
	#define CQ_RES_UD_CFA_V2_CFA_METADATA0_VID_MASK UINT32_C(0xfff)
	#define CQ_RES_UD_CFA_V2_CFA_METADATA0_VID_SFT 0
	/* When meta_format=1, this value is the VLAN DE. */
	#define CQ_RES_UD_CFA_V2_CFA_METADATA0_DE	UINT32_C(0x1000)
	/* When meta_format=1, this value is the VLAN PRI. */
	#define CQ_RES_UD_CFA_V2_CFA_METADATA0_PRI_MASK UINT32_C(0xe000)
	#define CQ_RES_UD_CFA_V2_CFA_METADATA0_PRI_SFT 13
	/* Immediate data in case the imm_flag set. */
	uint32_t	imm_data;
	uint32_t	qid;
	/*
	 * This value indicates the QPID associated with this operation.
	 * The driver will use the qid from thie CQE to map a QP handle
	 * in the completion record returned to the application.
	 */
	#define CQ_RES_UD_CFA_V2_QID_MASK UINT32_C(0xfffff)
	#define CQ_RES_UD_CFA_V2_QID_SFT 0
	/*
	 * This is data from the CFA block as indicated by the meta_format
	 * field.
	 * - meta_format 0 - none - metadata2 = 0 - not valid/not stripped
	 * - meta_format 1 - act_rec_ptr - metadata2 = {table_scope[5:0],
	 *   act_rec_ptr[25:0]}
	 * - meta_format 2 - tunnel_id - metadata2 = tunnel_id[31:0]
	 * - meta_format 3 - chdr_data - metadata2 = updated_chdr_data[31:0]
	 * - meta_format 4 - hdr_offsets - metadata2 = hdr_offsets[31:0]
	 * When vee_cmpl_mode is set in VNIC context, this is the upper 32b
	 * of the host address from the first BD used to place the packet.
	 */
	uint32_t	cfa_metadata2;
	/*
	 * Source MAC address for the UD message placed in the WQE
	 * that is completed by this CQE.
	 */
	uint16_t	src_mac[3];
	/* Lower 16b of the Source QP value from the DETH header. */
	uint16_t	src_qp_low;
	uint8_t	cqe_type_toggle;
	/*
	 * Indicate valid completion - written by the chip. Cumulus
	 * toggle this bit each time it finished consuming all PBL
	 * entries
	 */
	#define CQ_RES_UD_CFA_V2_TOGGLE		UINT32_C(0x1)
	/* This field defines the type of SQ WQE. */
	#define CQ_RES_UD_CFA_V2_CQE_TYPE_MASK	UINT32_C(0x1e)
	#define CQ_RES_UD_CFA_V2_CQE_TYPE_SFT	1
	/*
	 * Responder UD Completion with CFA - This is used for both RQ
	 * and SRQ completion for UD service QPs. It includes cfa fields
	 * (some of which carry VLAN information), in place of the QP
	 * handle. It is also used for QP1 QPs that are treated as UD.
	 */
		#define CQ_RES_UD_CFA_V2_CQE_TYPE_RES_UD_CFA  (UINT32_C(0x4) << 1)
		#define CQ_RES_UD_CFA_V2_CQE_TYPE_LAST	CQ_RES_UD_CFA_V2_CQE_TYPE_RES_UD_CFA
	/* This field indicates the status for the CQE. */
	uint8_t	status;
	/*
	 * This indicates that the completion is without error.
	 * All fields are valid.
	 */
	#define CQ_RES_UD_CFA_V2_STATUS_OK			UINT32_C(0x0)
	/*
	 * This indicates that write access was not allowed for
	 * at least one of the SGEs in the WQE.
	 *
	 * This is a fatal error. Only the srq_or_rq_wr_id is field
	 * is valid.
	 */
	#define CQ_RES_UD_CFA_V2_STATUS_LOCAL_ACCESS_ERROR	UINT32_C(0x1)
	/*
	 * This indicates that the packet was too long for the WQE
	 * provided on the SRQ/RQ.
	 *
	 * This is not a fatal error. All the fields are valid.
	 */
	#define CQ_RES_UD_CFA_V2_STATUS_HW_LOCAL_LENGTH_ERR	UINT32_C(0x2)
	/* LOCAL_PROTECTION_ERR is 3 */
	#define CQ_RES_UD_CFA_V2_STATUS_LOCAL_PROTECTION_ERR	UINT32_C(0x3)
	/* LOCAL_QP_OPERATION_ERR is 4 */
	#define CQ_RES_UD_CFA_V2_STATUS_LOCAL_QP_OPERATION_ERR   UINT32_C(0x4)
	/* MEMORY_MGT_OPERATION_ERR is 5 */
	#define CQ_RES_UD_CFA_V2_STATUS_MEMORY_MGT_OPERATION_ERR UINT32_C(0x5)
	/* WORK_REQUEST_FLUSHED_ERR is 7 */
	#define CQ_RES_UD_CFA_V2_STATUS_WORK_REQUEST_FLUSHED_ERR UINT32_C(0x7)
	/* HW_FLUSH_ERR is 8 */
	#define CQ_RES_UD_CFA_V2_STATUS_HW_FLUSH_ERR		UINT32_C(0x8)
	#define CQ_RES_UD_CFA_V2_STATUS_LAST			CQ_RES_UD_CFA_V2_STATUS_HW_FLUSH_ERR
	uint16_t	flags;
	/*
	 * This flag indicates that the completion is for a SRQ entry
	 * rather than for an RQ entry.
	 */
	#define CQ_RES_UD_CFA_V2_FLAGS_SRQ			UINT32_C(0x1)
	/* CQE relates to RQ WQE. */
		#define CQ_RES_UD_CFA_V2_FLAGS_SRQ_RQ		UINT32_C(0x0)
	/* CQE relates to SRQ WQE. */
		#define CQ_RES_UD_CFA_V2_FLAGS_SRQ_SRQ		UINT32_C(0x1)
		#define CQ_RES_UD_CFA_V2_FLAGS_SRQ_LAST		CQ_RES_UD_CFA_V2_FLAGS_SRQ_SRQ
	/* Immediate data indicator */
	#define CQ_RES_UD_CFA_V2_FLAGS_IMM			UINT32_C(0x2)
	#define CQ_RES_UD_CFA_V2_FLAGS_UNUSED_MASK		UINT32_C(0xc)
	#define CQ_RES_UD_CFA_V2_FLAGS_UNUSED_SFT		2
	#define CQ_RES_UD_CFA_V2_FLAGS_ROCE_IP_VER_MASK	UINT32_C(0x30)
	#define CQ_RES_UD_CFA_V2_FLAGS_ROCE_IP_VER_SFT	4
	/* RoCEv1 Message */
		#define CQ_RES_UD_CFA_V2_FLAGS_ROCE_IP_VER_V1	(UINT32_C(0x0) << 4)
	/* RoCEv2 IPv4 Message */
		#define CQ_RES_UD_CFA_V2_FLAGS_ROCE_IP_VER_V2IPV4	(UINT32_C(0x2) << 4)
	/* RoCEv2 IPv6 Message */
		#define CQ_RES_UD_CFA_V2_FLAGS_ROCE_IP_VER_V2IPV6	(UINT32_C(0x3) << 4)
		#define CQ_RES_UD_CFA_V2_FLAGS_ROCE_IP_VER_LAST	CQ_RES_UD_CFA_V2_FLAGS_ROCE_IP_VER_V2IPV6
	/* The field indicates what format the metadata field is. */
	#define CQ_RES_UD_CFA_V2_FLAGS_META_FORMAT_MASK	UINT32_C(0x3c0)
	#define CQ_RES_UD_CFA_V2_FLAGS_META_FORMAT_SFT	6
	/* No metadata information.  Value is zero. */
		#define CQ_RES_UD_CFA_V2_FLAGS_META_FORMAT_NONE	(UINT32_C(0x0) << 6)
	/*
	 * The {metadata1, metadata0} fields contain the vtag
	 * information: - vtag[19:0] = {valid, tpid_sel[2:0], pri[2:0],
	 * de, vid[11:0]} The metadata2 field contains the table scope
	 * and action record pointer. - metadata2[25:0] contains the
	 * action record pointer. - metadata2[31:26] contains the table
	 * scope.
	 */
		#define CQ_RES_UD_CFA_V2_FLAGS_META_FORMAT_ACT_REC_PTR  (UINT32_C(0x1) << 6)
	/*
	 * The {metadata1, metadata0} fields contain the vtag
	 * information:
	 * - vtag[19:0] = {valid, tpid_sel[2:0], pri[2:0], de, vid[11:0]}
	 * The metadata2 field contains the Tunnel ID
	 * value, justified to LSB. i
	 * - VXLAN = VNI[23:0] -> VXLAN Network ID
	 * - Geneve (NGE) = VNI[23:0] a-> Virtual Network Identifier
	 * - NVGRE = TNI[23:0] -> Tenant Network ID
	 * - GRE = KEY[31:0] -> key field with bit mask. zero if K=0
	 * - IPv4 = 0 (not populated)
	 * - IPv6 = Flow Label[19:0]
	 * - PPPoE = sessionID[15:0]
	 * - MPLs = Outer label[19:0]
	 * - UPAR = Selected[31:0] with bit mask
	 */
		#define CQ_RES_UD_CFA_V2_FLAGS_META_FORMAT_TUNNEL_ID	(UINT32_C(0x2) << 6)
	/*
	 * The {metadata1, metadata0} fields contain the vtag
	 * information:
	 * - vtag[19:0] = {valid, tpid_sel[2:0], pri[2:0],de, vid[11:0]}
	 * The metadata2 field contains the 32b metadata from the
	 * prepended header (chdr_data).
	 */
		#define CQ_RES_UD_CFA_V2_FLAGS_META_FORMAT_CHDR_DATA	(UINT32_C(0x3) << 6)
	/*
	 * If ext_meta_format is equal to 1, the metadata field contains
	 * the outer_l3_offset and lower 7 bits of the inner_l2_offset,
	 * - metadata[8:0] contains the outer_l3_offset.
	 * - metadata[15:9] contains the inner_l2_offset[6:0]
	 */
		#define CQ_RES_UD_CFA_V2_FLAGS_META_FORMAT_HDR_OFFSET   (UINT32_C(0x4) << 6)
		#define CQ_RES_UD_CFA_V2_FLAGS_META_FORMAT_LAST	CQ_RES_UD_CFA_V2_FLAGS_META_FORMAT_HDR_OFFSET
	uint32_t	src_qp_high_srq_or_rq_wr_id;
	/*
	 * Opaque value from RQ or SRQ WQE. Used by driver/lib to
	 * reference the WQE in order to claim the received data
	 * and reuse the WQE space
	 */
	#define CQ_RES_UD_CFA_V2_SRQ_OR_RQ_WR_ID_MASK	UINT32_C(0xfffff)
	#define CQ_RES_UD_CFA_V2_SRQ_OR_RQ_WR_ID_SFT		0
	#define CQ_RES_UD_CFA_V2_CFA_METADATA1_MASK		UINT32_C(0xf00000)
	#define CQ_RES_UD_CFA_V2_CFA_METADATA1_SFT		20
	/* When meta_format != 0, this value is the VLAN TPID_SEL. */
	#define CQ_RES_UD_CFA_V2_CFA_METADATA1_TPID_SEL_MASK	UINT32_C(0x700000)
	#define CQ_RES_UD_CFA_V2_CFA_METADATA1_TPID_SEL_SFT	20
	/* 0x88a8 */
		#define CQ_RES_UD_CFA_V2_CFA_METADATA1_TPID_SEL_TPID88A8   (UINT32_C(0x0) << 20)
	/* 0x8100 */
		#define CQ_RES_UD_CFA_V2_CFA_METADATA1_TPID_SEL_TPID8100   (UINT32_C(0x1) << 20)
	/* 0x9100 */
		#define CQ_RES_UD_CFA_V2_CFA_METADATA1_TPID_SEL_TPID9100   (UINT32_C(0x2) << 20)
	/* 0x9200 */
		#define CQ_RES_UD_CFA_V2_CFA_METADATA1_TPID_SEL_TPID9200   (UINT32_C(0x3) << 20)
	/* 0x9300 */
		#define CQ_RES_UD_CFA_V2_CFA_METADATA1_TPID_SEL_TPID9300   (UINT32_C(0x4) << 20)
	/* Value programmed in CFA VLANTPID register. */
		#define CQ_RES_UD_CFA_V2_CFA_METADATA1_TPID_SEL_TPIDCFG	(UINT32_C(0x5) << 20)
		#define CQ_RES_UD_CFA_V2_CFA_METADATA1_TPID_SEL_LAST	CQ_RES_UD_CFA_V2_CFA_METADATA1_TPID_SEL_TPIDCFG
	/* When meta_format != 0, this value is the VLAN valid. */
	#define CQ_RES_UD_CFA_V2_CFA_METADATA1_VALID		UINT32_C(0x800000)
	/* Upper 8b of the Source QP value from the DETH header. */
	#define CQ_RES_UD_CFA_V2_SRC_QP_HIGH_MASK		UINT32_C(0xff000000)
	#define CQ_RES_UD_CFA_V2_SRC_QP_HIGH_SFT		24
} cq_res_ud_cfa_v2_t, *pcq_res_ud_cfa_v2_t;

/* Responder RawEth and QP1 CQE */
/* cq_res_raweth_qp1 (size:256b/32B) */

typedef struct cq_res_raweth_qp1 {
	uint16_t	length;
	/*
	 * The length of the message's payload in bytes, stored in
	 * the SGEs
	 */
	#define CQ_RES_RAWETH_QP1_LENGTH_MASK UINT32_C(0x3fff)
	#define CQ_RES_RAWETH_QP1_LENGTH_SFT 0
	uint16_t	raweth_qp1_flags;
	#define CQ_RES_RAWETH_QP1_RAWETH_QP1_FLAGS_MASK		UINT32_C(0x3ff)
	#define CQ_RES_RAWETH_QP1_RAWETH_QP1_FLAGS_SFT		0
	/*
	 * When this bit is '1', it indicates a packet that has an
	 * error of some type.  Type of error is indicated in
	 * raweth_qp1_errors.
	 */
	#define CQ_RES_RAWETH_QP1_RAWETH_QP1_FLAGS_ERROR		UINT32_C(0x1)
	/*
	 * This value indicates what the inner packet determined for the
	 * packet was.
	 */
	#define CQ_RES_RAWETH_QP1_RAWETH_QP1_FLAGS_ITYPE_MASK		UINT32_C(0x3c0)
	#define CQ_RES_RAWETH_QP1_RAWETH_QP1_FLAGS_ITYPE_SFT		6
	/*
	 * Not Known:
	 * Indicates that the packet type was not known.
	 */
		#define CQ_RES_RAWETH_QP1_RAWETH_QP1_FLAGS_ITYPE_NOT_KNOWN	(UINT32_C(0x0) << 6)
	/*
	 * IP Packet:
	 * Indicates that the packet was an IP packet, but further
	 * classification was not possible.
	 */
		#define CQ_RES_RAWETH_QP1_RAWETH_QP1_FLAGS_ITYPE_IP		(UINT32_C(0x1) << 6)
	/*
	 * TCP Packet:
	 * Indicates that the packet was IP and TCP.
	 * This indicates that the raweth_qp1_payload_offset field is valid.
	 */
		#define CQ_RES_RAWETH_QP1_RAWETH_QP1_FLAGS_ITYPE_TCP		(UINT32_C(0x2) << 6)
	/*
	 * UDP Packet:
	 * Indicates that the packet was IP and UDP.
	 * This indicates that the raweth_qp1_payload_offset field is valid.
	 */
		#define CQ_RES_RAWETH_QP1_RAWETH_QP1_FLAGS_ITYPE_UDP		(UINT32_C(0x3) << 6)
	/*
	 * FCoE Packet:
	 * Indicates that the packet was recognized as a FCoE.
	 * This also indicates that the raweth_qp1_payload_offset field is valid.
	 */
		#define CQ_RES_RAWETH_QP1_RAWETH_QP1_FLAGS_ITYPE_FCOE		(UINT32_C(0x4) << 6)
	/*
	 * RoCE Packet:
	 * Indicates that the packet was recognized as a RoCE.
	 * This also indicates that the raweth_qp1_payload_offset field is valid.
	 */
		#define CQ_RES_RAWETH_QP1_RAWETH_QP1_FLAGS_ITYPE_ROCE		(UINT32_C(0x5) << 6)
	/*
	 * ICMP Packet:
	 * Indicates that the packet was recognized as ICMP.
	 * This indicates that the raweth_qp1_payload_offset field is valid.
	 */
		#define CQ_RES_RAWETH_QP1_RAWETH_QP1_FLAGS_ITYPE_ICMP		(UINT32_C(0x7) << 6)
	/*
	 * PtP packet wo/timestamp:
	 * Indicates that the packet was recognized as a PtP
	 * packet.
	 */
		#define CQ_RES_RAWETH_QP1_RAWETH_QP1_FLAGS_ITYPE_PTP_WO_TIMESTAMP   (UINT32_C(0x8) << 6)
	/*
	 * PtP packet w/timestamp:
	 * Indicates that the packet was recognized as a PtP
	 * packet and that a timestamp was taken for the packet.
	 */
		#define CQ_RES_RAWETH_QP1_RAWETH_QP1_FLAGS_ITYPE_PTP_W_TIMESTAMP	(UINT32_C(0x9) << 6)
		#define CQ_RES_RAWETH_QP1_RAWETH_QP1_FLAGS_ITYPE_LAST		CQ_RES_RAWETH_QP1_RAWETH_QP1_FLAGS_ITYPE_PTP_W_TIMESTAMP
	uint16_t	raweth_qp1_errors;
	/*
	 * This indicates that there was an error in the IP header
	 * checksum.
	 */
	#define CQ_RES_RAWETH_QP1_RAWETH_QP1_ERRORS_IP_CS_ERROR			UINT32_C(0x10)
	/*
	 * This indicates that there was an error in the TCP, UDP
	 * or ICMP checksum.
	 */
	#define CQ_RES_RAWETH_QP1_RAWETH_QP1_ERRORS_L4_CS_ERROR			UINT32_C(0x20)
	/*
	 * This indicates that there was an error in the tunnel
	 * IP header checksum.
	 */
	#define CQ_RES_RAWETH_QP1_RAWETH_QP1_ERRORS_T_IP_CS_ERROR			UINT32_C(0x40)
	/*
	 * This indicates that there was an error in the tunnel
	 * UDP checksum.
	 */
	#define CQ_RES_RAWETH_QP1_RAWETH_QP1_ERRORS_T_L4_CS_ERROR			UINT32_C(0x80)
	/*
	 * This indicates that there was a CRC error on either an FCoE
	 * or RoCE packet.  The itype indicates the packet type.
	 */
	#define CQ_RES_RAWETH_QP1_RAWETH_QP1_ERRORS_CRC_ERROR			UINT32_C(0x100)
	/*
	 * This indicates that there was an error in the tunnel
	 * portion of the packet when this
	 * field is non-zero.
	 */
	#define CQ_RES_RAWETH_QP1_RAWETH_QP1_ERRORS_T_PKT_ERROR_MASK		UINT32_C(0xe00)
	#define CQ_RES_RAWETH_QP1_RAWETH_QP1_ERRORS_T_PKT_ERROR_SFT		9
	/*
	 * No additional error occurred on the tunnel portion
	 * of the packet of the packet does not have a tunnel.
	 */
		#define CQ_RES_RAWETH_QP1_RAWETH_QP1_ERRORS_T_PKT_ERROR_NO_ERROR		(UINT32_C(0x0) << 9)
	/*
	 * Indicates that IP header version does not match
	 * expectation from L2 Ethertype for IPv4 and IPv6
	 * in the tunnel header.
	 */
		#define CQ_RES_RAWETH_QP1_RAWETH_QP1_ERRORS_T_PKT_ERROR_T_L3_BAD_VERSION	(UINT32_C(0x1) << 9)
	/*
	 * Indicates that header length is out of range in the
	 * tunnel header. Valid for
	 * IPv4.
	 */
		#define CQ_RES_RAWETH_QP1_RAWETH_QP1_ERRORS_T_PKT_ERROR_T_L3_BAD_HDR_LEN	(UINT32_C(0x2) << 9)
	/*
	 * Indicates that the physical packet is shorter than that
	 * claimed by the PPPoE header length for a tunnel PPPoE
	 * packet.
	 */
		#define CQ_RES_RAWETH_QP1_RAWETH_QP1_ERRORS_T_PKT_ERROR_TUNNEL_TOTAL_ERROR	(UINT32_C(0x3) << 9)
	/*
	 * Indicates that physical packet is shorter than that claimed
	 * by the tunnel l3 header length. Valid for IPv4, or IPv6
	 * tunnel packet packets.
	 */
		#define CQ_RES_RAWETH_QP1_RAWETH_QP1_ERRORS_T_PKT_ERROR_T_IP_TOTAL_ERROR	(UINT32_C(0x4) << 9)
	/*
	 * Indicates that the physical packet is shorter than that
	 * claimed by the tunnel UDP header length for a tunnel
	 * UDP packet that is not fragmented.
	 */
		#define CQ_RES_RAWETH_QP1_RAWETH_QP1_ERRORS_T_PKT_ERROR_T_UDP_TOTAL_ERROR	(UINT32_C(0x5) << 9)
	/*
	 * indicates that the IPv4 TTL or IPv6 hop limit check
	 * have failed (e.g. TTL = 0) in the tunnel header. Valid
	 * for IPv4, and IPv6.
	 */
		#define CQ_RES_RAWETH_QP1_RAWETH_QP1_ERRORS_T_PKT_ERROR_T_L3_BAD_TTL		(UINT32_C(0x6) << 9)
		#define CQ_RES_RAWETH_QP1_RAWETH_QP1_ERRORS_T_PKT_ERROR_LAST		CQ_RES_RAWETH_QP1_RAWETH_QP1_ERRORS_T_PKT_ERROR_T_L3_BAD_TTL
	/*
	 * This indicates that there was an error in the inner
	 * portion of the packet when this
	 * field is non-zero.
	 */
	#define CQ_RES_RAWETH_QP1_RAWETH_QP1_ERRORS_PKT_ERROR_MASK			UINT32_C(0xf000)
	#define CQ_RES_RAWETH_QP1_RAWETH_QP1_ERRORS_PKT_ERROR_SFT			12
	/*
	 * No additional error occurred on the tunnel portion
	 * of the packet of the packet does not have a tunnel.
	 */
		#define CQ_RES_RAWETH_QP1_RAWETH_QP1_ERRORS_PKT_ERROR_NO_ERROR		(UINT32_C(0x0) << 12)
	/*
	 * Indicates that IP header version does not match
	 * expectation from L2 Ethertype for IPv4 and IPv6 or that
	 * option other than VFT was parsed on
	 * FCoE packet.
	 */
		#define CQ_RES_RAWETH_QP1_RAWETH_QP1_ERRORS_PKT_ERROR_L3_BAD_VERSION		(UINT32_C(0x1) << 12)
	/*
	 * indicates that header length is out of range. Valid for
	 * IPv4 and RoCE
	 */
		#define CQ_RES_RAWETH_QP1_RAWETH_QP1_ERRORS_PKT_ERROR_L3_BAD_HDR_LEN		(UINT32_C(0x2) << 12)
	/*
	 * indicates that the IPv4 TTL or IPv6 hop limit check
	 * have failed (e.g. TTL = 0). Valid for IPv4, and IPv6
	 */
		#define CQ_RES_RAWETH_QP1_RAWETH_QP1_ERRORS_PKT_ERROR_L3_BAD_TTL		(UINT32_C(0x3) << 12)
	/*
	 * Indicates that physical packet is shorter than that
	 * claimed by the l3 header length. Valid for IPv4,
	 * IPv6 packet or RoCE packets.
	 */
		#define CQ_RES_RAWETH_QP1_RAWETH_QP1_ERRORS_PKT_ERROR_IP_TOTAL_ERROR		(UINT32_C(0x4) << 12)
	/*
	 * Indicates that the physical packet is shorter than that
	 * claimed by the UDP header length for a UDP packet that is
	 * not fragmented.
	 */
		#define CQ_RES_RAWETH_QP1_RAWETH_QP1_ERRORS_PKT_ERROR_UDP_TOTAL_ERROR	(UINT32_C(0x5) << 12)
	/*
	 * Indicates that TCP header length > IP payload. Valid for
	 * TCP packets only.
	 */
		#define CQ_RES_RAWETH_QP1_RAWETH_QP1_ERRORS_PKT_ERROR_L4_BAD_HDR_LEN		(UINT32_C(0x6) << 12)
	/* Indicates that TCP header length < 5. Valid for TCP. */
		#define CQ_RES_RAWETH_QP1_RAWETH_QP1_ERRORS_PKT_ERROR_L4_BAD_HDR_LEN_TOO_SMALL  (UINT32_C(0x7) << 12)
	/*
	 * Indicates that TCP option headers result in a TCP header
	 * size that does not match data offset in TCP header. Valid
	 * for TCP.
	 */
		#define CQ_RES_RAWETH_QP1_RAWETH_QP1_ERRORS_PKT_ERROR_L4_BAD_OPT_LEN		(UINT32_C(0x8) << 12)
		#define CQ_RES_RAWETH_QP1_RAWETH_QP1_ERRORS_PKT_ERROR_LAST			CQ_RES_RAWETH_QP1_RAWETH_QP1_ERRORS_PKT_ERROR_L4_BAD_OPT_LEN
	/*
	 * This field identifies the CFA action rule that was used for this
	 * packet.
	 */
	uint16_t	raweth_qp1_cfa_code;
	/*
	 * This is an application level ID used to identify the
	 * QP and its SQ and RQ.
	 */
	uint64_t	qp_handle;
	uint32_t	raweth_qp1_flags2;
	/*
	 * This indicates that the ip checksum was calculated for the
	 * inner packet and that the ip_cs_error field indicates if there
	 * was an error.
	 */
	#define CQ_RES_RAWETH_QP1_RAWETH_QP1_FLAGS2_IP_CS_CALC		UINT32_C(0x1)
	/*
	 * This indicates that the TCP, UDP or ICMP checksum was
	 * calculated for the inner packet and that the l4_cs_error field
	 * indicates if there was an error.
	 */
	#define CQ_RES_RAWETH_QP1_RAWETH_QP1_FLAGS2_L4_CS_CALC		UINT32_C(0x2)
	/*
	 * This indicates that the ip checksum was calculated for the
	 * tunnel header and that the t_ip_cs_error field indicates if there
	 * was an error.
	 */
	#define CQ_RES_RAWETH_QP1_RAWETH_QP1_FLAGS2_T_IP_CS_CALC		UINT32_C(0x4)
	/*
	 * This indicates that the UDP checksum was
	 * calculated for the tunnel packet and that the t_l4_cs_error field
	 * indicates if there was an error.
	 */
	#define CQ_RES_RAWETH_QP1_RAWETH_QP1_FLAGS2_T_L4_CS_CALC		UINT32_C(0x8)
	/* This value indicates what format the raweth_qp1_metadata field is. */
	#define CQ_RES_RAWETH_QP1_RAWETH_QP1_FLAGS2_META_FORMAT_MASK	UINT32_C(0xf0)
	#define CQ_RES_RAWETH_QP1_RAWETH_QP1_FLAGS2_META_FORMAT_SFT		4
	/* No metadata information.  Value is zero. */
		#define CQ_RES_RAWETH_QP1_RAWETH_QP1_FLAGS2_META_FORMAT_NONE		(UINT32_C(0x0) << 4)
	/*
	 * The raweth_qp1_metadata field contains the VLAN tag and TPID value.
	 * - raweth_qp1_metadata[11:0] contains the vlan VID value.
	 * - raweth_qp1_metadata[12] contains the vlan DE value.
	 * - raweth_qp1_metadata[15:13] contains the vlan PRI value.
	 * - raweth_qp1_metadata[31:16] contains the vlan TPID value.
	 */
		#define CQ_RES_RAWETH_QP1_RAWETH_QP1_FLAGS2_META_FORMAT_VLAN		(UINT32_C(0x1) << 4)
	/*
	 * If ext_meta_format is equal to 1, the metadata field
	 * contains the lower 16b of the tunnel ID value, justified
	 * to LSB
	 * - VXLAN = VNI[23:0] -> VXLAN Network ID
	 * - Geneve (NGE) = VNI[23:0] -> Virtual Network Identifier.
	 * - NVGRE = TNI[23:0] -> Tenant Network ID
	 * - GRE = KEY[31:0] -> key field with bit mask. zero if K = 0
	 * - IPV4 = 0 (not populated)
	 * - IPV6 = Flow Label[19:0]
	 * - PPPoE = sessionID[15:0]
	 * - MPLs = Outer label[19:0]
	 * - UPAR = Selected[31:0] with bit mask
	 */
		#define CQ_RES_RAWETH_QP1_RAWETH_QP1_FLAGS2_META_FORMAT_TUNNEL_ID	(UINT32_C(0x2) << 4)
	/*
	 * if ext_meta_format is equal to 1, metadata field contains
	 * 16b metadata from the prepended header (chdr_data).
	 */
		#define CQ_RES_RAWETH_QP1_RAWETH_QP1_FLAGS2_META_FORMAT_CHDR_DATA	(UINT32_C(0x3) << 4)
	/*
	 * If ext_meta_format is equal to 1, the metadata field contains
	 * the outer_l3_offset and lower 7 bits of the inner_l2_offset,
	 * - metadata[8:0] contains the outer_l3_offset.
	 * - metadata[15:9] contains the inner_l2_offset[6:0]
	 */
		#define CQ_RES_RAWETH_QP1_RAWETH_QP1_FLAGS2_META_FORMAT_HDR_OFFSET	(UINT32_C(0x4) << 4)
		#define CQ_RES_RAWETH_QP1_RAWETH_QP1_FLAGS2_META_FORMAT_LAST		CQ_RES_RAWETH_QP1_RAWETH_QP1_FLAGS2_META_FORMAT_HDR_OFFSET
	/*
	 * This field indicates the IP type for the inner-most IP header.
	 * A value of '0' indicates IPv4.  A value of '1' indicates IPv6.
	 * This value is only valid if itype indicates a packet
	 * with an IP header.
	 */
	#define CQ_RES_RAWETH_QP1_RAWETH_QP1_FLAGS2_IP_TYPE			UINT32_C(0x100)
	/*
	 * This indicates that the complete 1's complement checksum was
	 * calculated for the packet.
	 */
	#define CQ_RES_RAWETH_QP1_RAWETH_QP1_FLAGS2_COMPLETE_CHECKSUM_CALC	UINT32_C(0x200)
	/*
	 * The combination of this value and meta_format indicated what
	 * format the metadata field is.
	 */
	#define CQ_RES_RAWETH_QP1_RAWETH_QP1_FLAGS2_EXT_META_FORMAT_MASK	UINT32_C(0xc00)
	#define CQ_RES_RAWETH_QP1_RAWETH_QP1_FLAGS2_EXT_META_FORMAT_SFT	10
	/*
	 * This value is the complete 1's complement checksum calculated from
	 * the start of the outer L3 header to the end of the packet (not
	 * including the ethernet crc). It is valid when the
	 * 'complete_checksum_calc' flag is set.
	 */
	#define CQ_RES_RAWETH_QP1_RAWETH_QP1_FLAGS2_COMPLETE_CHECKSUM_MASK	UINT32_C(0xffff0000)
	#define CQ_RES_RAWETH_QP1_RAWETH_QP1_FLAGS2_COMPLETE_CHECKSUM_SFT	16
	/*
	 * This is data from the CFA block as indicated by the meta_format
	 * field.
	 */
	uint32_t	raweth_qp1_metadata;
	#define CQ_RES_RAWETH_QP1_RAWETH_QP1_METADATA_PRI_DE_VID_MASK	UINT32_C(0xffff)
	#define CQ_RES_RAWETH_QP1_RAWETH_QP1_METADATA_PRI_DE_VID_SFT	0
	/* When meta_format=1, this value is the VLAN VID. */
	#define CQ_RES_RAWETH_QP1_RAWETH_QP1_METADATA_VID_MASK	UINT32_C(0xfff)
	#define CQ_RES_RAWETH_QP1_RAWETH_QP1_METADATA_VID_SFT		0
	/* When meta_format=1, this value is the VLAN DE. */
	#define CQ_RES_RAWETH_QP1_RAWETH_QP1_METADATA_DE		UINT32_C(0x1000)
	/* When meta_format=1, this value is the VLAN PRI. */
	#define CQ_RES_RAWETH_QP1_RAWETH_QP1_METADATA_PRI_MASK	UINT32_C(0xe000)
	#define CQ_RES_RAWETH_QP1_RAWETH_QP1_METADATA_PRI_SFT		13
	/* When meta_format=1, this value is the VLAN TPID. */
	#define CQ_RES_RAWETH_QP1_RAWETH_QP1_METADATA_TPID_MASK	UINT32_C(0xffff0000)
	#define CQ_RES_RAWETH_QP1_RAWETH_QP1_METADATA_TPID_SFT	16
	uint8_t	cqe_type_toggle;
	/*
	 * Indicate valid completion - written by the chip. Cumulus
	 * toggle this bit each time it finished consuming all PBL
	 * entries
	 */
	#define CQ_RES_RAWETH_QP1_TOGGLE		UINT32_C(0x1)
	/* This field defines the type of SQ WQE. */
	#define CQ_RES_RAWETH_QP1_CQE_TYPE_MASK	UINT32_C(0x1e)
	#define CQ_RES_RAWETH_QP1_CQE_TYPE_SFT	1
	/*
	 * Responder RawEth and QP1 Completion - This is used for RQ
	 * completion for RawEth service and QP1 service QPs.
	 */
		#define CQ_RES_RAWETH_QP1_CQE_TYPE_RES_RAWETH_QP1  (UINT32_C(0x3) << 1)
		#define CQ_RES_RAWETH_QP1_CQE_TYPE_LAST	CQ_RES_RAWETH_QP1_CQE_TYPE_RES_RAWETH_QP1
	/* This field indicates the status for the CQE. */
	uint8_t	status;
	/*
	 * This indicates that the completion is without error.
	 * All fields are valid.
	 */
	#define CQ_RES_RAWETH_QP1_STATUS_OK			UINT32_C(0x0)
	/*
	 * This indicates that write access was not allowed for
	 * at least one of the SGEs in the WQE.
	 *
	 * This is a fatal error.  Only the srq_or_rq_wr_id is field
	 * is valid.
	 */
	#define CQ_RES_RAWETH_QP1_STATUS_LOCAL_ACCESS_ERROR	UINT32_C(0x1)
	/*
	 * This indicates that the packet was too long for the WQE
	 * provided on the RQ.
	 *
	 * This is not a fatal error.  All the fields are valid.
	 */
	#define CQ_RES_RAWETH_QP1_STATUS_HW_LOCAL_LENGTH_ERR	UINT32_C(0x2)
	/* LOCAL_PROTECTION_ERR is 3 */
	#define CQ_RES_RAWETH_QP1_STATUS_LOCAL_PROTECTION_ERR	UINT32_C(0x3)
	/* LOCAL_QP_OPERATION_ERR is 4 */
	#define CQ_RES_RAWETH_QP1_STATUS_LOCAL_QP_OPERATION_ERR   UINT32_C(0x4)
	/* MEMORY_MGT_OPERATION_ERR is 5 */
	#define CQ_RES_RAWETH_QP1_STATUS_MEMORY_MGT_OPERATION_ERR UINT32_C(0x5)
	/* WORK_REQUEST_FLUSHED_ERR is 7 */
	#define CQ_RES_RAWETH_QP1_STATUS_WORK_REQUEST_FLUSHED_ERR UINT32_C(0x7)
	/* HW_FLUSH_ERR is 8 */
	#define CQ_RES_RAWETH_QP1_STATUS_HW_FLUSH_ERR		UINT32_C(0x8)
	#define CQ_RES_RAWETH_QP1_STATUS_LAST			CQ_RES_RAWETH_QP1_STATUS_HW_FLUSH_ERR
	uint16_t	flags;
	/*
	 * This flag indicates that the completion is for a SRQ entry
	 * rather than for an RQ entry.
	 */
	#define CQ_RES_RAWETH_QP1_FLAGS_SRQ	UINT32_C(0x1)
	/* CQE relates to RQ WQE. */
		#define CQ_RES_RAWETH_QP1_FLAGS_SRQ_RQ	UINT32_C(0x0)
	/* CQE relates to SRQ WQE. */
		#define CQ_RES_RAWETH_QP1_FLAGS_SRQ_SRQ   UINT32_C(0x1)
		#define CQ_RES_RAWETH_QP1_FLAGS_SRQ_LAST CQ_RES_RAWETH_QP1_FLAGS_SRQ_SRQ
	uint32_t	raweth_qp1_payload_offset_srq_or_rq_wr_id;
	/*
	 * Opaque value from RQ or SRQ WQE. Used by driver/lib to
	 * reference the WQE in order to claim the received data
	 * and reuse the WQE space
	 */
	#define CQ_RES_RAWETH_QP1_SRQ_OR_RQ_WR_ID_MASK	UINT32_C(0xfffff)
	#define CQ_RES_RAWETH_QP1_SRQ_OR_RQ_WR_ID_SFT	0
	/*
	 * This value indicates the offset in bytes from the beginning of the packet
	 * where the inner payload starts.  This value is valid for TCP, UDP,
	 * FCoE, and RoCE packets.
	 *
	 * A value of zero indicates an offset of 256 bytes.
	 */
	#define CQ_RES_RAWETH_QP1_RAWETH_QP1_PAYLOAD_OFFSET_MASK UINT32_C(0xff000000)
	#define CQ_RES_RAWETH_QP1_RAWETH_QP1_PAYLOAD_OFFSET_SFT 24
} cq_res_raweth_qp1_t, *pcq_res_raweth_qp1_t;

/* Responder RawEth and QP1 CQE version 2 */
/* cq_res_raweth_qp1_v2 (size:256b/32B) */

typedef struct cq_res_raweth_qp1_v2 {
	uint16_t	length;
	/*
	 * The length of the message's payload in bytes, stored in
	 * the SGEs
	 */
	#define CQ_RES_RAWETH_QP1_V2_LENGTH_MASK UINT32_C(0x3fff)
	#define CQ_RES_RAWETH_QP1_V2_LENGTH_SFT 0
	uint16_t	raweth_qp1_flags;
	#define CQ_RES_RAWETH_QP1_V2_RAWETH_QP1_FLAGS_MASK		UINT32_C(0x3ff)
	#define CQ_RES_RAWETH_QP1_V2_RAWETH_QP1_FLAGS_SFT		0
	/*
	 * When this bit is '1', it indicates a packet that has an
	 * error of some type.  Type of error is indicated in
	 * raweth_qp1_errors.
	 */
	#define CQ_RES_RAWETH_QP1_V2_RAWETH_QP1_FLAGS_ERROR		UINT32_C(0x1)
	/*
	 * This value indicates what the inner packet determined for the
	 * packet was.
	 */
	#define CQ_RES_RAWETH_QP1_V2_RAWETH_QP1_FLAGS_ITYPE_MASK		UINT32_C(0x3c0)
	#define CQ_RES_RAWETH_QP1_V2_RAWETH_QP1_FLAGS_ITYPE_SFT		6
	/*
	 * Not Known:
	 * Indicates that the packet type was not known.
	 */
		#define CQ_RES_RAWETH_QP1_V2_RAWETH_QP1_FLAGS_ITYPE_NOT_KNOWN	(UINT32_C(0x0) << 6)
	/*
	 * IP Packet:
	 * Indicates that the packet was an IP packet, but further
	 * classification was not possible.
	 */
		#define CQ_RES_RAWETH_QP1_V2_RAWETH_QP1_FLAGS_ITYPE_IP		(UINT32_C(0x1) << 6)
	/*
	 * TCP Packet:
	 * Indicates that the packet was IP and TCP.
	 * This indicates that the raweth_qp1_payload_offset field is
	 * valid.
	 */
		#define CQ_RES_RAWETH_QP1_V2_RAWETH_QP1_FLAGS_ITYPE_TCP		(UINT32_C(0x2) << 6)
	/*
	 * UDP Packet:
	 * Indicates that the packet was IP and UDP.
	 * This indicates that the raweth_qp1_payload_offset field is
	 * valid.
	 */
		#define CQ_RES_RAWETH_QP1_V2_RAWETH_QP1_FLAGS_ITYPE_UDP		(UINT32_C(0x3) << 6)
	/*
	 * FCoE Packet:
	 * Indicates that the packet was recognized as a FCoE.
	 * This also indicates that the raweth_qp1_payload_offset field
	 * is valid.
	 */
		#define CQ_RES_RAWETH_QP1_V2_RAWETH_QP1_FLAGS_ITYPE_FCOE		(UINT32_C(0x4) << 6)
	/*
	 * RoCE Packet:
	 * Indicates that the packet was recognized as a RoCE.
	 * This also indicates that the raweth_qp1_payload_offset field
	 * is valid.
	 */
		#define CQ_RES_RAWETH_QP1_V2_RAWETH_QP1_FLAGS_ITYPE_ROCE		(UINT32_C(0x5) << 6)
	/*
	 * ICMP Packet:
	 * Indicates that the packet was recognized as ICMP.
	 * This indicates that the raweth_qp1_payload_offset field is
	 * valid.
	 */
		#define CQ_RES_RAWETH_QP1_V2_RAWETH_QP1_FLAGS_ITYPE_ICMP		(UINT32_C(0x7) << 6)
	/*
	 * PtP packet wo/timestamp:
	 * Indicates that the packet was recognized as a PtP
	 * packet.
	 */
		#define CQ_RES_RAWETH_QP1_V2_RAWETH_QP1_FLAGS_ITYPE_PTP_WO_TIMESTAMP   (UINT32_C(0x8) << 6)
	/*
	 * PtP packet w/timestamp:
	 * Indicates that the packet was recognized as a PtP
	 * packet and that a timestamp was taken for the packet.
	 */
		#define CQ_RES_RAWETH_QP1_V2_RAWETH_QP1_FLAGS_ITYPE_PTP_W_TIMESTAMP	(UINT32_C(0x9) << 6)
		#define CQ_RES_RAWETH_QP1_V2_RAWETH_QP1_FLAGS_ITYPE_LAST		CQ_RES_RAWETH_QP1_V2_RAWETH_QP1_FLAGS_ITYPE_PTP_W_TIMESTAMP
	uint16_t	raweth_qp1_errors;
	/*
	 * This indicates that there was an error in the IP header
	 * checksum.
	 */
	#define CQ_RES_RAWETH_QP1_V2_RAWETH_QP1_ERRORS_IP_CS_ERROR			UINT32_C(0x10)
	/*
	 * This indicates that there was an error in the TCP, UDP
	 * or ICMP checksum.
	 */
	#define CQ_RES_RAWETH_QP1_V2_RAWETH_QP1_ERRORS_L4_CS_ERROR			UINT32_C(0x20)
	/*
	 * This indicates that there was an error in the tunnel
	 * IP header checksum.
	 */
	#define CQ_RES_RAWETH_QP1_V2_RAWETH_QP1_ERRORS_T_IP_CS_ERROR			UINT32_C(0x40)
	/*
	 * This indicates that there was an error in the tunnel
	 * UDP checksum.
	 */
	#define CQ_RES_RAWETH_QP1_V2_RAWETH_QP1_ERRORS_T_L4_CS_ERROR			UINT32_C(0x80)
	/*
	 * This indicates that there was a CRC error on either an FCoE
	 * or RoCE packet.  The itype indicates the packet type.
	 */
	#define CQ_RES_RAWETH_QP1_V2_RAWETH_QP1_ERRORS_CRC_ERROR			UINT32_C(0x100)
	/*
	 * This indicates that there was an error in the tunnel
	 * portion of the packet when this
	 * field is non-zero.
	 */
	#define CQ_RES_RAWETH_QP1_V2_RAWETH_QP1_ERRORS_T_PKT_ERROR_MASK		UINT32_C(0xe00)
	#define CQ_RES_RAWETH_QP1_V2_RAWETH_QP1_ERRORS_T_PKT_ERROR_SFT		9
	/*
	 * No additional error occurred on the tunnel portion
	 * of the packet of the packet does not have a tunnel.
	 */
		#define CQ_RES_RAWETH_QP1_V2_RAWETH_QP1_ERRORS_T_PKT_ERROR_NO_ERROR		(UINT32_C(0x0) << 9)
	/*
	 * Indicates that IP header version does not match
	 * expectation from L2 Ethertype for IPv4 and IPv6
	 * in the tunnel header.
	 */
		#define CQ_RES_RAWETH_QP1_V2_RAWETH_QP1_ERRORS_T_PKT_ERROR_T_L3_BAD_VERSION	(UINT32_C(0x1) << 9)
	/*
	 * Indicates that header length is out of range in the
	 * tunnel header. Valid for
	 * IPv4.
	 */
		#define CQ_RES_RAWETH_QP1_V2_RAWETH_QP1_ERRORS_T_PKT_ERROR_T_L3_BAD_HDR_LEN	(UINT32_C(0x2) << 9)
	/*
	 * Indicates that the physical packet is shorter than that
	 * claimed by the PPPoE header length for a tunnel PPPoE
	 * packet.
	 */
		#define CQ_RES_RAWETH_QP1_V2_RAWETH_QP1_ERRORS_T_PKT_ERROR_TUNNEL_TOTAL_ERROR	(UINT32_C(0x3) << 9)
	/*
	 * Indicates that physical packet is shorter than that claimed
	 * by the tunnel l3 header length. Valid for IPv4, or IPv6
	 * tunnel packet packets.
	 */
		#define CQ_RES_RAWETH_QP1_V2_RAWETH_QP1_ERRORS_T_PKT_ERROR_T_IP_TOTAL_ERROR	(UINT32_C(0x4) << 9)
	/*
	 * Indicates that the physical packet is shorter than that
	 * claimed by the tunnel UDP header length for a tunnel
	 * UDP packet that is not fragmented.
	 */
		#define CQ_RES_RAWETH_QP1_V2_RAWETH_QP1_ERRORS_T_PKT_ERROR_T_UDP_TOTAL_ERROR	(UINT32_C(0x5) << 9)
	/*
	 * indicates that the IPv4 TTL or IPv6 hop limit check
	 * have failed (e.g. TTL = 0) in the tunnel header. Valid
	 * for IPv4, and IPv6.
	 */
		#define CQ_RES_RAWETH_QP1_V2_RAWETH_QP1_ERRORS_T_PKT_ERROR_T_L3_BAD_TTL		(UINT32_C(0x6) << 9)
		#define CQ_RES_RAWETH_QP1_V2_RAWETH_QP1_ERRORS_T_PKT_ERROR_LAST		CQ_RES_RAWETH_QP1_V2_RAWETH_QP1_ERRORS_T_PKT_ERROR_T_L3_BAD_TTL
	/*
	 * This indicates that there was an error in the inner
	 * portion of the packet when this
	 * field is non-zero.
	 */
	#define CQ_RES_RAWETH_QP1_V2_RAWETH_QP1_ERRORS_PKT_ERROR_MASK			UINT32_C(0xf000)
	#define CQ_RES_RAWETH_QP1_V2_RAWETH_QP1_ERRORS_PKT_ERROR_SFT			12
	/*
	 * No additional error occurred on the tunnel portion
	 * of the packet of the packet does not have a tunnel.
	 */
		#define CQ_RES_RAWETH_QP1_V2_RAWETH_QP1_ERRORS_PKT_ERROR_NO_ERROR		(UINT32_C(0x0) << 12)
	/*
	 * Indicates that IP header version does not match
	 * expectation from L2 Ethertype for IPv4 and IPv6 or that
	 * option other than VFT was parsed on
	 * FCoE packet.
	 */
		#define CQ_RES_RAWETH_QP1_V2_RAWETH_QP1_ERRORS_PKT_ERROR_L3_BAD_VERSION		(UINT32_C(0x1) << 12)
	/*
	 * indicates that header length is out of range. Valid for
	 * IPv4 and RoCE
	 */
		#define CQ_RES_RAWETH_QP1_V2_RAWETH_QP1_ERRORS_PKT_ERROR_L3_BAD_HDR_LEN		(UINT32_C(0x2) << 12)
	/*
	 * indicates that the IPv4 TTL or IPv6 hop limit check
	 * have failed (e.g. TTL = 0). Valid for IPv4, and IPv6
	 */
		#define CQ_RES_RAWETH_QP1_V2_RAWETH_QP1_ERRORS_PKT_ERROR_L3_BAD_TTL		(UINT32_C(0x3) << 12)
	/*
	 * Indicates that physical packet is shorter than that
	 * claimed by the l3 header length. Valid for IPv4,
	 * IPv6 packet or RoCE packets.
	 */
		#define CQ_RES_RAWETH_QP1_V2_RAWETH_QP1_ERRORS_PKT_ERROR_IP_TOTAL_ERROR		(UINT32_C(0x4) << 12)
	/*
	 * Indicates that the physical packet is shorter than that
	 * claimed by the UDP header length for a UDP packet that is
	 * not fragmented.
	 */
		#define CQ_RES_RAWETH_QP1_V2_RAWETH_QP1_ERRORS_PKT_ERROR_UDP_TOTAL_ERROR	(UINT32_C(0x5) << 12)
	/*
	 * Indicates that TCP header length > IP payload. Valid for
	 * TCP packets only.
	 */
		#define CQ_RES_RAWETH_QP1_V2_RAWETH_QP1_ERRORS_PKT_ERROR_L4_BAD_HDR_LEN		(UINT32_C(0x6) << 12)
	/* Indicates that TCP header length < 5. Valid for TCP. */
		#define CQ_RES_RAWETH_QP1_V2_RAWETH_QP1_ERRORS_PKT_ERROR_L4_BAD_HDR_LEN_TOO_SMALL  (UINT32_C(0x7) << 12)
	/*
	 * Indicates that TCP option headers result in a TCP header
	 * size that does not match data offset in TCP header. Valid
	 * for TCP.
	 */
		#define CQ_RES_RAWETH_QP1_V2_RAWETH_QP1_ERRORS_PKT_ERROR_L4_BAD_OPT_LEN		(UINT32_C(0x8) << 12)
		#define CQ_RES_RAWETH_QP1_V2_RAWETH_QP1_ERRORS_PKT_ERROR_LAST			CQ_RES_RAWETH_QP1_V2_RAWETH_QP1_ERRORS_PKT_ERROR_L4_BAD_OPT_LEN
	/* This is data from the CFA as indicated by the meta_format field. */
	uint16_t	cfa_metadata0;
	/* When meta_format=1, this value is the VLAN VID. */
	#define CQ_RES_RAWETH_QP1_V2_CFA_METADATA0_VID_MASK UINT32_C(0xfff)
	#define CQ_RES_RAWETH_QP1_V2_CFA_METADATA0_VID_SFT 0
	/* When meta_format=1, this value is the VLAN DE. */
	#define CQ_RES_RAWETH_QP1_V2_CFA_METADATA0_DE	UINT32_C(0x1000)
	/* When meta_format=1, this value is the VLAN PRI. */
	#define CQ_RES_RAWETH_QP1_V2_CFA_METADATA0_PRI_MASK UINT32_C(0xe000)
	#define CQ_RES_RAWETH_QP1_V2_CFA_METADATA0_PRI_SFT 13
	/*
	 * This is an application level ID used to identify the
	 * QP and its SQ and RQ.
	 */
	uint64_t	qp_handle;
	uint32_t	raweth_qp1_flags2;
	/*
	 * When this bit is '0', the cs_ok field has the following
	 * definition:- ip_cs_ok[2:0] = The number of header groups with a
	 * valid IP checksum in the delivered packet, counted from the
	 * outer-most header group to the inner-most header group, stopping
	 * at the first error. - l4_cs_ok[5:3] = The number of header groups
	 * with a valid L4 checksum in the delivered packet, counted from
	 * the outer-most header group to the inner-most header group,
	 * stopping at the first error. When this bit is '1', the cs_ok
	 * field has the following definition: - hdr_cnt[2:0] = The number of
	 * header groups that were parsed by the chip and passed in the
	 * delivered packet. - ip_cs_all_ok[3] =This bit will be '1' if all
	 * the parsed header groups with an IP checksum are valid.
	 * - l4_cs_all_ok[4] = This bit will be '1' if all the parsed header
	 * groups with an L4 checksum are valid.
	 */
	#define CQ_RES_RAWETH_QP1_V2_RAWETH_QP1_FLAGS2_CS_ALL_OK_MODE		UINT32_C(0x8)
	/* This value indicates what format the metadata field is. */
	#define CQ_RES_RAWETH_QP1_V2_RAWETH_QP1_FLAGS2_META_FORMAT_MASK	UINT32_C(0xf0)
	#define CQ_RES_RAWETH_QP1_V2_RAWETH_QP1_FLAGS2_META_FORMAT_SFT		4
	/* There is no metadata information. Values are zero. */
		#define CQ_RES_RAWETH_QP1_V2_RAWETH_QP1_FLAGS2_META_FORMAT_NONE		(UINT32_C(0x0) << 4)
	/*
	 * The {metadata1, metadata0} fields contain the vtag
	 * information: - vtag[19:0] = {valid, tpid_sel[2:0], pri[2:0],
	 * de, vid[11:0]} The metadata2 field contains the table scope
	 * and action record pointer. - metadata2[25:0] contains the
	 * action record pointer. - metadata2[31:26] contains the table
	 * scope.
	 */
		#define CQ_RES_RAWETH_QP1_V2_RAWETH_QP1_FLAGS2_META_FORMAT_ACT_REC_PTR	(UINT32_C(0x1) << 4)
	/*
	 * The {metadata1, metadata0} fields contain the vtag
	 * information:
	 * - vtag[19:0] = {valid, tpid_sel[2:0], pri[2:0], de, vid[11:0]}
	 * The metadata2 field contains the Tunnel ID
	 * value, justified to LSB. i
	 * - VXLAN = VNI[23:0] -> VXLAN Network ID
	 * - Geneve (NGE) = VNI[23:0] a-> Virtual Network Identifier
	 * - NVGRE = TNI[23:0] -> Tenant Network ID
	 * - GRE = KEY[31:0] -> key field with bit mask. zero if K=0
	 * - IPv4 = 0 (not populated)
	 * - IPv6 = Flow Label[19:0]
	 * - PPPoE = sessionID[15:0]
	 * - MPLs = Outer label[19:0]
	 * - UPAR = Selected[31:0] with bit mask
	 */
		#define CQ_RES_RAWETH_QP1_V2_RAWETH_QP1_FLAGS2_META_FORMAT_TUNNEL_ID	(UINT32_C(0x2) << 4)
	/*
	 * The {metadata1, metadata0} fields contain the vtag
	 * information:
	 * - vtag[19:0] = {valid, tpid_sel[2:0], pri[2:0],de, vid[11:0]}
	 * The metadata2 field contains the 32b metadata from the prepended
	 * header (chdr_data).
	 */
		#define CQ_RES_RAWETH_QP1_V2_RAWETH_QP1_FLAGS2_META_FORMAT_CHDR_DATA	(UINT32_C(0x3) << 4)
	/*
	 * The {metadata1, metadata0} fields contain the vtag
	 * information:
	 * - vtag[19:0] = {valid, tpid_sel[2:0], pri[2:0], de, vid[11:0]}
	 * The metadata2 field contains the outer_l3_offset,
	 * inner_l2_offset, inner_l3_offset, and inner_l4_size.
	 * - metadata2[8:0] contains the outer_l3_offset.
	 * - metadata2[17:9] contains the inner_l2_offset.
	 * - metadata2[26:18] contains the inner_l3_offset.
	 * - metadata2[31:27] contains the inner_l4_size.
	 */
		#define CQ_RES_RAWETH_QP1_V2_RAWETH_QP1_FLAGS2_META_FORMAT_HDR_OFFSET	(UINT32_C(0x4) << 4)
		#define CQ_RES_RAWETH_QP1_V2_RAWETH_QP1_FLAGS2_META_FORMAT_LAST		CQ_RES_RAWETH_QP1_V2_RAWETH_QP1_FLAGS2_META_FORMAT_HDR_OFFSET
	/*
	 * This field indicates the IP type for the inner-most IP header.
	 * A value of '0' indicates IPv4.  A value of '1' indicates IPv6.
	 * This value is only valid if itype indicates a packet
	 * with an IP header.
	 */
	#define CQ_RES_RAWETH_QP1_V2_RAWETH_QP1_FLAGS2_IP_TYPE			UINT32_C(0x100)
	/*
	 * This indicates that the complete 1's complement checksum was
	 * calculated for the packet.
	 */
	#define CQ_RES_RAWETH_QP1_V2_RAWETH_QP1_FLAGS2_COMPLETE_CHECKSUM_CALC	UINT32_C(0x200)
	/*
	 * This field indicates the status of IP and L4 CS calculations done
	 * by the chip. The format of this field is indicated by the
	 * cs_all_ok_mode bit.
	 */
	#define CQ_RES_RAWETH_QP1_V2_RAWETH_QP1_FLAGS2_CS_OK_MASK		UINT32_C(0xfc00)
	#define CQ_RES_RAWETH_QP1_V2_RAWETH_QP1_FLAGS2_CS_OK_SFT		10
	/*
	 * This value is the complete 1's complement checksum calculated from
	 * the start of the outer L3 header to the end of the packet (not
	 * including the ethernet crc). It is valid when the
	 * 'complete_checksum_calc' flag is set.
	 */
	#define CQ_RES_RAWETH_QP1_V2_RAWETH_QP1_FLAGS2_COMPLETE_CHECKSUM_MASK	UINT32_C(0xffff0000)
	#define CQ_RES_RAWETH_QP1_V2_RAWETH_QP1_FLAGS2_COMPLETE_CHECKSUM_SFT	16
	/*
	 * This is data from the CFA block as indicated by the meta_format
	 * field.
	 * - meta_format 0 - none - metadata2 = 0 - not valid/not stripped
	 * - meta_format 1 - act_rec_ptr - metadata2 = {table_scope[5:0],
	 *   act_rec_ptr[25:0]}
	 * - meta_format 2 - tunnel_id - metadata2 = tunnel_id[31:0]
	 * - meta_format 3 - chdr_data - metadata2 = updated_chdr_data[31:0]
	 * - meta_format 4 - hdr_offsets - metadata2 = hdr_offsets[31:0]
	 * When vee_cmpl_mode is set in VNIC context, this is the upper 32b
	 * of the host address from the first BD used to place the packet.
	 */
	uint32_t	cfa_metadata2;
	uint8_t	cqe_type_toggle;
	/*
	 * Indicate valid completion - written by the chip. Cumulus
	 * toggle this bit each time it finished consuming all PBL
	 * entries
	 */
	#define CQ_RES_RAWETH_QP1_V2_TOGGLE		UINT32_C(0x1)
	/* This field defines the type of SQ WQE. */
	#define CQ_RES_RAWETH_QP1_V2_CQE_TYPE_MASK	UINT32_C(0x1e)
	#define CQ_RES_RAWETH_QP1_V2_CQE_TYPE_SFT	1
	/*
	 * Responder RawEth and QP1 Completion - This is used for RQ
	 * completion for RawEth service and QP1 service QPs.
	 */
		#define CQ_RES_RAWETH_QP1_V2_CQE_TYPE_RES_RAWETH_QP1  (UINT32_C(0x3) << 1)
		#define CQ_RES_RAWETH_QP1_V2_CQE_TYPE_LAST	CQ_RES_RAWETH_QP1_V2_CQE_TYPE_RES_RAWETH_QP1
	/* This field indicates the status for the CQE. */
	uint8_t	status;
	/*
	 * This indicates that the completion is without error.
	 * All fields are valid.
	 */
	#define CQ_RES_RAWETH_QP1_V2_STATUS_OK			UINT32_C(0x0)
	/*
	 * This indicates that write access was not allowed for
	 * at least one of the SGEs in the WQE.
	 *
	 * This is a fatal error.  Only the srq_or_rq_wr_id is field
	 * is valid.
	 */
	#define CQ_RES_RAWETH_QP1_V2_STATUS_LOCAL_ACCESS_ERROR	UINT32_C(0x1)
	/*
	 * This indicates that the packet was too long for the WQE
	 * provided on the RQ.
	 *
	 * This is not a fatal error.  All the fields are valid.
	 */
	#define CQ_RES_RAWETH_QP1_V2_STATUS_HW_LOCAL_LENGTH_ERR	UINT32_C(0x2)
	/* LOCAL_PROTECTION_ERR is 3 */
	#define CQ_RES_RAWETH_QP1_V2_STATUS_LOCAL_PROTECTION_ERR	UINT32_C(0x3)
	/* LOCAL_QP_OPERATION_ERR is 4 */
	#define CQ_RES_RAWETH_QP1_V2_STATUS_LOCAL_QP_OPERATION_ERR   UINT32_C(0x4)
	/* MEMORY_MGT_OPERATION_ERR is 5 */
	#define CQ_RES_RAWETH_QP1_V2_STATUS_MEMORY_MGT_OPERATION_ERR UINT32_C(0x5)
	/* WORK_REQUEST_FLUSHED_ERR is 7 */
	#define CQ_RES_RAWETH_QP1_V2_STATUS_WORK_REQUEST_FLUSHED_ERR UINT32_C(0x7)
	/* HW_FLUSH_ERR is 8 */
	#define CQ_RES_RAWETH_QP1_V2_STATUS_HW_FLUSH_ERR		UINT32_C(0x8)
	#define CQ_RES_RAWETH_QP1_V2_STATUS_LAST			CQ_RES_RAWETH_QP1_V2_STATUS_HW_FLUSH_ERR
	uint16_t	flags;
	/*
	 * This flag indicates that the completion is for a SRQ entry
	 * rather than for an RQ entry.
	 */
	#define CQ_RES_RAWETH_QP1_V2_FLAGS_SRQ	UINT32_C(0x1)
	/* CQE relates to RQ WQE. */
		#define CQ_RES_RAWETH_QP1_V2_FLAGS_SRQ_RQ	UINT32_C(0x0)
	/* CQE relates to SRQ WQE. */
		#define CQ_RES_RAWETH_QP1_V2_FLAGS_SRQ_SRQ   UINT32_C(0x1)
		#define CQ_RES_RAWETH_QP1_V2_FLAGS_SRQ_LAST CQ_RES_RAWETH_QP1_V2_FLAGS_SRQ_SRQ
	uint32_t	raweth_qp1_payload_offset_srq_or_rq_wr_id;
	/*
	 * Opaque value from RQ or SRQ WQE. Used by driver/lib to
	 * reference the WQE in order to claim the received data
	 * and reuse the WQE space
	 */
	#define CQ_RES_RAWETH_QP1_V2_SRQ_OR_RQ_WR_ID_MASK	UINT32_C(0xfffff)
	#define CQ_RES_RAWETH_QP1_V2_SRQ_OR_RQ_WR_ID_SFT		0
	#define CQ_RES_RAWETH_QP1_V2_CFA_METADATA1_MASK		UINT32_C(0xf00000)
	#define CQ_RES_RAWETH_QP1_V2_CFA_METADATA1_SFT		20
	/* When meta_format != 0, this value is the VLAN TPID_SEL. */
	#define CQ_RES_RAWETH_QP1_V2_CFA_METADATA1_TPID_SEL_MASK	UINT32_C(0x700000)
	#define CQ_RES_RAWETH_QP1_V2_CFA_METADATA1_TPID_SEL_SFT	20
	/* 0x88a8 */
		#define CQ_RES_RAWETH_QP1_V2_CFA_METADATA1_TPID_SEL_TPID88A8   (UINT32_C(0x0) << 20)
	/* 0x8100 */
		#define CQ_RES_RAWETH_QP1_V2_CFA_METADATA1_TPID_SEL_TPID8100   (UINT32_C(0x1) << 20)
	/* 0x9100 */
		#define CQ_RES_RAWETH_QP1_V2_CFA_METADATA1_TPID_SEL_TPID9100   (UINT32_C(0x2) << 20)
	/* 0x9200 */
		#define CQ_RES_RAWETH_QP1_V2_CFA_METADATA1_TPID_SEL_TPID9200   (UINT32_C(0x3) << 20)
	/* 0x9300 */
		#define CQ_RES_RAWETH_QP1_V2_CFA_METADATA1_TPID_SEL_TPID9300   (UINT32_C(0x4) << 20)
	/* Value programmed in CFA VLANTPID register. */
		#define CQ_RES_RAWETH_QP1_V2_CFA_METADATA1_TPID_SEL_TPIDCFG	(UINT32_C(0x5) << 20)
		#define CQ_RES_RAWETH_QP1_V2_CFA_METADATA1_TPID_SEL_LAST	CQ_RES_RAWETH_QP1_V2_CFA_METADATA1_TPID_SEL_TPIDCFG
	/* When meta_format != 0, this value is the VLAN valid. */
	#define CQ_RES_RAWETH_QP1_V2_CFA_METADATA1_VALID		UINT32_C(0x800000)
	/*
	 * This value indicates the offset in bytes from the beginning of
	 * the packet where the inner payload starts.  This value is valid
	 * for TCP, UDP, FCoE, and RoCE packets.
	 *
	 * A value of zero indicates an offset of 256 bytes.
	 */
	#define CQ_RES_RAWETH_QP1_V2_RAWETH_QP1_PAYLOAD_OFFSET_MASK UINT32_C(0xff000000)
	#define CQ_RES_RAWETH_QP1_V2_RAWETH_QP1_PAYLOAD_OFFSET_SFT  24
} cq_res_raweth_qp1_v2_t, *pcq_res_raweth_qp1_v2_t;

/* Terminal CQE */
/* cq_terminal (size:256b/32B) */

typedef struct cq_terminal {
	/*
	 * This is an application level ID used to identify the
	 * QP and its SQ and RQ.
	 */
	uint64_t	qp_handle;
	/*
	 * Final SQ Consumer Index value.  Any additional SQ WQEs will
	 * have to be completed by the user provider.
	 */
	uint16_t	sq_cons_idx;
	/*
	 * Final RQ Consumer Index value.  Any additional RQ WQEs will
	 * have to be completed by the user provider.
	 */
	uint16_t	rq_cons_idx;
	uint32_t	reserved32_1;
	uint64_t	reserved64_3;
	uint8_t	cqe_type_toggle;
	/*
	 * Indicate valid completion - written by the chip. Cumulus
	 * toggle this bit each time it finished consuming all PBL
	 * entries
	 */
	#define CQ_TERMINAL_TOGGLE	UINT32_C(0x1)
	/* This field defines the type of SQ WQE. */
	#define CQ_TERMINAL_CQE_TYPE_MASK	UINT32_C(0x1e)
	#define CQ_TERMINAL_CQE_TYPE_SFT	1
	/*
	 * Terminal completion - This is used to indicate that no
	 * further completions will be made for this QP on this CQ.
	 */
		#define CQ_TERMINAL_CQE_TYPE_TERMINAL  (UINT32_C(0xe) << 1)
		#define CQ_TERMINAL_CQE_TYPE_LAST	CQ_TERMINAL_CQE_TYPE_TERMINAL
	/* This field indicates the status for the CQE. */
	uint8_t	status;
	/* OK is 0 */
	#define CQ_TERMINAL_STATUS_OK UINT32_C(0x0)
	#define CQ_TERMINAL_STATUS_LAST CQ_TERMINAL_STATUS_OK
	uint16_t	reserved16;
	uint32_t	reserved32_2;
} cq_terminal_t, *pcq_terminal_t;

/* Cutoff CQE */
/* cq_cutoff (size:256b/32B) */

typedef struct cq_cutoff {
	uint64_t	reserved64_1;
	uint64_t	reserved64_2;
	uint64_t	reserved64_3;
	uint8_t	cqe_type_toggle;
	/*
	 * Indicate valid completion - written by the chip. Cumulus
	 * toggle this bit each time it finished consuming all PBL
	 * entries
	 */
	#define CQ_CUTOFF_TOGGLE	UINT32_C(0x1)
	/* This field defines the type of SQ WQE. */
	#define CQ_CUTOFF_CQE_TYPE_MASK   UINT32_C(0x1e)
	#define CQ_CUTOFF_CQE_TYPE_SFT	1
	/* Cut off CQE; for CQ resize see CQ and SRQ Resize */
		#define CQ_CUTOFF_CQE_TYPE_CUT_OFF  (UINT32_C(0xf) << 1)
		#define CQ_CUTOFF_CQE_TYPE_LAST	CQ_CUTOFF_CQE_TYPE_CUT_OFF
	/* This field indicates the status for the CQE. */
	uint8_t	status;
	/* OK is 0 */
	#define CQ_CUTOFF_STATUS_OK UINT32_C(0x0)
	#define CQ_CUTOFF_STATUS_LAST CQ_CUTOFF_STATUS_OK
	uint16_t	reserved16;
	uint32_t	reserved32;
} cq_cutoff_t, *pcq_cutoff_t;

/* nq_base (size:128b/16B) */

typedef struct nq_base {
	uint16_t	info10_type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units.  Even values indicate 16B
	 * records.  Odd values indicate 32B
	 * records.
	 */
	#define NQ_BASE_TYPE_MASK	UINT32_C(0x3f)
	#define NQ_BASE_TYPE_SFT		0
	/* CQ Notification */
		#define NQ_BASE_TYPE_CQ_NOTIFICATION  UINT32_C(0x30)
	/* SRQ Threshold Event */
		#define NQ_BASE_TYPE_SRQ_EVENT	UINT32_C(0x32)
	/* DBQ Threshold Event */
		#define NQ_BASE_TYPE_DBQ_EVENT	UINT32_C(0x34)
	/* QP Async Notification */
		#define NQ_BASE_TYPE_QP_EVENT	UINT32_C(0x38)
	/* Function Async Notification */
		#define NQ_BASE_TYPE_FUNC_EVENT	UINT32_C(0x3a)
		#define NQ_BASE_TYPE_LAST		NQ_BASE_TYPE_FUNC_EVENT
	/* info10 is 10 b */
	#define NQ_BASE_INFO10_MASK	UINT32_C(0xffc0)
	#define NQ_BASE_INFO10_SFT	6
	/* info16 is 16 b */
	uint16_t	info16;
	/* info32 is 32 b */
	uint32_t	info32;
	/* info32 is 32 b */
	uint64_t	info63_v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue.   The even passes
	 * will write 1.  The odd passes will write 0.
	 */
	#define NQ_BASE_V	UINT32_C(0x1)
	/* info63 is 63 b */
	#define NQ_BASE_INFO63_MASK UINT32_C(0xfffffffe)
	#define NQ_BASE_INFO63_SFT 1
} nq_base_t, *pnq_base_t;

/* Completion Queue Notification */
/* nq_cn (size:128b/16B) */

typedef struct nq_cn {
	uint16_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units.  Even values indicate 16B
	 * records.  Odd values indicate 32B
	 * records.
	 */
	#define NQ_CN_TYPE_MASK	UINT32_C(0x3f)
	#define NQ_CN_TYPE_SFT		0
	/* CQ Notification */
		#define NQ_CN_TYPE_CQ_NOTIFICATION  UINT32_C(0x30)
		#define NQ_CN_TYPE_LAST		NQ_CN_TYPE_CQ_NOTIFICATION
	uint16_t	reserved16;
	/*
	 * This is an application level ID used to identify the
	 * CQ.  This field carries the lower 32b of the value.
	 */
	uint32_t	cq_handle_low;
	uint32_t	v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue.   The even passes
	 * will write 1.  The odd passes will write 0.
	 */
	#define NQ_CN_V	UINT32_C(0x1)
	/*
	 * This is an application level ID used to identify the
	 * CQ.  This field carries the upper 32b of the value.
	 */
	uint32_t	cq_handle_high;
} nq_cn_t, *pnq_cn_t;

/* SRQ Event Notification */
/* nq_srq_event (size:128b/16B) */

typedef struct nq_srq_event {
	uint8_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units.  Even values indicate 16B
	 * records.  Odd values indicate 32B
	 * records.
	 */
	#define NQ_SRQ_EVENT_TYPE_MASK	UINT32_C(0x3f)
	#define NQ_SRQ_EVENT_TYPE_SFT	0
	/* SRQ Threshold Event */
		#define NQ_SRQ_EVENT_TYPE_SRQ_EVENT  UINT32_C(0x32)
		#define NQ_SRQ_EVENT_TYPE_LAST	NQ_SRQ_EVENT_TYPE_SRQ_EVENT
	/*
	 * This value define what type of async event has occurred
	 * on the SRQ.
	 */
	uint8_t	event;
	/* The threshold event has occurred on the specified SRQ. */
	#define NQ_SRQ_EVENT_EVENT_SRQ_THRESHOLD_EVENT UINT32_C(0x1)
	#define NQ_SRQ_EVENT_EVENT_LAST		NQ_SRQ_EVENT_EVENT_SRQ_THRESHOLD_EVENT
	uint16_t	reserved16;
	/*
	 * This is the SRQ handle value for the queue that has
	 * reached it's event threshold.  This field carries the
	 * lower 32b of the value.
	 */
	uint32_t	srq_handle_low;
	uint32_t	v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue.   The even passes
	 * will write 1.  The odd passes will write 0.
	 */
	#define NQ_SRQ_EVENT_V	UINT32_C(0x1)
	/*
	 * This is the SRQ handle value for the queue that has
	 * reached it's event threshold.  This field carries the
	 * upper 32b of the value.
	 */
	uint32_t	srq_handle_high;
} nq_srq_event_t, *pnq_srq_event_t;

/* DBQ Async Event Notification */
/* nq_dbq_event (size:128b/16B) */

typedef struct nq_dbq_event {
	uint8_t	type;
	/*
	 * This field indicates the exact type of the completion.
	 * By convention, the LSB identifies the length of the
	 * record in 16B units.  Even values indicate 16B
	 * records.  Odd values indicate 32B
	 * records.
	 */
	#define NQ_DBQ_EVENT_TYPE_MASK	UINT32_C(0x3f)
	#define NQ_DBQ_EVENT_TYPE_SFT	0
	/* DBQ Threshold Event */
		#define NQ_DBQ_EVENT_TYPE_DBQ_EVENT  UINT32_C(0x34)
		#define NQ_DBQ_EVENT_TYPE_LAST	NQ_DBQ_EVENT_TYPE_DBQ_EVENT
	/* This value define what type of action the driver should take. */
	uint8_t	event;
	/*
	 * The driver should start writing dummy values to the
	 * the doorbell in an attempt to consume all the PCIE
	 * posted write resources and prevent doorbell overflow.
	 */
	#define NQ_DBQ_EVENT_EVENT_DBQ_THRESHOLD_EVENT UINT32_C(0x1)
	#define NQ_DBQ_EVENT_EVENT_LAST		NQ_DBQ_EVENT_EVENT_DBQ_THRESHOLD_EVENT
	uint16_t	db_pfid;
	/*
	 * This is the PFID of function that wrote the doorbell that
	 * crossed the async event threshold.
	 */
	#define NQ_DBQ_EVENT_DB_PFID_MASK UINT32_C(0xf)
	#define NQ_DBQ_EVENT_DB_PFID_SFT 0
	uint32_t	db_dpi;
	/*
	 * This is the DPI of the doorbell write that crossed
	 * the async event threshold.
	 */
	#define NQ_DBQ_EVENT_DB_DPI_MASK UINT32_C(0xfffff)
	#define NQ_DBQ_EVENT_DB_DPI_SFT 0
	uint32_t	v;
	/*
	 * This value is written by the NIC such that it will be different
	 * for each pass through the completion queue.   The even passes
	 * will write 1.  The odd passes will write 0.
	 */
	#define NQ_DBQ_EVENT_V	UINT32_C(0x1)
	uint32_t	db_type_db_xid;
	/*
	 * DB 'XID' field from doorbell that crossed the async event
	 * threshold.  This is a QPID, SID, or CID, depending on
	 * the db_type field.
	 */
	#define NQ_DBQ_EVENT_DB_XID_MASK UINT32_C(0xfffff)
	#define NQ_DBQ_EVENT_DB_XID_SFT  0
	/*
	 * DB 'type' field from doorbell that crossed the async event
	 * threshold.
	 */
	#define NQ_DBQ_EVENT_DB_TYPE_MASK UINT32_C(0xf0000000)
	#define NQ_DBQ_EVENT_DB_TYPE_SFT 28
} nq_dbq_event_t, *pnq_dbq_event_t;

/* Input Read Request Queue (IRRQ) Message */
/* xrrq_irrq (size:256b/32B) */

typedef struct xrrq_irrq {
	uint16_t	credits_type;
	/* Type indication */
	#define XRRQ_IRRQ_TYPE	UINT32_C(0x1)
	/* RDMA Read */
		#define XRRQ_IRRQ_TYPE_READ_REQ	UINT32_C(0x0)
	/* Atomic */
		#define XRRQ_IRRQ_TYPE_ATOMIC_REQ  UINT32_C(0x1)
		#define XRRQ_IRRQ_TYPE_LAST	XRRQ_IRRQ_TYPE_ATOMIC_REQ
	/*
	 * The credit code calculated by Rx path when receiving the
	 * request. It will be placed in the syndrome credit code with
	 * the acks on first and last response.
	 */
	#define XRRQ_IRRQ_CREDITS_MASK   UINT32_C(0xf800)
	#define XRRQ_IRRQ_CREDITS_SFT	11
	uint16_t	reserved16;
	uint32_t	reserved32;
	uint32_t	psn;
	/* The PSN of the outstanding incoming request */
	#define XRRQ_IRRQ_PSN_MASK UINT32_C(0xffffff)
	#define XRRQ_IRRQ_PSN_SFT 0
	uint32_t	msn;
	/*
	 * The value of QPC.pending_ack_msn after it is incremented as a
	 * result of receiving the read/atomic request.  IRRQ.msn-1 will be
	 * placed in the MSN field of the first response and IRRQ.msn will
	 * placed in the MSN field of the last or only response.
	 */
	#define XRRQ_IRRQ_MSN_MASK UINT32_C(0xffffff)
	#define XRRQ_IRRQ_MSN_SFT 0
	/*
	 * Virtual address on local host for RDMA READ
	 *
	 * In case of duplicate Atomic, the VA is not required to
	 * be validated, only the PSN is, thus this field is used
	 * to store the value returned in the Ack to the atomic
	 * request, and if duplicate arrives, this value is used
	 * again for resending the ack.
	 */
	uint64_t	va_or_atomic_result;
	/* The key to the MR/W in the request */
	uint32_t	rdma_r_key;
	/* Length in bytes of the data requested. Length must be 8 if type is atomic. */
	uint32_t	length;
} xrrq_irrq_t, *pxrrq_irrq_t;

/* Output Read Request Queue (ORRQ) Message */
/* xrrq_orrq (size:256b/32B) */

typedef struct xrrq_orrq {
	uint16_t	num_sges_type;
	/* Type indication */
	#define XRRQ_ORRQ_TYPE	UINT32_C(0x1)
	/* RDMA Read */
		#define XRRQ_ORRQ_TYPE_READ_REQ	UINT32_C(0x0)
	/* Atomic */
		#define XRRQ_ORRQ_TYPE_ATOMIC_REQ  UINT32_C(0x1)
		#define XRRQ_ORRQ_TYPE_LAST	XRRQ_ORRQ_TYPE_ATOMIC_REQ
	/*
	 * Up to 6 SGEs. This value is 1 if type is atomic as one
	 * SGE is required to store Atomic response result field. 2
	 * more bits allocated for future growth.
	 *
	 * Note that, if num_sges is 1 for an RDMA Read request, then
	 * the first_sge_phy_or_sing_sge_va, single_sge_l_key, and
	 * single_sge_size fields will be populated from the single
	 * SGE.
	 *
	 * If num_sges is 2 or more for an RDMA Read request, then
	 * the first_sge_phy_or_sing_sge_va field carries the
	 * physical address in host memory where the first sge is
	 * stored.  The single_sge_l_key and single_sge_size fields
	 * are unused in this case.
	 *
	 * A special case is a zero-length, zero-sge RDMA read request
	 * WQE.  In this situation, num_sges will be 1.  However,
	 * first_sge_phy_or_sing_sge_va, single_sge_l_key, and
	 * single_sge_size will all be populated with zeros.
	 */
	#define XRRQ_ORRQ_NUM_SGES_MASK  UINT32_C(0xf800)
	#define XRRQ_ORRQ_NUM_SGES_SFT   11
	uint16_t	reserved16;
	/* Length in bytes of the data requested. Length must be 8 if type is atomic. */
	uint32_t	length;
	uint32_t	psn;
	/* The PSN of the outstanding outgoing request */
	#define XRRQ_ORRQ_PSN_MASK UINT32_C(0xffffff)
	#define XRRQ_ORRQ_PSN_SFT 0
	uint32_t	end_psn;
	/*
	 * The expected last PSN on a response to this request where
	 * an ack with response, rather than just response, should
	 * arrive. If ack arrive with smaller PSN than end_psn then it
	 * is considered a NAK.
	 */
	#define XRRQ_ORRQ_END_PSN_MASK UINT32_C(0xffffff)
	#define XRRQ_ORRQ_END_PSN_SFT 0
	/*
	 * If num_sges == 1 this is the va of that SGE. Otherwise,
	 * physical address to the first SGE specified by the WQE.
	 * Points to the first SGE in the Request's WQE in the SQ.
	 * It is assumed that WQE does not cross page boundaries!
	 * Driver is responsible to enforce that. SGEs are 16B
	 * aligned 0b0000 lsb added to get 64 bit address.
	 */
	uint64_t	first_sge_phy_or_sing_sge_va;
	/* The L_Key of a single SGE if used */
	uint32_t	single_sge_l_key;
	/* The size in bytes of the single SGE if used */
	uint32_t	single_sge_size;
} xrrq_orrq_t, *pxrrq_orrq_t;

/* Page Table Entry (PTE) */
/* ptu_pte (size:64b/8B) */

typedef struct ptu_pte {
	uint64_t	page_next_to_last_last_valid;
	/*
	 * This field indicates if the PTE is valid.   A value of '0'
	 * indicates that the page is not valid.  A value of '1'
	 * indicates that the page is valid.  A reference to an
	 * invalid page will return a PTU error.
	 */
	#define PTU_PTE_VALID		UINT32_C(0x1)
	/*
	 * This field is used only for "ring" PBLs that are used for
	 * SQ, RQ, SRQ, or CQ structures.   For all other PBL structures,
	 * this bit should be zero.  When this bit is '1', it indicates
	 * that the page pointed to by this PTE is the last page in the
	 * ring.  A prefetch for the ring should use the first PTE in
	 * the PBL.
	 */
	#define PTU_PTE_LAST		UINT32_C(0x2)
	/*
	 * This field is used only for "ring" PBLs that are used for
	 * SQ, RQ, SRQ, or CQ structures.   For all other PBL structures,
	 * this bit should be zero.  When this bit is '1', it indicates
	 * that this is the next-to-last page of the PBL.
	 */
	#define PTU_PTE_NEXT_TO_LAST	UINT32_C(0x4)
	/* These bits should be programmed to zero. */
	#define PTU_PTE_UNUSED_MASK	UINT32_C(0xff8)
	#define PTU_PTE_UNUSED_SFT	3
	/*
	 * This is the upper bits of the physical page controlled by
	 * this PTE.   If the page is larger than 4KB, then the unused
	 * lower bits of the page address should be zero.
	 */
	#define PTU_PTE_PAGE_MASK	UINT32_C(0xfffff000)
	#define PTU_PTE_PAGE_SFT	12
} ptu_pte_t, *pptu_pte_t;

/* Page Directory Entry (PDE) */
/* ptu_pde (size:64b/8B) */

typedef struct ptu_pde {
	uint64_t	page_valid;
	/*
	 * This field indicates if the PTE is valid.   A value of '0'
	 * indicates that the page is not valid.  A value of '1'
	 * indicates that the page is valid.  A reference to an
	 * invalid page will return a PTU error.
	 */
	#define PTU_PDE_VALID	UINT32_C(0x1)
	/* These bits should be programmed to zero. */
	#define PTU_PDE_UNUSED_MASK UINT32_C(0xffe)
	#define PTU_PDE_UNUSED_SFT 1
	/*
	 * This is the upper bits of the physical page controlled by
	 * this PTE.   If the page is larger than 4KB, then the unused
	 * lower bits of the page address should be zero.
	 */
	#define PTU_PDE_PAGE_MASK  UINT32_C(0xfffff000)
	#define PTU_PDE_PAGE_SFT   12
} ptu_pde_t, *pptu_pde_t;

/*
 * This is the 64b doorbell format.  The host writes this message
 * format directly to byte offset 0 of the appropriate doorbell page.
 */
/* dbc_dbc (size:64b/8B) */

typedef struct dbc_dbc {
	uint32_t	index;
	/*
	 * This value is the index being written.
	 *
	 * For SQ, RQ, and SRQ, this is the producer index and the unit is
	 * 16B of queue space for L2 path and for the Engine path. For RoCE
	 * path there is a legacy mode with 128B unit size and a variable
	 * size WQE mode with 16B unit size of queue space. This mode is
	 * configured in the QP.
	 *
	 * For CQ this is the consumer index and the unit is 32B of queue
	 * space for the RoCE/Engine path and the CQ index unit is 16B of
	 * queue space for the L2 path.
	 *
	 * For NQ this is the consumer index and the unit is always 16B of
	 * queue space.
	 *
	 * The index size is 24b for L2 and engine paths and 16b for the
	 * RoCE path. Unused bits should be written as zero.
	 */
	#define DBC_DBC_INDEX_MASK	UINT32_C(0xffffff)
	#define DBC_DBC_INDEX_SFT	0
	/*
	 * The epoch bit provides a frame of reference for the queue index.
	 * S/W will toggle this bit in the doorbell each time index range is
	 * wrapped. This allows the receiving HW block to more efficiently
	 * detect out-of-order doorbells and to ignore the older doorbells.
	 * Out-of-order doorbells occur normally during dropped doorbell
	 * recovery.
	 */
	#define DBC_DBC_EPOCH		UINT32_C(0x1000000)
	/*
	 * The resize_toggle bit tells that the CQ cutoff is done.
	 * Every time CQ is resized by CQ cutoff, this bit toggles when it
	 * is done. If this bit toggles, HW can restart to use the resized
	 * CQ.
	 */
	#define DBC_DBC_RESIZE_TOGGLE	UINT32_C(0x2000000)
	uint32_t	type_path_xid;
	/*
	 * This value identifies the resource that the doorbell is intended
	 * to notify.
	 *
	 * For SQ and RQ, this is the QPID.  For SRQ, this is the SID.  For
	 * CQ, this is the CID. For NQ, this is the NID.
	 *
	 * Bits [19:16] of this values must be zero for a SID value.
	 */
	#define DBC_DBC_XID_MASK	UINT32_C(0xfffff)
	#define DBC_DBC_XID_SFT	0
	/*
	 * This value defines the intended doorbell path between RoCE and
	 * L2.
	 */
	#define DBC_DBC_PATH_MASK	UINT32_C(0x3000000)
	#define DBC_DBC_PATH_SFT	24
	/* This is a RoCE doorbell message. */
		#define DBC_DBC_PATH_ROCE	(UINT32_C(0x0) << 24)
	/* This is a L2 doorbell message. */
		#define DBC_DBC_PATH_L2		(UINT32_C(0x1) << 24)
	/* Engine path doorbell. */
		#define DBC_DBC_PATH_ENGINE	(UINT32_C(0x2) << 24)
		#define DBC_DBC_PATH_LAST	DBC_DBC_PATH_ENGINE
	/*
	 * This indicates it is valid doorbell update. It should be set for
	 * each doorbell written to the chip and set when doorbell message is
	 * written to the backup doorbell location. The bit should be cleared
	 * in the backup doorbell location at time zero to indicate that the
	 * backup doorbell has not yet been written.
	 */
	#define DBC_DBC_VALID		UINT32_C(0x4000000)
	/*
	 * When this bit is set to one, the chip will capture debug
	 * information for the doorbell ring. This is intended to only be
	 * used on SQ doorbell rings.
	 */
	#define DBC_DBC_DEBUG_TRACE	UINT32_C(0x8000000)
	/* This value identifies the type of doorbell being written. */
	#define DBC_DBC_TYPE_MASK	UINT32_C(0xf0000000)
	#define DBC_DBC_TYPE_SFT	28
	/*
	 * This is a SQ producer index update.   It indicates one or more
	 * new entries have been written to the SQ for the QPID indicated
	 * on the xID field. This type is valid for L2, RoCE and Engine
	 * path.
	 */
		#define DBC_DBC_TYPE_SQ		(UINT32_C(0x0) << 28)
	/*
	 * This is a RQ producer index update.   It indicates one or more
	 * new entries have been written to the RQ for the QPID indicated
	 * on the xID field. This type is valid for RoCE path.
	 */
		#define DBC_DBC_TYPE_RQ		(UINT32_C(0x1) << 28)
	/*
	 * This is a SRQ producer index update.   It indicates one or more
	 * new entries have been written to the SRQ for the SID indicated
	 * on the xID field. This type is valid for L2 and RoCE path.
	 */
		#define DBC_DBC_TYPE_SRQ		(UINT32_C(0x2) << 28)
	/*
	 * This doorbell command arms the SRQ async event.
	 * The xID field must identify the SID that is begin armed.
	 * The index field is will set the arm threshold such that
	 * a notification will be generated if less than that number
	 * or SRQ entries are posted. This type is valid for RoCE path.
	 */
		#define DBC_DBC_TYPE_SRQ_ARM	(UINT32_C(0x3) << 28)
	/*
	 * This is a CQ consumer index update.   It indicates one or more
	 * entries have been processed off the CQ indicated on the xID
	 * field.This type is valid for L2, RoCE and Engine path.
	 */
		#define DBC_DBC_TYPE_CQ		(UINT32_C(0x4) << 28)
	/*
	 * this is a CQ consumer index update that also arms the CQ for
	 * solicited events. This type is valid for RoCE path.
	 */
		#define DBC_DBC_TYPE_CQ_ARMSE	(UINT32_C(0x5) << 28)
	/*
	 * This is a CQ consumer index update that also arms the CQ
	 * for any new CQE. This type is valid for L2, RoCE and Engine
	 * path.
	 */
		#define DBC_DBC_TYPE_CQ_ARMALL	(UINT32_C(0x6) << 28)
	/*
	 * This is a CQ arm enable message.  This message must be sent
	 * from the privileged driver before a new CQ_ARMSE or CQ_ARMALL
	 * message will be accepted.
	 *
	 * This doorbell can only be sent from the privileged (first)
	 * doorbell page of a function.
	 */
		#define DBC_DBC_TYPE_CQ_ARMENA	(UINT32_C(0x7) << 28)
	/*
	 * This doorbell command enables the SRQ async event
	 * to be armed.  This message must be sent from the privileged
	 * driver before a new SRQ_ARM message will be accepted.
	 * The xID field must identify the SID that is begin enabled
	 * for arm.
	 *
	 * This doorbell can only be sent from the privileged (first)
	 * doorbell page of a function.
	 */
		#define DBC_DBC_TYPE_SRQ_ARMENA	(UINT32_C(0x8) << 28)
	/*
	 * This doorbell command indicates that the cutoff CQE has
	 * been processed and the driver is now processing completions
	 * from the new CQ.
	 *
	 * The index field for this doorbell type must be zero.
	 */
		#define DBC_DBC_TYPE_CQ_CUTOFF_ACK  (UINT32_C(0x9) << 28)
	/*
	 * This is a NQ consumer index update. It indicates one or more
	 * entries have been processed off the NQ indicated on the xID
	 * field. This type is valid for L2, RoCE and Engine path.
	 */
		#define DBC_DBC_TYPE_NQ		(UINT32_C(0xa) << 28)
	/*
	 * This is a NQ consumer index update that also arms the NQ for
	 * any new NQE. This type is valid for L2, RoCE and Engine path.
	 */
		#define DBC_DBC_TYPE_NQ_ARM	(UINT32_C(0xb) << 28)
	/*
	 * This is a NQ consumer index update that also arms the NQ for
	 * any new NQE. It is used for the legacy INT mask. This type
	 * is valid for L2, RoCE and Engine path.
	 */
		#define DBC_DBC_TYPE_NQ_MASK	(UINT32_C(0xe) << 28)
	/*
	 * This doorbell command is used during doorbell moderation
	 * to consume system BW and help prevent doorbell FIFO
	 * overflow.
	 *
	 * All other fields should be zero for NULL doorbell.
	 * For doorbell recovery, NULL doorbell type in the Application
	 * table indicates that it is the last QP entry for the function.
	 * This type is valid for L2, RoCE and Engine path.
	 */
		#define DBC_DBC_TYPE_NULL	(UINT32_C(0xf) << 28)
		#define DBC_DBC_TYPE_LAST	DBC_DBC_TYPE_NULL
} dbc_dbc_t, *pdbc_dbc_t;

/*
 * This is the 32b doorbell format.  The host writes this message
 * format directly to byte offset 8 of the appropriate doorbell page.
 */
/* dbc_dbc32 (size:32b/4B) */

typedef struct dbc_dbc32 {
	uint32_t	type_abs_incr_xid;
	/*
	 * This value identifies the resource that the doorbell is intended
	 * to notify.
	 *
	 * For SQ and RQ, this is the QPID.  For SRQ, this is the SID.  For
	 * CQ, this is the CID.
	 *
	 * Bits [19:16] of this values must be zero for a SID value.
	 */
	#define DBC_DBC32_XID_MASK UINT32_C(0xfffff)
	#define DBC_DBC32_XID_SFT  0
	/*
	 * This value defines the intended doorbell path between RoCE and
	 * L2.
	 */
	#define DBC_DBC32_PATH_MASK UINT32_C(0xc00000)
	#define DBC_DBC32_PATH_SFT 22
	/* This is a RoCE doorbell message. */
		#define DBC_DBC32_PATH_ROCE  (UINT32_C(0x0) << 22)
	/* This is a L2 doorbell message. */
		#define DBC_DBC32_PATH_L2	(UINT32_C(0x1) << 22)
		#define DBC_DBC32_PATH_LAST DBC_DBC32_PATH_L2
	/*
	 * When abs=0, this value is the value to add to the appropriate
	 * index value.
	 *
	 * When abs=1, this value is the new value for the index.  Absolute
	 * value is used when the queue is being wrapped.  When abs=1,
	 * the incr value follows the same rules as the index value
	 * in the 64b doorbell.
	 */
	#define DBC_DBC32_INCR_MASK UINT32_C(0xf000000)
	#define DBC_DBC32_INCR_SFT 24
	/* This value defines how the incr value will be interpreted. */
	#define DBC_DBC32_ABS	UINT32_C(0x10000000)
	/* This value identifies the type of doorbell being written. */
	#define DBC_DBC32_TYPE_MASK UINT32_C(0xe0000000)
	#define DBC_DBC32_TYPE_SFT 29
	/*
	 * This is a SQ producer index update.   It indicates one or more
	 * new entries have been written to the SQ for the QPID indicated
	 * on the xID field.
	 */
		#define DBC_DBC32_TYPE_SQ	(UINT32_C(0x0) << 29)
		#define DBC_DBC32_TYPE_LAST DBC_DBC32_TYPE_SQ
} dbc_dbc32_t, *pdbc_dbc32_t;

/*
 * This is the 64b Push Start doorbell format. The host writes this message
 * format directly to offset of each push associated WCB (write combine
 * buffer) within doorbell page. WCB#0 = offset 16, WCB#1 = offset 24,
 * WCB#2 = offset 32, ... The start doorbell is followed by write combining
 * data to the WCB and then that is followed by a end doorbell.
 */
/* db_push_start (size:64b/8B) */

typedef struct db_push_start {
	uint64_t	db;
	/*
	 * This is the push index and should be the SQ slot index, aligned
	 * to the start of the corresponding push WQE/packet in the Send
	 * Queue.
	 *
	 * The index size is 16b for RoCE path and 24b for L2 and Engine
	 * paths. Any unused bits should be written as zero.
	 *
	 * The index unit is 16B for L2 path. For RoCE there is a legacy
	 * mode with 128B unit size and a variable size mode with 16B unit
	 * size. For Engine mode, the unit size is 16B, where RQEs are
	 * always 128B - so it always increments by eight 16B slots per
	 * RQE.
	 *
	 * > This field is not used by the older versions of the chip, but
	 * > is used in this and future revisions of the chip. In older
	 * > versions of the chip, the driver is required to complete the
	 * > push doorbell operation by following it with a regular doorbell
	 * > which will be used to properly increment the producer index.
	 * > This extra doorbell write is not needed on this and future
	 * > versions of the chip.
	 */
	#define DB_PUSH_START_DB_INDEX_MASK	UINT32_C(0xffffff)
	#define DB_PUSH_START_DB_INDEX_SFT	0
	/*
	 * This value is the PI index (lower 8bits) within 4K DPI
	 * associated with push write. It is the doorbell page that
	 * contains the WCB that will be used.
	 */
	#define DB_PUSH_START_DB_PI_LO_MASK	UINT32_C(0xff000000)
	#define DB_PUSH_START_DB_PI_LO_SFT	24
	/*
	 * This value identifies the resource that the doorbell is intended
	 * to notify.
	 *
	 * This is the QPID.
	 */
	#define DB_PUSH_START_DB_XID_MASK	UINT32_C(0xfffff00000000)L
	#define DB_PUSH_START_DB_XID_SFT	32
	/*
	 * This value is the PI index (upper 4bits) within 4K DPI
	 * associated with push write. It is the doorbell page that
	 * contains the WCB that will be used.
	 */
	#define DB_PUSH_START_DB_PI_HI_MASK	UINT32_C(0xf0000000000000)L
	#define DB_PUSH_START_DB_PI_HI_SFT	52
	/* This value identifies the type of doorbell being written. */
	#define DB_PUSH_START_DB_TYPE_MASK	UINT32_C(0xf000000000000000)L
	#define DB_PUSH_START_DB_TYPE_SFT	60
	/*
	 * This is a SQ producer index update for Push. It indicates
	 * one or more new entries have been written to the SQ for the
	 * QPID indicated on the `xid` field.
	 */
		#define DB_PUSH_START_DB_TYPE_PUSH_START  (UINT32_C(0xc)L << 60)
	/*
	 * This is a SQ producer index update for Push. It indicates
	 * one or more new entries have been written to the SQ for the
	 * QPID indicated on the `xid` field.
	 */
		#define DB_PUSH_START_DB_TYPE_PUSH_END	(UINT32_C(0xd)L << 60)
		#define DB_PUSH_START_DB_TYPE_LAST	DB_PUSH_START_DB_TYPE_PUSH_END
} db_push_start_t, *pdb_push_start_t;

/*
 * This is the 64b Push End doorbell format. The host writes this message
 * format directly to offset of each push associated WCB (write combine
 * buffer) within doorbell page. WCB#0 = offset 16, WCB#1 = offset 24,
 * WCB#2 = offset 32, ... The start doorbell is followed by write combining
 * data to the WCB and then that is followed by a end doorbell.
 */
/* db_push_end (size:64b/8B) */

typedef struct db_push_end {
	uint64_t	db;
	/*
	 * This is the producer index and should be the queue index of the
	 * last WQE written plus the length field contained in that WQE.
	 * For example, if the length is 8 index units and the WQE was
	 * written to the first location in the queue (zero), this index
	 * should be written to 8. The index should point to the start of
	 * the first location that has not been filled in with WQE data.
	 *
	 * For L2 and Engine SQ, the index unit is 16B. For RoCE there are
	 * two modes. For Legacy fixed size RQE mode, the unit is 128B. For
	 * variable size RQE mode, the unit is 16B.
	 *
	 * The index size is 24b for L2 and engine paths and 16b for the
	 * RoCE path. Unused bits should be written as zero.
	 *
	 * > In past revisions of this chip, this field was the push index
	 * > rather than the producer index. For this version of the chip
	 * > and future versions of the chip, this field must be the
	 * > producer index, as described above.
	 * >
	 * > Also, in past revisions of this chip, an additional
	 * > doorbell write was needed to communicate the producer index.
	 * > In this and future versions of the chip, this extra doorbell
	 * > write is no longer needed.
	 */
	#define DB_PUSH_END_DB_INDEX_MASK	UINT32_C(0xffffff)
	#define DB_PUSH_END_DB_INDEX_SFT	0
	/*
	 * This value is the PI index (lower 8bits) within 4K DPI
	 * associated with push write. It is the doorbell page that
	 * contains the WCB that will be used.
	 */
	#define DB_PUSH_END_DB_PI_LO_MASK	UINT32_C(0xff000000)
	#define DB_PUSH_END_DB_PI_LO_SFT	24
	/*
	 * This value identifies the resource that the doorbell is intended
	 * to notify.
	 *
	 * This is the QPID.
	 */
	#define DB_PUSH_END_DB_XID_MASK	UINT32_C(0xfffff00000000)L
	#define DB_PUSH_END_DB_XID_SFT	32
	/*
	 * This value is the PI index (upper 4bits) within 4K DPI
	 * associated with push write. It is the doorbell page that
	 * contains the WCB that will be used.
	 */
	#define DB_PUSH_END_DB_PI_HI_MASK	UINT32_C(0xf0000000000000)L
	#define DB_PUSH_END_DB_PI_HI_SFT	52
	/*
	 * This value defines the intended doorbell path between RoCE and
	 * L2.
	 */
	#define DB_PUSH_END_DB_PATH_MASK	UINT32_C(0x300000000000000)L
	#define DB_PUSH_END_DB_PATH_SFT	56
	/* This is a RoCE doorbell message. */
		#define DB_PUSH_END_DB_PATH_ROCE	(UINT32_C(0x0)L << 56)
	/* This is a L2 doorbell message. */
		#define DB_PUSH_END_DB_PATH_L2	(UINT32_C(0x1)L << 56)
	/* Engine path doorbell. */
		#define DB_PUSH_END_DB_PATH_ENGINE	(UINT32_C(0x2)L << 56)
		#define DB_PUSH_END_DB_PATH_LAST	DB_PUSH_END_DB_PATH_ENGINE
	/*
	 * When this bit is set to one, the chip will capture debug
	 * information for the doorbell ring. This is intended to only be
	 * used on SQ doorbell rings.
	 */
	#define DB_PUSH_END_DB_DEBUG_TRACE	UINT32_C(0x800000000000000)L
	/* This value identifies the type of doorbell being written. */
	#define DB_PUSH_END_DB_TYPE_MASK	UINT32_C(0xf000000000000000)L
	#define DB_PUSH_END_DB_TYPE_SFT	60
	/*
	 * This is a SQ producer index update for Push. It indicates
	 * one or more new entries have been written to the SQ for the
	 * QPID indicated on the `xid` field.
	 */
		#define DB_PUSH_END_DB_TYPE_PUSH_START   (UINT32_C(0xc)L << 60)
	/*
	 * This is a SQ producer index update for Push. It indicates
	 * one or more new entries have been written to the SQ for the
	 * QPID indicated on the `xid` field.
	 */
		#define DB_PUSH_END_DB_TYPE_PUSH_END	(UINT32_C(0xd)L << 60)
		#define DB_PUSH_END_DB_TYPE_LAST	DB_PUSH_END_DB_TYPE_PUSH_END
} db_push_end_t, *pdb_push_end_t;

/*
 * This is the Push information that is the second 8B of the Push
 * Doorbell.
 */
/* db_push_info (size:64b/8B) */

typedef struct db_push_info {
	uint32_t	push_size_push_index;
	/*
	 * This value is the index for the push being started. For
	 * example, if the push_size is 8 index units and the WQE was
	 * written to the first location in the queue (zero), this
	 * push_index should be written to 0. The push_index should point
	 * to the start of the first location that the push is started.
	 *
	 * The push_index unit is 16B, except in RoCE legacy WQE mode, in
	 * which case the unit is 128B.
	 *
	 * The push_index size is 24b for L2 and 16b for the RoCE path.
	 * Unused bits should be written as zero.
	 */
	#define DB_PUSH_INFO_PUSH_INDEX_MASK UINT32_C(0xffffff)
	#define DB_PUSH_INFO_PUSH_INDEX_SFT 0
	/*
	 * This value defines the size of push. The unit is 8B. The value
	 * 0 means 256B size of push. The push write is done in 8B units
	 * by the SW.
	 *
	 * Note: For packet rate performance reasons, it is recommended
	 * that SW aligns push requests with a granularity of 16B.
	 */
	#define DB_PUSH_INFO_PUSH_SIZE_MASK UINT32_C(0x1f000000)
	#define DB_PUSH_INFO_PUSH_SIZE_SFT  24
	uint32_t	reserved32;
} db_push_info_t, *pdb_push_info_t;

/*
 * This is the "Absolute" 32b Doorbell format. The host writes this
 * message format directly to byte offset 0xC of the appropriate
 * doorbell page.
 *
 * Absolute doorbells are supported for only a limited number of
 * functions and for a limited number of xID values within each
 * function.
 *
 * Doorbell recovery can be supported for absolute 32b doorbells.
 */
/* dbc_absolute_db_32 (size:32b/4B) */

typedef struct dbc_absolute_db_32 {
	uint32_t	index;
	/*
	 * This value is the index being written. For SQ, RQ, SRQ, this is
	 * the producer index and should be the queue index of the last WQE
	 * or BD written plus the length field contained in that WQE/BD.
	 * For example, if the length is 8 index units and the WQE was
	 * written to the first location in the queue (zero), this index
	 * should be written to 8. The index should point to the start of
	 * the first location that has not been filled in with WQE/BD data.
	 *
	 * For CQ, this is the consumer index and should be the starting
	 * queue index of the last CQE processed plus the size of the last
	 * processed CQE in index units. The index should point to the start
	 * of the first CQE in the queue that has not been processed.
	 *
	 * For NQ, this is the consumer index and should be the starting
	 * queue index of the last NQE processed plus the size of the last
	 * processed NQE in index units. The index should point to the start
	 * of the first NQE in the queue that has not been processed.
	 *
	 * For L2 and Engine SQ, the index unit is 16B. For RoCE there are
	 * two modes. For Legacy fixed size RQE mode, the unit is 128B. For
	 * variable size RQE mode, the unit is 16B. For RoCE and engine CQs,
	 * the index unit is 32B. For L2 CQs, the index unit is 16B.
	 *
	 * For NQ this is the consumer index and the unit is always 16B of
	 * queue space.
	 *
	 * The index size is 16b for all queue types. This limits the size
	 * of some queues when absolute doorbells are in use. Unused bits
	 * should be written as zero.
	 */
	#define DBC_ABSOLUTE_DB_32_INDEX_MASK	UINT32_C(0xffff)
	#define DBC_ABSOLUTE_DB_32_INDEX_SFT	0
	/*
	 * The epoch bit provides a frame of reference for the queue index.
	 * S/W will toggle this bit in the doorbell each time index range is
	 * wrapped. This allows the receiving HW block to more efficiently
	 * detect out-of-order doorbells and to ignore the older doorbells.
	 * Out-of-order doorbells occur normally during dropped doorbell
	 * recovery.
	 */
	#define DBC_ABSOLUTE_DB_32_EPOCH		UINT32_C(0x10000)
	/*
	 * The resize_toggle bit tells that the CQ cutoff is done.
	 * Every time CQ is resized by CQ cutoff, this bit toggles when it
	 * is done. If this bit toggles, HW can restart to use the resized
	 * CQ.
	 */
	#define DBC_ABSOLUTE_DB_32_RESIZE_TOGGLE	UINT32_C(0x20000)
	/*
	 * This value identifies the resource that the doorbell is intended
	 * to notify.
	 *
	 * This is a "modified" xID value. The DBR block will convert this
	 * value into the full xID value by looking up the base xID for this
	 * particular function and adding the mxID value to that base value.
	 */
	#define DBC_ABSOLUTE_DB_32_MXID_MASK	UINT32_C(0xfc0000)
	#define DBC_ABSOLUTE_DB_32_MXID_SFT	18
	/*
	 * This value defines the intended doorbell path between RoCE and
	 * L2.
	 */
	#define DBC_ABSOLUTE_DB_32_PATH_MASK	UINT32_C(0x3000000)
	#define DBC_ABSOLUTE_DB_32_PATH_SFT	24
	/* This is a RoCE doorbell message. */
		#define DBC_ABSOLUTE_DB_32_PATH_ROCE	(UINT32_C(0x0) << 24)
	/* This is a L2 doorbell message. */
		#define DBC_ABSOLUTE_DB_32_PATH_L2		(UINT32_C(0x1) << 24)
		#define DBC_ABSOLUTE_DB_32_PATH_LAST	DBC_ABSOLUTE_DB_32_PATH_L2
	/*
	 * This indicates it is valid doorbell update. It should be set for
	 * each doorbell written to the chip and set when doorbell message is
	 * written to the backup doorbell location. The bit should be cleared
	 * in the backup doorbell location at time zero to indicate that the
	 * backup doorbell has not yet been written.
	 */
	#define DBC_ABSOLUTE_DB_32_VALID		UINT32_C(0x4000000)
	/*
	 * When this bit is set to one, the chip will capture debug
	 * information for the doorbell ring. This is intended to only be
	 * used on SQ doorbell rings.
	 */
	#define DBC_ABSOLUTE_DB_32_DEBUG_TRACE	UINT32_C(0x8000000)
	/* This value identifies the type of doorbell being written. */
	#define DBC_ABSOLUTE_DB_32_TYPE_MASK	UINT32_C(0xf0000000)
	#define DBC_ABSOLUTE_DB_32_TYPE_SFT	28
	/*
	 * This is a SQ producer index update.   It indicates one or more
	 * new entries have been written to the SQ for the QPID indicated
	 * on the xID field. This type is valid for L2, RoCE and Engine
	 * path.
	 */
		#define DBC_ABSOLUTE_DB_32_TYPE_SQ		(UINT32_C(0x0) << 28)
	/*
	 * This is a RQ producer index update.   It indicates one or more
	 * new entries have been written to the RQ for the QPID indicated
	 * on the xID field. This type is valid for RoCE path.
	 */
		#define DBC_ABSOLUTE_DB_32_TYPE_RQ		(UINT32_C(0x1) << 28)
	/*
	 * This is a SRQ producer index update.   It indicates one or more
	 * new entries have been written to the SRQ for the SID indicated
	 * on the xID field. This type is valid for L2 and RoCE path.
	 */
		#define DBC_ABSOLUTE_DB_32_TYPE_SRQ		(UINT32_C(0x2) << 28)
	/*
	 * This doorbell command arms the SRQ async event.
	 * The xID field must identify the SID that is begin armed.
	 * The index field is will set the arm threshold such that
	 * a notification will be generated if less than that number
	 * or SRQ entries are posted. This type is valid for RoCE path.
	 */
		#define DBC_ABSOLUTE_DB_32_TYPE_SRQ_ARM	(UINT32_C(0x3) << 28)
	/*
	 * This is a CQ consumer index update.   It indicates one or more
	 * entries have been processed off the CQ indicated on the xID
	 * field.This type is valid for L2, RoCE and Engine path.
	 */
		#define DBC_ABSOLUTE_DB_32_TYPE_CQ		(UINT32_C(0x4) << 28)
	/*
	 * this is a CQ consumer index update that also arms the CQ for
	 * solicited events. This type is valid for RoCE path.
	 */
		#define DBC_ABSOLUTE_DB_32_TYPE_CQ_ARMSE	(UINT32_C(0x5) << 28)
	/*
	 * This is a CQ consumer index update that also arms the CQ
	 * for any new CQE. This type is valid for L2, RoCE and Engine
	 * path.
	 */
		#define DBC_ABSOLUTE_DB_32_TYPE_CQ_ARMALL	(UINT32_C(0x6) << 28)
	/*
	 * This is a NQ consumer index update. It indicates one or more
	 * entries have been processed off the NQ indicated on the xID
	 * field. This type is valid for L2, RoCE and Engine path.
	 */
		#define DBC_ABSOLUTE_DB_32_TYPE_NQ		(UINT32_C(0xa) << 28)
	/*
	 * This is a NQ consumer index update that also arms the NQ for
	 * any new NQE. This type is valid for L2, RoCE and Engine path.
	 */
		#define DBC_ABSOLUTE_DB_32_TYPE_NQ_ARM	(UINT32_C(0xb) << 28)
	/*
	 * This is a NQ consumer index update that also arms the NQ for
	 * any new NQE. It is used for the legacy INT mask. This type
	 * is valid for L2, RoCE and Engine path.
	 */
		#define DBC_ABSOLUTE_DB_32_TYPE_NQ_MASK	(UINT32_C(0xe) << 28)
	/*
	 * This doorbell command is used during doorbell moderation
	 * to consume system BW and help prevent doorbell FIFO
	 * overflow.
	 *
	 * All other fields should be zero for NULL doorbell.
	 * For doorbell recovery, NULL doorbell type in the Application
	 * table indicates that it is the last QP entry for the function.
	 * This type is valid for L2, RoCE and Engine path.
	 */
		#define DBC_ABSOLUTE_DB_32_TYPE_NULL	(UINT32_C(0xf) << 28)
		#define DBC_ABSOLUTE_DB_32_TYPE_LAST	DBC_ABSOLUTE_DB_32_TYPE_NULL
} dbc_absolute_db_32_t, *pdbc_absolute_db_32_t;

/*
 * This is the "Relative" 32b Doorbell format. The host writes this
 * message format directly to byte offset 8 of the appropriate doorbell
 * page.
 *
 * Doorbell recovery can not be supported for relative doorbells. So
 * relative doorbells are only safe to use when SOC is supporting the
 * context backing store in local DDR. If that is the case, it is safe
 * to turn off doorbell drops and use this type of doorbell.
 */
/* dbc_relative_db_32 (size:32b/4B) */

typedef struct dbc_relative_db_32 {
	uint32_t	xid;
	/*
	 * This value identifies the resource that the doorbell is intended
	 * to notify.
	 *
	 * For SQ, this is the QPID value.
	 */
	#define DBC_RELATIVE_DB_32_XID_MASK	UINT32_C(0xfffff)
	#define DBC_RELATIVE_DB_32_XID_SFT	0
	/*
	 * This value defines the intended doorbell path between RoCE and
	 * L2.
	 */
	#define DBC_RELATIVE_DB_32_PATH_MASK	UINT32_C(0xc00000)
	#define DBC_RELATIVE_DB_32_PATH_SFT	22
	/* This is a RoCE doorbell message. */
		#define DBC_RELATIVE_DB_32_PATH_ROCE	(UINT32_C(0x0) << 22)
	/* This is a L2 doorbell message. */
		#define DBC_RELATIVE_DB_32_PATH_L2	(UINT32_C(0x1) << 22)
		#define DBC_RELATIVE_DB_32_PATH_LAST	DBC_RELATIVE_DB_32_PATH_L2
	/*
	 * This value is the value to add to the appropriate index value.
	 *
	 * The increment unit is 16B for L2 path. For RoCE there is a
	 * legacy mode with 128B unit size and a variable size mode with
	 * 32B unit size. For Engine mode, the unit size is always 128B.
	 */
	#define DBC_RELATIVE_DB_32_INCR_MASK	UINT32_C(0x1f000000)
	#define DBC_RELATIVE_DB_32_INCR_SFT	24
	/* This value identifies the type of doorbell being written. */
	#define DBC_RELATIVE_DB_32_TYPE_MASK	UINT32_C(0xe0000000)
	#define DBC_RELATIVE_DB_32_TYPE_SFT	29
	/*
	 * This is a SQ producer index update.   It indicates one or more
	 * new entries have been written to the SQ for the QPID indicated
	 * on the xID field. This type is valid for L2, RoCE and Engine
	 * path.
	 */
		#define DBC_RELATIVE_DB_32_TYPE_SQ	(UINT32_C(0x0) << 29)
	/*
	 * This is a SRQ producer index update.   It indicates one or more
	 * new entries have been written to the SRQ for the SID indicated
	 * on the xID field. This type is valid for L2 and RoCE path.
	 */
		#define DBC_RELATIVE_DB_32_TYPE_SRQ	(UINT32_C(0x1) << 29)
	/*
	 * This is a CQ consumer index update.   It indicates one or more
	 * entries have been processed off the CQ indicated on the xID
	 * field.This type is valid for L2, RoCE and Engine path.
	 */
		#define DBC_RELATIVE_DB_32_TYPE_CQ	(UINT32_C(0x2) << 29)
	/*
	 * This is a CQ consumer index update that also arms the CQ
	 * for any new CQE. This type is valid for L2, RoCE and Engine
	 * path.
	 */
		#define DBC_RELATIVE_DB_32_TYPE_CQ_ARMALL  (UINT32_C(0x3) << 29)
	/*
	 * This is a NQ consumer index update. It indicates one or more
	 * entries have been processed off the NQ indicated on the xID
	 * field. This type is valid for L2, RoCE and Engine path.
	 */
		#define DBC_RELATIVE_DB_32_TYPE_NQ	(UINT32_C(0x4) << 29)
	/*
	 * This is a NQ consumer index update that also arms the NQ for
	 * any new NQE. This type is valid for L2, RoCE and Engine path.
	 */
		#define DBC_RELATIVE_DB_32_TYPE_NQ_ARM	(UINT32_C(0x5) << 29)
	/*
	 * This is a NQ consumer index update that also arms the NQ for
	 * any new NQE. It is used for the legacy INT mask. This type
	 * is valid for L2, RoCE and Engine path.
	 */
		#define DBC_RELATIVE_DB_32_TYPE_NQ_MASK	(UINT32_C(0x6) << 29)
		#define DBC_RELATIVE_DB_32_TYPE_LAST	DBC_RELATIVE_DB_32_TYPE_NQ_MASK
} dbc_relative_db_32_t, *pdbc_relative_db_32_t;

/*
 * The kernel memory structure is per-type (SQ, RQ, SRQ/SRQ_ARM and
 * CQ/CQ_ARMSE/CQ_ARMALL). Each kernel driver will support a table for
 * the doorbell recovery.
 */
/* dbc_drk (size:128b/16B) */

typedef struct dbc_drk {
	uint32_t	db_format_linked_last_valid;
	/*
	 * This indicates it is valid entry. It should be set for each
	 * doorbell written to the chip. The bit should be cleared at time
	 * zero to indicate that it has not yet been written. The bit i
	 * should be cleared when the function for the table is disabled.
	 */
	#define DBC_DRK_VALID	UINT32_C(0x1)
	/* This indicates it is last entry for the table. */
	#define DBC_DRK_LAST	UINT32_C(0x2)
	/* This indicates it is entry for the next 4KB kernel memory pointer. */
	#define DBC_DRK_LINKED	UINT32_C(0x4)
	/*
	 * This field indicates if the doorbells in the table are 32b
	 * absolute or 64b format.
	 */
	#define DBC_DRK_DB_FORMAT	UINT32_C(0x8)
	/* The doorbells are 64b format. */
		#define DBC_DRK_DB_FORMAT_B64   (UINT32_C(0x0) << 3)
	/*
	 * The doorbells are in the absolute 32b format. The doorbell
	 * is in the right-most half of the 64b space provided in the
	 * application table entry.
	 */
		#define DBC_DRK_DB_FORMAT_B32A  (UINT32_C(0x1) << 3)
		#define DBC_DRK_DB_FORMAT_LAST DBC_DRK_DB_FORMAT_B32A
	uint32_t	pi;
	/*
	 * Page Index portion of DPI{VF_VALID,VFID,PI}. The pi needs to match
	 * the value from the context DPI for the operation to be valid or the
	 * pi must be zero, indicating a write from the privileged driver.
	 *
	 * pi in the kernel memory table is there for DBR to generate the DPI
	 * message to the client.
	 */
	#define DBC_DRK_PI_MASK UINT32_C(0xffff)
	#define DBC_DRK_PI_SFT 0
	/*
	 * It is the application memory page(4KB) pointer when linked = 0.
	 * It is the next kernel memory page(4KB) pointer when linked = 1.
	 * The pointer doesn't have to be aligned to the page(4KB) but it
	 * should be aligned to 128B boundary. This means that the bottom
	 * 7b of the pointer must be zero.
	 */
	uint64_t	memptr;
} dbc_drk_t, *pdbc_drk_t;

/*
 * This is a firmware status register that indicates the software status
 * exposed by the firmware to the host.
 *
 * > This register is not present in previous versions of this chip.
 */
/* fw_status_reg (size:32b/4B) */

typedef struct fw_status_reg {
	uint32_t	fw_status;
	/*
	 * These bits indicate the status as being reported by the firmware.
	 *
	 * The value should be interpreted as follows:
	 * A value below 0x8000 is an indication that the firmware is still in the
	 * process of starting up and is not ready. The host driver should
	 * continue waiting with a timeout for firmware status to be ready.
	 * >	0x0000 to 0x00FF : SBL state information
	 * >	0x0200 to 0x02FF : SBI state information
	 * >	0x0400 to 0x04FF : SRT state information
	 * >	0x0600 to 0x06FF : CRT/CHIMP state information
	 * >	0x0800 to 0x0FFF : Reserved for future fw functionality
	 *
	 * A value of 0x8000 indicates firmware is ready and healthy. The host
	 * driver can start initiating HWRM commands to the firmware.
	 *
	 * A value over 0x8000 is an indication that the firmware has detected
	 * a fatal error, this error could be in one of the hardware block or
	 * in a software module. The lower 8 bits indicate a block/module
	 * specific error and the upper 8 bits identify the hardware block
	 * or firmware module that was the source of the error.
	 * >	0x81XX - 0xBFXX  : 63 ASIC blocks
	 * >	0xC0XX to 0xFEXX : 63 Firmware modules
	 * >	0xFFXX	: Reserved for future
	 */
	#define FW_STATUS_REG_CODE_MASK		UINT32_C(0xffff)
	#define FW_STATUS_REG_CODE_SFT		0
	/* Indicates firmware is ready. */
		#define FW_STATUS_REG_CODE_READY		UINT32_C(0x8000)
		#define FW_STATUS_REG_CODE_LAST		FW_STATUS_REG_CODE_READY
	/*
	 * Image Degraded bit. If set indicates that one of the firmware
	 * image is degraded.
	 *
	 * The firmware binary located on NVM has redundant copies to protect
	 * against corruption. When one of the primary or secondary copy is
	 * detected as corrupted, this bit will be set by the firmware either
	 * as part of power on from the context of hwrm_fw_health_check.
	 */
	#define FW_STATUS_REG_IMAGE_DEGRADED	UINT32_C(0x10000)
	/*
	 * Recoverable bit. If set indicates that the fatal error is
	 * recoverable with a full reset.
	 *
	 * This bit should be used by host software and deployment models
	 * that support error recovery by resetting the controller. A recovery
	 * should be attempted from a fatal error condition only if this bit
	 * is set. This bit is meaningful only when the code field is greater
	 * than 0x8000 (32768 decimal).
	 */
	#define FW_STATUS_REG_RECOVERABLE		UINT32_C(0x20000)
	/*
	 * Crash dump is in process. If set indicates that the firmware is
	 * currently recording a crash dump.
	 *
	 * This bit provides a hint to the host driver if the firmware is
	 * currently recording a crash dump. Host driers should avoid resetting
	 * the controller when a crash dump is in progress if possible. This
	 * bit is meaningful only when the code field is greater than
	 * 0x8000 (32768 decimal).
	 */
	#define FW_STATUS_REG_CRASHDUMP_ONGOING	UINT32_C(0x40000)
	/*
	 * Crash dump is available. If set indicates that a firmware crash dump
	 * was recorded before and is now available.
	 *
	 * This bit provides indication to the host driver that the firmware has
	 * completed a crash dump. This bit is meaningful only when the code
	 * field is greater than 0x8000 (32768 decimal).
	 */
	#define FW_STATUS_REG_CRASHDUMP_COMPLETE	UINT32_C(0x80000)
	/*
	 * This bit is used to indicate device state when it enters the shutdown mode
	 * and stopped the communication with the host. The host should initiate the
	 * reload of firmware image or initiate the reset to bring the device to the
	 * normal operational state and re-establish the communication.
	 *
	 * This bit is meaningful only when the code field is greater than 0x8000
	 * (32768 decimal).
	 */
	#define FW_STATUS_REG_SHUTDOWN		UINT32_C(0x100000)
	/*
	 * This bit will be set to 1 by the FW when FW crashed without master
	 * function.
	 *
	 * This bit is controller specific, not all products will support this bit.
	 * This bit is valid only when the code field is greater than 0x8000
	 * (32768 decimal).
	 */
	#define FW_STATUS_REG_CRASHED_NO_MASTER	UINT32_C(0x200000)
	/*
	 * The firmware sets this bit to 1 when the firmware has taken an exception
	 * and expects to initiate error recovery.
	 *
	 * This bit is valid only when the code field is greater than 0x8000
	 * (32768 decimal).
	 */
	#define FW_STATUS_REG_RECOVERING		UINT32_C(0x400000)
} fw_status_reg_t, *pfw_status_reg_t;

/*
 * This structure is fixed at the beginning of the ChiMP SRAM (GRC
 * offset: 0x31001F0). Host software is expected to read from this
 * location for a defined signature. If it exists, the software can
 * assume the presence of this structure and the validity of the
 * FW_STATUS location in the next field.
 */
/* hcomm_status (size:64b/8B) */

typedef struct hcomm_status {
	uint32_t	sig_ver;
	/*
	 * This field defines the version of the structure. The latest
	 * version value is 1.
	 */
	#define HCOMM_STATUS_VER_MASK	UINT32_C(0xff)
	#define HCOMM_STATUS_VER_SFT	0
		#define HCOMM_STATUS_VER_LATEST	UINT32_C(0x1)
		#define HCOMM_STATUS_VER_LAST	HCOMM_STATUS_VER_LATEST
	/*
	 * This field is to store the signature value to indicate the
	 * presence of the structure.
	 */
	#define HCOMM_STATUS_SIGNATURE_MASK UINT32_C(0xffffff00)
	#define HCOMM_STATUS_SIGNATURE_SFT 8
		#define HCOMM_STATUS_SIGNATURE_VAL   (UINT32_C(0x484353) << 8)
		#define HCOMM_STATUS_SIGNATURE_LAST HCOMM_STATUS_SIGNATURE_VAL
	uint32_t	fw_status_loc;
	#define HCOMM_STATUS_TRUE_ADDR_SPACE_MASK	UINT32_C(0x3)
	#define HCOMM_STATUS_TRUE_ADDR_SPACE_SFT	0
	/* PCIE configuration space */
		#define HCOMM_STATUS_FW_STATUS_LOC_ADDR_SPACE_PCIE_CFG  UINT32_C(0x0)
	/* GRC space */
		#define HCOMM_STATUS_FW_STATUS_LOC_ADDR_SPACE_GRC	UINT32_C(0x1)
	/* BAR0 space */
		#define HCOMM_STATUS_FW_STATUS_LOC_ADDR_SPACE_BAR0	UINT32_C(0x2)
	/* BAR1 space */
		#define HCOMM_STATUS_FW_STATUS_LOC_ADDR_SPACE_BAR1	UINT32_C(0x3)
		#define HCOMM_STATUS_FW_STATUS_LOC_ADDR_SPACE_LAST	HCOMM_STATUS_FW_STATUS_LOC_ADDR_SPACE_BAR1
	/*
	 * This offset where the fw_status register is located. The value
	 * is generally 4-byte aligned.
	 */
	#define HCOMM_STATUS_TRUE_OFFSET_MASK	UINT32_C(0xfffffffc)
	#define HCOMM_STATUS_TRUE_OFFSET_SFT	2
} hcomm_status_t, *phcomm_status_t;

/* This is the GRC offset where the hcomm_status struct resides. */
#define HCOMM_STATUS_STRUCT_LOC 0x31001F0UL

/****************
 * hwrm_oem_cmd *
 ****************/


/* hwrm_oem_cmd_input (size:1024b/128B) */

typedef struct hwrm_oem_cmd_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	IANA;
	uint32_t	unused_0;
	/* This field contains the vendor specific command data. */
	uint32_t	oem_data[26];
} hwrm_oem_cmd_input_t, *phwrm_oem_cmd_input_t;

/* hwrm_oem_cmd_output (size:768b/96B) */

typedef struct hwrm_oem_cmd_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint32_t	IANA;
	uint32_t	unused_0;
	/* This field contains the vendor specific response data. */
	uint32_t	oem_data[18];
	uint8_t	unused_1[7];
	/*
	 * This field is used in Output records to indicate that the output
	 * is completely written to RAM.  This field should be read as '1'
	 * to indicate that the output has been completely written.
	 * When writing a command completion or response to an internal processor,
	 * the order of writes has to be such that this field is written last.
	 */
	uint8_t	valid;
} hwrm_oem_cmd_output_t, *phwrm_oem_cmd_output_t;

/***********
 * hwrm_sv *
 ***********/


/* hwrm_sv_input (size:1152b/144B) */

typedef struct hwrm_sv_input {
	/* The HWRM command request type. */
	uint16_t	req_type;
	/*
	 * The completion ring to send the completion event on. This should
	 * be the NQ ID returned from the `nq_alloc` HWRM command.
	 */
	uint16_t	cmpl_ring;
	/*
	 * The sequence ID is used by the driver for tracking multiple
	 * commands. This ID is treated as opaque data by the firmware and
	 * the value is returned in the `hwrm_resp_hdr` upon completion.
	 */
	uint16_t	seq_id;
	/*
	 * The target ID of the command:
	 * * 0x0-0xFFF8 - The function ID
	 * * 0xFFF8-0xFFFC, 0xFFFE - Reserved for internal processors
	 * * 0xFFFD - Reserved for user-space HWRM interface
	 * * 0xFFFF - HWRM
	 */
	uint16_t	target_id;
	/*
	 * A physical address pointer pointing to a host buffer that the
	 * command's response data will be written. This can be either a host
	 * physical address (HPA) or a guest physical address (GPA) and must
	 * point to a physically contiguous block of memory.
	 */
	uint64_t	resp_addr;
	uint32_t	opaque[32];
} hwrm_sv_input_t, *phwrm_sv_input_t;

/* hwrm_sv_output (size:1088b/136B) */

typedef struct hwrm_sv_output {
	/* The specific error status for the command. */
	uint16_t	error_code;
	/* The HWRM command request type. */
	uint16_t	req_type;
	/* The sequence ID from the original command. */
	uint16_t	seq_id;
	/* The length of the response data in number of bytes. */
	uint16_t	resp_len;
	uint32_t	opaque[32];
} hwrm_sv_output_t, *phwrm_sv_output_t;

#endif /* _HSI_STRUCT_DEF_EXTERNAL_H_ */
