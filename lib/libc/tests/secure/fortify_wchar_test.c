/* @generated by `generate-fortify-tests.lua "wchar"` */

#define	_FORTIFY_SOURCE	2
#define	TMPFILE_SIZE	(1024 * 32)

#include <sys/param.h>
#include <sys/random.h>
#include <sys/resource.h>
#include <sys/time.h>
#include <sys/uio.h>
#include <sys/wait.h>
#include <dirent.h>
#include <errno.h>
#include <fcntl.h>
#include <limits.h>
#include <poll.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sysexits.h>
#include <unistd.h>
#include <wchar.h>
#include <atf-c.h>

static FILE * __unused
new_fp(size_t __len)
{
	static char fpbuf[LINE_MAX];
	FILE *fp;

	ATF_REQUIRE(__len <= sizeof(fpbuf));

	memset(fpbuf, 'A', sizeof(fpbuf) - 1);
	fpbuf[sizeof(fpbuf) - 1] = '\0';

	fp = fmemopen(fpbuf, sizeof(fpbuf), "rb");
	ATF_REQUIRE(fp != NULL);

	return (fp);
}

/*
 * Create a new symlink to use for readlink(2) style tests, we'll just use a
 * random target name to have something interesting to look at.
 */
static const char * __unused
new_symlink(size_t __len)
{
	static const char linkname[] = "link";
	char target[MAXNAMLEN];
	int error;

	ATF_REQUIRE(__len <= sizeof(target));

	arc4random_buf(target, sizeof(target));

	error = unlink(linkname);
	ATF_REQUIRE(error == 0 || errno == ENOENT);

	error = symlink(target, linkname);
	ATF_REQUIRE(error == 0);

	return (linkname);
}

/*
 * Constructs a tmpfile that we can use for testing read(2) and friends.
 */
static int __unused
new_tmpfile(void)
{
	char buf[1024];
	ssize_t rv;
	size_t written;
	int fd;

	fd = open("tmpfile", O_RDWR | O_CREAT | O_TRUNC, 0644);
	ATF_REQUIRE(fd >= 0);

	written = 0;
	while (written < TMPFILE_SIZE) {
		rv = write(fd, buf, sizeof(buf));
		ATF_REQUIRE(rv > 0);

		written += rv;
	}

	ATF_REQUIRE_EQ(0, lseek(fd, 0, SEEK_SET));
	return (fd);
}

static void
disable_coredumps(void)
{
	struct rlimit rl = { 0 };

	if (setrlimit(RLIMIT_CORE, &rl) == -1)
		_exit(EX_OSERR);
}

/*
 * Replaces stdin with a file that we can actually read from, for tests where
 * we want a FILE * or fd that we can get data from.
 */
static void __unused
replace_stdin(void)
{
	int fd;

	fd = new_tmpfile();

	(void)dup2(fd, STDIN_FILENO);
	if (fd != STDIN_FILENO)
		close(fd);
}

ATF_TC_WITHOUT_HEAD(wmemcpy_before_end);
ATF_TC_BODY(wmemcpy_before_end, tc)
{
#define BUF &__stack.__buf
	struct {
		uint8_t padding_l;
		wchar_t __buf[42];
		uint8_t padding_r;
	} __stack;
	const size_t __bufsz __unused = sizeof(__stack.__buf);
	const size_t __len = 42 - 1;
	const size_t __idx __unused = __len - 1;
	wchar_t src[__len + 10];

	wmemcpy(__stack.__buf, src, __len);
#undef BUF

}

ATF_TC_WITHOUT_HEAD(wmemcpy_end);
ATF_TC_BODY(wmemcpy_end, tc)
{
#define BUF &__stack.__buf
	struct {
		uint8_t padding_l;
		wchar_t __buf[42];
		uint8_t padding_r;
	} __stack;
	const size_t __bufsz __unused = sizeof(__stack.__buf);
	const size_t __len = 42;
	const size_t __idx __unused = __len - 1;
	wchar_t src[__len + 10];

	wmemcpy(__stack.__buf, src, __len);
#undef BUF

}

ATF_TC_WITHOUT_HEAD(wmemcpy_heap_before_end);
ATF_TC_BODY(wmemcpy_heap_before_end, tc)
{
#define BUF __stack.__buf
	struct {
		uint8_t padding_l;
		wchar_t * __buf;
		uint8_t padding_r;
	} __stack;
	const size_t __bufsz __unused = sizeof(*__stack.__buf) * (42);
	const size_t __len = 42 - 1;
	const size_t __idx __unused = __len - 1;
	wchar_t src[__len + 10];

	__stack.__buf = malloc(__bufsz);

	wmemcpy(__stack.__buf, src, __len);
#undef BUF

}

ATF_TC_WITHOUT_HEAD(wmemcpy_heap_end);
ATF_TC_BODY(wmemcpy_heap_end, tc)
{
#define BUF __stack.__buf
	struct {
		uint8_t padding_l;
		wchar_t * __buf;
		uint8_t padding_r;
	} __stack;
	const size_t __bufsz __unused = sizeof(*__stack.__buf) * (42);
	const size_t __len = 42;
	const size_t __idx __unused = __len - 1;
	wchar_t src[__len + 10];

	__stack.__buf = malloc(__bufsz);

	wmemcpy(__stack.__buf, src, __len);
#undef BUF

}

ATF_TC_WITHOUT_HEAD(wmemcpy_heap_after_end);
ATF_TC_BODY(wmemcpy_heap_after_end, tc)
{
#define BUF __stack.__buf
	struct {
		uint8_t padding_l;
		wchar_t * __buf;
		uint8_t padding_r;
	} __stack;
	const size_t __bufsz __unused = sizeof(*__stack.__buf) * (42);
	const size_t __len = 42 + 1;
	const size_t __idx __unused = __len - 1;
	pid_t __child;
	int __status;
	wchar_t src[__len + 10];

	__child = fork();
	ATF_REQUIRE(__child >= 0);
	if (__child > 0)
		goto monitor;

	/* Child */
	disable_coredumps();
	__stack.__buf = malloc(__bufsz);

	wmemcpy(__stack.__buf, src, __len);
	_exit(EX_SOFTWARE);	/* Should have aborted. */

monitor:
	while (waitpid(__child, &__status, 0) != __child) {
		ATF_REQUIRE_EQ(EINTR, errno);
	}

	if (!WIFSIGNALED(__status)) {
		switch (WEXITSTATUS(__status)) {
		case EX_SOFTWARE:
			atf_tc_fail("FORTIFY_SOURCE failed to abort");
			break;
		case EX_OSERR:
			atf_tc_fail("setrlimit(2) failed");
			break;
		default:
			atf_tc_fail("child exited with status %d",
			    WEXITSTATUS(__status));
		}
	} else {
		ATF_REQUIRE_EQ(SIGABRT, WTERMSIG(__status));
	}
#undef BUF

}

ATF_TC_WITHOUT_HEAD(wmempcpy_before_end);
ATF_TC_BODY(wmempcpy_before_end, tc)
{
#define BUF &__stack.__buf
	struct {
		uint8_t padding_l;
		wchar_t __buf[42];
		uint8_t padding_r;
	} __stack;
	const size_t __bufsz __unused = sizeof(__stack.__buf);
	const size_t __len = 42 - 1;
	const size_t __idx __unused = __len - 1;
	wchar_t src[__len + 10];

	wmempcpy(__stack.__buf, src, __len);
#undef BUF

}

ATF_TC_WITHOUT_HEAD(wmempcpy_end);
ATF_TC_BODY(wmempcpy_end, tc)
{
#define BUF &__stack.__buf
	struct {
		uint8_t padding_l;
		wchar_t __buf[42];
		uint8_t padding_r;
	} __stack;
	const size_t __bufsz __unused = sizeof(__stack.__buf);
	const size_t __len = 42;
	const size_t __idx __unused = __len - 1;
	wchar_t src[__len + 10];

	wmempcpy(__stack.__buf, src, __len);
#undef BUF

}

ATF_TC_WITHOUT_HEAD(wmempcpy_heap_before_end);
ATF_TC_BODY(wmempcpy_heap_before_end, tc)
{
#define BUF __stack.__buf
	struct {
		uint8_t padding_l;
		wchar_t * __buf;
		uint8_t padding_r;
	} __stack;
	const size_t __bufsz __unused = sizeof(*__stack.__buf) * (42);
	const size_t __len = 42 - 1;
	const size_t __idx __unused = __len - 1;
	wchar_t src[__len + 10];

	__stack.__buf = malloc(__bufsz);

	wmempcpy(__stack.__buf, src, __len);
#undef BUF

}

ATF_TC_WITHOUT_HEAD(wmempcpy_heap_end);
ATF_TC_BODY(wmempcpy_heap_end, tc)
{
#define BUF __stack.__buf
	struct {
		uint8_t padding_l;
		wchar_t * __buf;
		uint8_t padding_r;
	} __stack;
	const size_t __bufsz __unused = sizeof(*__stack.__buf) * (42);
	const size_t __len = 42;
	const size_t __idx __unused = __len - 1;
	wchar_t src[__len + 10];

	__stack.__buf = malloc(__bufsz);

	wmempcpy(__stack.__buf, src, __len);
#undef BUF

}

ATF_TC_WITHOUT_HEAD(wmempcpy_heap_after_end);
ATF_TC_BODY(wmempcpy_heap_after_end, tc)
{
#define BUF __stack.__buf
	struct {
		uint8_t padding_l;
		wchar_t * __buf;
		uint8_t padding_r;
	} __stack;
	const size_t __bufsz __unused = sizeof(*__stack.__buf) * (42);
	const size_t __len = 42 + 1;
	const size_t __idx __unused = __len - 1;
	pid_t __child;
	int __status;
	wchar_t src[__len + 10];

	__child = fork();
	ATF_REQUIRE(__child >= 0);
	if (__child > 0)
		goto monitor;

	/* Child */
	disable_coredumps();
	__stack.__buf = malloc(__bufsz);

	wmempcpy(__stack.__buf, src, __len);
	_exit(EX_SOFTWARE);	/* Should have aborted. */

monitor:
	while (waitpid(__child, &__status, 0) != __child) {
		ATF_REQUIRE_EQ(EINTR, errno);
	}

	if (!WIFSIGNALED(__status)) {
		switch (WEXITSTATUS(__status)) {
		case EX_SOFTWARE:
			atf_tc_fail("FORTIFY_SOURCE failed to abort");
			break;
		case EX_OSERR:
			atf_tc_fail("setrlimit(2) failed");
			break;
		default:
			atf_tc_fail("child exited with status %d",
			    WEXITSTATUS(__status));
		}
	} else {
		ATF_REQUIRE_EQ(SIGABRT, WTERMSIG(__status));
	}
#undef BUF

}

ATF_TC_WITHOUT_HEAD(wmemmove_before_end);
ATF_TC_BODY(wmemmove_before_end, tc)
{
#define BUF &__stack.__buf
	struct {
		uint8_t padding_l;
		wchar_t __buf[42];
		uint8_t padding_r;
	} __stack;
	const size_t __bufsz __unused = sizeof(__stack.__buf);
	const size_t __len = 42 - 1;
	const size_t __idx __unused = __len - 1;
	wchar_t src[__len + 10];

	wmemmove(__stack.__buf, src, __len);
#undef BUF

}

ATF_TC_WITHOUT_HEAD(wmemmove_end);
ATF_TC_BODY(wmemmove_end, tc)
{
#define BUF &__stack.__buf
	struct {
		uint8_t padding_l;
		wchar_t __buf[42];
		uint8_t padding_r;
	} __stack;
	const size_t __bufsz __unused = sizeof(__stack.__buf);
	const size_t __len = 42;
	const size_t __idx __unused = __len - 1;
	wchar_t src[__len + 10];

	wmemmove(__stack.__buf, src, __len);
#undef BUF

}

ATF_TC_WITHOUT_HEAD(wmemmove_heap_before_end);
ATF_TC_BODY(wmemmove_heap_before_end, tc)
{
#define BUF __stack.__buf
	struct {
		uint8_t padding_l;
		wchar_t * __buf;
		uint8_t padding_r;
	} __stack;
	const size_t __bufsz __unused = sizeof(*__stack.__buf) * (42);
	const size_t __len = 42 - 1;
	const size_t __idx __unused = __len - 1;
	wchar_t src[__len + 10];

	__stack.__buf = malloc(__bufsz);

	wmemmove(__stack.__buf, src, __len);
#undef BUF

}

ATF_TC_WITHOUT_HEAD(wmemmove_heap_end);
ATF_TC_BODY(wmemmove_heap_end, tc)
{
#define BUF __stack.__buf
	struct {
		uint8_t padding_l;
		wchar_t * __buf;
		uint8_t padding_r;
	} __stack;
	const size_t __bufsz __unused = sizeof(*__stack.__buf) * (42);
	const size_t __len = 42;
	const size_t __idx __unused = __len - 1;
	wchar_t src[__len + 10];

	__stack.__buf = malloc(__bufsz);

	wmemmove(__stack.__buf, src, __len);
#undef BUF

}

ATF_TC_WITHOUT_HEAD(wmemmove_heap_after_end);
ATF_TC_BODY(wmemmove_heap_after_end, tc)
{
#define BUF __stack.__buf
	struct {
		uint8_t padding_l;
		wchar_t * __buf;
		uint8_t padding_r;
	} __stack;
	const size_t __bufsz __unused = sizeof(*__stack.__buf) * (42);
	const size_t __len = 42 + 1;
	const size_t __idx __unused = __len - 1;
	pid_t __child;
	int __status;
	wchar_t src[__len + 10];

	__child = fork();
	ATF_REQUIRE(__child >= 0);
	if (__child > 0)
		goto monitor;

	/* Child */
	disable_coredumps();
	__stack.__buf = malloc(__bufsz);

	wmemmove(__stack.__buf, src, __len);
	_exit(EX_SOFTWARE);	/* Should have aborted. */

monitor:
	while (waitpid(__child, &__status, 0) != __child) {
		ATF_REQUIRE_EQ(EINTR, errno);
	}

	if (!WIFSIGNALED(__status)) {
		switch (WEXITSTATUS(__status)) {
		case EX_SOFTWARE:
			atf_tc_fail("FORTIFY_SOURCE failed to abort");
			break;
		case EX_OSERR:
			atf_tc_fail("setrlimit(2) failed");
			break;
		default:
			atf_tc_fail("child exited with status %d",
			    WEXITSTATUS(__status));
		}
	} else {
		ATF_REQUIRE_EQ(SIGABRT, WTERMSIG(__status));
	}
#undef BUF

}

ATF_TC_WITHOUT_HEAD(wmemset_before_end);
ATF_TC_BODY(wmemset_before_end, tc)
{
#define BUF &__stack.__buf
	struct {
		uint8_t padding_l;
		wchar_t __buf[42];
		uint8_t padding_r;
	} __stack;
	const size_t __bufsz __unused = sizeof(__stack.__buf);
	const size_t __len = 42 - 1;
	const size_t __idx __unused = __len - 1;

	wmemset(__stack.__buf, L'0', __len);
#undef BUF

}

ATF_TC_WITHOUT_HEAD(wmemset_end);
ATF_TC_BODY(wmemset_end, tc)
{
#define BUF &__stack.__buf
	struct {
		uint8_t padding_l;
		wchar_t __buf[42];
		uint8_t padding_r;
	} __stack;
	const size_t __bufsz __unused = sizeof(__stack.__buf);
	const size_t __len = 42;
	const size_t __idx __unused = __len - 1;

	wmemset(__stack.__buf, L'0', __len);
#undef BUF

}

ATF_TC_WITHOUT_HEAD(wmemset_heap_before_end);
ATF_TC_BODY(wmemset_heap_before_end, tc)
{
#define BUF __stack.__buf
	struct {
		uint8_t padding_l;
		wchar_t * __buf;
		uint8_t padding_r;
	} __stack;
	const size_t __bufsz __unused = sizeof(*__stack.__buf) * (42);
	const size_t __len = 42 - 1;
	const size_t __idx __unused = __len - 1;

	__stack.__buf = malloc(__bufsz);

	wmemset(__stack.__buf, L'0', __len);
#undef BUF

}

ATF_TC_WITHOUT_HEAD(wmemset_heap_end);
ATF_TC_BODY(wmemset_heap_end, tc)
{
#define BUF __stack.__buf
	struct {
		uint8_t padding_l;
		wchar_t * __buf;
		uint8_t padding_r;
	} __stack;
	const size_t __bufsz __unused = sizeof(*__stack.__buf) * (42);
	const size_t __len = 42;
	const size_t __idx __unused = __len - 1;

	__stack.__buf = malloc(__bufsz);

	wmemset(__stack.__buf, L'0', __len);
#undef BUF

}

ATF_TC_WITHOUT_HEAD(wmemset_heap_after_end);
ATF_TC_BODY(wmemset_heap_after_end, tc)
{
#define BUF __stack.__buf
	struct {
		uint8_t padding_l;
		wchar_t * __buf;
		uint8_t padding_r;
	} __stack;
	const size_t __bufsz __unused = sizeof(*__stack.__buf) * (42);
	const size_t __len = 42 + 1;
	const size_t __idx __unused = __len - 1;
	pid_t __child;
	int __status;

	__child = fork();
	ATF_REQUIRE(__child >= 0);
	if (__child > 0)
		goto monitor;

	/* Child */
	disable_coredumps();
	__stack.__buf = malloc(__bufsz);

	wmemset(__stack.__buf, L'0', __len);
	_exit(EX_SOFTWARE);	/* Should have aborted. */

monitor:
	while (waitpid(__child, &__status, 0) != __child) {
		ATF_REQUIRE_EQ(EINTR, errno);
	}

	if (!WIFSIGNALED(__status)) {
		switch (WEXITSTATUS(__status)) {
		case EX_SOFTWARE:
			atf_tc_fail("FORTIFY_SOURCE failed to abort");
			break;
		case EX_OSERR:
			atf_tc_fail("setrlimit(2) failed");
			break;
		default:
			atf_tc_fail("child exited with status %d",
			    WEXITSTATUS(__status));
		}
	} else {
		ATF_REQUIRE_EQ(SIGABRT, WTERMSIG(__status));
	}
#undef BUF

}

ATF_TC_WITHOUT_HEAD(wcpcpy_before_end);
ATF_TC_BODY(wcpcpy_before_end, tc)
{
#define BUF &__stack.__buf
	struct {
		uint8_t padding_l;
		wchar_t __buf[42];
		uint8_t padding_r;
	} __stack;
	const size_t __bufsz __unused = sizeof(__stack.__buf);
	const size_t __len = 42 - 1;
	const size_t __idx __unused = __len - 1;
	wchar_t src[__len];

	wmemset(__stack.__buf, 0, __len);
	wmemset(src, 'A', __len - 1);
	src[__len - 1] = '\0';

	wcpcpy(__stack.__buf, src);
#undef BUF

}

ATF_TC_WITHOUT_HEAD(wcpcpy_end);
ATF_TC_BODY(wcpcpy_end, tc)
{
#define BUF &__stack.__buf
	struct {
		uint8_t padding_l;
		wchar_t __buf[42];
		uint8_t padding_r;
	} __stack;
	const size_t __bufsz __unused = sizeof(__stack.__buf);
	const size_t __len = 42;
	const size_t __idx __unused = __len - 1;
	wchar_t src[__len];

	wmemset(__stack.__buf, 0, __len);
	wmemset(src, 'A', __len - 1);
	src[__len - 1] = '\0';

	wcpcpy(__stack.__buf, src);
#undef BUF

}

ATF_TC_WITHOUT_HEAD(wcpcpy_heap_before_end);
ATF_TC_BODY(wcpcpy_heap_before_end, tc)
{
#define BUF __stack.__buf
	struct {
		uint8_t padding_l;
		wchar_t * __buf;
		uint8_t padding_r;
	} __stack;
	const size_t __bufsz __unused = sizeof(*__stack.__buf) * (42);
	const size_t __len = 42 - 1;
	const size_t __idx __unused = __len - 1;
	wchar_t src[__len];

	__stack.__buf = malloc(__bufsz);
	wmemset(__stack.__buf, 0, __len);
	wmemset(src, 'A', __len - 1);
	src[__len - 1] = '\0';

	wcpcpy(__stack.__buf, src);
#undef BUF

}

ATF_TC_WITHOUT_HEAD(wcpcpy_heap_end);
ATF_TC_BODY(wcpcpy_heap_end, tc)
{
#define BUF __stack.__buf
	struct {
		uint8_t padding_l;
		wchar_t * __buf;
		uint8_t padding_r;
	} __stack;
	const size_t __bufsz __unused = sizeof(*__stack.__buf) * (42);
	const size_t __len = 42;
	const size_t __idx __unused = __len - 1;
	wchar_t src[__len];

	__stack.__buf = malloc(__bufsz);
	wmemset(__stack.__buf, 0, __len);
	wmemset(src, 'A', __len - 1);
	src[__len - 1] = '\0';

	wcpcpy(__stack.__buf, src);
#undef BUF

}

ATF_TC_WITHOUT_HEAD(wcpcpy_heap_after_end);
ATF_TC_BODY(wcpcpy_heap_after_end, tc)
{
#define BUF __stack.__buf
	struct {
		uint8_t padding_l;
		wchar_t * __buf;
		uint8_t padding_r;
	} __stack;
	const size_t __bufsz __unused = sizeof(*__stack.__buf) * (42);
	const size_t __len = 42 + 1;
	const size_t __idx __unused = __len - 1;
	pid_t __child;
	int __status;
	wchar_t src[__len];

	__child = fork();
	ATF_REQUIRE(__child >= 0);
	if (__child > 0)
		goto monitor;

	/* Child */
	disable_coredumps();
	__stack.__buf = malloc(__bufsz);
	wmemset(__stack.__buf, 0, __len);
	wmemset(src, 'A', __len - 1);
	src[__len - 1] = '\0';

	wcpcpy(__stack.__buf, src);
	_exit(EX_SOFTWARE);	/* Should have aborted. */

monitor:
	while (waitpid(__child, &__status, 0) != __child) {
		ATF_REQUIRE_EQ(EINTR, errno);
	}

	if (!WIFSIGNALED(__status)) {
		switch (WEXITSTATUS(__status)) {
		case EX_SOFTWARE:
			atf_tc_fail("FORTIFY_SOURCE failed to abort");
			break;
		case EX_OSERR:
			atf_tc_fail("setrlimit(2) failed");
			break;
		default:
			atf_tc_fail("child exited with status %d",
			    WEXITSTATUS(__status));
		}
	} else {
		ATF_REQUIRE_EQ(SIGABRT, WTERMSIG(__status));
	}
#undef BUF

}

ATF_TC_WITHOUT_HEAD(wcpncpy_before_end);
ATF_TC_BODY(wcpncpy_before_end, tc)
{
#define BUF &__stack.__buf
	struct {
		uint8_t padding_l;
		wchar_t __buf[42];
		uint8_t padding_r;
	} __stack;
	const size_t __bufsz __unused = sizeof(__stack.__buf);
	const size_t __len = 42 - 1;
	const size_t __idx __unused = __len - 1;
	wchar_t src[__len];

	wmemset(__stack.__buf, 0, __len);
	wmemset(src, 'A', __len - 1);
	src[__len - 1] = '\0';

	wcpncpy(__stack.__buf, src, __len);
#undef BUF

}

ATF_TC_WITHOUT_HEAD(wcpncpy_end);
ATF_TC_BODY(wcpncpy_end, tc)
{
#define BUF &__stack.__buf
	struct {
		uint8_t padding_l;
		wchar_t __buf[42];
		uint8_t padding_r;
	} __stack;
	const size_t __bufsz __unused = sizeof(__stack.__buf);
	const size_t __len = 42;
	const size_t __idx __unused = __len - 1;
	wchar_t src[__len];

	wmemset(__stack.__buf, 0, __len);
	wmemset(src, 'A', __len - 1);
	src[__len - 1] = '\0';

	wcpncpy(__stack.__buf, src, __len);
#undef BUF

}

ATF_TC_WITHOUT_HEAD(wcpncpy_heap_before_end);
ATF_TC_BODY(wcpncpy_heap_before_end, tc)
{
#define BUF __stack.__buf
	struct {
		uint8_t padding_l;
		wchar_t * __buf;
		uint8_t padding_r;
	} __stack;
	const size_t __bufsz __unused = sizeof(*__stack.__buf) * (42);
	const size_t __len = 42 - 1;
	const size_t __idx __unused = __len - 1;
	wchar_t src[__len];

	__stack.__buf = malloc(__bufsz);
	wmemset(__stack.__buf, 0, __len);
	wmemset(src, 'A', __len - 1);
	src[__len - 1] = '\0';

	wcpncpy(__stack.__buf, src, __len);
#undef BUF

}

ATF_TC_WITHOUT_HEAD(wcpncpy_heap_end);
ATF_TC_BODY(wcpncpy_heap_end, tc)
{
#define BUF __stack.__buf
	struct {
		uint8_t padding_l;
		wchar_t * __buf;
		uint8_t padding_r;
	} __stack;
	const size_t __bufsz __unused = sizeof(*__stack.__buf) * (42);
	const size_t __len = 42;
	const size_t __idx __unused = __len - 1;
	wchar_t src[__len];

	__stack.__buf = malloc(__bufsz);
	wmemset(__stack.__buf, 0, __len);
	wmemset(src, 'A', __len - 1);
	src[__len - 1] = '\0';

	wcpncpy(__stack.__buf, src, __len);
#undef BUF

}

ATF_TC_WITHOUT_HEAD(wcpncpy_heap_after_end);
ATF_TC_BODY(wcpncpy_heap_after_end, tc)
{
#define BUF __stack.__buf
	struct {
		uint8_t padding_l;
		wchar_t * __buf;
		uint8_t padding_r;
	} __stack;
	const size_t __bufsz __unused = sizeof(*__stack.__buf) * (42);
	const size_t __len = 42 + 1;
	const size_t __idx __unused = __len - 1;
	pid_t __child;
	int __status;
	wchar_t src[__len];

	__child = fork();
	ATF_REQUIRE(__child >= 0);
	if (__child > 0)
		goto monitor;

	/* Child */
	disable_coredumps();
	__stack.__buf = malloc(__bufsz);
	wmemset(__stack.__buf, 0, __len);
	wmemset(src, 'A', __len - 1);
	src[__len - 1] = '\0';

	wcpncpy(__stack.__buf, src, __len);
	_exit(EX_SOFTWARE);	/* Should have aborted. */

monitor:
	while (waitpid(__child, &__status, 0) != __child) {
		ATF_REQUIRE_EQ(EINTR, errno);
	}

	if (!WIFSIGNALED(__status)) {
		switch (WEXITSTATUS(__status)) {
		case EX_SOFTWARE:
			atf_tc_fail("FORTIFY_SOURCE failed to abort");
			break;
		case EX_OSERR:
			atf_tc_fail("setrlimit(2) failed");
			break;
		default:
			atf_tc_fail("child exited with status %d",
			    WEXITSTATUS(__status));
		}
	} else {
		ATF_REQUIRE_EQ(SIGABRT, WTERMSIG(__status));
	}
#undef BUF

}

ATF_TC_WITHOUT_HEAD(wcscat_before_end);
ATF_TC_BODY(wcscat_before_end, tc)
{
#define BUF &__stack.__buf
	struct {
		uint8_t padding_l;
		wchar_t __buf[42];
		uint8_t padding_r;
	} __stack;
	const size_t __bufsz __unused = sizeof(__stack.__buf);
	const size_t __len = 42 - 1;
	const size_t __idx __unused = __len - 1;
	wchar_t src[__len];

	wmemset(__stack.__buf, 0, __len);
	wmemset(src, 'A', __len - 1);
	src[__len - 1] = '\0';

	wcscat(__stack.__buf, src);
#undef BUF

}

ATF_TC_WITHOUT_HEAD(wcscat_end);
ATF_TC_BODY(wcscat_end, tc)
{
#define BUF &__stack.__buf
	struct {
		uint8_t padding_l;
		wchar_t __buf[42];
		uint8_t padding_r;
	} __stack;
	const size_t __bufsz __unused = sizeof(__stack.__buf);
	const size_t __len = 42;
	const size_t __idx __unused = __len - 1;
	wchar_t src[__len];

	wmemset(__stack.__buf, 0, __len);
	wmemset(src, 'A', __len - 1);
	src[__len - 1] = '\0';

	wcscat(__stack.__buf, src);
#undef BUF

}

ATF_TC_WITHOUT_HEAD(wcscat_heap_before_end);
ATF_TC_BODY(wcscat_heap_before_end, tc)
{
#define BUF __stack.__buf
	struct {
		uint8_t padding_l;
		wchar_t * __buf;
		uint8_t padding_r;
	} __stack;
	const size_t __bufsz __unused = sizeof(*__stack.__buf) * (42);
	const size_t __len = 42 - 1;
	const size_t __idx __unused = __len - 1;
	wchar_t src[__len];

	__stack.__buf = malloc(__bufsz);
	wmemset(__stack.__buf, 0, __len);
	wmemset(src, 'A', __len - 1);
	src[__len - 1] = '\0';

	wcscat(__stack.__buf, src);
#undef BUF

}

ATF_TC_WITHOUT_HEAD(wcscat_heap_end);
ATF_TC_BODY(wcscat_heap_end, tc)
{
#define BUF __stack.__buf
	struct {
		uint8_t padding_l;
		wchar_t * __buf;
		uint8_t padding_r;
	} __stack;
	const size_t __bufsz __unused = sizeof(*__stack.__buf) * (42);
	const size_t __len = 42;
	const size_t __idx __unused = __len - 1;
	wchar_t src[__len];

	__stack.__buf = malloc(__bufsz);
	wmemset(__stack.__buf, 0, __len);
	wmemset(src, 'A', __len - 1);
	src[__len - 1] = '\0';

	wcscat(__stack.__buf, src);
#undef BUF

}

ATF_TC_WITHOUT_HEAD(wcscat_heap_after_end);
ATF_TC_BODY(wcscat_heap_after_end, tc)
{
#define BUF __stack.__buf
	struct {
		uint8_t padding_l;
		wchar_t * __buf;
		uint8_t padding_r;
	} __stack;
	const size_t __bufsz __unused = sizeof(*__stack.__buf) * (42);
	const size_t __len = 42 + 1;
	const size_t __idx __unused = __len - 1;
	pid_t __child;
	int __status;
	wchar_t src[__len];

	__child = fork();
	ATF_REQUIRE(__child >= 0);
	if (__child > 0)
		goto monitor;

	/* Child */
	disable_coredumps();
	__stack.__buf = malloc(__bufsz);
	wmemset(__stack.__buf, 0, __len);
	wmemset(src, 'A', __len - 1);
	src[__len - 1] = '\0';

	wcscat(__stack.__buf, src);
	_exit(EX_SOFTWARE);	/* Should have aborted. */

monitor:
	while (waitpid(__child, &__status, 0) != __child) {
		ATF_REQUIRE_EQ(EINTR, errno);
	}

	if (!WIFSIGNALED(__status)) {
		switch (WEXITSTATUS(__status)) {
		case EX_SOFTWARE:
			atf_tc_fail("FORTIFY_SOURCE failed to abort");
			break;
		case EX_OSERR:
			atf_tc_fail("setrlimit(2) failed");
			break;
		default:
			atf_tc_fail("child exited with status %d",
			    WEXITSTATUS(__status));
		}
	} else {
		ATF_REQUIRE_EQ(SIGABRT, WTERMSIG(__status));
	}
#undef BUF

}

ATF_TC_WITHOUT_HEAD(wcslcat_before_end);
ATF_TC_BODY(wcslcat_before_end, tc)
{
#define BUF &__stack.__buf
	struct {
		uint8_t padding_l;
		wchar_t __buf[42];
		uint8_t padding_r;
	} __stack;
	const size_t __bufsz __unused = sizeof(__stack.__buf);
	const size_t __len = 42 - 1;
	const size_t __idx __unused = __len - 1;
	wchar_t src[__len];

	wmemset(__stack.__buf, 0, __len);
	wmemset(src, 'A', __len - 1);
	src[__len - 1] = '\0';

	wcslcat(__stack.__buf, src, __len);
#undef BUF

}

ATF_TC_WITHOUT_HEAD(wcslcat_end);
ATF_TC_BODY(wcslcat_end, tc)
{
#define BUF &__stack.__buf
	struct {
		uint8_t padding_l;
		wchar_t __buf[42];
		uint8_t padding_r;
	} __stack;
	const size_t __bufsz __unused = sizeof(__stack.__buf);
	const size_t __len = 42;
	const size_t __idx __unused = __len - 1;
	wchar_t src[__len];

	wmemset(__stack.__buf, 0, __len);
	wmemset(src, 'A', __len - 1);
	src[__len - 1] = '\0';

	wcslcat(__stack.__buf, src, __len);
#undef BUF

}

ATF_TC_WITHOUT_HEAD(wcslcat_heap_before_end);
ATF_TC_BODY(wcslcat_heap_before_end, tc)
{
#define BUF __stack.__buf
	struct {
		uint8_t padding_l;
		wchar_t * __buf;
		uint8_t padding_r;
	} __stack;
	const size_t __bufsz __unused = sizeof(*__stack.__buf) * (42);
	const size_t __len = 42 - 1;
	const size_t __idx __unused = __len - 1;
	wchar_t src[__len];

	__stack.__buf = malloc(__bufsz);
	wmemset(__stack.__buf, 0, __len);
	wmemset(src, 'A', __len - 1);
	src[__len - 1] = '\0';

	wcslcat(__stack.__buf, src, __len);
#undef BUF

}

ATF_TC_WITHOUT_HEAD(wcslcat_heap_end);
ATF_TC_BODY(wcslcat_heap_end, tc)
{
#define BUF __stack.__buf
	struct {
		uint8_t padding_l;
		wchar_t * __buf;
		uint8_t padding_r;
	} __stack;
	const size_t __bufsz __unused = sizeof(*__stack.__buf) * (42);
	const size_t __len = 42;
	const size_t __idx __unused = __len - 1;
	wchar_t src[__len];

	__stack.__buf = malloc(__bufsz);
	wmemset(__stack.__buf, 0, __len);
	wmemset(src, 'A', __len - 1);
	src[__len - 1] = '\0';

	wcslcat(__stack.__buf, src, __len);
#undef BUF

}

ATF_TC_WITHOUT_HEAD(wcslcat_heap_after_end);
ATF_TC_BODY(wcslcat_heap_after_end, tc)
{
#define BUF __stack.__buf
	struct {
		uint8_t padding_l;
		wchar_t * __buf;
		uint8_t padding_r;
	} __stack;
	const size_t __bufsz __unused = sizeof(*__stack.__buf) * (42);
	const size_t __len = 42 + 1;
	const size_t __idx __unused = __len - 1;
	pid_t __child;
	int __status;
	wchar_t src[__len];

	__child = fork();
	ATF_REQUIRE(__child >= 0);
	if (__child > 0)
		goto monitor;

	/* Child */
	disable_coredumps();
	__stack.__buf = malloc(__bufsz);
	wmemset(__stack.__buf, 0, __len);
	wmemset(src, 'A', __len - 1);
	src[__len - 1] = '\0';

	wcslcat(__stack.__buf, src, __len);
	_exit(EX_SOFTWARE);	/* Should have aborted. */

monitor:
	while (waitpid(__child, &__status, 0) != __child) {
		ATF_REQUIRE_EQ(EINTR, errno);
	}

	if (!WIFSIGNALED(__status)) {
		switch (WEXITSTATUS(__status)) {
		case EX_SOFTWARE:
			atf_tc_fail("FORTIFY_SOURCE failed to abort");
			break;
		case EX_OSERR:
			atf_tc_fail("setrlimit(2) failed");
			break;
		default:
			atf_tc_fail("child exited with status %d",
			    WEXITSTATUS(__status));
		}
	} else {
		ATF_REQUIRE_EQ(SIGABRT, WTERMSIG(__status));
	}
#undef BUF

}

ATF_TC_WITHOUT_HEAD(wcsncat_before_end);
ATF_TC_BODY(wcsncat_before_end, tc)
{
#define BUF &__stack.__buf
	struct {
		uint8_t padding_l;
		wchar_t __buf[42];
		uint8_t padding_r;
	} __stack;
	const size_t __bufsz __unused = sizeof(__stack.__buf);
	const size_t __len = 42 - 1;
	const size_t __idx __unused = __len - 1;
	wchar_t src[__len];

	wmemset(__stack.__buf, 0, __len);
	wmemset(src, 'A', __len - 1);
	src[__len - 1] = '\0';

	wcsncat(__stack.__buf, src, __len);
#undef BUF

}

ATF_TC_WITHOUT_HEAD(wcsncat_end);
ATF_TC_BODY(wcsncat_end, tc)
{
#define BUF &__stack.__buf
	struct {
		uint8_t padding_l;
		wchar_t __buf[42];
		uint8_t padding_r;
	} __stack;
	const size_t __bufsz __unused = sizeof(__stack.__buf);
	const size_t __len = 42;
	const size_t __idx __unused = __len - 1;
	wchar_t src[__len];

	wmemset(__stack.__buf, 0, __len);
	wmemset(src, 'A', __len - 1);
	src[__len - 1] = '\0';

	wcsncat(__stack.__buf, src, __len);
#undef BUF

}

ATF_TC_WITHOUT_HEAD(wcsncat_heap_before_end);
ATF_TC_BODY(wcsncat_heap_before_end, tc)
{
#define BUF __stack.__buf
	struct {
		uint8_t padding_l;
		wchar_t * __buf;
		uint8_t padding_r;
	} __stack;
	const size_t __bufsz __unused = sizeof(*__stack.__buf) * (42);
	const size_t __len = 42 - 1;
	const size_t __idx __unused = __len - 1;
	wchar_t src[__len];

	__stack.__buf = malloc(__bufsz);
	wmemset(__stack.__buf, 0, __len);
	wmemset(src, 'A', __len - 1);
	src[__len - 1] = '\0';

	wcsncat(__stack.__buf, src, __len);
#undef BUF

}

ATF_TC_WITHOUT_HEAD(wcsncat_heap_end);
ATF_TC_BODY(wcsncat_heap_end, tc)
{
#define BUF __stack.__buf
	struct {
		uint8_t padding_l;
		wchar_t * __buf;
		uint8_t padding_r;
	} __stack;
	const size_t __bufsz __unused = sizeof(*__stack.__buf) * (42);
	const size_t __len = 42;
	const size_t __idx __unused = __len - 1;
	wchar_t src[__len];

	__stack.__buf = malloc(__bufsz);
	wmemset(__stack.__buf, 0, __len);
	wmemset(src, 'A', __len - 1);
	src[__len - 1] = '\0';

	wcsncat(__stack.__buf, src, __len);
#undef BUF

}

ATF_TC_WITHOUT_HEAD(wcsncat_heap_after_end);
ATF_TC_BODY(wcsncat_heap_after_end, tc)
{
#define BUF __stack.__buf
	struct {
		uint8_t padding_l;
		wchar_t * __buf;
		uint8_t padding_r;
	} __stack;
	const size_t __bufsz __unused = sizeof(*__stack.__buf) * (42);
	const size_t __len = 42 + 1;
	const size_t __idx __unused = __len - 1;
	pid_t __child;
	int __status;
	wchar_t src[__len];

	__child = fork();
	ATF_REQUIRE(__child >= 0);
	if (__child > 0)
		goto monitor;

	/* Child */
	disable_coredumps();
	__stack.__buf = malloc(__bufsz);
	wmemset(__stack.__buf, 0, __len);
	wmemset(src, 'A', __len - 1);
	src[__len - 1] = '\0';

	wcsncat(__stack.__buf, src, __len);
	_exit(EX_SOFTWARE);	/* Should have aborted. */

monitor:
	while (waitpid(__child, &__status, 0) != __child) {
		ATF_REQUIRE_EQ(EINTR, errno);
	}

	if (!WIFSIGNALED(__status)) {
		switch (WEXITSTATUS(__status)) {
		case EX_SOFTWARE:
			atf_tc_fail("FORTIFY_SOURCE failed to abort");
			break;
		case EX_OSERR:
			atf_tc_fail("setrlimit(2) failed");
			break;
		default:
			atf_tc_fail("child exited with status %d",
			    WEXITSTATUS(__status));
		}
	} else {
		ATF_REQUIRE_EQ(SIGABRT, WTERMSIG(__status));
	}
#undef BUF

}

ATF_TC_WITHOUT_HEAD(wcscpy_before_end);
ATF_TC_BODY(wcscpy_before_end, tc)
{
#define BUF &__stack.__buf
	struct {
		uint8_t padding_l;
		wchar_t __buf[42];
		uint8_t padding_r;
	} __stack;
	const size_t __bufsz __unused = sizeof(__stack.__buf);
	const size_t __len = 42 - 1;
	const size_t __idx __unused = __len - 1;
	wchar_t src[__len];

	wmemset(__stack.__buf, 0, __len);
	wmemset(src, 'A', __len - 1);
	src[__len - 1] = '\0';

	wcscpy(__stack.__buf, src);
#undef BUF

}

ATF_TC_WITHOUT_HEAD(wcscpy_end);
ATF_TC_BODY(wcscpy_end, tc)
{
#define BUF &__stack.__buf
	struct {
		uint8_t padding_l;
		wchar_t __buf[42];
		uint8_t padding_r;
	} __stack;
	const size_t __bufsz __unused = sizeof(__stack.__buf);
	const size_t __len = 42;
	const size_t __idx __unused = __len - 1;
	wchar_t src[__len];

	wmemset(__stack.__buf, 0, __len);
	wmemset(src, 'A', __len - 1);
	src[__len - 1] = '\0';

	wcscpy(__stack.__buf, src);
#undef BUF

}

ATF_TC_WITHOUT_HEAD(wcscpy_heap_before_end);
ATF_TC_BODY(wcscpy_heap_before_end, tc)
{
#define BUF __stack.__buf
	struct {
		uint8_t padding_l;
		wchar_t * __buf;
		uint8_t padding_r;
	} __stack;
	const size_t __bufsz __unused = sizeof(*__stack.__buf) * (42);
	const size_t __len = 42 - 1;
	const size_t __idx __unused = __len - 1;
	wchar_t src[__len];

	__stack.__buf = malloc(__bufsz);
	wmemset(__stack.__buf, 0, __len);
	wmemset(src, 'A', __len - 1);
	src[__len - 1] = '\0';

	wcscpy(__stack.__buf, src);
#undef BUF

}

ATF_TC_WITHOUT_HEAD(wcscpy_heap_end);
ATF_TC_BODY(wcscpy_heap_end, tc)
{
#define BUF __stack.__buf
	struct {
		uint8_t padding_l;
		wchar_t * __buf;
		uint8_t padding_r;
	} __stack;
	const size_t __bufsz __unused = sizeof(*__stack.__buf) * (42);
	const size_t __len = 42;
	const size_t __idx __unused = __len - 1;
	wchar_t src[__len];

	__stack.__buf = malloc(__bufsz);
	wmemset(__stack.__buf, 0, __len);
	wmemset(src, 'A', __len - 1);
	src[__len - 1] = '\0';

	wcscpy(__stack.__buf, src);
#undef BUF

}

ATF_TC_WITHOUT_HEAD(wcscpy_heap_after_end);
ATF_TC_BODY(wcscpy_heap_after_end, tc)
{
#define BUF __stack.__buf
	struct {
		uint8_t padding_l;
		wchar_t * __buf;
		uint8_t padding_r;
	} __stack;
	const size_t __bufsz __unused = sizeof(*__stack.__buf) * (42);
	const size_t __len = 42 + 1;
	const size_t __idx __unused = __len - 1;
	pid_t __child;
	int __status;
	wchar_t src[__len];

	__child = fork();
	ATF_REQUIRE(__child >= 0);
	if (__child > 0)
		goto monitor;

	/* Child */
	disable_coredumps();
	__stack.__buf = malloc(__bufsz);
	wmemset(__stack.__buf, 0, __len);
	wmemset(src, 'A', __len - 1);
	src[__len - 1] = '\0';

	wcscpy(__stack.__buf, src);
	_exit(EX_SOFTWARE);	/* Should have aborted. */

monitor:
	while (waitpid(__child, &__status, 0) != __child) {
		ATF_REQUIRE_EQ(EINTR, errno);
	}

	if (!WIFSIGNALED(__status)) {
		switch (WEXITSTATUS(__status)) {
		case EX_SOFTWARE:
			atf_tc_fail("FORTIFY_SOURCE failed to abort");
			break;
		case EX_OSERR:
			atf_tc_fail("setrlimit(2) failed");
			break;
		default:
			atf_tc_fail("child exited with status %d",
			    WEXITSTATUS(__status));
		}
	} else {
		ATF_REQUIRE_EQ(SIGABRT, WTERMSIG(__status));
	}
#undef BUF

}

ATF_TC_WITHOUT_HEAD(wcslcpy_before_end);
ATF_TC_BODY(wcslcpy_before_end, tc)
{
#define BUF &__stack.__buf
	struct {
		uint8_t padding_l;
		wchar_t __buf[42];
		uint8_t padding_r;
	} __stack;
	const size_t __bufsz __unused = sizeof(__stack.__buf);
	const size_t __len = 42 - 1;
	const size_t __idx __unused = __len - 1;
	wchar_t src[__len];

	wmemset(__stack.__buf, 0, __len);
	wmemset(src, 'A', __len - 1);
	src[__len - 1] = '\0';

	wcslcpy(__stack.__buf, src, __len);
#undef BUF

}

ATF_TC_WITHOUT_HEAD(wcslcpy_end);
ATF_TC_BODY(wcslcpy_end, tc)
{
#define BUF &__stack.__buf
	struct {
		uint8_t padding_l;
		wchar_t __buf[42];
		uint8_t padding_r;
	} __stack;
	const size_t __bufsz __unused = sizeof(__stack.__buf);
	const size_t __len = 42;
	const size_t __idx __unused = __len - 1;
	wchar_t src[__len];

	wmemset(__stack.__buf, 0, __len);
	wmemset(src, 'A', __len - 1);
	src[__len - 1] = '\0';

	wcslcpy(__stack.__buf, src, __len);
#undef BUF

}

ATF_TC_WITHOUT_HEAD(wcslcpy_heap_before_end);
ATF_TC_BODY(wcslcpy_heap_before_end, tc)
{
#define BUF __stack.__buf
	struct {
		uint8_t padding_l;
		wchar_t * __buf;
		uint8_t padding_r;
	} __stack;
	const size_t __bufsz __unused = sizeof(*__stack.__buf) * (42);
	const size_t __len = 42 - 1;
	const size_t __idx __unused = __len - 1;
	wchar_t src[__len];

	__stack.__buf = malloc(__bufsz);
	wmemset(__stack.__buf, 0, __len);
	wmemset(src, 'A', __len - 1);
	src[__len - 1] = '\0';

	wcslcpy(__stack.__buf, src, __len);
#undef BUF

}

ATF_TC_WITHOUT_HEAD(wcslcpy_heap_end);
ATF_TC_BODY(wcslcpy_heap_end, tc)
{
#define BUF __stack.__buf
	struct {
		uint8_t padding_l;
		wchar_t * __buf;
		uint8_t padding_r;
	} __stack;
	const size_t __bufsz __unused = sizeof(*__stack.__buf) * (42);
	const size_t __len = 42;
	const size_t __idx __unused = __len - 1;
	wchar_t src[__len];

	__stack.__buf = malloc(__bufsz);
	wmemset(__stack.__buf, 0, __len);
	wmemset(src, 'A', __len - 1);
	src[__len - 1] = '\0';

	wcslcpy(__stack.__buf, src, __len);
#undef BUF

}

ATF_TC_WITHOUT_HEAD(wcslcpy_heap_after_end);
ATF_TC_BODY(wcslcpy_heap_after_end, tc)
{
#define BUF __stack.__buf
	struct {
		uint8_t padding_l;
		wchar_t * __buf;
		uint8_t padding_r;
	} __stack;
	const size_t __bufsz __unused = sizeof(*__stack.__buf) * (42);
	const size_t __len = 42 + 1;
	const size_t __idx __unused = __len - 1;
	pid_t __child;
	int __status;
	wchar_t src[__len];

	__child = fork();
	ATF_REQUIRE(__child >= 0);
	if (__child > 0)
		goto monitor;

	/* Child */
	disable_coredumps();
	__stack.__buf = malloc(__bufsz);
	wmemset(__stack.__buf, 0, __len);
	wmemset(src, 'A', __len - 1);
	src[__len - 1] = '\0';

	wcslcpy(__stack.__buf, src, __len);
	_exit(EX_SOFTWARE);	/* Should have aborted. */

monitor:
	while (waitpid(__child, &__status, 0) != __child) {
		ATF_REQUIRE_EQ(EINTR, errno);
	}

	if (!WIFSIGNALED(__status)) {
		switch (WEXITSTATUS(__status)) {
		case EX_SOFTWARE:
			atf_tc_fail("FORTIFY_SOURCE failed to abort");
			break;
		case EX_OSERR:
			atf_tc_fail("setrlimit(2) failed");
			break;
		default:
			atf_tc_fail("child exited with status %d",
			    WEXITSTATUS(__status));
		}
	} else {
		ATF_REQUIRE_EQ(SIGABRT, WTERMSIG(__status));
	}
#undef BUF

}

ATF_TC_WITHOUT_HEAD(wcsncpy_before_end);
ATF_TC_BODY(wcsncpy_before_end, tc)
{
#define BUF &__stack.__buf
	struct {
		uint8_t padding_l;
		wchar_t __buf[42];
		uint8_t padding_r;
	} __stack;
	const size_t __bufsz __unused = sizeof(__stack.__buf);
	const size_t __len = 42 - 1;
	const size_t __idx __unused = __len - 1;
	wchar_t src[__len];

	wmemset(__stack.__buf, 0, __len);
	wmemset(src, 'A', __len - 1);
	src[__len - 1] = '\0';

	wcsncpy(__stack.__buf, src, __len);
#undef BUF

}

ATF_TC_WITHOUT_HEAD(wcsncpy_end);
ATF_TC_BODY(wcsncpy_end, tc)
{
#define BUF &__stack.__buf
	struct {
		uint8_t padding_l;
		wchar_t __buf[42];
		uint8_t padding_r;
	} __stack;
	const size_t __bufsz __unused = sizeof(__stack.__buf);
	const size_t __len = 42;
	const size_t __idx __unused = __len - 1;
	wchar_t src[__len];

	wmemset(__stack.__buf, 0, __len);
	wmemset(src, 'A', __len - 1);
	src[__len - 1] = '\0';

	wcsncpy(__stack.__buf, src, __len);
#undef BUF

}

ATF_TC_WITHOUT_HEAD(wcsncpy_heap_before_end);
ATF_TC_BODY(wcsncpy_heap_before_end, tc)
{
#define BUF __stack.__buf
	struct {
		uint8_t padding_l;
		wchar_t * __buf;
		uint8_t padding_r;
	} __stack;
	const size_t __bufsz __unused = sizeof(*__stack.__buf) * (42);
	const size_t __len = 42 - 1;
	const size_t __idx __unused = __len - 1;
	wchar_t src[__len];

	__stack.__buf = malloc(__bufsz);
	wmemset(__stack.__buf, 0, __len);
	wmemset(src, 'A', __len - 1);
	src[__len - 1] = '\0';

	wcsncpy(__stack.__buf, src, __len);
#undef BUF

}

ATF_TC_WITHOUT_HEAD(wcsncpy_heap_end);
ATF_TC_BODY(wcsncpy_heap_end, tc)
{
#define BUF __stack.__buf
	struct {
		uint8_t padding_l;
		wchar_t * __buf;
		uint8_t padding_r;
	} __stack;
	const size_t __bufsz __unused = sizeof(*__stack.__buf) * (42);
	const size_t __len = 42;
	const size_t __idx __unused = __len - 1;
	wchar_t src[__len];

	__stack.__buf = malloc(__bufsz);
	wmemset(__stack.__buf, 0, __len);
	wmemset(src, 'A', __len - 1);
	src[__len - 1] = '\0';

	wcsncpy(__stack.__buf, src, __len);
#undef BUF

}

ATF_TC_WITHOUT_HEAD(wcsncpy_heap_after_end);
ATF_TC_BODY(wcsncpy_heap_after_end, tc)
{
#define BUF __stack.__buf
	struct {
		uint8_t padding_l;
		wchar_t * __buf;
		uint8_t padding_r;
	} __stack;
	const size_t __bufsz __unused = sizeof(*__stack.__buf) * (42);
	const size_t __len = 42 + 1;
	const size_t __idx __unused = __len - 1;
	pid_t __child;
	int __status;
	wchar_t src[__len];

	__child = fork();
	ATF_REQUIRE(__child >= 0);
	if (__child > 0)
		goto monitor;

	/* Child */
	disable_coredumps();
	__stack.__buf = malloc(__bufsz);
	wmemset(__stack.__buf, 0, __len);
	wmemset(src, 'A', __len - 1);
	src[__len - 1] = '\0';

	wcsncpy(__stack.__buf, src, __len);
	_exit(EX_SOFTWARE);	/* Should have aborted. */

monitor:
	while (waitpid(__child, &__status, 0) != __child) {
		ATF_REQUIRE_EQ(EINTR, errno);
	}

	if (!WIFSIGNALED(__status)) {
		switch (WEXITSTATUS(__status)) {
		case EX_SOFTWARE:
			atf_tc_fail("FORTIFY_SOURCE failed to abort");
			break;
		case EX_OSERR:
			atf_tc_fail("setrlimit(2) failed");
			break;
		default:
			atf_tc_fail("child exited with status %d",
			    WEXITSTATUS(__status));
		}
	} else {
		ATF_REQUIRE_EQ(SIGABRT, WTERMSIG(__status));
	}
#undef BUF

}

ATF_TP_ADD_TCS(tp)
{
	ATF_TP_ADD_TC(tp, wmemcpy_before_end);
	ATF_TP_ADD_TC(tp, wmemcpy_end);
	ATF_TP_ADD_TC(tp, wmemcpy_heap_before_end);
	ATF_TP_ADD_TC(tp, wmemcpy_heap_end);
	ATF_TP_ADD_TC(tp, wmemcpy_heap_after_end);
	ATF_TP_ADD_TC(tp, wmempcpy_before_end);
	ATF_TP_ADD_TC(tp, wmempcpy_end);
	ATF_TP_ADD_TC(tp, wmempcpy_heap_before_end);
	ATF_TP_ADD_TC(tp, wmempcpy_heap_end);
	ATF_TP_ADD_TC(tp, wmempcpy_heap_after_end);
	ATF_TP_ADD_TC(tp, wmemmove_before_end);
	ATF_TP_ADD_TC(tp, wmemmove_end);
	ATF_TP_ADD_TC(tp, wmemmove_heap_before_end);
	ATF_TP_ADD_TC(tp, wmemmove_heap_end);
	ATF_TP_ADD_TC(tp, wmemmove_heap_after_end);
	ATF_TP_ADD_TC(tp, wmemset_before_end);
	ATF_TP_ADD_TC(tp, wmemset_end);
	ATF_TP_ADD_TC(tp, wmemset_heap_before_end);
	ATF_TP_ADD_TC(tp, wmemset_heap_end);
	ATF_TP_ADD_TC(tp, wmemset_heap_after_end);
	ATF_TP_ADD_TC(tp, wcpcpy_before_end);
	ATF_TP_ADD_TC(tp, wcpcpy_end);
	ATF_TP_ADD_TC(tp, wcpcpy_heap_before_end);
	ATF_TP_ADD_TC(tp, wcpcpy_heap_end);
	ATF_TP_ADD_TC(tp, wcpcpy_heap_after_end);
	ATF_TP_ADD_TC(tp, wcpncpy_before_end);
	ATF_TP_ADD_TC(tp, wcpncpy_end);
	ATF_TP_ADD_TC(tp, wcpncpy_heap_before_end);
	ATF_TP_ADD_TC(tp, wcpncpy_heap_end);
	ATF_TP_ADD_TC(tp, wcpncpy_heap_after_end);
	ATF_TP_ADD_TC(tp, wcscat_before_end);
	ATF_TP_ADD_TC(tp, wcscat_end);
	ATF_TP_ADD_TC(tp, wcscat_heap_before_end);
	ATF_TP_ADD_TC(tp, wcscat_heap_end);
	ATF_TP_ADD_TC(tp, wcscat_heap_after_end);
	ATF_TP_ADD_TC(tp, wcslcat_before_end);
	ATF_TP_ADD_TC(tp, wcslcat_end);
	ATF_TP_ADD_TC(tp, wcslcat_heap_before_end);
	ATF_TP_ADD_TC(tp, wcslcat_heap_end);
	ATF_TP_ADD_TC(tp, wcslcat_heap_after_end);
	ATF_TP_ADD_TC(tp, wcsncat_before_end);
	ATF_TP_ADD_TC(tp, wcsncat_end);
	ATF_TP_ADD_TC(tp, wcsncat_heap_before_end);
	ATF_TP_ADD_TC(tp, wcsncat_heap_end);
	ATF_TP_ADD_TC(tp, wcsncat_heap_after_end);
	ATF_TP_ADD_TC(tp, wcscpy_before_end);
	ATF_TP_ADD_TC(tp, wcscpy_end);
	ATF_TP_ADD_TC(tp, wcscpy_heap_before_end);
	ATF_TP_ADD_TC(tp, wcscpy_heap_end);
	ATF_TP_ADD_TC(tp, wcscpy_heap_after_end);
	ATF_TP_ADD_TC(tp, wcslcpy_before_end);
	ATF_TP_ADD_TC(tp, wcslcpy_end);
	ATF_TP_ADD_TC(tp, wcslcpy_heap_before_end);
	ATF_TP_ADD_TC(tp, wcslcpy_heap_end);
	ATF_TP_ADD_TC(tp, wcslcpy_heap_after_end);
	ATF_TP_ADD_TC(tp, wcsncpy_before_end);
	ATF_TP_ADD_TC(tp, wcsncpy_end);
	ATF_TP_ADD_TC(tp, wcsncpy_heap_before_end);
	ATF_TP_ADD_TC(tp, wcsncpy_heap_end);
	ATF_TP_ADD_TC(tp, wcsncpy_heap_after_end);
	return (atf_no_error());
}
